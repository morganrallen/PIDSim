(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var Ractive = require("ractive");

var tplCar = '<image class="car" xlink:href="car.svg" y="{{ y }}" x="{{ x }}" transform="rotate({{ a }} {{ x }} {{ y }})" height="40" width="100" />';

var RCar = Ractive.extend({
  template: tplCar
});

module.exports = RCar;

},{"ractive":6}],2:[function(require,module,exports){
"use strict";

var TAU = 2 * Math.PI;
var raf = window.requestAnimationFrame;
var RActive = require("ractive");
var Sparklines = require("sparklines");
var dat = require("dat-gui");
var RCar = require("./car");

function clamp(v, min, max) {
  return v < min ? min : v > max ? max : v;
}

var data = {
  car: {
    a: 0,
    x: 0,
    y: 25,
    steeringAngle: 0,
    maxSteeringAngle: 30,
    speed: 1
  },
  road: {
    y: 300
  },
  circles: [],
  stop: {
    action: "Stop"
  },
  terms: {
    timeChange: "0",
    err: "0",
    dErr: "0",
    errSum: "0",
    output: "0",
    pTerm: "0",
    iTerm: "0",
    dTerm: "0"
  }
};

window.data = data;

var datGui = new dat.GUI();
datGui.add(data.car, "x").listen();
datGui.add(data.car, "y").listen();
datGui.add(data.car, "steeringAngle").listen();
datGui.add(data.car, "a").listen();
datGui.add(data.car, "speed", 0, 50);
datGui.add(data.road, "y", 0, 500);
datGui.add(data.terms, "timeChange").listen();
datGui.add(data.terms, "err").listen();
datGui.add(data.terms, "dErr").listen();
datGui.add(data.terms, "errSum").listen();
datGui.add(data.terms, "pTerm").listen();
datGui.add(data.terms, "iTerm").listen();
datGui.add(data.terms, "dTerm").listen();
datGui.add(data.terms, "output").listen();

var elRoad = new RActive({
  append: true,
  el: document.querySelector("svg"),
  template: '<rect id="road" y="{{ road.y }}"></rect>',
  data: data
});

var elCar = new RCar({
  append: true,
  el: document.querySelector("svg"),
  data: data.car
});

var elRoadDistance = new RActive({
  append: true,
  el: document.querySelector("svg"),
  template: '<div id="road-indicator" style="left: {{ car.x }}px; top: {{ car.y + ((road.y - car.y ) / 2) }}px;">{{ Math.round(road.y - car.y) }}</div>',
  data: data
});

var stop = false;

var elStop = new RActive({
  append: true,
  el: document.querySelector("svg"),
  template: '<div on-click="startstop">{{ action }}</div><div on-click="set">Reset</div>',
  data: data.stop
});

elStop.on("set", function() {
  data.car.x = data.car.a = 0;
  data.car.y = 50;
});

elStop.on("startstop", function() {
  stop = !stop;

  data.stop.action = stop ? "Start" : "Stop";
  elStop.update("action");

  if(!stop) {
    animate();
  }
});

var elHighlighter = new RActive({
  append: true,
  el: document.querySelector("svg"),
  template: '<svg id="highlight" style="left: {{ car.x - 40 }}px; top: {{ car.y - 40}}px;">\
    {{#circles}}<circle cx="{{ x }}" cy="{{ y }}" r="1" />{{/}}\
  </svg>',
  data: data
});

var step = 0.1;
var angle = 0;
while(angle < TAU) {
  var x = 90 + (60 * Math.cos(angle));
  var y = 68 + (60 * Math.sin(angle));

  data.circles.push({
    x: x,
    y: y
  });

  angle += step;
}

elHighlighter.update("circles");

var elIndicatorAngle = new RActive({
  append: true,
  el: document.querySelector("svg"),
  template: '<image id="arrow_angle" xlink:href="arrow.svg" transform="rotate({{ (car.a + car.steeringAngle) - 90 }} {{ car.x }} {{ car.y + 40 }})" x="{{ car.x }}" y="{{ car.y + 40 }}" height="100" width="30" />',
  data: data
});

var ta = document.querySelector("textarea");

var updatePIDFunction = true;
document.querySelector("textarea").addEventListener("keyup", function(e) {
  console.log(e.keyCode);
  if(e.keyCode >= 32) {
    updatePIDFunction = true;
  }
}, false);

var fnPID = function(){};

var sparkErr = new Sparklines(document.querySelector(".charts.err"), {
  lineColor: "blue",
  height: 100,
  maxColor: "green",
  minColor: "red",
  width: 500
});

var sparkSet = new Sparklines(document.querySelector(".charts.set"), {
  lineColor: "red",
  height: 100,
  maxColor: "green",
  minColor: "red",
  width: 500
});

var sparkErrData = [];
var sparkSetData = [];

function animate() {
  var vX = (data.car.speed * 6) * Math.cos(data.car.a * (Math.PI / 180));
  var vY = (data.car.speed * 6) * Math.sin(data.car.a * (Math.PI / 180));

  data.car.x += vX;
  data.car.y += vY;
  data.car.a += data.car.steeringAngle * 0.1;

  if(data.car.x > 650) {
    data.car.x = 0;
  }

  var syntaxOK = true;

  if(updatePIDFunction) {
    try {
      fnPID = eval("(function() { " + ta.value.trim() + "})()");
      updatePIDFunction = false;
    } catch(e) {
      syntaxOK = false;
    }
  }

  sparkErrData.push(data.car.y - 40);
  sparkSetData.push(data.road.y);

  sparkErr.draw(sparkErrData);
  sparkSet.draw(sparkSetData);

  if(syntaxOK) {
    try {
      data.car.steeringAngle = clamp(fnPID((data.road.y - data.car.y), data.car.steeringAngle), -data.car.maxSteeringAngle, data.car.maxSteeringAngle);
    } catch(e) {
    }
  }

  elCar.update();
  elRoad.update();
  elRoadDistance.update();
  elIndicatorAngle.update("car");
  elHighlighter.update("car");

  if(stop !== true) {
    raf(animate);
  }
}

animate();

},{"./car":1,"dat-gui":3,"ractive":6,"sparklines":7}],3:[function(require,module,exports){
module.exports = require('./vendor/dat.gui')
module.exports.color = require('./vendor/dat.color')
},{"./vendor/dat.color":4,"./vendor/dat.gui":5}],4:[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.color = dat.color || {};

/** @namespace */
dat.utils = dat.utils || {};

dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.Color = dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common),
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common);
},{}],5:[function(require,module,exports){
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.gui = dat.gui || {};

/** @namespace */
dat.utils = dat.utils || {};

/** @namespace */
dat.controllers = dat.controllers || {};

/** @namespace */
dat.dom = dat.dom || {};

/** @namespace */
dat.color = dat.color || {};

dat.utils.css = (function () {
  return {
    load: function (url, doc) {
      doc = doc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function(css, doc) {
      doc = doc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = css;
      doc.getElementsByTagName('head')[0].appendChild(injected);
    }
  }
})();


dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.controllers.Controller = (function (common) {

  /**
   * @class An "abstract" class that represents a given property of an object.
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var Controller = function(object, property) {

    this.initialValue = object[property];

    /**
     * Those who extend this class will put their DOM elements in here.
     * @type {DOMElement}
     */
    this.domElement = document.createElement('div');

    /**
     * The object to manipulate
     * @type {Object}
     */
    this.object = object;

    /**
     * The name of the property to manipulate
     * @type {String}
     */
    this.property = property;

    /**
     * The function to be called on change.
     * @type {Function}
     * @ignore
     */
    this.__onChange = undefined;

    /**
     * The function to be called on finishing change.
     * @type {Function}
     * @ignore
     */
    this.__onFinishChange = undefined;

  };

  common.extend(

      Controller.prototype,

      /** @lends dat.controllers.Controller.prototype */
      {

        /**
         * Specify that a function fire every time someone changes the value with
         * this Controller.
         *
         * @param {Function} fnc This function will be called whenever the value
         * is modified via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onChange: function(fnc) {
          this.__onChange = fnc;
          return this;
        },

        /**
         * Specify that a function fire every time someone "finishes" changing
         * the value wih this Controller. Useful for values that change
         * incrementally like numbers or strings.
         *
         * @param {Function} fnc This function will be called whenever
         * someone "finishes" changing the value via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onFinishChange: function(fnc) {
          this.__onFinishChange = fnc;
          return this;
        },

        /**
         * Change the value of <code>object[property]</code>
         *
         * @param {Object} newValue The new value of <code>object[property]</code>
         */
        setValue: function(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        },

        /**
         * Gets the value of <code>object[property]</code>
         *
         * @returns {Object} The current value of <code>object[property]</code>
         */
        getValue: function() {
          return this.object[this.property];
        },

        /**
         * Refreshes the visual display of a Controller in order to keep sync
         * with the object's current value.
         * @returns {dat.controllers.Controller} this
         */
        updateDisplay: function() {
          return this;
        },

        /**
         * @returns {Boolean} true if the value has deviated from initialValue
         */
        isModified: function() {
          return this.initialValue !== this.getValue()
        }

      }

  );

  return Controller;


})(dat.utils.common);


dat.dom.dom = (function (common) {

  var EVENT_MAP = {
    'HTMLEvents': ['change'],
    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
    'KeyboardEvents': ['keydown']
  };

  var EVENT_MAP_INV = {};
  common.each(EVENT_MAP, function(v, k) {
    common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });

  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {

    if (val === '0' || common.isUndefined(val)) return 0;

    var match = val.match(CSS_VALUE_PIXELS);

    if (!common.isNull(match)) {
      return parseFloat(match[1]);
    }

    // TODO ...ems? %?

    return 0;

  }

  /**
   * @namespace
   * @member dat.dom
   */
  var dom = {

    /**
     * 
     * @param elem
     * @param selectable
     */
    makeSelectable: function(elem, selectable) {

      if (elem === undefined || elem.style === undefined) return;

      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };

      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';

    },

    /**
     *
     * @param elem
     * @param horizontal
     * @param vertical
     */
    makeFullscreen: function(elem, horizontal, vertical) {

      if (common.isUndefined(horizontal)) horizontal = true;
      if (common.isUndefined(vertical)) vertical = true;

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }

    },

    /**
     *
     * @param elem
     * @param eventType
     * @param params
     */
    fakeEvent: function(elem, eventType, params, aux) {
      params = params || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }
      var evt = document.createEvent(className);
      switch (className) {
        case 'MouseEvents':
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false,
              params.cancelable || true, window, params.clickCount || 1,
              0, //screen X
              0, //screen Y
              clientX, //client X
              clientY, //client Y
              false, false, false, false, 0, null);
          break;
        case 'KeyboardEvents':
          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
          common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false,
              params.cancelable, window,
              params.ctrlKey, params.altKey,
              params.shiftKey, params.metaKey,
              params.keyCode, params.charCode);
          break;
        default:
          evt.initEvent(eventType, params.bubbles || false,
              params.cancelable || true);
          break;
      }
      common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    bind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.addEventListener)
        elem.addEventListener(event, func, bool);
      else if (elem.attachEvent)
        elem.attachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    unbind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.removeEventListener)
        elem.removeEventListener(event, func, bool);
      else if (elem.detachEvent)
        elem.detachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    addClass: function(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) == -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    removeClass: function(elem, className) {
      if (className) {
        if (elem.className === undefined) {
          // elem.className = className;
        } else if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index != -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }
      return dom;
    },

    hasClass: function(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },

    /**
     *
     * @param elem
     */
    getWidth: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-left-width']) +
          cssValueToPixels(style['border-right-width']) +
          cssValueToPixels(style['padding-left']) +
          cssValueToPixels(style['padding-right']) +
          cssValueToPixels(style['width']);
    },

    /**
     *
     * @param elem
     */
    getHeight: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-top-width']) +
          cssValueToPixels(style['border-bottom-width']) +
          cssValueToPixels(style['padding-top']) +
          cssValueToPixels(style['padding-bottom']) +
          cssValueToPixels(style['height']);
    },

    /**
     *
     * @param elem
     */
    getOffset: function(elem) {
      var offset = {left: 0, top:0};
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
        } while (elem = elem.offsetParent);
      }
      return offset;
    },

    // http://stackoverflow.com/posts/2684561/revisions
    /**
     * 
     * @param elem
     */
    isActive: function(elem) {
      return elem === document.activeElement && ( elem.type || elem.href );
    }

  };

  return dom;

})(dat.utils.common);


dat.controllers.OptionController = (function (Controller, dom, common) {

  /**
   * @class Provides a select input to alter the property of an object, using a
   * list of accepted values.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object|string[]} options A map of labels to acceptable values, or
   * a list of acceptable string values.
   *
   * @member dat.controllers
   */
  var OptionController = function(object, property, options) {

    OptionController.superclass.call(this, object, property);

    var _this = this;

    /**
     * The drop down menu
     * @ignore
     */
    this.__select = document.createElement('select');

    if (common.isArray(options)) {
      var map = {};
      common.each(options, function(element) {
        map[element] = element;
      });
      options = map;
    }

    common.each(options, function(value, key) {

      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);

    });

    // Acknowledge original value
    this.updateDisplay();

    dom.bind(this.__select, 'change', function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });

    this.domElement.appendChild(this.__select);

  };

  OptionController.superclass = Controller;

  common.extend(

      OptionController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn;
        },

        updateDisplay: function() {
          this.__select.value = this.getValue();
          return OptionController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return OptionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberController = (function (Controller, common) {

  /**
   * @class Represents a given property of an object that is a number.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberController = function(object, property, params) {

    NumberController.superclass.call(this, object, property);

    params = params || {};

    this.__min = params.min;
    this.__max = params.max;
    this.__step = params.step;

    if (common.isUndefined(this.__step)) {

      if (this.initialValue == 0) {
        this.__impliedStep = 1; // What are we, psychics?
      } else {
        // Hey Doug, check this out.
        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
      }

    } else {

      this.__impliedStep = this.__step;

    }

    this.__precision = numDecimals(this.__impliedStep);


  };

  NumberController.superclass = Controller;

  common.extend(

      NumberController.prototype,
      Controller.prototype,

      /** @lends dat.controllers.NumberController.prototype */
      {

        setValue: function(v) {

          if (this.__min !== undefined && v < this.__min) {
            v = this.__min;
          } else if (this.__max !== undefined && v > this.__max) {
            v = this.__max;
          }

          if (this.__step !== undefined && v % this.__step != 0) {
            v = Math.round(v / this.__step) * this.__step;
          }

          return NumberController.superclass.prototype.setValue.call(this, v);

        },

        /**
         * Specify a minimum value for <code>object[property]</code>.
         *
         * @param {Number} minValue The minimum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        min: function(v) {
          this.__min = v;
          return this;
        },

        /**
         * Specify a maximum value for <code>object[property]</code>.
         *
         * @param {Number} maxValue The maximum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        max: function(v) {
          this.__max = v;
          return this;
        },

        /**
         * Specify a step value that dat.controllers.NumberController
         * increments by.
         *
         * @param {Number} stepValue The step value for
         * dat.controllers.NumberController
         * @default if minimum and maximum specified increment is 1% of the
         * difference otherwise stepValue is 1
         * @returns {dat.controllers.NumberController} this
         */
        step: function(v) {
          this.__step = v;
          return this;
        }

      }

  );

  function numDecimals(x) {
    x = x.toString();
    if (x.indexOf('.') > -1) {
      return x.length - x.indexOf('.') - 1;
    } else {
      return 0;
    }
  }

  return NumberController;

})(dat.controllers.Controller,
dat.utils.common);


dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

  /**
   * @class Represents a given property of an object that is a number and
   * provides an input element with which to manipulate it.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerBox = function(object, property, params) {

    this.__truncationSuspended = false;

    NumberControllerBox.superclass.call(this, object, property, params);

    var _this = this;

    /**
     * {Number} Previous mouse y position
     * @ignore
     */
    var prev_y;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    // Makes it so manually specified values are not truncated.

    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'mousedown', onMouseDown);
    dom.bind(this.__input, 'keydown', function(e) {

      // When pressing entire, you can be as precise as you want.
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
      }

    });

    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!common.isNaN(attempted)) _this.setValue(attempted);
    }

    function onBlur() {
      onChange();
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prev_y = e.clientY;
    }

    function onMouseDrag(e) {

      var diff = prev_y - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prev_y = e.clientY;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  NumberControllerBox.superclass = NumberController;

  common.extend(

      NumberControllerBox.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {

          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  return NumberControllerBox;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

  /**
   * @class Represents a given property of an object that is a number, contains
   * a minimum and maximum, and provides a slider element with which to
   * manipulate it. It should be noted that the slider element is made up of
   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
   * <code>&lt;slider&gt;</code> element.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   * 
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Number} minValue Minimum allowed value
   * @param {Number} maxValue Maximum allowed value
   * @param {Number} stepValue Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerSlider = function(object, property, min, max, step) {

    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

    var _this = this;

    this.__background = document.createElement('div');
    this.__foreground = document.createElement('div');
    


    dom.bind(this.__background, 'mousedown', onMouseDown);
    
    dom.addClass(this.__background, 'slider');
    dom.addClass(this.__foreground, 'slider-fg');

    function onMouseDown(e) {

      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);

      onMouseDrag(e);
    }

    function onMouseDrag(e) {

      e.preventDefault();

      var offset = dom.getOffset(_this.__background);
      var width = dom.getWidth(_this.__background);
      
      _this.setValue(
        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
      );

      return false;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.__background.appendChild(this.__foreground);
    this.domElement.appendChild(this.__background);

  };

  NumberControllerSlider.superclass = NumberController;

  /**
   * Injects default stylesheet for slider elements.
   */
  NumberControllerSlider.useDefaultStyles = function() {
    css.inject(styleSheet);
  };

  common.extend(

      NumberControllerSlider.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {
          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
          this.__foreground.style.width = pct*100+'%';
          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
        }

      }



  );

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  return NumberControllerSlider;
  
})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.css,
dat.utils.common,
".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


dat.controllers.FunctionController = (function (Controller, dom, common) {

  /**
   * @class Provides a GUI interface to fire a specified method, a property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var FunctionController = function(object, property, text) {

    FunctionController.superclass.call(this, object, property);

    var _this = this;

    this.__button = document.createElement('div');
    this.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(this.__button, 'click', function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });

    dom.addClass(this.__button, 'button');

    this.domElement.appendChild(this.__button);


  };

  FunctionController.superclass = Controller;

  common.extend(

      FunctionController.prototype,
      Controller.prototype,
      {
        
        fire: function() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.getValue().call(this.object);
        }
      }

  );

  return FunctionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.BooleanController = (function (Controller, dom, common) {

  /**
   * @class Provides a checkbox input to alter the boolean property of an object.
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var BooleanController = function(object, property) {

    BooleanController.superclass.call(this, object, property);

    var _this = this;
    this.__prev = this.getValue();

    this.__checkbox = document.createElement('input');
    this.__checkbox.setAttribute('type', 'checkbox');


    dom.bind(this.__checkbox, 'change', onChange, false);

    this.domElement.appendChild(this.__checkbox);

    // Match original value
    this.updateDisplay();

    function onChange() {
      _this.setValue(!_this.__prev);
    }

  };

  BooleanController.superclass = Controller;

  common.extend(

      BooleanController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn;
        },

        updateDisplay: function() {
          
          if (this.getValue() === true) {
            this.__checkbox.setAttribute('checked', 'checked');
            this.__checkbox.checked = true;    
          } else {
              this.__checkbox.checked = false;
          }

          return BooleanController.superclass.prototype.updateDisplay.call(this);

        }


      }

  );

  return BooleanController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common);


dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

  css.inject(styleSheet);

  /** Outer-most className for GUI's */
  var CSS_NAMESPACE = 'dg';

  var HIDE_KEY_CODE = 72;

  /** The only value shared between the JS and SCSS. Use caution. */
  var CLOSE_BUTTON_HEIGHT = 20;

  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = (function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  })();

  var SAVE_DIALOGUE;

  /** Have we yet to create an autoPlace GUI? */
  var auto_place_virgin = true;

  /** Fixed position div that auto place GUI's go inside */
  var auto_place_container;

  /** Are we hiding the GUI's ? */
  var hide = false;

  /** GUI's which should be hidden */
  var hideable_guis = [];

  /**
   * A lightweight controller library for JavaScript. It allows you to easily
   * manipulate variables and fire functions on the fly.
   * @class
   *
   * @member dat.gui
   *
   * @param {Object} [params]
   * @param {String} [params.name] The name of this GUI.
   * @param {Object} [params.load] JSON object representing the saved state of
   * this GUI.
   * @param {Boolean} [params.auto=true]
   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
   * @param {Boolean} [params.closed] If true, starts closed
   */
  var GUI = function(params) {

    var _this = this;

    /**
     * Outermost DOM Element
     * @type DOMElement
     */
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);

    dom.addClass(this.domElement, CSS_NAMESPACE);

    /**
     * Nested GUI's by name
     * @ignore
     */
    this.__folders = {};

    this.__controllers = [];

    /**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
    this.__rememberedObjects = [];

    /**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
     *    propertyName: Controller,
     *    anotherPropertyName: Controller
     *  },
     *  {
     *    propertyName: Controller
     *  }
     * ]
     */
    this.__rememberedObjectIndecesToControllers = [];

    this.__listening = [];

    params = params || {};

    // Default parameters
    params = common.defaults(params, {
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });

    params = common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });


    if (!common.isUndefined(params.load)) {

      // Explicit preset
      if (params.preset) params.load.preset = params.preset;

    } else {

      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

    }

    if (common.isUndefined(params.parent) && params.hideable) {
      hideable_guis.push(this);
    }

    // Only root level GUI's are resizable.
    params.resizable = common.isUndefined(params.parent) && params.resizable;


    if (params.autoPlace && common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

    // Not part of params because I don't want people passing this in via
    // constructor. Should be a 'remembered' value.
    var use_local_storage =
        SUPPORTS_LOCAL_STORAGE &&
            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

    Object.defineProperties(this,

        /** @lends dat.gui.GUI.prototype */
        {

          /**
           * The parent <code>GUI</code>
           * @type dat.gui.GUI
           */
          parent: {
            get: function() {
              return params.parent;
            }
          },

          scrollable: {
            get: function() {
              return params.scrollable;
            }
          },

          /**
           * Handles <code>GUI</code>'s element placement for you
           * @type Boolean
           */
          autoPlace: {
            get: function() {
              return params.autoPlace;
            }
          },

          /**
           * The identifier for a set of saved values
           * @type String
           */
          preset: {

            get: function() {
              if (_this.parent) {
                return _this.getRoot().preset;
              } else {
                return params.load.preset;
              }
            },

            set: function(v) {
              if (_this.parent) {
                _this.getRoot().preset = v;
              } else {
                params.load.preset = v;
              }
              setPresetSelectIndex(this);
              _this.revert();
            }

          },

          /**
           * The width of <code>GUI</code> element
           * @type Number
           */
          width: {
            get: function() {
              return params.width;
            },
            set: function(v) {
              params.width = v;
              setWidth(_this, v);
            }
          },

          /**
           * The name of <code>GUI</code>. Used for folders. i.e
           * a folder's name
           * @type String
           */
          name: {
            get: function() {
              return params.name;
            },
            set: function(v) {
              // TODO Check for collisions among sibling folders
              params.name = v;
              if (title_row_name) {
                title_row_name.innerHTML = params.name;
              }
            }
          },

          /**
           * Whether the <code>GUI</code> is collapsed or not
           * @type Boolean
           */
          closed: {
            get: function() {
              return params.closed;
            },
            set: function(v) {
              params.closed = v;
              if (params.closed) {
                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
              } else {
                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
              }
              // For browsers that aren't going to respect the CSS transition,
              // Lets just check our height against the window height right off
              // the bat.
              this.onResize();

              if (_this.__closeButton) {
                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
              }
            }
          },

          /**
           * Contains all presets
           * @type Object
           */
          load: {
            get: function() {
              return params.load;
            }
          },

          /**
           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
           * <code>remember</code>ing
           * @type Boolean
           */
          useLocalStorage: {

            get: function() {
              return use_local_storage;
            },
            set: function(bool) {
              if (SUPPORTS_LOCAL_STORAGE) {
                use_local_storage = bool;
                if (bool) {
                  dom.bind(window, 'unload', saveToLocalStorage);
                } else {
                  dom.unbind(window, 'unload', saveToLocalStorage);
                }
                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
              }
            }

          }

        });

    // Are we a root level GUI?
    if (common.isUndefined(params.parent)) {

      params.closed = false;

      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      // Are we supposed to be loading locally?
      if (SUPPORTS_LOCAL_STORAGE) {

        if (use_local_storage) {

          _this.useLocalStorage = true;

          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (saved_gui) {
            params.load = JSON.parse(saved_gui);
          }

        }

      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
      this.domElement.appendChild(this.__closeButton);

      dom.bind(this.__closeButton, 'click', function() {

        _this.closed = !_this.closed;


      });


      // Oh, you're a nested GUI!
    } else {

      if (params.closed === undefined) {
        params.closed = true;
      }

      var title_row_name = document.createTextNode(params.name);
      dom.addClass(title_row_name, 'controller-name');

      var title_row = addRow(_this, title_row_name);

      var on_click_title = function(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

      dom.addClass(title_row, 'title');
      dom.bind(title_row, 'click', on_click_title);

      if (!params.closed) {
        this.closed = false;
      }

    }

    if (params.autoPlace) {

      if (common.isUndefined(params.parent)) {

        if (auto_place_virgin) {
          auto_place_container = document.createElement('div');
          dom.addClass(auto_place_container, CSS_NAMESPACE);
          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(auto_place_container);
          auto_place_virgin = false;
        }

        // Put it in the dom for you.
        auto_place_container.appendChild(this.domElement);

        // Apply the auto styles
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

      }


      // Make it not elastic.
      if (!this.parent) setWidth(_this, params.width);

    }

    dom.bind(window, 'resize', function() { _this.onResize() });
    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
    this.onResize();


    if (params.resizable) {
      addResizeHandle(this);
    }

    function saveToLocalStorage() {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }

    var root = _this.getRoot();
    function resetWidth() {
        var root = _this.getRoot();
        root.width += 1;
        common.defer(function() {
          root.width -= 1;
        });
      }

      if (!params.parent) {
        resetWidth();
      }

  };

  GUI.toggleHide = function() {

    hide = !hide;
    common.each(hideable_guis, function(gui) {
      gui.domElement.style.zIndex = hide ? -999 : 999;
      gui.domElement.style.opacity = hide ? 0 : 1;
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_DRAG = 'drag';

  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  dom.bind(window, 'keydown', function(e) {

    if (document.activeElement.type !== 'text' &&
        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }

  }, false);

  common.extend(

      GUI.prototype,

      /** @lends dat.gui.GUI */
      {

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.Controller} The new controller that was added.
         * @instance
         */
        add: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
              }
          );

        },

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.ColorController} The new controller that was added.
         * @instance
         */
        addColor: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                color: true
              }
          );

        },

        /**
         * @param controller
         * @instance
         */
        remove: function(controller) {

          // TODO listening?
          this.__ul.removeChild(controller.__li);
          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
          var _this = this;
          common.defer(function() {
            _this.onResize();
          });

        },

        destroy: function() {

          if (this.autoPlace) {
            auto_place_container.removeChild(this.domElement);
          }

        },

        /**
         * @param name
         * @returns {dat.gui.GUI} The new folder.
         * @throws {Error} if this GUI already has a folder by the specified
         * name
         * @instance
         */
        addFolder: function(name) {

          // We have to prevent collisions on names in order to have a key
          // by which to remember saved values
          if (this.__folders[name] !== undefined) {
            throw new Error('You already have a folder in this GUI by the' +
                ' name "' + name + '"');
          }

          var new_gui_params = { name: name, parent: this };

          // We need to pass down the autoPlace trait so that we can
          // attach event listeners to open/close folder actions to
          // ensure that a scrollbar appears if the window is too short.
          new_gui_params.autoPlace = this.autoPlace;

          // Do we have saved appearance data for this folder?

          if (this.load && // Anything loaded?
              this.load.folders && // Was my parent a dead-end?
              this.load.folders[name]) { // Did daddy remember me?

            // Start me closed if I was closed
            new_gui_params.closed = this.load.folders[name].closed;

            // Pass down the loaded data
            new_gui_params.load = this.load.folders[name];

          }

          var gui = new GUI(new_gui_params);
          this.__folders[name] = gui;

          var li = addRow(this, gui.domElement);
          dom.addClass(li, 'folder');
          return gui;

        },

        open: function() {
          this.closed = false;
        },

        close: function() {
          this.closed = true;
        },

        onResize: function() {

          var root = this.getRoot();

          if (root.scrollable) {

            var top = dom.getOffset(root.__ul).top;
            var h = 0;

            common.each(root.__ul.childNodes, function(node) {
              if (! (root.autoPlace && node === root.__save_row))
                h += dom.getHeight(node);
            });

            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
            } else {
              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = 'auto';
            }

          }

          if (root.__resize_handle) {
            common.defer(function() {
              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
            });
          }

          if (root.__closeButton) {
            root.__closeButton.style.width = root.width + 'px';
          }

        },

        /**
         * Mark objects for saving. The order of these objects cannot change as
         * the GUI grows. When remembering new objects, append them to the end
         * of the list.
         *
         * @param {Object...} objects
         * @throws {Error} if not called on a top level GUI.
         * @instance
         */
        remember: function() {

          if (common.isUndefined(SAVE_DIALOGUE)) {
            SAVE_DIALOGUE = new CenteredDiv();
            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
          }

          if (this.parent) {
            throw new Error("You can only call remember on a top level GUI.");
          }

          var _this = this;

          common.each(Array.prototype.slice.call(arguments), function(object) {
            if (_this.__rememberedObjects.length == 0) {
              addSaveMenu(_this);
            }
            if (_this.__rememberedObjects.indexOf(object) == -1) {
              _this.__rememberedObjects.push(object);
            }
          });

          if (this.autoPlace) {
            // Set save row width
            setWidth(this, this.width);
          }

        },

        /**
         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
         * @instance
         */
        getRoot: function() {
          var gui = this;
          while (gui.parent) {
            gui = gui.parent;
          }
          return gui;
        },

        /**
         * @returns {Object} a JSON object representing the current state of
         * this GUI as well as its remembered properties.
         * @instance
         */
        getSaveObject: function() {

          var toReturn = this.load;

          toReturn.closed = this.closed;

          // Am I remembering any values?
          if (this.__rememberedObjects.length > 0) {

            toReturn.preset = this.preset;

            if (!toReturn.remembered) {
              toReturn.remembered = {};
            }

            toReturn.remembered[this.preset] = getCurrentPreset(this);

          }

          toReturn.folders = {};
          common.each(this.__folders, function(element, key) {
            toReturn.folders[key] = element.getSaveObject();
          });

          return toReturn;

        },

        save: function() {

          if (!this.load.remembered) {
            this.load.remembered = {};
          }

          this.load.remembered[this.preset] = getCurrentPreset(this);
          markPresetModified(this, false);

        },

        saveAs: function(presetName) {

          if (!this.load.remembered) {

            // Retain default values upon first save
            this.load.remembered = {};
            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

          }

          this.load.remembered[presetName] = getCurrentPreset(this);
          this.preset = presetName;
          addPresetOption(this, presetName, true);

        },

        revert: function(gui) {

          common.each(this.__controllers, function(controller) {
            // Make revert work on Default.
            if (!this.getRoot().load.remembered) {
              controller.setValue(controller.initialValue);
            } else {
              recallSavedValue(gui || this.getRoot(), controller);
            }
          }, this);

          common.each(this.__folders, function(folder) {
            folder.revert(folder);
          });

          if (!gui) {
            markPresetModified(this.getRoot(), false);
          }


        },

        listen: function(controller) {

          var init = this.__listening.length == 0;
          this.__listening.push(controller);
          if (init) updateDisplays(this.__listening);

        }

      }

  );

  function add(gui, object, property, params) {

    if (object[property] === undefined) {
      throw new Error("Object " + object + " has no property \"" + property + "\"");
    }

    var controller;

    if (params.color) {

      controller = new ColorController(object, property);

    } else {

      var factoryArgs = [object,property].concat(params.factoryArgs);
      controller = controllerFactory.apply(gui, factoryArgs);

    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);

    dom.addClass(controller.domElement, 'c');

    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;

    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);

    var li = addRow(gui, container, params.before);

    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
    dom.addClass(li, typeof controller.getValue());

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;

  }

  /**
   * Add a row to the end of the GUI or before another row.
   *
   * @param gui
   * @param [dom] If specified, inserts the dom content in the new row
   * @param [liBefore] If specified, places the new row before another row
   */
  function addRow(gui, dom, liBefore) {
    var li = document.createElement('li');
    if (dom) li.appendChild(dom);
    if (liBefore) {
      gui.__ul.insertBefore(li, params.before);
    } else {
      gui.__ul.appendChild(li);
    }
    gui.onResize();
    return li;
  }

  function augmentController(gui, li, controller) {

    controller.__li = li;
    controller.__gui = gui;

    common.extend(controller, {

      options: function(options) {

        if (arguments.length > 1) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [common.toArray(arguments)]
              }
          );

        }

        if (common.isArray(options) || common.isObject(options)) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [options]
              }
          );

        }

      },

      name: function(v) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
        return controller;
      },

      listen: function() {
        controller.__gui.listen(controller);
        return controller;
      },

      remove: function() {
        controller.__gui.remove(controller);
        return controller;
      }

    });

    // All sliders should be accompanied by a box.
    if (controller instanceof NumberControllerSlider) {

      var box = new NumberControllerBox(controller.object, controller.property,
          { min: controller.__min, max: controller.__max, step: controller.__step });

      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pc.apply(controller, args);
          return pb.apply(box, args);
        }
      });

      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

    }
    else if (controller instanceof NumberControllerBox) {

      var r = function(returned) {

        // Have we defined both boundaries?
        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

          // Well, then lets just replace this with a slider.
          controller.remove();
          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [controller.__min, controller.__max, controller.__step]
              });

        }

        return returned;

      };

      controller.min = common.compose(r, controller.min);
      controller.max = common.compose(r, controller.max);

    }
    else if (controller instanceof BooleanController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__checkbox, 'click');
      });

      dom.bind(controller.__checkbox, 'click', function(e) {
        e.stopPropagation(); // Prevents double-toggle
      })

    }
    else if (controller instanceof FunctionController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__button, 'click');
      });

      dom.bind(li, 'mouseover', function() {
        dom.addClass(controller.__button, 'hover');
      });

      dom.bind(li, 'mouseout', function() {
        dom.removeClass(controller.__button, 'hover');
      });

    }
    else if (controller instanceof ColorController) {

      dom.addClass(li, 'color');
      controller.updateDisplay = common.compose(function(r) {
        li.style.borderLeftColor = controller.__color.toString();
        return r;
      }, controller.updateDisplay);

      controller.updateDisplay();

    }

    controller.setValue = common.compose(function(r) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }
      return r;
    }, controller.setValue);

  }

  function recallSavedValue(gui, controller) {

    // Find the topmost GUI, that's where remembered objects live.
    var root = gui.getRoot();

    // Does the object we're controlling match anything we've been told to
    // remember?
    var matched_index = root.__rememberedObjects.indexOf(controller.object);

    // Why yes, it does!
    if (matched_index != -1) {

      // Let me fetch a map of controllers for thcommon.isObject.
      var controller_map =
          root.__rememberedObjectIndecesToControllers[matched_index];

      // Ohp, I believe this is the first controller we've created for this
      // object. Lets make the map fresh.
      if (controller_map === undefined) {
        controller_map = {};
        root.__rememberedObjectIndecesToControllers[matched_index] =
            controller_map;
      }

      // Keep track of this controller
      controller_map[controller.property] = controller;

      // Okay, now have we saved any values for this controller?
      if (root.load && root.load.remembered) {

        var preset_map = root.load.remembered;

        // Which preset are we trying to load?
        var preset;

        if (preset_map[gui.preset]) {

          preset = preset_map[gui.preset];

        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

          // Uhh, you can have the default instead?
          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

        } else {

          // Nada.

          return;

        }


        // Did the loaded object remember thcommon.isObject?
        if (preset[matched_index] &&

          // Did we remember this particular property?
            preset[matched_index][controller.property] !== undefined) {

          // We did remember something for this guy ...
          var value = preset[matched_index][controller.property];

          // And that's what it is.
          controller.initialValue = value;
          controller.setValue(value);

        }

      }

    }

  }

  function getLocalStorageHash(gui, key) {
    // TODO how does this deal with multiple GUI's?
    return document.location.href + '.' + key;

  }

  function addSaveMenu(gui) {

    var div = gui.__save_row = document.createElement('li');

    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');

    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');

    // TODO replace with FunctionController
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');

    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');

    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');

    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {

      common.each(gui.load.remembered, function(value, key) {
        addPresetOption(gui, key, key == gui.preset);
      });

    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function() {


      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;

    });

    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {

      var saveLocally = document.getElementById('dg-save-locally');
      var explain = document.getElementById('dg-local-explain');

      saveLocally.style.display = 'block';

      var localStorageCheckBox = document.getElementById('dg-local-storage');

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      function showHideExplain() {
        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
      }

      showHideExplain();

      // TODO: Use a boolean controller, fool!
      dom.bind(localStorageCheckBox, 'change', function() {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain();
      });

    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');

    dom.bind(newConstructorTextArea, 'keydown', function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
        SAVE_DIALOGUE.hide();
      }
    });

    dom.bind(gears, 'click', function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });

    dom.bind(button, 'click', function() {
      gui.save();
    });

    dom.bind(button2, 'click', function() {
      var presetName = prompt('Enter a new preset name.');
      if (presetName) gui.saveAs(presetName);
    });

    dom.bind(button3, 'click', function() {
      gui.revert();
    });

//    div.appendChild(button2);

  }

  function addResizeHandle(gui) {

    gui.__resize_handle = document.createElement('div');

    common.extend(gui.__resize_handle.style, {

      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
//      border: '1px solid blue'

    });

    var pmouseX;

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);

    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

    function dragStart(e) {

      e.preventDefault();

      pmouseX = e.clientX;

      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);

      return false;

    }

    function drag(e) {

      e.preventDefault();

      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;

      return false;

    }

    function dragStop() {

      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);

    }

  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';
    // Auto placed save-rows are position fixed, so we have to
    // set the width manually if we want it to bleed to the edge
    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {

    var toReturn = {};

    // For each object I'm remembering
    common.each(gui.__rememberedObjects, function(val, index) {

      var saved_values = {};

      // The controllers I've made for thcommon.isObject by property
      var controller_map =
          gui.__rememberedObjectIndecesToControllers[index];

      // Remember each value for each property
      common.each(controller_map, function(controller, property) {
        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });

      // Save the values for thcommon.isObject
      toReturn[index] = saved_values;

    });

    return toReturn;

  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;
    gui.__preset_select.appendChild(opt);
    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value == gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
//    console.log('mark', modified, opt);
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function updateDisplays(controllerArray) {


    if (controllerArray.length != 0) {

      requestAnimationFrame(function() {
        updateDisplays(controllerArray);
      });

    }

    common.each(controllerArray, function(c) {
      c.updateDisplay();
    });

  }

  return GUI;

})(dat.utils.css,
"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

      return function(object, property) {

        var initialValue = object[property];

        // Providing options?
        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
          return new OptionController(object, property, arguments[2]);
        }

        // Providing a map?

        if (common.isNumber(initialValue)) {

          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

            // Has min and max.
            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

          } else {

            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

          }

        }

        if (common.isString(initialValue)) {
          return new StringController(object, property);
        }

        if (common.isFunction(initialValue)) {
          return new FunctionController(object, property, '');
        }

        if (common.isBoolean(initialValue)) {
          return new BooleanController(object, property);
        }

      }

    })(dat.controllers.OptionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.StringController = (function (Controller, dom, common) {

  /**
   * @class Provides a text input to alter the string property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var StringController = function(object, property) {

    StringController.superclass.call(this, object, property);

    var _this = this;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    dom.bind(this.__input, 'keyup', onChange);
    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    

    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  StringController.superclass = Controller;

  common.extend(

      StringController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {
          // Stops the caret from moving on account of:
          // keyup -> setValue -> updateDisplay
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return StringController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return StringController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common),
dat.controllers.FunctionController,
dat.controllers.BooleanController,
dat.utils.common),
dat.controllers.Controller,
dat.controllers.BooleanController,
dat.controllers.FunctionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.OptionController,
dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

  var ColorController = function(object, property) {

    ColorController.superclass.call(this, object, property);

    this.__color = new Color(this.getValue());
    this.__temp = new Color(0);

    var _this = this;

    this.domElement = document.createElement('div');

    dom.makeSelectable(this.domElement, false);

    this.__selector = document.createElement('div');
    this.__selector.className = 'selector';

    this.__saturation_field = document.createElement('div');
    this.__saturation_field.className = 'saturation-field';

    this.__field_knob = document.createElement('div');
    this.__field_knob.className = 'field-knob';
    this.__field_knob_border = '2px solid ';

    this.__hue_knob = document.createElement('div');
    this.__hue_knob.className = 'hue-knob';

    this.__hue_field = document.createElement('div');
    this.__hue_field.className = 'hue-field';

    this.__input = document.createElement('input');
    this.__input.type = 'text';
    this.__input_textShadow = '0 1px 1px ';

    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) { // on enter
        onBlur.call(this);
      }
    });

    dom.bind(this.__input, 'blur', onBlur);

    dom.bind(this.__selector, 'mousedown', function(e) {

      dom
        .addClass(this, 'drag')
        .bind(window, 'mouseup', function(e) {
          dom.removeClass(_this.__selector, 'drag');
        });

    });

    var value_field = document.createElement('div');

    common.extend(this.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });

    common.extend(this.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    
    common.extend(this.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });

    common.extend(this.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });

    common.extend(value_field.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    
    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

    common.extend(this.__hue_field.style, {
      width: '15px',
      height: '100px',
      display: 'inline-block',
      border: '1px solid #555',
      cursor: 'ns-resize'
    });

    hueGradient(this.__hue_field);

    common.extend(this.__input.style, {
      outline: 'none',
//      width: '120px',
      textAlign: 'center',
//      padding: '4px',
//      marginBottom: '6px',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
    });

    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
    dom.bind(this.__field_knob, 'mousedown', fieldDown);

    dom.bind(this.__hue_field, 'mousedown', function(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'mouseup', unbindH);
    });

    function fieldDown(e) {
      setSV(e);
      // document.body.style.cursor = 'none';
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'mouseup', unbindSV);
    }

    function unbindSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'mouseup', unbindSV);
      // document.body.style.cursor = 'default';
    }

    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function unbindH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'mouseup', unbindH);
    }

    this.__saturation_field.appendChild(value_field);
    this.__selector.appendChild(this.__field_knob);
    this.__selector.appendChild(this.__saturation_field);
    this.__selector.appendChild(this.__hue_field);
    this.__hue_field.appendChild(this.__hue_knob);

    this.domElement.appendChild(this.__input);
    this.domElement.appendChild(this.__selector);

    this.updateDisplay();

    function setSV(e) {

      e.preventDefault();

      var w = dom.getWidth(_this.__saturation_field);
      var o = dom.getOffset(_this.__saturation_field);
      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

      if (v > 1) v = 1;
      else if (v < 0) v = 0;

      if (s > 1) s = 1;
      else if (s < 0) s = 0;

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());


      return false;

    }

    function setH(e) {

      e.preventDefault();

      var s = dom.getHeight(_this.__hue_field);
      var o = dom.getOffset(_this.__hue_field);
      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

      if (h > 1) h = 1;
      else if (h < 0) h = 0;

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;

    }

  };

  ColorController.superclass = Controller;

  common.extend(

      ColorController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {

          var i = interpret(this.getValue());

          if (i !== false) {

            var mismatch = false;

            // Check for mismatch on the interpreted value.

            common.each(Color.COMPONENTS, function(component) {
              if (!common.isUndefined(i[component]) &&
                  !common.isUndefined(this.__color.__state[component]) &&
                  i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {}; // break
              }
            }, this);

            // If nothing diverges, we keep our previous values
            // for statefulness, otherwise we recalculate fresh
            if (mismatch) {
              common.extend(this.__color.__state, i);
            }

          }

          common.extend(this.__temp.__state, this.__color.__state);

          this.__temp.a = 1;

          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
          var _flip = 255 - flip;

          common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + 'px',
            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
            backgroundColor: this.__temp.toString(),
            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
          });

          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

          this.__temp.s = 1;
          this.__temp.v = 1;

          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

          common.extend(this.__input.style, {
            backgroundColor: this.__input.value = this.__color.toString(),
            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
          });

        }

      }

  );
  
  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
  
  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    common.each(vendors, function(vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
    });
  }
  
  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  }


  return ColorController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret,
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common),
dat.color.interpret,
dat.utils.common),
dat.utils.requestAnimationFrame = (function () {

  /**
   * requirejs version of Paul Irish's RequestAnimationFrame
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */

  return window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {

        window.setTimeout(callback, 1000 / 60);

      };
})(),
dat.dom.CenteredDiv = (function (dom, common) {


  var CenteredDiv = function() {

    this.backgroundElement = document.createElement('div');
    common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear'
    });

    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';

    this.domElement = document.createElement('div');
    common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
    });


    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;
    dom.bind(this.backgroundElement, 'click', function() {
      _this.hide();
    });


  };

  CenteredDiv.prototype.show = function() {

    var _this = this;
    


    this.backgroundElement.style.display = 'block';

    this.domElement.style.display = 'block';
    this.domElement.style.opacity = 0;
//    this.domElement.style.top = '52%';
    this.domElement.style.webkitTransform = 'scale(1.1)';

    this.layout();

    common.defer(function() {
      _this.backgroundElement.style.opacity = 1;
      _this.domElement.style.opacity = 1;
      _this.domElement.style.webkitTransform = 'scale(1)';
    });

  };

  CenteredDiv.prototype.hide = function() {

    var _this = this;

    var hide = function() {

      _this.domElement.style.display = 'none';
      _this.backgroundElement.style.display = 'none';

      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
      dom.unbind(_this.domElement, 'transitionend', hide);
      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

    };

    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
    dom.bind(this.domElement, 'transitionend', hide);
    dom.bind(this.domElement, 'oTransitionEnd', hide);

    this.backgroundElement.style.opacity = 0;
//    this.domElement.style.top = '48%';
    this.domElement.style.opacity = 0;
    this.domElement.style.webkitTransform = 'scale(1.1)';

  };

  CenteredDiv.prototype.layout = function() {
    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
  };
  
  function lockScroll(e) {
    console.log(e);
  }

  return CenteredDiv;

})(dat.dom.dom,
dat.utils.common),
dat.dom.dom,
dat.utils.common);
},{}],6:[function(require,module,exports){
/*
	Ractive.js v0.7.3
	Sat Apr 25 2015 13:52:38 GMT-0400 (EDT) - commit da40f81c660ba2f09c45a09a9c20fdd34ee36d80

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  global.Ractive = factory()
}(this, function () { 'use strict';

  var TEMPLATE_VERSION = 3;

  var defaultOptions = {

  	// render placement:
  	el: void 0,
  	append: false,

  	// template:
  	template: { v: TEMPLATE_VERSION, t: [] },

  	// parse:     // TODO static delimiters?
  	preserveWhitespace: false,
  	sanitize: false,
  	stripComments: true,
  	delimiters: ["{{", "}}"],
  	tripleDelimiters: ["{{{", "}}}"],
  	interpolate: false,

  	// data & binding:
  	data: {},
  	computed: {},
  	magic: false,
  	modifyArrays: true,
  	adapt: [],
  	isolated: false,
  	twoway: true,
  	lazy: false,

  	// transitions:
  	noIntro: false,
  	transitionsEnabled: true,
  	complete: void 0,

  	// css:
  	css: null,
  	noCssTransform: false
  };

  var config_defaults = defaultOptions;

  // These are a subset of the easing equations found at
  // https://raw.github.com/danro/easing-js - license info
  // follows:

  // --------------------------------------------------
  // easing.js v0.5.4
  // Generic set of easing functions with AMD support
  // https://github.com/danro/easing-js
  // This code may be freely distributed under the MIT license
  // http://danro.mit-license.org/
  // --------------------------------------------------
  // All functions adapted from Thomas Fuchs & Jeremy Kahn
  // Easing Equations (c) 2003 Robert Penner, BSD license
  // https://raw.github.com/danro/easing-js/master/LICENSE
  // --------------------------------------------------

  // In that library, the functions named easeIn, easeOut, and
  // easeInOut below are named easeInCubic, easeOutCubic, and
  // (you guessed it) easeInOutCubic.
  //
  // You can add additional easing functions to this list, and they
  // will be globally available.

  var static_easing = {
  	linear: function (pos) {
  		return pos;
  	},
  	easeIn: function (pos) {
  		return Math.pow(pos, 3);
  	},
  	easeOut: function (pos) {
  		return Math.pow(pos - 1, 3) + 1;
  	},
  	easeInOut: function (pos) {
  		if ((pos /= 0.5) < 1) {
  			return 0.5 * Math.pow(pos, 3);
  		}
  		return 0.5 * (Math.pow(pos - 2, 3) + 2);
  	}
  };

  /*global console, navigator */
  var isClient, isJsdom, hasConsole, environment__magic, namespaces, svg, vendors;

  isClient = typeof document === "object";

  isJsdom = typeof navigator !== "undefined" && /jsDom/.test(navigator.appName);

  hasConsole = typeof console !== "undefined" && typeof console.warn === "function" && typeof console.warn.apply === "function";

  try {
  	Object.defineProperty({}, "test", { value: 0 });
  	environment__magic = true;
  } catch (e) {
  	environment__magic = false;
  }

  namespaces = {
  	html: "http://www.w3.org/1999/xhtml",
  	mathml: "http://www.w3.org/1998/Math/MathML",
  	svg: "http://www.w3.org/2000/svg",
  	xlink: "http://www.w3.org/1999/xlink",
  	xml: "http://www.w3.org/XML/1998/namespace",
  	xmlns: "http://www.w3.org/2000/xmlns/"
  };

  if (typeof document === "undefined") {
  	svg = false;
  } else {
  	svg = document && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
  }

  vendors = ["o", "ms", "moz", "webkit"];

  var createElement, matches, dom__div, methodNames, unprefixed, prefixed, dom__i, j, makeFunction;

  // Test for SVG support
  if (!svg) {
  	createElement = function (type, ns) {
  		if (ns && ns !== namespaces.html) {
  			throw "This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information";
  		}

  		return document.createElement(type);
  	};
  } else {
  	createElement = function (type, ns) {
  		if (!ns || ns === namespaces.html) {
  			return document.createElement(type);
  		}

  		return document.createElementNS(ns, type);
  	};
  }

  function getElement(input) {
  	var output;

  	if (!input || typeof input === "boolean") {
  		return;
  	}

  	if (typeof window === "undefined" || !document || !input) {
  		return null;
  	}

  	// We already have a DOM node - no work to do. (Duck typing alert!)
  	if (input.nodeType) {
  		return input;
  	}

  	// Get node from string
  	if (typeof input === "string") {
  		// try ID first
  		output = document.getElementById(input);

  		// then as selector, if possible
  		if (!output && document.querySelector) {
  			output = document.querySelector(input);
  		}

  		// did it work?
  		if (output && output.nodeType) {
  			return output;
  		}
  	}

  	// If we've been given a collection (jQuery, Zepto etc), extract the first item
  	if (input[0] && input[0].nodeType) {
  		return input[0];
  	}

  	return null;
  }

  if (!isClient) {
  	matches = null;
  } else {
  	dom__div = createElement("div");
  	methodNames = ["matches", "matchesSelector"];

  	makeFunction = function (methodName) {
  		return function (node, selector) {
  			return node[methodName](selector);
  		};
  	};

  	dom__i = methodNames.length;

  	while (dom__i-- && !matches) {
  		unprefixed = methodNames[dom__i];

  		if (dom__div[unprefixed]) {
  			matches = makeFunction(unprefixed);
  		} else {
  			j = vendors.length;
  			while (j--) {
  				prefixed = vendors[dom__i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);

  				if (dom__div[prefixed]) {
  					matches = makeFunction(prefixed);
  					break;
  				}
  			}
  		}
  	}

  	// IE8...
  	if (!matches) {
  		matches = function (node, selector) {
  			var nodes, parentNode, i;

  			parentNode = node.parentNode;

  			if (!parentNode) {
  				// empty dummy <div>
  				dom__div.innerHTML = "";

  				parentNode = dom__div;
  				node = node.cloneNode();

  				dom__div.appendChild(node);
  			}

  			nodes = parentNode.querySelectorAll(selector);

  			i = nodes.length;
  			while (i--) {
  				if (nodes[i] === node) {
  					return true;
  				}
  			}

  			return false;
  		};
  	}
  }

  function detachNode(node) {
  	if (node && typeof node.parentNode !== "unknown" && node.parentNode) {
  		node.parentNode.removeChild(node);
  	}

  	return node;
  }

  function safeToStringValue(value) {
  	return value == null || !value.toString ? "" : value;
  }

  var legacy = null;

  var create, defineProperty, defineProperties;

  try {
  	Object.defineProperty({}, "test", { value: 0 });

  	if (isClient) {
  		Object.defineProperty(document.createElement("div"), "test", { value: 0 });
  	}

  	defineProperty = Object.defineProperty;
  } catch (err) {
  	// Object.defineProperty doesn't exist, or we're in IE8 where you can
  	// only use it with DOM objects (what were you smoking, MSFT?)
  	defineProperty = function (obj, prop, desc) {
  		obj[prop] = desc.value;
  	};
  }

  try {
  	try {
  		Object.defineProperties({}, { test: { value: 0 } });
  	} catch (err) {
  		// TODO how do we account for this? noMagic = true;
  		throw err;
  	}

  	if (isClient) {
  		Object.defineProperties(createElement("div"), { test: { value: 0 } });
  	}

  	defineProperties = Object.defineProperties;
  } catch (err) {
  	defineProperties = function (obj, props) {
  		var prop;

  		for (prop in props) {
  			if (props.hasOwnProperty(prop)) {
  				defineProperty(obj, prop, props[prop]);
  			}
  		}
  	};
  }

  try {
  	Object.create(null);

  	create = Object.create;
  } catch (err) {
  	// sigh
  	create = (function () {
  		var F = function () {};

  		return function (proto, props) {
  			var obj;

  			if (proto === null) {
  				return {};
  			}

  			F.prototype = proto;
  			obj = new F();

  			if (props) {
  				Object.defineProperties(obj, props);
  			}

  			return obj;
  		};
  	})();
  }

  function utils_object__extend(target) {
  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		sources[_key - 1] = arguments[_key];
  	}

  	var prop, source;

  	while (source = sources.shift()) {
  		for (prop in source) {
  			if (hasOwn.call(source, prop)) {
  				target[prop] = source[prop];
  			}
  		}
  	}

  	return target;
  }

  function fillGaps(target) {
  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		sources[_key - 1] = arguments[_key];
  	}

  	sources.forEach(function (s) {
  		for (var key in s) {
  			if (s.hasOwnProperty(key) && !(key in target)) {
  				target[key] = s[key];
  			}
  		}
  	});

  	return target;
  }

  var hasOwn = Object.prototype.hasOwnProperty;

  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
  var is__toString = Object.prototype.toString,
      arrayLikePattern = /^\[object (?:Array|FileList)\]$/;
  function isArray(thing) {
  	return is__toString.call(thing) === "[object Array]";
  }

  function isArrayLike(obj) {
  	return arrayLikePattern.test(is__toString.call(obj));
  }

  function isEqual(a, b) {
  	if (a === null && b === null) {
  		return true;
  	}

  	if (typeof a === "object" || typeof b === "object") {
  		return false;
  	}

  	return a === b;
  }

  function is__isNumeric(thing) {
  	return !isNaN(parseFloat(thing)) && isFinite(thing);
  }

  function isObject(thing) {
  	return thing && is__toString.call(thing) === "[object Object]";
  }

  var noop = function () {};

  /* global console */
  var alreadyWarned = {},
      log,
      printWarning,
      welcome;

  if (hasConsole) {
  	(function () {
  		var welcomeIntro = ["%cRactive.js %c0.7.3 %cin debug mode, %cmore...", "color: rgb(114, 157, 52); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;"];
  		var welcomeMessage = "You're running Ractive 0.7.3 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\n\nTo disable debug mode, add this line at the start of your app:\n  Ractive.DEBUG = false;\n\nTo disable debug mode when your app is minified, add this snippet:\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\n\nGet help and support:\n  http://docs.ractivejs.org\n  http://stackoverflow.com/questions/tagged/ractivejs\n  http://groups.google.com/forum/#!forum/ractive-js\n  http://twitter.com/ractivejs\n\nFound a bug? Raise an issue:\n  https://github.com/ractivejs/ractive/issues\n\n";

  		welcome = function () {
  			var hasGroup = !!console.groupCollapsed;
  			console[hasGroup ? "groupCollapsed" : "log"].apply(console, welcomeIntro);
  			console.log(welcomeMessage);
  			if (hasGroup) {
  				console.groupEnd(welcomeIntro);
  			}

  			welcome = noop;
  		};

  		printWarning = function (message, args) {
  			welcome();

  			// extract information about the instance this message pertains to, if applicable
  			if (typeof args[args.length - 1] === "object") {
  				var options = args.pop();
  				var ractive = options ? options.ractive : null;

  				if (ractive) {
  					// if this is an instance of a component that we know the name of, add
  					// it to the message
  					var _name = undefined;
  					if (ractive.component && (_name = ractive.component.name)) {
  						message = "<" + _name + "> " + message;
  					}

  					var node = undefined;
  					if (node = options.node || ractive.fragment && ractive.fragment.rendered && ractive.find("*")) {
  						args.push(node);
  					}
  				}
  			}

  			console.warn.apply(console, ["%cRactive.js: %c" + message, "color: rgb(114, 157, 52);", "color: rgb(85, 85, 85);"].concat(args));
  		};

  		log = function () {
  			console.log.apply(console, arguments);
  		};
  	})();
  } else {
  	printWarning = log = welcome = noop;
  }

  function format(message, args) {
  	return message.replace(/%s/g, function () {
  		return args.shift();
  	});
  }

  function fatal(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);
  	throw new Error(message);
  }

  function logIfDebug() {
  	if (_Ractive.DEBUG) {
  		log.apply(null, arguments);
  	}
  }

  function warn(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);
  	printWarning(message, args);
  }

  function warnOnce(message) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	message = format(message, args);

  	if (alreadyWarned[message]) {
  		return;
  	}

  	alreadyWarned[message] = true;
  	printWarning(message, args);
  }

  function warnIfDebug() {
  	if (_Ractive.DEBUG) {
  		warn.apply(null, arguments);
  	}
  }

  function warnOnceIfDebug() {
  	if (_Ractive.DEBUG) {
  		warnOnce.apply(null, arguments);
  	}
  }

  // Error messages that are used (or could be) in multiple places
  var badArguments = "Bad arguments";
  var noRegistryFunctionReturn = "A function was specified for \"%s\" %s, but no %s was returned";
  var missingPlugin = function (name, type) {
    return "Missing \"" + name + "\" " + type + " plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#" + type + "s";
  };

  function findInViewHierarchy(registryName, ractive, name) {
  	var instance = findInstance(registryName, ractive, name);
  	return instance ? instance[registryName][name] : null;
  }

  function findInstance(registryName, ractive, name) {
  	while (ractive) {
  		if (name in ractive[registryName]) {
  			return ractive;
  		}

  		if (ractive.isolated) {
  			return null;
  		}

  		ractive = ractive.parent;
  	}
  }

  var interpolate = function (from, to, ractive, type) {
  	if (from === to) {
  		return snap(to);
  	}

  	if (type) {

  		var interpol = findInViewHierarchy("interpolators", ractive, type);
  		if (interpol) {
  			return interpol(from, to) || snap(to);
  		}

  		fatal(missingPlugin(type, "interpolator"));
  	}

  	return static_interpolators.number(from, to) || static_interpolators.array(from, to) || static_interpolators.object(from, to) || snap(to);
  };

  var shared_interpolate = interpolate;

  function snap(to) {
  	return function () {
  		return to;
  	};
  }

  var interpolators = {
  	number: function (from, to) {
  		var delta;

  		if (!is__isNumeric(from) || !is__isNumeric(to)) {
  			return null;
  		}

  		from = +from;
  		to = +to;

  		delta = to - from;

  		if (!delta) {
  			return function () {
  				return from;
  			};
  		}

  		return function (t) {
  			return from + t * delta;
  		};
  	},

  	array: function (from, to) {
  		var intermediate, interpolators, len, i;

  		if (!isArray(from) || !isArray(to)) {
  			return null;
  		}

  		intermediate = [];
  		interpolators = [];

  		i = len = Math.min(from.length, to.length);
  		while (i--) {
  			interpolators[i] = shared_interpolate(from[i], to[i]);
  		}

  		// surplus values - don't interpolate, but don't exclude them either
  		for (i = len; i < from.length; i += 1) {
  			intermediate[i] = from[i];
  		}

  		for (i = len; i < to.length; i += 1) {
  			intermediate[i] = to[i];
  		}

  		return function (t) {
  			var i = len;

  			while (i--) {
  				intermediate[i] = interpolators[i](t);
  			}

  			return intermediate;
  		};
  	},

  	object: function (from, to) {
  		var properties, len, interpolators, intermediate, prop;

  		if (!isObject(from) || !isObject(to)) {
  			return null;
  		}

  		properties = [];
  		intermediate = {};
  		interpolators = {};

  		for (prop in from) {
  			if (hasOwn.call(from, prop)) {
  				if (hasOwn.call(to, prop)) {
  					properties.push(prop);
  					interpolators[prop] = shared_interpolate(from[prop], to[prop]);
  				} else {
  					intermediate[prop] = from[prop];
  				}
  			}
  		}

  		for (prop in to) {
  			if (hasOwn.call(to, prop) && !hasOwn.call(from, prop)) {
  				intermediate[prop] = to[prop];
  			}
  		}

  		len = properties.length;

  		return function (t) {
  			var i = len,
  			    prop;

  			while (i--) {
  				prop = properties[i];

  				intermediate[prop] = interpolators[prop](t);
  			}

  			return intermediate;
  		};
  	}
  };

  var static_interpolators = interpolators;

  // This function takes a keypath such as 'foo.bar.baz', and returns
  // all the variants of that keypath that include a wildcard in place
  // of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
  // These are then checked against the dependants map (ractive.viewmodel.depsMap)
  // to see if any pattern observers are downstream of one or more of
  // these wildcard keypaths (e.g. 'foo.bar.*.status')
  var utils_getPotentialWildcardMatches = getPotentialWildcardMatches;

  var starMaps = {};
  function getPotentialWildcardMatches(keypath) {
  	var keys, starMap, mapper, i, result, wildcardKeypath;

  	keys = keypath.split(".");
  	if (!(starMap = starMaps[keys.length])) {
  		starMap = getStarMap(keys.length);
  	}

  	result = [];

  	mapper = function (star, i) {
  		return star ? "*" : keys[i];
  	};

  	i = starMap.length;
  	while (i--) {
  		wildcardKeypath = starMap[i].map(mapper).join(".");

  		if (!result.hasOwnProperty(wildcardKeypath)) {
  			result.push(wildcardKeypath);
  			result[wildcardKeypath] = true;
  		}
  	}

  	return result;
  }

  // This function returns all the possible true/false combinations for
  // a given number - e.g. for two, the possible combinations are
  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].
  // It does so by getting all the binary values between 0 and e.g. 11
  function getStarMap(num) {
  	var ones = "",
  	    max,
  	    binary,
  	    starMap,
  	    mapper,
  	    i,
  	    j,
  	    l,
  	    map;

  	if (!starMaps[num]) {
  		starMap = [];

  		while (ones.length < num) {
  			ones += 1;
  		}

  		max = parseInt(ones, 2);

  		mapper = function (digit) {
  			return digit === "1";
  		};

  		for (i = 0; i <= max; i += 1) {
  			binary = i.toString(2);
  			while (binary.length < num) {
  				binary = "0" + binary;
  			}

  			map = [];
  			l = binary.length;
  			for (j = 0; j < l; j++) {
  				map.push(mapper(binary[j]));
  			}
  			starMap[i] = map;
  		}

  		starMaps[num] = starMap;
  	}

  	return starMaps[num];
  }

  var refPattern = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
  var patternPattern = /\*/;
  var keypathCache = {};

  var Keypath = function (str) {
  	var keys = str.split(".");

  	this.str = str;

  	if (str[0] === "@") {
  		this.isSpecial = true;
  		this.value = decodeKeypath(str);
  	}

  	this.firstKey = keys[0];
  	this.lastKey = keys.pop();

  	this.isPattern = patternPattern.test(str);

  	this.parent = str === "" ? null : getKeypath(keys.join("."));
  	this.isRoot = !str;
  };

  Keypath.prototype = {
  	equalsOrStartsWith: function (keypath) {
  		return keypath === this || this.startsWith(keypath);
  	},

  	join: function (str) {
  		return getKeypath(this.isRoot ? String(str) : this.str + "." + str);
  	},

  	replace: function (oldKeypath, newKeypath) {
  		if (this === oldKeypath) {
  			return newKeypath;
  		}

  		if (this.startsWith(oldKeypath)) {
  			return newKeypath === null ? newKeypath : getKeypath(this.str.replace(oldKeypath.str + ".", newKeypath.str + "."));
  		}
  	},

  	startsWith: function (keypath) {
  		if (!keypath) {
  			// TODO under what circumstances does this happen?
  			return false;
  		}

  		return keypath && this.str.substr(0, keypath.str.length + 1) === keypath.str + ".";
  	},

  	toString: function () {
  		throw new Error("Bad coercion");
  	},

  	valueOf: function () {
  		throw new Error("Bad coercion");
  	},

  	wildcardMatches: function () {
  		return this._wildcardMatches || (this._wildcardMatches = utils_getPotentialWildcardMatches(this.str));
  	}
  };
  function assignNewKeypath(target, property, oldKeypath, newKeypath) {
  	var existingKeypath = target[property];

  	if (existingKeypath && (existingKeypath.equalsOrStartsWith(newKeypath) || !existingKeypath.equalsOrStartsWith(oldKeypath))) {
  		return;
  	}

  	target[property] = existingKeypath ? existingKeypath.replace(oldKeypath, newKeypath) : newKeypath;
  	return true;
  }

  function decodeKeypath(keypath) {
  	var value = keypath.slice(2);

  	if (keypath[1] === "i") {
  		return is__isNumeric(value) ? +value : value;
  	} else {
  		return value;
  	}
  }

  function getKeypath(str) {
  	if (str == null) {
  		return str;
  	}

  	// TODO it *may* be worth having two versions of this function - one where
  	// keypathCache inherits from null, and one for IE8. Depends on how
  	// much of an overhead hasOwnProperty is - probably negligible
  	if (!keypathCache.hasOwnProperty(str)) {
  		keypathCache[str] = new Keypath(str);
  	}

  	return keypathCache[str];
  }

  function getMatchingKeypaths(ractive, keypath) {
  	var keys, key, matchingKeypaths;

  	keys = keypath.str.split(".");
  	matchingKeypaths = [rootKeypath];

  	while (key = keys.shift()) {
  		if (key === "*") {
  			// expand to find all valid child keypaths
  			matchingKeypaths = matchingKeypaths.reduce(expand, []);
  		} else {
  			if (matchingKeypaths[0] === rootKeypath) {
  				// first key
  				matchingKeypaths[0] = getKeypath(key);
  			} else {
  				matchingKeypaths = matchingKeypaths.map(concatenate(key));
  			}
  		}
  	}

  	return matchingKeypaths;

  	function expand(matchingKeypaths, keypath) {
  		var wrapper, value, keys;

  		if (keypath.isRoot) {
  			keys = [].concat(Object.keys(ractive.viewmodel.data), Object.keys(ractive.viewmodel.mappings), Object.keys(ractive.viewmodel.computations));
  		} else {
  			wrapper = ractive.viewmodel.wrapped[keypath.str];
  			value = wrapper ? wrapper.get() : ractive.viewmodel.get(keypath);

  			keys = value ? Object.keys(value) : null;
  		}

  		if (keys) {
  			keys.forEach(function (key) {
  				if (key !== "_ractive" || !isArray(value)) {
  					matchingKeypaths.push(keypath.join(key));
  				}
  			});
  		}

  		return matchingKeypaths;
  	}
  }

  function concatenate(key) {
  	return function (keypath) {
  		return keypath.join(key);
  	};
  }
  function normalise(ref) {
  	return ref ? ref.replace(refPattern, ".$1") : "";
  }

  var rootKeypath = getKeypath("");

  var shared_add = add;
  var shared_add__errorMessage = "Cannot add to a non-numeric value";
  function add(root, keypath, d) {
  	if (typeof keypath !== "string" || !is__isNumeric(d)) {
  		throw new Error("Bad arguments");
  	}

  	var value = undefined,
  	    changes = undefined;

  	if (/\*/.test(keypath)) {
  		changes = {};

  		getMatchingKeypaths(root, getKeypath(normalise(keypath))).forEach(function (keypath) {
  			var value = root.viewmodel.get(keypath);

  			if (!is__isNumeric(value)) {
  				throw new Error(shared_add__errorMessage);
  			}

  			changes[keypath.str] = value + d;
  		});

  		return root.set(changes);
  	}

  	value = root.get(keypath);

  	if (!is__isNumeric(value)) {
  		throw new Error(shared_add__errorMessage);
  	}

  	return root.set(keypath, +value + d);
  }

  var prototype_add = Ractive$add;
  function Ractive$add(keypath, d) {
  	return shared_add(this, keypath, d === undefined ? 1 : +d);
  }

  var requestAnimationFrame;

  // If window doesn't exist, we don't need requestAnimationFrame
  if (typeof window === "undefined") {
  	requestAnimationFrame = null;
  } else {
  	// https://gist.github.com/paulirish/1579671
  	(function (vendors, lastTime, window) {

  		var x, setTimeout;

  		if (window.requestAnimationFrame) {
  			return;
  		}

  		for (x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
  			window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
  		}

  		if (!window.requestAnimationFrame) {
  			setTimeout = window.setTimeout;

  			window.requestAnimationFrame = function (callback) {
  				var currTime, timeToCall, id;

  				currTime = Date.now();
  				timeToCall = Math.max(0, 16 - (currTime - lastTime));
  				id = setTimeout(function () {
  					callback(currTime + timeToCall);
  				}, timeToCall);

  				lastTime = currTime + timeToCall;
  				return id;
  			};
  		}
  	})(vendors, 0, window);

  	requestAnimationFrame = window.requestAnimationFrame;
  }

  var rAF = requestAnimationFrame;

  var getTime;

  if (typeof window !== "undefined" && window.performance && typeof window.performance.now === "function") {
  	getTime = function () {
  		return window.performance.now();
  	};
  } else {
  	getTime = function () {
  		return Date.now();
  	};
  }

  var utils_getTime = getTime;

  var deprecations = {
  	construct: {
  		deprecated: "beforeInit",
  		replacement: "onconstruct"
  	},
  	render: {
  		deprecated: "init",
  		message: "The \"init\" method has been deprecated " + "and will likely be removed in a future release. " + "You can either use the \"oninit\" method which will fire " + "only once prior to, and regardless of, any eventual ractive " + "instance being rendered, or if you need to access the " + "rendered DOM, use \"onrender\" instead. " + "See http://docs.ractivejs.org/latest/migrating for more information."
  	},
  	complete: {
  		deprecated: "complete",
  		replacement: "oncomplete"
  	}
  };

  function Hook(event) {
  	this.event = event;
  	this.method = "on" + event;
  	this.deprecate = deprecations[event];
  }

  Hook.prototype.fire = function (ractive, arg) {
  	function call(method) {
  		if (ractive[method]) {
  			arg ? ractive[method](arg) : ractive[method]();
  			return true;
  		}
  	}

  	call(this.method);

  	if (!ractive[this.method] && this.deprecate && call(this.deprecate.deprecated)) {
  		if (this.deprecate.message) {
  			warnIfDebug(this.deprecate.message);
  		} else {
  			warnIfDebug("The method \"%s\" has been deprecated in favor of \"%s\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.", this.deprecate.deprecated, this.deprecate.replacement);
  		}
  	}

  	arg ? ractive.fire(this.event, arg) : ractive.fire(this.event);
  };

  var hooks_Hook = Hook;

  function addToArray(array, value) {
  	var index = array.indexOf(value);

  	if (index === -1) {
  		array.push(value);
  	}
  }

  function arrayContains(array, value) {
  	for (var i = 0, c = array.length; i < c; i++) {
  		if (array[i] == value) {
  			return true;
  		}
  	}

  	return false;
  }

  function arrayContentsMatch(a, b) {
  	var i;

  	if (!isArray(a) || !isArray(b)) {
  		return false;
  	}

  	if (a.length !== b.length) {
  		return false;
  	}

  	i = a.length;
  	while (i--) {
  		if (a[i] !== b[i]) {
  			return false;
  		}
  	}

  	return true;
  }

  function ensureArray(x) {
  	if (typeof x === "string") {
  		return [x];
  	}

  	if (x === undefined) {
  		return [];
  	}

  	return x;
  }

  function lastItem(array) {
  	return array[array.length - 1];
  }

  function removeFromArray(array, member) {
  	var index = array.indexOf(member);

  	if (index !== -1) {
  		array.splice(index, 1);
  	}
  }

  function toArray(arrayLike) {
  	var array = [],
  	    i = arrayLike.length;
  	while (i--) {
  		array[i] = arrayLike[i];
  	}

  	return array;
  }

  var _Promise,
      PENDING = {},
      FULFILLED = {},
      REJECTED = {};

  if (typeof Promise === "function") {
  	// use native Promise
  	_Promise = Promise;
  } else {
  	_Promise = function (callback) {
  		var fulfilledHandlers = [],
  		    rejectedHandlers = [],
  		    state = PENDING,
  		    result,
  		    dispatchHandlers,
  		    makeResolver,
  		    fulfil,
  		    reject,
  		    promise;

  		makeResolver = function (newState) {
  			return function (value) {
  				if (state !== PENDING) {
  					return;
  				}

  				result = value;
  				state = newState;

  				dispatchHandlers = makeDispatcher(state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result);

  				// dispatch onFulfilled and onRejected handlers asynchronously
  				wait(dispatchHandlers);
  			};
  		};

  		fulfil = makeResolver(FULFILLED);
  		reject = makeResolver(REJECTED);

  		try {
  			callback(fulfil, reject);
  		} catch (err) {
  			reject(err);
  		}

  		promise = {
  			// `then()` returns a Promise - 2.2.7
  			then: function (onFulfilled, onRejected) {
  				var promise2 = new _Promise(function (fulfil, reject) {

  					var processResolutionHandler = function (handler, handlers, forward) {

  						// 2.2.1.1
  						if (typeof handler === "function") {
  							handlers.push(function (p1result) {
  								var x;

  								try {
  									x = handler(p1result);
  									utils_Promise__resolve(promise2, x, fulfil, reject);
  								} catch (err) {
  									reject(err);
  								}
  							});
  						} else {
  							// Forward the result of promise1 to promise2, if resolution handlers
  							// are not given
  							handlers.push(forward);
  						}
  					};

  					// 2.2
  					processResolutionHandler(onFulfilled, fulfilledHandlers, fulfil);
  					processResolutionHandler(onRejected, rejectedHandlers, reject);

  					if (state !== PENDING) {
  						// If the promise has resolved already, dispatch the appropriate handlers asynchronously
  						wait(dispatchHandlers);
  					}
  				});

  				return promise2;
  			}
  		};

  		promise["catch"] = function (onRejected) {
  			return this.then(null, onRejected);
  		};

  		return promise;
  	};

  	_Promise.all = function (promises) {
  		return new _Promise(function (fulfil, reject) {
  			var result = [],
  			    pending,
  			    i,
  			    processPromise;

  			if (!promises.length) {
  				fulfil(result);
  				return;
  			}

  			processPromise = function (promise, i) {
  				if (promise && typeof promise.then === "function") {
  					promise.then(function (value) {
  						result[i] = value;
  						--pending || fulfil(result);
  					}, reject);
  				} else {
  					result[i] = promise;
  					--pending || fulfil(result);
  				}
  			};

  			pending = i = promises.length;
  			while (i--) {
  				processPromise(promises[i], i);
  			}
  		});
  	};

  	_Promise.resolve = function (value) {
  		return new _Promise(function (fulfil) {
  			fulfil(value);
  		});
  	};

  	_Promise.reject = function (reason) {
  		return new _Promise(function (fulfil, reject) {
  			reject(reason);
  		});
  	};
  }

  var utils_Promise = _Promise;

  // TODO use MutationObservers or something to simulate setImmediate
  function wait(callback) {
  	setTimeout(callback, 0);
  }

  function makeDispatcher(handlers, result) {
  	return function () {
  		var handler;

  		while (handler = handlers.shift()) {
  			handler(result);
  		}
  	};
  }

  function utils_Promise__resolve(promise, x, fulfil, reject) {
  	// Promise Resolution Procedure
  	var then;

  	// 2.3.1
  	if (x === promise) {
  		throw new TypeError("A promise's fulfillment handler cannot return the same promise");
  	}

  	// 2.3.2
  	if (x instanceof _Promise) {
  		x.then(fulfil, reject);
  	}

  	// 2.3.3
  	else if (x && (typeof x === "object" || typeof x === "function")) {
  		try {
  			then = x.then; // 2.3.3.1
  		} catch (e) {
  			reject(e); // 2.3.3.2
  			return;
  		}

  		// 2.3.3.3
  		if (typeof then === "function") {
  			var called, resolvePromise, rejectPromise;

  			resolvePromise = function (y) {
  				if (called) {
  					return;
  				}
  				called = true;
  				utils_Promise__resolve(promise, y, fulfil, reject);
  			};

  			rejectPromise = function (r) {
  				if (called) {
  					return;
  				}
  				called = true;
  				reject(r);
  			};

  			try {
  				then.call(x, resolvePromise, rejectPromise);
  			} catch (e) {
  				if (!called) {
  					// 2.3.3.3.4.1
  					reject(e); // 2.3.3.3.4.2
  					called = true;
  					return;
  				}
  			}
  		} else {
  			fulfil(x);
  		}
  	} else {
  		fulfil(x);
  	}
  }

  var getInnerContext = function (fragment) {
  	do {
  		if (fragment.context !== undefined) {
  			return fragment.context;
  		}
  	} while (fragment = fragment.parent);

  	return rootKeypath;
  };

  var shared_resolveRef = resolveRef;

  function resolveRef(ractive, ref, fragment) {
  	var keypath;

  	ref = normalise(ref);

  	// If a reference begins '~/', it's a top-level reference
  	if (ref.substr(0, 2) === "~/") {
  		keypath = getKeypath(ref.substring(2));
  		createMappingIfNecessary(ractive, keypath.firstKey, fragment);
  	}

  	// If a reference begins with '.', it's either a restricted reference or
  	// an ancestor reference...
  	else if (ref[0] === ".") {
  		keypath = resolveAncestorRef(getInnerContext(fragment), ref);

  		if (keypath) {
  			createMappingIfNecessary(ractive, keypath.firstKey, fragment);
  		}
  	}

  	// ...otherwise we need to figure out the keypath based on context
  	else {
  		keypath = resolveAmbiguousReference(ractive, getKeypath(ref), fragment);
  	}

  	return keypath;
  }

  function resolveAncestorRef(baseContext, ref) {
  	var contextKeys;

  	// TODO...
  	if (baseContext != undefined && typeof baseContext !== "string") {
  		baseContext = baseContext.str;
  	}

  	// {{.}} means 'current context'
  	if (ref === ".") return getKeypath(baseContext);

  	contextKeys = baseContext ? baseContext.split(".") : [];

  	// ancestor references (starting "../") go up the tree
  	if (ref.substr(0, 3) === "../") {
  		while (ref.substr(0, 3) === "../") {
  			if (!contextKeys.length) {
  				throw new Error("Could not resolve reference - too many \"../\" prefixes");
  			}

  			contextKeys.pop();
  			ref = ref.substring(3);
  		}

  		contextKeys.push(ref);
  		return getKeypath(contextKeys.join("."));
  	}

  	// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
  	if (!baseContext) {
  		return getKeypath(ref.replace(/^\.\/?/, ""));
  	}

  	return getKeypath(baseContext + ref.replace(/^\.\//, "."));
  }

  function resolveAmbiguousReference(ractive, ref, fragment, isParentLookup) {
  	var context, key, parentValue, hasContextChain, parentKeypath;

  	if (ref.isRoot) {
  		return ref;
  	}

  	key = ref.firstKey;

  	while (fragment) {
  		context = fragment.context;
  		fragment = fragment.parent;

  		if (!context) {
  			continue;
  		}

  		hasContextChain = true;
  		parentValue = ractive.viewmodel.get(context);

  		if (parentValue && (typeof parentValue === "object" || typeof parentValue === "function") && key in parentValue) {
  			return context.join(ref.str);
  		}
  	}

  	// Root/computed/mapped property?
  	if (isRootProperty(ractive.viewmodel, key)) {
  		return ref;
  	}

  	// If this is an inline component, and it's not isolated, we
  	// can try going up the scope chain
  	if (ractive.parent && !ractive.isolated) {
  		hasContextChain = true;
  		fragment = ractive.component.parentFragment;

  		key = getKeypath(key);

  		if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, fragment, true)) {
  			// We need to create an inter-component binding
  			ractive.viewmodel.map(key, {
  				origin: ractive.parent.viewmodel,
  				keypath: parentKeypath
  			});

  			return ref;
  		}
  	}

  	// If there's no context chain, and the instance is either a) isolated or
  	// b) an orphan, then we know that the keypath is identical to the reference
  	if (!isParentLookup && !hasContextChain) {
  		// the data object needs to have a property by this name,
  		// to prevent future failed lookups
  		ractive.viewmodel.set(ref, undefined);
  		return ref;
  	}
  }

  function createMappingIfNecessary(ractive, key) {
  	var parentKeypath;

  	if (!ractive.parent || ractive.isolated || isRootProperty(ractive.viewmodel, key)) {
  		return;
  	}

  	key = getKeypath(key);

  	if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, ractive.component.parentFragment, true)) {
  		ractive.viewmodel.map(key, {
  			origin: ractive.parent.viewmodel,
  			keypath: parentKeypath
  		});
  	}
  }

  function isRootProperty(viewmodel, key) {
  	// special case for reference to root
  	return key === "" || key in viewmodel.data || key in viewmodel.computations || key in viewmodel.mappings;
  }

  function teardown(x) {
    x.teardown();
  }

  function methodCallers__unbind(x) {
    x.unbind();
  }

  function methodCallers__unrender(x) {
    x.unrender();
  }

  function cancel(x) {
    x.cancel();
  }

  var TransitionManager = function (callback, parent) {
  	this.callback = callback;
  	this.parent = parent;

  	this.intros = [];
  	this.outros = [];

  	this.children = [];
  	this.totalChildren = this.outroChildren = 0;

  	this.detachQueue = [];
  	this.decoratorQueue = [];
  	this.outrosComplete = false;

  	if (parent) {
  		parent.addChild(this);
  	}
  };

  TransitionManager.prototype = {
  	addChild: function (child) {
  		this.children.push(child);

  		this.totalChildren += 1;
  		this.outroChildren += 1;
  	},

  	decrementOutros: function () {
  		this.outroChildren -= 1;
  		check(this);
  	},

  	decrementTotal: function () {
  		this.totalChildren -= 1;
  		check(this);
  	},

  	add: function (transition) {
  		var list = transition.isIntro ? this.intros : this.outros;
  		list.push(transition);
  	},

  	addDecorator: function (decorator) {
  		this.decoratorQueue.push(decorator);
  	},

  	remove: function (transition) {
  		var list = transition.isIntro ? this.intros : this.outros;
  		removeFromArray(list, transition);
  		check(this);
  	},

  	init: function () {
  		this.ready = true;
  		check(this);
  	},

  	detachNodes: function () {
  		this.decoratorQueue.forEach(teardown);
  		this.detachQueue.forEach(detach);
  		this.children.forEach(detachNodes);
  	}
  };

  function detach(element) {
  	element.detach();
  }

  function detachNodes(tm) {
  	tm.detachNodes();
  }

  function check(tm) {
  	if (!tm.ready || tm.outros.length || tm.outroChildren) return;

  	// If all outros are complete, and we haven't already done this,
  	// we notify the parent if there is one, otherwise
  	// start detaching nodes
  	if (!tm.outrosComplete) {
  		if (tm.parent) {
  			tm.parent.decrementOutros(tm);
  		} else {
  			tm.detachNodes();
  		}

  		tm.outrosComplete = true;
  	}

  	// Once everything is done, we can notify parent transition
  	// manager and call the callback
  	if (!tm.intros.length && !tm.totalChildren) {
  		if (typeof tm.callback === "function") {
  			tm.callback();
  		}

  		if (tm.parent) {
  			tm.parent.decrementTotal();
  		}
  	}
  }

  var global_TransitionManager = TransitionManager;

  var batch,
      runloop,
      unresolved = [],
      changeHook = new hooks_Hook("change");

  runloop = {
  	start: function (instance, returnPromise) {
  		var promise, fulfilPromise;

  		if (returnPromise) {
  			promise = new utils_Promise(function (f) {
  				return fulfilPromise = f;
  			});
  		}

  		batch = {
  			previousBatch: batch,
  			transitionManager: new global_TransitionManager(fulfilPromise, batch && batch.transitionManager),
  			views: [],
  			tasks: [],
  			ractives: [],
  			instance: instance
  		};

  		if (instance) {
  			batch.ractives.push(instance);
  		}

  		return promise;
  	},

  	end: function () {
  		flushChanges();

  		batch.transitionManager.init();
  		if (!batch.previousBatch && !!batch.instance) batch.instance.viewmodel.changes = [];
  		batch = batch.previousBatch;
  	},

  	addRactive: function (ractive) {
  		if (batch) {
  			addToArray(batch.ractives, ractive);
  		}
  	},

  	registerTransition: function (transition) {
  		transition._manager = batch.transitionManager;
  		batch.transitionManager.add(transition);
  	},

  	registerDecorator: function (decorator) {
  		batch.transitionManager.addDecorator(decorator);
  	},

  	addView: function (view) {
  		batch.views.push(view);
  	},

  	addUnresolved: function (thing) {
  		unresolved.push(thing);
  	},

  	removeUnresolved: function (thing) {
  		removeFromArray(unresolved, thing);
  	},

  	// synchronise node detachments with transition ends
  	detachWhenReady: function (thing) {
  		batch.transitionManager.detachQueue.push(thing);
  	},

  	scheduleTask: function (task, postRender) {
  		var _batch;

  		if (!batch) {
  			task();
  		} else {
  			_batch = batch;
  			while (postRender && _batch.previousBatch) {
  				// this can't happen until the DOM has been fully updated
  				// otherwise in some situations (with components inside elements)
  				// transitions and decorators will initialise prematurely
  				_batch = _batch.previousBatch;
  			}

  			_batch.tasks.push(task);
  		}
  	}
  };

  var global_runloop = runloop;

  function flushChanges() {
  	var i, thing, changeHash;

  	while (batch.ractives.length) {
  		thing = batch.ractives.pop();
  		changeHash = thing.viewmodel.applyChanges();

  		if (changeHash) {
  			changeHook.fire(thing, changeHash);
  		}
  	}

  	attemptKeypathResolution();

  	// Now that changes have been fully propagated, we can update the DOM
  	// and complete other tasks
  	for (i = 0; i < batch.views.length; i += 1) {
  		batch.views[i].update();
  	}
  	batch.views.length = 0;

  	for (i = 0; i < batch.tasks.length; i += 1) {
  		batch.tasks[i]();
  	}
  	batch.tasks.length = 0;

  	// If updating the view caused some model blowback - e.g. a triple
  	// containing <option> elements caused the binding on the <select>
  	// to update - then we start over
  	if (batch.ractives.length) return flushChanges();
  }

  function attemptKeypathResolution() {
  	var i, item, keypath, resolved;

  	i = unresolved.length;

  	// see if we can resolve any unresolved references
  	while (i--) {
  		item = unresolved[i];

  		if (item.keypath) {
  			// it resolved some other way. TODO how? two-way binding? Seems
  			// weird that we'd still end up here
  			unresolved.splice(i, 1);
  			continue; // avoid removing the wrong thing should the next condition be true
  		}

  		if (keypath = shared_resolveRef(item.root, item.ref, item.parentFragment)) {
  			(resolved || (resolved = [])).push({
  				item: item,
  				keypath: keypath
  			});

  			unresolved.splice(i, 1);
  		}
  	}

  	if (resolved) {
  		resolved.forEach(global_runloop__resolve);
  	}
  }

  function global_runloop__resolve(resolved) {
  	resolved.item.resolve(resolved.keypath);
  }

  var queue = [];

  var animations = {
  	tick: function () {
  		var i, animation, now;

  		now = utils_getTime();

  		global_runloop.start();

  		for (i = 0; i < queue.length; i += 1) {
  			animation = queue[i];

  			if (!animation.tick(now)) {
  				// animation is complete, remove it from the stack, and decrement i so we don't miss one
  				queue.splice(i--, 1);
  			}
  		}

  		global_runloop.end();

  		if (queue.length) {
  			rAF(animations.tick);
  		} else {
  			animations.running = false;
  		}
  	},

  	add: function (animation) {
  		queue.push(animation);

  		if (!animations.running) {
  			animations.running = true;
  			rAF(animations.tick);
  		}
  	},

  	// TODO optimise this
  	abort: function (keypath, root) {
  		var i = queue.length,
  		    animation;

  		while (i--) {
  			animation = queue[i];

  			if (animation.root === root && animation.keypath === keypath) {
  				animation.stop();
  			}
  		}
  	}
  };

  var shared_animations = animations;

  var Animation = function (options) {
  	var key;

  	this.startTime = Date.now();

  	// from and to
  	for (key in options) {
  		if (options.hasOwnProperty(key)) {
  			this[key] = options[key];
  		}
  	}

  	this.interpolator = shared_interpolate(this.from, this.to, this.root, this.interpolator);
  	this.running = true;

  	this.tick();
  };

  Animation.prototype = {
  	tick: function () {
  		var elapsed, t, value, timeNow, index, keypath;

  		keypath = this.keypath;

  		if (this.running) {
  			timeNow = Date.now();
  			elapsed = timeNow - this.startTime;

  			if (elapsed >= this.duration) {
  				if (keypath !== null) {
  					global_runloop.start(this.root);
  					this.root.viewmodel.set(keypath, this.to);
  					global_runloop.end();
  				}

  				if (this.step) {
  					this.step(1, this.to);
  				}

  				this.complete(this.to);

  				index = this.root._animations.indexOf(this);

  				// TODO investigate why this happens
  				if (index === -1) {
  					warnIfDebug("Animation was not found");
  				}

  				this.root._animations.splice(index, 1);

  				this.running = false;
  				return false; // remove from the stack
  			}

  			t = this.easing ? this.easing(elapsed / this.duration) : elapsed / this.duration;

  			if (keypath !== null) {
  				value = this.interpolator(t);
  				global_runloop.start(this.root);
  				this.root.viewmodel.set(keypath, value);
  				global_runloop.end();
  			}

  			if (this.step) {
  				this.step(t, value);
  			}

  			return true; // keep in the stack
  		}

  		return false; // remove from the stack
  	},

  	stop: function () {
  		var index;

  		this.running = false;

  		index = this.root._animations.indexOf(this);

  		// TODO investigate why this happens
  		if (index === -1) {
  			warnIfDebug("Animation was not found");
  		}

  		this.root._animations.splice(index, 1);
  	}
  };

  var animate_Animation = Animation;

  var prototype_animate = Ractive$animate;

  var noAnimation = { stop: noop };
  function Ractive$animate(keypath, to, options) {
  	var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;

  	promise = new utils_Promise(function (fulfil) {
  		return fulfilPromise = fulfil;
  	});

  	// animate multiple keypaths
  	if (typeof keypath === "object") {
  		options = to || {};
  		easing = options.easing;
  		duration = options.duration;

  		animations = [];

  		// we don't want to pass the `step` and `complete` handlers, as they will
  		// run for each animation! So instead we'll store the handlers and create
  		// our own...
  		step = options.step;
  		complete = options.complete;

  		if (step || complete) {
  			currentValues = {};

  			options.step = null;
  			options.complete = null;

  			makeValueCollector = function (keypath) {
  				return function (t, value) {
  					currentValues[keypath] = value;
  				};
  			};
  		}

  		for (k in keypath) {
  			if (keypath.hasOwnProperty(k)) {
  				if (step || complete) {
  					collectValue = makeValueCollector(k);
  					options = { easing: easing, duration: duration };

  					if (step) {
  						options.step = collectValue;
  					}
  				}

  				options.complete = complete ? collectValue : noop;
  				animations.push(animate(this, k, keypath[k], options));
  			}
  		}

  		// Create a dummy animation, to facilitate step/complete
  		// callbacks, and Promise fulfilment
  		dummyOptions = { easing: easing, duration: duration };

  		if (step) {
  			dummyOptions.step = function (t) {
  				return step(t, currentValues);
  			};
  		}

  		if (complete) {
  			promise.then(function (t) {
  				return complete(t, currentValues);
  			});
  		}

  		dummyOptions.complete = fulfilPromise;

  		dummy = animate(this, null, null, dummyOptions);
  		animations.push(dummy);

  		promise.stop = function () {
  			var animation;

  			while (animation = animations.pop()) {
  				animation.stop();
  			}

  			if (dummy) {
  				dummy.stop();
  			}
  		};

  		return promise;
  	}

  	// animate a single keypath
  	options = options || {};

  	if (options.complete) {
  		promise.then(options.complete);
  	}

  	options.complete = fulfilPromise;
  	animation = animate(this, keypath, to, options);

  	promise.stop = function () {
  		return animation.stop();
  	};
  	return promise;
  }

  function animate(root, keypath, to, options) {
  	var easing, duration, animation, from;

  	if (keypath) {
  		keypath = getKeypath(normalise(keypath));
  	}

  	if (keypath !== null) {
  		from = root.viewmodel.get(keypath);
  	}

  	// cancel any existing animation
  	// TODO what about upstream/downstream keypaths?
  	shared_animations.abort(keypath, root);

  	// don't bother animating values that stay the same
  	if (isEqual(from, to)) {
  		if (options.complete) {
  			options.complete(options.to);
  		}

  		return noAnimation;
  	}

  	// easing function
  	if (options.easing) {
  		if (typeof options.easing === "function") {
  			easing = options.easing;
  		} else {
  			easing = root.easing[options.easing];
  		}

  		if (typeof easing !== "function") {
  			easing = null;
  		}
  	}

  	// duration
  	duration = options.duration === undefined ? 400 : options.duration;

  	// TODO store keys, use an internal set method
  	animation = new animate_Animation({
  		keypath: keypath,
  		from: from,
  		to: to,
  		root: root,
  		duration: duration,
  		easing: easing,
  		interpolator: options.interpolator,

  		// TODO wrap callbacks if necessary, to use instance as context
  		step: options.step,
  		complete: options.complete
  	});

  	shared_animations.add(animation);
  	root._animations.push(animation);

  	return animation;
  }

  var prototype_detach = Ractive$detach;
  var prototype_detach__detachHook = new hooks_Hook("detach");
  function Ractive$detach() {
  	if (this.detached) {
  		return this.detached;
  	}

  	if (this.el) {
  		removeFromArray(this.el.__ractive_instances__, this);
  	}
  	this.detached = this.fragment.detach();
  	prototype_detach__detachHook.fire(this);
  	return this.detached;
  }

  var prototype_find = Ractive$find;

  function Ractive$find(selector) {
  	if (!this.el) {
  		return null;
  	}

  	return this.fragment.find(selector);
  }

  var test = Query$test;
  function Query$test(item, noDirty) {
  	var itemMatches;

  	if (this._isComponentQuery) {
  		itemMatches = !this.selector || item.name === this.selector;
  	} else {
  		itemMatches = item.node ? matches(item.node, this.selector) : null;
  	}

  	if (itemMatches) {
  		this.push(item.node || item.instance);

  		if (!noDirty) {
  			this._makeDirty();
  		}

  		return true;
  	}
  }

  var makeQuery_cancel = function () {
  	var liveQueries, selector, index;

  	liveQueries = this._root[this._isComponentQuery ? "liveComponentQueries" : "liveQueries"];
  	selector = this.selector;

  	index = liveQueries.indexOf(selector);

  	if (index !== -1) {
  		liveQueries.splice(index, 1);
  		liveQueries[selector] = null;
  	}
  };

  var sortByItemPosition = function (a, b) {
  	var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;

  	ancestryA = getAncestry(a.component || a._ractive.proxy);
  	ancestryB = getAncestry(b.component || b._ractive.proxy);

  	oldestA = lastItem(ancestryA);
  	oldestB = lastItem(ancestryB);

  	// remove items from the end of both ancestries as long as they are identical
  	// - the final one removed is the closest mutual ancestor
  	while (oldestA && oldestA === oldestB) {
  		ancestryA.pop();
  		ancestryB.pop();

  		mutualAncestor = oldestA;

  		oldestA = lastItem(ancestryA);
  		oldestB = lastItem(ancestryB);
  	}

  	// now that we have the mutual ancestor, we can find which is earliest
  	oldestA = oldestA.component || oldestA;
  	oldestB = oldestB.component || oldestB;

  	fragmentA = oldestA.parentFragment;
  	fragmentB = oldestB.parentFragment;

  	// if both items share a parent fragment, our job is easy
  	if (fragmentA === fragmentB) {
  		indexA = fragmentA.items.indexOf(oldestA);
  		indexB = fragmentB.items.indexOf(oldestB);

  		// if it's the same index, it means one contains the other,
  		// so we see which has the longest ancestry
  		return indexA - indexB || ancestryA.length - ancestryB.length;
  	}

  	// if mutual ancestor is a section, we first test to see which section
  	// fragment comes first
  	if (fragments = mutualAncestor.fragments) {
  		indexA = fragments.indexOf(fragmentA);
  		indexB = fragments.indexOf(fragmentB);

  		return indexA - indexB || ancestryA.length - ancestryB.length;
  	}

  	throw new Error("An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!");
  };

  function getParent(item) {
  	var parentFragment;

  	if (parentFragment = item.parentFragment) {
  		return parentFragment.owner;
  	}

  	if (item.component && (parentFragment = item.component.parentFragment)) {
  		return parentFragment.owner;
  	}
  }

  function getAncestry(item) {
  	var ancestry, ancestor;

  	ancestry = [item];

  	ancestor = getParent(item);

  	while (ancestor) {
  		ancestry.push(ancestor);
  		ancestor = getParent(ancestor);
  	}

  	return ancestry;
  }

  var sortByDocumentPosition = function (node, otherNode) {
  	var bitmask;

  	if (node.compareDocumentPosition) {
  		bitmask = node.compareDocumentPosition(otherNode);
  		return bitmask & 2 ? 1 : -1;
  	}

  	// In old IE, we can piggy back on the mechanism for
  	// comparing component positions
  	return sortByItemPosition(node, otherNode);
  };

  var sort = function () {
  	this.sort(this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition);
  	this._dirty = false;
  };

  var makeQuery_dirty = function () {
  	var _this = this;

  	if (!this._dirty) {
  		this._dirty = true;

  		// Once the DOM has been updated, ensure the query
  		// is correctly ordered
  		global_runloop.scheduleTask(function () {
  			_this._sort();
  		});
  	}
  };

  var remove = function (nodeOrComponent) {
  	var index = this.indexOf(this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent);

  	if (index !== -1) {
  		this.splice(index, 1);
  	}
  };

  var _makeQuery = makeQuery;
  function makeQuery(ractive, selector, live, isComponentQuery) {
  	var query = [];

  	defineProperties(query, {
  		selector: { value: selector },
  		live: { value: live },

  		_isComponentQuery: { value: isComponentQuery },
  		_test: { value: test }
  	});

  	if (!live) {
  		return query;
  	}

  	defineProperties(query, {
  		cancel: { value: makeQuery_cancel },

  		_root: { value: ractive },
  		_sort: { value: sort },
  		_makeDirty: { value: makeQuery_dirty },
  		_remove: { value: remove },

  		_dirty: { value: false, writable: true }
  	});

  	return query;
  }

  var prototype_findAll = Ractive$findAll;
  function Ractive$findAll(selector, options) {
  	var liveQueries, query;

  	if (!this.el) {
  		return [];
  	}

  	options = options || {};
  	liveQueries = this._liveQueries;

  	// Shortcut: if we're maintaining a live query with this
  	// selector, we don't need to traverse the parallel DOM
  	if (query = liveQueries[selector]) {

  		// Either return the exact same query, or (if not live) a snapshot
  		return options && options.live ? query : query.slice();
  	}

  	query = _makeQuery(this, selector, !!options.live, false);

  	// Add this to the list of live queries Ractive needs to maintain,
  	// if applicable
  	if (query.live) {
  		liveQueries.push(selector);
  		liveQueries["_" + selector] = query;
  	}

  	this.fragment.findAll(selector, query);
  	return query;
  }

  var prototype_findAllComponents = Ractive$findAllComponents;
  function Ractive$findAllComponents(selector, options) {
  	var liveQueries, query;

  	options = options || {};
  	liveQueries = this._liveComponentQueries;

  	// Shortcut: if we're maintaining a live query with this
  	// selector, we don't need to traverse the parallel DOM
  	if (query = liveQueries[selector]) {

  		// Either return the exact same query, or (if not live) a snapshot
  		return options && options.live ? query : query.slice();
  	}

  	query = _makeQuery(this, selector, !!options.live, true);

  	// Add this to the list of live queries Ractive needs to maintain,
  	// if applicable
  	if (query.live) {
  		liveQueries.push(selector);
  		liveQueries["_" + selector] = query;
  	}

  	this.fragment.findAllComponents(selector, query);
  	return query;
  }

  var prototype_findComponent = Ractive$findComponent;

  function Ractive$findComponent(selector) {
  	return this.fragment.findComponent(selector);
  }

  var findContainer = Ractive$findContainer;

  function Ractive$findContainer(selector) {
  	if (this.container) {
  		if (this.container.component && this.container.component.name === selector) {
  			return this.container;
  		} else {
  			return this.container.findContainer(selector);
  		}
  	}

  	return null;
  }

  var findParent = Ractive$findParent;

  function Ractive$findParent(selector) {

  	if (this.parent) {
  		if (this.parent.component && this.parent.component.name === selector) {
  			return this.parent;
  		} else {
  			return this.parent.findParent(selector);
  		}
  	}

  	return null;
  }

  var eventStack = {
  	enqueue: function (ractive, event) {
  		if (ractive.event) {
  			ractive._eventQueue = ractive._eventQueue || [];
  			ractive._eventQueue.push(ractive.event);
  		}
  		ractive.event = event;
  	},
  	dequeue: function (ractive) {
  		if (ractive._eventQueue && ractive._eventQueue.length) {
  			ractive.event = ractive._eventQueue.pop();
  		} else {
  			delete ractive.event;
  		}
  	}
  };

  var shared_eventStack = eventStack;

  var shared_fireEvent = fireEvent;

  function fireEvent(ractive, eventName) {
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	if (!eventName) {
  		return;
  	}

  	if (!options.event) {
  		options.event = {
  			name: eventName,
  			// until event not included as argument default
  			_noArg: true
  		};
  	} else {
  		options.event.name = eventName;
  	}

  	var eventNames = getKeypath(eventName).wildcardMatches();
  	fireEventAs(ractive, eventNames, options.event, options.args, true);
  }

  function fireEventAs(ractive, eventNames, event, args) {
  	var initialFire = arguments[4] === undefined ? false : arguments[4];

  	var subscribers,
  	    i,
  	    bubble = true;

  	shared_eventStack.enqueue(ractive, event);

  	for (i = eventNames.length; i >= 0; i--) {
  		subscribers = ractive._subs[eventNames[i]];

  		if (subscribers) {
  			bubble = notifySubscribers(ractive, subscribers, event, args) && bubble;
  		}
  	}

  	shared_eventStack.dequeue(ractive);

  	if (ractive.parent && bubble) {

  		if (initialFire && ractive.component) {
  			var fullName = ractive.component.name + "." + eventNames[eventNames.length - 1];
  			eventNames = getKeypath(fullName).wildcardMatches();

  			if (event) {
  				event.component = ractive;
  			}
  		}

  		fireEventAs(ractive.parent, eventNames, event, args);
  	}
  }

  function notifySubscribers(ractive, subscribers, event, args) {
  	var originalEvent = null,
  	    stopEvent = false;

  	if (event && !event._noArg) {
  		args = [event].concat(args);
  	}

  	// subscribers can be modified inflight, e.g. "once" functionality
  	// so we need to copy to make sure everyone gets called
  	subscribers = subscribers.slice();

  	for (var i = 0, len = subscribers.length; i < len; i += 1) {
  		if (subscribers[i].apply(ractive, args) === false) {
  			stopEvent = true;
  		}
  	}

  	if (event && !event._noArg && stopEvent && (originalEvent = event.original)) {
  		originalEvent.preventDefault && originalEvent.preventDefault();
  		originalEvent.stopPropagation && originalEvent.stopPropagation();
  	}

  	return !stopEvent;
  }

  var prototype_fire = Ractive$fire;
  function Ractive$fire(eventName) {

  	var options = {
  		args: Array.prototype.slice.call(arguments, 1)
  	};

  	shared_fireEvent(this, eventName, options);
  }

  var prototype_get = Ractive$get;
  var options = {
  	capture: true, // top-level calls should be intercepted
  	noUnwrap: true, // wrapped values should NOT be unwrapped
  	fullRootGet: true // root get should return mappings
  };
  function Ractive$get(keypath) {
  	var value;

  	keypath = getKeypath(normalise(keypath));
  	value = this.viewmodel.get(keypath, options);

  	// Create inter-component binding, if necessary
  	if (value === undefined && this.parent && !this.isolated) {
  		if (shared_resolveRef(this, keypath.str, this.component.parentFragment)) {
  			// creates binding as side-effect, if appropriate
  			value = this.viewmodel.get(keypath);
  		}
  	}

  	return value;
  }

  var insert = Ractive$insert;

  var insertHook = new hooks_Hook("insert");
  function Ractive$insert(target, anchor) {
  	if (!this.fragment.rendered) {
  		// TODO create, and link to, documentation explaining this
  		throw new Error("The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.");
  	}

  	target = getElement(target);
  	anchor = getElement(anchor) || null;

  	if (!target) {
  		throw new Error("You must specify a valid target to insert into");
  	}

  	target.insertBefore(this.detach(), anchor);
  	this.el = target;

  	(target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);
  	this.detached = null;

  	fireInsertHook(this);
  }

  function fireInsertHook(ractive) {
  	insertHook.fire(ractive);

  	ractive.findAllComponents("*").forEach(function (child) {
  		fireInsertHook(child.instance);
  	});
  }

  var prototype_merge = Ractive$merge;
  function Ractive$merge(keypath, array, options) {
  	var currentArray, promise;

  	keypath = getKeypath(normalise(keypath));
  	currentArray = this.viewmodel.get(keypath);

  	// If either the existing value or the new value isn't an
  	// array, just do a regular set
  	if (!isArray(currentArray) || !isArray(array)) {
  		return this.set(keypath, array, options && options.complete);
  	}

  	// Manage transitions
  	promise = global_runloop.start(this, true);
  	this.viewmodel.merge(keypath, currentArray, array, options);
  	global_runloop.end();

  	return promise;
  }

  var Observer = function (ractive, keypath, callback, options) {
  	this.root = ractive;
  	this.keypath = keypath;
  	this.callback = callback;
  	this.defer = options.defer;

  	// default to root as context, but allow it to be overridden
  	this.context = options && options.context ? options.context : ractive;
  };

  Observer.prototype = {
  	init: function (immediate) {
  		this.value = this.root.get(this.keypath.str);

  		if (immediate !== false) {
  			this.update();
  		} else {
  			this.oldValue = this.value;
  		}
  	},

  	setValue: function (value) {
  		var _this = this;

  		if (!isEqual(value, this.value)) {
  			this.value = value;

  			if (this.defer && this.ready) {
  				global_runloop.scheduleTask(function () {
  					return _this.update();
  				});
  			} else {
  				this.update();
  			}
  		}
  	},

  	update: function () {
  		// Prevent infinite loops
  		if (this.updating) {
  			return;
  		}

  		this.updating = true;

  		this.callback.call(this.context, this.value, this.oldValue, this.keypath.str);
  		this.oldValue = this.value;

  		this.updating = false;
  	}
  };

  var observe_Observer = Observer;

  var observe_getPattern = getPattern;
  function getPattern(ractive, pattern) {
  	var matchingKeypaths, values;

  	matchingKeypaths = getMatchingKeypaths(ractive, pattern);

  	values = {};
  	matchingKeypaths.forEach(function (keypath) {
  		values[keypath.str] = ractive.get(keypath.str);
  	});

  	return values;
  }

  var PatternObserver,
      slice = Array.prototype.slice;

  PatternObserver = function (ractive, keypath, callback, options) {
  	this.root = ractive;

  	this.callback = callback;
  	this.defer = options.defer;

  	this.keypath = keypath;
  	this.regex = new RegExp("^" + keypath.str.replace(/\./g, "\\.").replace(/\*/g, "([^\\.]+)") + "$");
  	this.values = {};

  	if (this.defer) {
  		this.proxies = [];
  	}

  	// default to root as context, but allow it to be overridden
  	this.context = options && options.context ? options.context : ractive;
  };

  PatternObserver.prototype = {
  	init: function (immediate) {
  		var values, keypath;

  		values = observe_getPattern(this.root, this.keypath);

  		if (immediate !== false) {
  			for (keypath in values) {
  				if (values.hasOwnProperty(keypath)) {
  					this.update(getKeypath(keypath));
  				}
  			}
  		} else {
  			this.values = values;
  		}
  	},

  	update: function (keypath) {
  		var _this = this;

  		var values;

  		if (keypath.isPattern) {
  			values = observe_getPattern(this.root, keypath);

  			for (keypath in values) {
  				if (values.hasOwnProperty(keypath)) {
  					this.update(getKeypath(keypath));
  				}
  			}

  			return;
  		}

  		// special case - array mutation should not trigger `array.*`
  		// pattern observer with `array.length`
  		if (this.root.viewmodel.implicitChanges[keypath.str]) {
  			return;
  		}

  		if (this.defer && this.ready) {
  			global_runloop.scheduleTask(function () {
  				return _this.getProxy(keypath).update();
  			});
  			return;
  		}

  		this.reallyUpdate(keypath);
  	},

  	reallyUpdate: function (keypath) {
  		var keypathStr, value, keys, args;

  		keypathStr = keypath.str;
  		value = this.root.viewmodel.get(keypath);

  		// Prevent infinite loops
  		if (this.updating) {
  			this.values[keypathStr] = value;
  			return;
  		}

  		this.updating = true;

  		if (!isEqual(value, this.values[keypathStr]) || !this.ready) {
  			keys = slice.call(this.regex.exec(keypathStr), 1);
  			args = [value, this.values[keypathStr], keypathStr].concat(keys);

  			this.values[keypathStr] = value;
  			this.callback.apply(this.context, args);
  		}

  		this.updating = false;
  	},

  	getProxy: function (keypath) {
  		var _this = this;

  		if (!this.proxies[keypath.str]) {
  			this.proxies[keypath.str] = {
  				update: function () {
  					return _this.reallyUpdate(keypath);
  				}
  			};
  		}

  		return this.proxies[keypath.str];
  	}
  };

  var observe_PatternObserver = PatternObserver;

  var observe_getObserverFacade = getObserverFacade;
  var emptyObject = {};
  function getObserverFacade(ractive, keypath, callback, options) {
  	var observer, isPatternObserver, cancelled;

  	keypath = getKeypath(normalise(keypath));
  	options = options || emptyObject;

  	// pattern observers are treated differently
  	if (keypath.isPattern) {
  		observer = new observe_PatternObserver(ractive, keypath, callback, options);
  		ractive.viewmodel.patternObservers.push(observer);
  		isPatternObserver = true;
  	} else {
  		observer = new observe_Observer(ractive, keypath, callback, options);
  	}

  	observer.init(options.init);
  	ractive.viewmodel.register(keypath, observer, isPatternObserver ? "patternObservers" : "observers");

  	// This flag allows observers to initialise even with undefined values
  	observer.ready = true;

  	var facade = {
  		cancel: function () {
  			var index;

  			if (cancelled) {
  				return;
  			}

  			if (isPatternObserver) {
  				index = ractive.viewmodel.patternObservers.indexOf(observer);

  				ractive.viewmodel.patternObservers.splice(index, 1);
  				ractive.viewmodel.unregister(keypath, observer, "patternObservers");
  			} else {
  				ractive.viewmodel.unregister(keypath, observer, "observers");
  			}
  			cancelled = true;
  		}
  	};

  	ractive._observers.push(facade);
  	return facade;
  }

  var observe = Ractive$observe;
  function Ractive$observe(keypath, callback, options) {

  	var observers, map, keypaths, i;

  	// Allow a map of keypaths to handlers
  	if (isObject(keypath)) {
  		options = callback;
  		map = keypath;

  		observers = [];

  		for (keypath in map) {
  			if (map.hasOwnProperty(keypath)) {
  				callback = map[keypath];
  				observers.push(this.observe(keypath, callback, options));
  			}
  		}

  		return {
  			cancel: function () {
  				while (observers.length) {
  					observers.pop().cancel();
  				}
  			}
  		};
  	}

  	// Allow `ractive.observe( callback )` - i.e. observe entire model
  	if (typeof keypath === "function") {
  		options = callback;
  		callback = keypath;
  		keypath = "";

  		return observe_getObserverFacade(this, keypath, callback, options);
  	}

  	keypaths = keypath.split(" ");

  	// Single keypath
  	if (keypaths.length === 1) {
  		return observe_getObserverFacade(this, keypath, callback, options);
  	}

  	// Multiple space-separated keypaths
  	observers = [];

  	i = keypaths.length;
  	while (i--) {
  		keypath = keypaths[i];

  		if (keypath) {
  			observers.push(observe_getObserverFacade(this, keypath, callback, options));
  		}
  	}

  	return {
  		cancel: function () {
  			while (observers.length) {
  				observers.pop().cancel();
  			}
  		}
  	};
  }

  var observeOnce = Ractive$observeOnce;

  function Ractive$observeOnce(property, callback, options) {

  	var observer = this.observe(property, function () {
  		callback.apply(this, arguments);
  		observer.cancel();
  	}, { init: false, defer: options && options.defer });

  	return observer;
  }

  var shared_trim = function (str) {
    return str.trim();
  };

  var notEmptyString = function (str) {
    return str !== "";
  };

  var off = Ractive$off;
  function Ractive$off(eventName, callback) {
  	var _this = this;

  	var eventNames;

  	// if no arguments specified, remove all callbacks
  	if (!eventName) {
  		// TODO use this code instead, once the following issue has been resolved
  		// in PhantomJS (tests are unpassable otherwise!)
  		// https://github.com/ariya/phantomjs/issues/11856
  		// defineProperty( this, '_subs', { value: create( null ), configurable: true });
  		for (eventName in this._subs) {
  			delete this._subs[eventName];
  		}
  	} else {
  		// Handle multiple space-separated event names
  		eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);

  		eventNames.forEach(function (eventName) {
  			var subscribers, index;

  			// If we have subscribers for this event...
  			if (subscribers = _this._subs[eventName]) {
  				// ...if a callback was specified, only remove that
  				if (callback) {
  					index = subscribers.indexOf(callback);
  					if (index !== -1) {
  						subscribers.splice(index, 1);
  					}
  				}

  				// ...otherwise remove all callbacks
  				else {
  					_this._subs[eventName] = [];
  				}
  			}
  		});
  	}

  	return this;
  }

  var on = Ractive$on;
  function Ractive$on(eventName, callback) {
  	var _this = this;

  	var listeners, n, eventNames;

  	// allow mutliple listeners to be bound in one go
  	if (typeof eventName === "object") {
  		listeners = [];

  		for (n in eventName) {
  			if (eventName.hasOwnProperty(n)) {
  				listeners.push(this.on(n, eventName[n]));
  			}
  		}

  		return {
  			cancel: function () {
  				var listener;

  				while (listener = listeners.pop()) {
  					listener.cancel();
  				}
  			}
  		};
  	}

  	// Handle multiple space-separated event names
  	eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);

  	eventNames.forEach(function (eventName) {
  		(_this._subs[eventName] || (_this._subs[eventName] = [])).push(callback);
  	});

  	return {
  		cancel: function () {
  			return _this.off(eventName, callback);
  		}
  	};
  }

  var once = Ractive$once;

  function Ractive$once(eventName, handler) {

  	var listener = this.on(eventName, function () {
  		handler.apply(this, arguments);
  		listener.cancel();
  	});

  	// so we can still do listener.cancel() manually
  	return listener;
  }

  // This function takes an array, the name of a mutator method, and the
  // arguments to call that mutator method with, and returns an array that
  // maps the old indices to their new indices.

  // So if you had something like this...
  //
  //     array = [ 'a', 'b', 'c', 'd' ];
  //     array.push( 'e' );
  //
  // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
  // have changed. If you then did this...
  //
  //     array.unshift( 'z' );
  //
  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
  // one higher to make room for the 'z'. If you removed an item, the new index
  // would be -1...
  //
  //     array.splice( 2, 2 );
  //
  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].
  //
  // This information is used to enable fast, non-destructive shuffling of list
  // sections when you do e.g. `ractive.splice( 'items', 2, 2 );

  var shared_getNewIndices = getNewIndices;

  function getNewIndices(array, methodName, args) {
  	var spliceArguments,
  	    len,
  	    newIndices = [],
  	    removeStart,
  	    removeEnd,
  	    balance,
  	    i;

  	spliceArguments = getSpliceEquivalent(array, methodName, args);

  	if (!spliceArguments) {
  		return null; // TODO support reverse and sort?
  	}

  	len = array.length;
  	balance = spliceArguments.length - 2 - spliceArguments[1];

  	removeStart = Math.min(len, spliceArguments[0]);
  	removeEnd = removeStart + spliceArguments[1];

  	for (i = 0; i < removeStart; i += 1) {
  		newIndices.push(i);
  	}

  	for (; i < removeEnd; i += 1) {
  		newIndices.push(-1);
  	}

  	for (; i < len; i += 1) {
  		newIndices.push(i + balance);
  	}

  	// there is a net shift for the rest of the array starting with index + balance
  	if (balance !== 0) {
  		newIndices.touchedFrom = spliceArguments[0];
  	} else {
  		newIndices.touchedFrom = array.length;
  	}

  	return newIndices;
  }

  // The pop, push, shift an unshift methods can all be represented
  // as an equivalent splice
  function getSpliceEquivalent(array, methodName, args) {
  	switch (methodName) {
  		case "splice":
  			if (args[0] !== undefined && args[0] < 0) {
  				args[0] = array.length + Math.max(args[0], -array.length);
  			}

  			while (args.length < 2) {
  				args.push(0);
  			}

  			// ensure we only remove elements that exist
  			args[1] = Math.min(args[1], array.length - args[0]);

  			return args;

  		case "sort":
  		case "reverse":
  			return null;

  		case "pop":
  			if (array.length) {
  				return [array.length - 1, 1];
  			}
  			return [0, 0];

  		case "push":
  			return [array.length, 0].concat(args);

  		case "shift":
  			return [0, array.length ? 1 : 0];

  		case "unshift":
  			return [0, 0].concat(args);
  	}
  }

  var arrayProto = Array.prototype;

  var makeArrayMethod = function (methodName) {
  	return function (keypath) {
  		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  			args[_key - 1] = arguments[_key];
  		}

  		var array,
  		    newIndices = [],
  		    len,
  		    promise,
  		    result;

  		keypath = getKeypath(normalise(keypath));

  		array = this.viewmodel.get(keypath);
  		len = array.length;

  		if (!isArray(array)) {
  			throw new Error("Called ractive." + methodName + "('" + keypath.str + "'), but '" + keypath.str + "' does not refer to an array");
  		}

  		newIndices = shared_getNewIndices(array, methodName, args);

  		result = arrayProto[methodName].apply(array, args);
  		promise = global_runloop.start(this, true).then(function () {
  			return result;
  		});

  		if (!!newIndices) {
  			this.viewmodel.smartUpdate(keypath, array, newIndices);
  		} else {
  			this.viewmodel.mark(keypath);
  		}

  		global_runloop.end();

  		return promise;
  	};
  };

  var pop = makeArrayMethod("pop");

  var push = makeArrayMethod("push");

  var css,
      update,
      styleElement,
      head,
      styleSheet,
      inDom,
      global_css__prefix = "/* Ractive.js component styles */\n",
      styles = [],
      dirty = false;

  if (!isClient) {
  	// TODO handle encapsulated CSS in server-rendered HTML!
  	css = {
  		add: noop,
  		apply: noop
  	};
  } else {
  	styleElement = document.createElement("style");
  	styleElement.type = "text/css";

  	head = document.getElementsByTagName("head")[0];

  	inDom = false;

  	// Internet Exploder won't let you use styleSheet.innerHTML - we have to
  	// use styleSheet.cssText instead
  	styleSheet = styleElement.styleSheet;

  	update = function () {
  		var css = global_css__prefix + styles.map(function (s) {
  			return "\n/* {" + s.id + "} */\n" + s.styles;
  		}).join("\n");

  		if (styleSheet) {
  			styleSheet.cssText = css;
  		} else {
  			styleElement.innerHTML = css;
  		}

  		if (!inDom) {
  			head.appendChild(styleElement);
  			inDom = true;
  		}
  	};

  	css = {
  		add: function (s) {
  			styles.push(s);
  			dirty = true;
  		},

  		apply: function () {
  			if (dirty) {
  				update();
  				dirty = false;
  			}
  		}
  	};
  }

  var global_css = css;

  var prototype_render = Ractive$render;

  var renderHook = new hooks_Hook("render"),
      completeHook = new hooks_Hook("complete");
  function Ractive$render(target, anchor) {
  	var _this = this;

  	var promise, instances, transitionsEnabled;

  	// if `noIntro` is `true`, temporarily disable transitions
  	transitionsEnabled = this.transitionsEnabled;
  	if (this.noIntro) {
  		this.transitionsEnabled = false;
  	}

  	promise = global_runloop.start(this, true);
  	global_runloop.scheduleTask(function () {
  		return renderHook.fire(_this);
  	}, true);

  	if (this.fragment.rendered) {
  		throw new Error("You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first");
  	}

  	target = getElement(target) || this.el;
  	anchor = getElement(anchor) || this.anchor;

  	this.el = target;
  	this.anchor = anchor;

  	if (!this.append && target) {
  		// Teardown any existing instances *before* trying to set up the new one -
  		// avoids certain weird bugs
  		var others = target.__ractive_instances__;
  		if (others && others.length) {
  			removeOtherInstances(others);
  		}

  		// make sure we are the only occupants
  		target.innerHTML = ""; // TODO is this quicker than removeChild? Initial research inconclusive
  	}

  	if (this.cssId) {
  		// ensure encapsulated CSS is up-to-date
  		global_css.apply();
  	}

  	if (target) {
  		if (!(instances = target.__ractive_instances__)) {
  			target.__ractive_instances__ = [this];
  		} else {
  			instances.push(this);
  		}

  		if (anchor) {
  			target.insertBefore(this.fragment.render(), anchor);
  		} else {
  			target.appendChild(this.fragment.render());
  		}
  	}

  	global_runloop.end();

  	this.transitionsEnabled = transitionsEnabled;

  	return promise.then(function () {
  		return completeHook.fire(_this);
  	});
  }

  function removeOtherInstances(others) {
  	others.splice(0, others.length).forEach(teardown);
  }

  var adaptConfigurator = {
  	extend: function (Parent, proto, options) {
  		proto.adapt = custom_adapt__combine(proto.adapt, ensureArray(options.adapt));
  	},

  	init: function () {}
  };

  var custom_adapt = adaptConfigurator;

  function custom_adapt__combine(a, b) {
  	var c = a.slice(),
  	    i = b.length;

  	while (i--) {
  		if (! ~c.indexOf(b[i])) {
  			c.push(b[i]);
  		}
  	}

  	return c;
  }

  var transform = transformCss;

  var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
      commentsPattern = /\/\*.*?\*\//g,
      selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~\(]+(?:\([^\)]+\))?)?\s*[\s\+\>\~]?)\s*/g,
      mediaQueryPattern = /^@media/,
      dataRvcGuidPattern = /\[data-ractive-css~="\{[a-z0-9-]+\}"]/g;
  function transformCss(css, id) {
  	var transformed, dataAttr, addGuid;

  	dataAttr = "[data-ractive-css~=\"{" + id + "}\"]";

  	addGuid = function (selector) {
  		var selectorUnits,
  		    match,
  		    unit,
  		    base,
  		    prepended,
  		    appended,
  		    i,
  		    transformed = [];

  		selectorUnits = [];

  		while (match = selectorUnitPattern.exec(selector)) {
  			selectorUnits.push({
  				str: match[0],
  				base: match[1],
  				modifiers: match[2]
  			});
  		}

  		// For each simple selector within the selector, we need to create a version
  		// that a) combines with the id, and b) is inside the id
  		base = selectorUnits.map(extractString);

  		i = selectorUnits.length;
  		while (i--) {
  			appended = base.slice();

  			// Pseudo-selectors should go after the attribute selector
  			unit = selectorUnits[i];
  			appended[i] = unit.base + dataAttr + unit.modifiers || "";

  			prepended = base.slice();
  			prepended[i] = dataAttr + " " + prepended[i];

  			transformed.push(appended.join(" "), prepended.join(" "));
  		}

  		return transformed.join(", ");
  	};

  	if (dataRvcGuidPattern.test(css)) {
  		transformed = css.replace(dataRvcGuidPattern, dataAttr);
  	} else {
  		transformed = css.replace(commentsPattern, "").replace(selectorsPattern, function (match, $1) {
  			var selectors, transformed;

  			// don't transform media queries!
  			if (mediaQueryPattern.test($1)) return match;

  			selectors = $1.split(",").map(trim);
  			transformed = selectors.map(addGuid).join(", ") + " ";

  			return match.replace($1, transformed);
  		});
  	}

  	return transformed;
  }

  function trim(str) {
  	if (str.trim) {
  		return str.trim();
  	}

  	return str.replace(/^\s+/, "").replace(/\s+$/, "");
  }

  function extractString(unit) {
  	return unit.str;
  }

  var css_css__uid = 1;

  var cssConfigurator = {
  	name: "css",

  	extend: function (Parent, proto, options) {
  		if (options.css) {
  			var id = css_css__uid++;
  			var styles = options.noCssTransform ? options.css : transform(options.css, id);

  			proto.cssId = id;
  			global_css.add({ id: id, styles: styles });
  		}
  	},

  	init: function () {}
  };

  var css_css = cssConfigurator;

  function validate(data) {
  	// Warn if userOptions.data is a non-POJO
  	if (data && data.constructor !== Object) {
  		if (typeof data === "function") {} else if (typeof data !== "object") {
  			fatal("data option must be an object or a function, `" + data + "` is not valid");
  		} else {
  			warnIfDebug("If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged");
  		}
  	}
  }

  var dataConfigurator = {
  	name: "data",

  	extend: function (Parent, proto, options) {
  		var key = undefined,
  		    value = undefined;

  		// check for non-primitives, which could cause mutation-related bugs
  		if (options.data && isObject(options.data)) {
  			for (key in options.data) {
  				value = options.data[key];

  				if (value && typeof value === "object") {
  					if (isObject(value) || isArray(value)) {
  						warnIfDebug("Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\n\n  // this...\n  data: function () {\n    return {\n      myObject: {}\n    };\n  })\n\n  // instead of this:\n  data: {\n    myObject: {}\n  }");
  					}
  				}
  			}
  		}

  		proto.data = custom_data__combine(proto.data, options.data);
  	},

  	init: function (Parent, ractive, options) {
  		var result = custom_data__combine(Parent.prototype.data, options.data);

  		if (typeof result === "function") {
  			result = result.call(ractive);
  		}

  		return result || {};
  	},

  	reset: function (ractive) {
  		var result = this.init(ractive.constructor, ractive, ractive.viewmodel);

  		ractive.viewmodel.reset(result);
  		return true;
  	}
  };

  var custom_data = dataConfigurator;

  function custom_data__combine(parentValue, childValue) {
  	validate(childValue);

  	var parentIsFn = typeof parentValue === "function";
  	var childIsFn = typeof childValue === "function";

  	// Very important, otherwise child instance can become
  	// the default data object on Ractive or a component.
  	// then ractive.set() ends up setting on the prototype!
  	if (!childValue && !parentIsFn) {
  		childValue = {};
  	}

  	// Fast path, where we just need to copy properties from
  	// parent to child
  	if (!parentIsFn && !childIsFn) {
  		return fromProperties(childValue, parentValue);
  	}

  	return function () {
  		var child = childIsFn ? callDataFunction(childValue, this) : childValue;
  		var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;

  		return fromProperties(child, parent);
  	};
  }

  function callDataFunction(fn, context) {
  	var data = fn.call(context);

  	if (!data) return;

  	if (typeof data !== "object") {
  		fatal("Data function must return an object");
  	}

  	if (data.constructor !== Object) {
  		warnOnceIfDebug("Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged");
  	}

  	return data;
  }

  function fromProperties(primary, secondary) {
  	if (primary && secondary) {
  		for (var key in secondary) {
  			if (!(key in primary)) {
  				primary[key] = secondary[key];
  			}
  		}

  		return primary;
  	}

  	return primary || secondary;
  }

  // TODO do we need to support this in the new Ractive() case?

  var Parser,
      ParseError,
      parse_Parser__leadingWhitespace = /^\s+/;

  ParseError = function (message) {
  	this.name = "ParseError";
  	this.message = message;
  	try {
  		throw new Error(message);
  	} catch (e) {
  		this.stack = e.stack;
  	}
  };

  ParseError.prototype = Error.prototype;

  Parser = function (str, options) {
  	var items,
  	    item,
  	    lineStart = 0;

  	this.str = str;
  	this.options = options || {};
  	this.pos = 0;

  	this.lines = this.str.split("\n");
  	this.lineEnds = this.lines.map(function (line) {
  		var lineEnd = lineStart + line.length + 1; // +1 for the newline

  		lineStart = lineEnd;
  		return lineEnd;
  	}, 0);

  	// Custom init logic
  	if (this.init) this.init(str, options);

  	items = [];

  	while (this.pos < this.str.length && (item = this.read())) {
  		items.push(item);
  	}

  	this.leftover = this.remaining();
  	this.result = this.postProcess ? this.postProcess(items, options) : items;
  };

  Parser.prototype = {
  	read: function (converters) {
  		var pos, i, len, item;

  		if (!converters) converters = this.converters;

  		pos = this.pos;

  		len = converters.length;
  		for (i = 0; i < len; i += 1) {
  			this.pos = pos; // reset for each attempt

  			if (item = converters[i](this)) {
  				return item;
  			}
  		}

  		return null;
  	},

  	getLinePos: function (char) {
  		var lineNum = 0,
  		    lineStart = 0,
  		    columnNum;

  		while (char >= this.lineEnds[lineNum]) {
  			lineStart = this.lineEnds[lineNum];
  			lineNum += 1;
  		}

  		columnNum = char - lineStart;
  		return [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!
  	},

  	error: function (message) {
  		var pos = this.getLinePos(this.pos);
  		var lineNum = pos[0];
  		var columnNum = pos[1];

  		var line = this.lines[pos[0] - 1];
  		var numTabs = 0;
  		var annotation = line.replace(/\t/g, function (match, char) {
  			if (char < pos[1]) {
  				numTabs += 1;
  			}

  			return "  ";
  		}) + "\n" + new Array(pos[1] + numTabs).join(" ") + "^----";

  		var error = new ParseError("" + message + " at line " + lineNum + " character " + columnNum + ":\n" + annotation);

  		error.line = pos[0];
  		error.character = pos[1];
  		error.shortMessage = message;

  		throw error;
  	},

  	matchString: function (string) {
  		if (this.str.substr(this.pos, string.length) === string) {
  			this.pos += string.length;
  			return string;
  		}
  	},

  	matchPattern: function (pattern) {
  		var match;

  		if (match = pattern.exec(this.remaining())) {
  			this.pos += match[0].length;
  			return match[1] || match[0];
  		}
  	},

  	allowWhitespace: function () {
  		this.matchPattern(parse_Parser__leadingWhitespace);
  	},

  	remaining: function () {
  		return this.str.substring(this.pos);
  	},

  	nextChar: function () {
  		return this.str.charAt(this.pos);
  	}
  };

  Parser.extend = function (proto) {
  	var Parent = this,
  	    Child,
  	    key;

  	Child = function (str, options) {
  		Parser.call(this, str, options);
  	};

  	Child.prototype = create(Parent.prototype);

  	for (key in proto) {
  		if (hasOwn.call(proto, key)) {
  			Child.prototype[key] = proto[key];
  		}
  	}

  	Child.extend = Parser.extend;
  	return Child;
  };

  var parse_Parser = Parser;

  var TEXT = 1;
  var INTERPOLATOR = 2;
  var TRIPLE = 3;
  var SECTION = 4;
  var INVERTED = 5;
  var CLOSING = 6;
  var ELEMENT = 7;
  var PARTIAL = 8;
  var COMMENT = 9;
  var DELIMCHANGE = 10;
  var ATTRIBUTE = 13;
  var CLOSING_TAG = 14;
  var COMPONENT = 15;
  var YIELDER = 16;
  var INLINE_PARTIAL = 17;
  var DOCTYPE = 18;

  var NUMBER_LITERAL = 20;
  var STRING_LITERAL = 21;
  var ARRAY_LITERAL = 22;
  var OBJECT_LITERAL = 23;
  var BOOLEAN_LITERAL = 24;
  var REGEXP_LITERAL = 25;

  var GLOBAL = 26;
  var KEY_VALUE_PAIR = 27;

  var REFERENCE = 30;
  var REFINEMENT = 31;
  var MEMBER = 32;
  var PREFIX_OPERATOR = 33;
  var BRACKETED = 34;
  var CONDITIONAL = 35;
  var INFIX_OPERATOR = 36;

  var INVOCATION = 40;

  var SECTION_IF = 50;
  var SECTION_UNLESS = 51;
  var SECTION_EACH = 52;
  var SECTION_WITH = 53;
  var SECTION_IF_WITH = 54;

  var ELSE = 60;
  var ELSEIF = 61;

  var mustache_readDelimiterChange = readDelimiterChange;
  var delimiterChangePattern = /^[^\s=]+/,
      whitespacePattern = /^\s+/;
  function readDelimiterChange(parser) {
  	var start, opening, closing;

  	if (!parser.matchString("=")) {
  		return null;
  	}

  	start = parser.pos;

  	// allow whitespace before new opening delimiter
  	parser.allowWhitespace();

  	opening = parser.matchPattern(delimiterChangePattern);
  	if (!opening) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace (in fact, it's necessary...)
  	if (!parser.matchPattern(whitespacePattern)) {
  		return null;
  	}

  	closing = parser.matchPattern(delimiterChangePattern);
  	if (!closing) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace before closing '='
  	parser.allowWhitespace();

  	if (!parser.matchString("=")) {
  		parser.pos = start;
  		return null;
  	}

  	return [opening, closing];
  }

  var readRegexpLiteral = readRegexpLiteral__readNumberLiteral;
  var regexpPattern = /^(\/(?:[^\n\r\u2028\u2029/\\[]|\\.|\[(?:[^\n\r\u2028\u2029\]\\]|\\.)*])+\/(?:([gimuy])(?![a-z]*\2))*(?![a-zA-Z_$0-9]))/;
  function readRegexpLiteral__readNumberLiteral(parser) {
  	var result;

  	if (result = parser.matchPattern(regexpPattern)) {
  		return {
  			t: REGEXP_LITERAL,
  			v: result
  		};
  	}

  	return null;
  }

  var converters_readMustache = readMustache;

  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };
  function readMustache(parser) {
  	var mustache, i;

  	// If we're inside a <script> or <style> tag, and we're not
  	// interpolating, bug out
  	if (parser.interpolate[parser.inside] === false) {
  		return null;
  	}

  	for (i = 0; i < parser.tags.length; i += 1) {
  		if (mustache = readMustacheOfType(parser, parser.tags[i])) {
  			return mustache;
  		}
  	}
  }

  function readMustacheOfType(parser, tag) {
  	var start, mustache, reader, i;

  	start = parser.pos;

  	if (parser.matchString("\\" + tag.open)) {
  		if (start === 0 || parser.str[start - 1] !== "\\") {
  			return tag.open;
  		}
  	} else if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	// delimiter change?
  	if (mustache = mustache_readDelimiterChange(parser)) {
  		// find closing delimiter or abort...
  		if (!parser.matchString(tag.close)) {
  			return null;
  		}

  		// ...then make the switch
  		tag.open = mustache[0];
  		tag.close = mustache[1];
  		parser.sortMustacheTags();

  		return delimiterChangeToken;
  	}

  	parser.allowWhitespace();

  	// illegal section closer
  	if (parser.matchString("/")) {
  		parser.pos -= 1;
  		var rewind = parser.pos;
  		if (!readRegexpLiteral(parser)) {
  			parser.pos = rewind - tag.close.length;
  			parser.error("Attempted to close a section that wasn't open");
  		} else {
  			parser.pos = rewind;
  		}
  	}

  	for (i = 0; i < tag.readers.length; i += 1) {
  		reader = tag.readers[i];

  		if (mustache = reader(parser, tag)) {
  			if (tag.isStatic) {
  				mustache.s = true; // TODO make this `1` instead - more compact
  			}

  			if (parser.includeLinePositions) {
  				mustache.p = parser.getLinePos(start);
  			}

  			return mustache;
  		}
  	}

  	parser.pos = start;
  	return null;
  }

  var expectedExpression = "Expected a JavaScript expression";
  var expectedParen = "Expected closing paren";

  var literal_readNumberLiteral = literal_readNumberLiteral__readNumberLiteral;
  var literal_readNumberLiteral__numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
  function literal_readNumberLiteral__readNumberLiteral(parser) {
  	var result;

  	if (result = parser.matchPattern(literal_readNumberLiteral__numberPattern)) {
  		return {
  			t: NUMBER_LITERAL,
  			v: result
  		};
  	}

  	return null;
  }

  var literal_readBooleanLiteral = readBooleanLiteral;
  function readBooleanLiteral(parser) {
  	var remaining = parser.remaining();

  	if (remaining.substr(0, 4) === "true") {
  		parser.pos += 4;
  		return {
  			t: BOOLEAN_LITERAL,
  			v: "true"
  		};
  	}

  	if (remaining.substr(0, 5) === "false") {
  		parser.pos += 5;
  		return {
  			t: BOOLEAN_LITERAL,
  			v: "false"
  		};
  	}

  	return null;
  }

  var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;

  // Match one or more characters until: ", ', \, or EOL/EOF.
  // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
  stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;

  // Match one escape sequence, including the backslash.
  escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;

  // Match one ES5 line continuation (backslash + line terminator).
  lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;

  // Helper for defining getDoubleQuotedString and getSingleQuotedString.
  var makeQuotedStringMatcher = function (okQuote) {
  	return function (parser) {
  		var start, literal, done, next;

  		start = parser.pos;
  		literal = "\"";
  		done = false;

  		while (!done) {
  			next = parser.matchPattern(stringMiddlePattern) || parser.matchPattern(escapeSequencePattern) || parser.matchString(okQuote);
  			if (next) {
  				if (next === "\"") {
  					literal += "\\\"";
  				} else if (next === "\\'") {
  					literal += "'";
  				} else {
  					literal += next;
  				}
  			} else {
  				next = parser.matchPattern(lineContinuationPattern);
  				if (next) {
  					// convert \(newline-like) into a \u escape, which is allowed in JSON
  					literal += "\\u" + ("000" + next.charCodeAt(1).toString(16)).slice(-4);
  				} else {
  					done = true;
  				}
  			}
  		}

  		literal += "\"";

  		// use JSON.parse to interpret escapes
  		return JSON.parse(literal);
  	};
  };

  var getSingleQuotedString = makeQuotedStringMatcher("\"");
  var getDoubleQuotedString = makeQuotedStringMatcher("'");

  var readStringLiteral = function (parser) {
  	var start, string;

  	start = parser.pos;

  	if (parser.matchString("\"")) {
  		string = getDoubleQuotedString(parser);

  		if (!parser.matchString("\"")) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: STRING_LITERAL,
  			v: string
  		};
  	}

  	if (parser.matchString("'")) {
  		string = getSingleQuotedString(parser);

  		if (!parser.matchString("'")) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: STRING_LITERAL,
  			v: string
  		};
  	}

  	return null;
  };

  var patterns__name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;

  // http://mathiasbynens.be/notes/javascript-properties
  // can be any name, string literal, or number literal
  var shared_readKey = readKey;
  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
  function readKey(parser) {
  	var token;

  	if (token = readStringLiteral(parser)) {
  		return identifier.test(token.v) ? token.v : "\"" + token.v.replace(/"/g, "\\\"") + "\"";
  	}

  	if (token = literal_readNumberLiteral(parser)) {
  		return token.v;
  	}

  	if (token = parser.matchPattern(patterns__name)) {
  		return token;
  	}
  }

  var keyValuePair = readKeyValuePair;
  function readKeyValuePair(parser) {
  	var start, key, value;

  	start = parser.pos;

  	// allow whitespace between '{' and key
  	parser.allowWhitespace();

  	key = shared_readKey(parser);
  	if (key === null) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace between key and ':'
  	parser.allowWhitespace();

  	// next character must be ':'
  	if (!parser.matchString(":")) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace between ':' and value
  	parser.allowWhitespace();

  	// next expression must be a, well... expression
  	value = converters_readExpression(parser);
  	if (value === null) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: KEY_VALUE_PAIR,
  		k: key,
  		v: value
  	};
  }

  var objectLiteral_keyValuePairs = readKeyValuePairs;
  function readKeyValuePairs(parser) {
  	var start, pairs, pair, keyValuePairs;

  	start = parser.pos;

  	pair = keyValuePair(parser);
  	if (pair === null) {
  		return null;
  	}

  	pairs = [pair];

  	if (parser.matchString(",")) {
  		keyValuePairs = readKeyValuePairs(parser);

  		if (!keyValuePairs) {
  			parser.pos = start;
  			return null;
  		}

  		return pairs.concat(keyValuePairs);
  	}

  	return pairs;
  }

  var readObjectLiteral = function (parser) {
  	var start, keyValuePairs;

  	start = parser.pos;

  	// allow whitespace
  	parser.allowWhitespace();

  	if (!parser.matchString("{")) {
  		parser.pos = start;
  		return null;
  	}

  	keyValuePairs = objectLiteral_keyValuePairs(parser);

  	// allow whitespace between final value and '}'
  	parser.allowWhitespace();

  	if (!parser.matchString("}")) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: OBJECT_LITERAL,
  		m: keyValuePairs
  	};
  };

  var shared_readExpressionList = readExpressionList;
  function readExpressionList(parser) {
  	var start, expressions, expr, next;

  	start = parser.pos;

  	parser.allowWhitespace();

  	expr = converters_readExpression(parser);

  	if (expr === null) {
  		return null;
  	}

  	expressions = [expr];

  	// allow whitespace between expression and ','
  	parser.allowWhitespace();

  	if (parser.matchString(",")) {
  		next = readExpressionList(parser);
  		if (next === null) {
  			parser.error(expectedExpression);
  		}

  		next.forEach(append);
  	}

  	function append(expression) {
  		expressions.push(expression);
  	}

  	return expressions;
  }

  var readArrayLiteral = function (parser) {
  	var start, expressionList;

  	start = parser.pos;

  	// allow whitespace before '['
  	parser.allowWhitespace();

  	if (!parser.matchString("[")) {
  		parser.pos = start;
  		return null;
  	}

  	expressionList = shared_readExpressionList(parser);

  	if (!parser.matchString("]")) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: ARRAY_LITERAL,
  		m: expressionList
  	};
  };

  var primary_readLiteral = readLiteral;
  function readLiteral(parser) {
  	return literal_readNumberLiteral(parser) || literal_readBooleanLiteral(parser) || readStringLiteral(parser) || readObjectLiteral(parser) || readArrayLiteral(parser) || readRegexpLiteral(parser);
  }

  var primary_readReference = readReference;
  var prefixPattern = /^(?:~\/|(?:\.\.\/)+|\.\/(?:\.\.\/)*|\.)/,
      globals,
      keywords;

  // if a reference is a browser global, we don't deference it later, so it needs special treatment
  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\b/;

  // keywords are not valid references, with the exception of `this`
  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;

  var legalReference = /^[a-zA-Z$_0-9]+(?:(?:\.[a-zA-Z$_0-9]+)|(?:\[[0-9]+\]))*/;
  var relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;
  function readReference(parser) {
  	var startPos, prefix, name, global, reference, lastDotIndex;

  	startPos = parser.pos;

  	name = parser.matchPattern(/^@(?:keypath|index|key)/);

  	if (!name) {
  		prefix = parser.matchPattern(prefixPattern) || "";
  		name = !prefix && parser.relaxedNames && parser.matchPattern(relaxedName) || parser.matchPattern(legalReference);

  		if (!name && prefix === ".") {
  			prefix = "";
  			name = ".";
  		}
  	}

  	if (!name) {
  		return null;
  	}

  	// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)
  	if (!prefix && !parser.relaxedNames && keywords.test(name)) {
  		parser.pos = startPos;
  		return null;
  	}

  	// if this is a browser global, stop here
  	if (!prefix && globals.test(name)) {
  		global = globals.exec(name)[0];
  		parser.pos = startPos + global.length;

  		return {
  			t: GLOBAL,
  			v: global
  		};
  	}

  	reference = (prefix || "") + normalise(name);

  	if (parser.matchString("(")) {
  		// if this is a method invocation (as opposed to a function) we need
  		// to strip the method name from the reference combo, else the context
  		// will be wrong
  		lastDotIndex = reference.lastIndexOf(".");
  		if (lastDotIndex !== -1) {
  			reference = reference.substr(0, lastDotIndex);
  			parser.pos = startPos + reference.length;
  		} else {
  			parser.pos -= 1;
  		}
  	}

  	return {
  		t: REFERENCE,
  		n: reference.replace(/^this\./, "./").replace(/^this$/, ".")
  	};
  }

  var primary_readBracketedExpression = readBracketedExpression;
  function readBracketedExpression(parser) {
  	var start, expr;

  	start = parser.pos;

  	if (!parser.matchString("(")) {
  		return null;
  	}

  	parser.allowWhitespace();

  	expr = converters_readExpression(parser);
  	if (!expr) {
  		parser.error(expectedExpression);
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(")")) {
  		parser.error(expectedParen);
  	}

  	return {
  		t: BRACKETED,
  		x: expr
  	};
  }

  var readPrimary = function (parser) {
  	return primary_readLiteral(parser) || primary_readReference(parser) || primary_readBracketedExpression(parser);
  };

  var shared_readRefinement = readRefinement;
  function readRefinement(parser) {
  	var start, name, expr;

  	start = parser.pos;

  	parser.allowWhitespace();

  	// "." name
  	if (parser.matchString(".")) {
  		parser.allowWhitespace();

  		if (name = parser.matchPattern(patterns__name)) {
  			return {
  				t: REFINEMENT,
  				n: name
  			};
  		}

  		parser.error("Expected a property name");
  	}

  	// "[" expression "]"
  	if (parser.matchString("[")) {
  		parser.allowWhitespace();

  		expr = converters_readExpression(parser);
  		if (!expr) {
  			parser.error(expectedExpression);
  		}

  		parser.allowWhitespace();

  		if (!parser.matchString("]")) {
  			parser.error("Expected ']'");
  		}

  		return {
  			t: REFINEMENT,
  			x: expr
  		};
  	}

  	return null;
  }

  var readMemberOrInvocation = function (parser) {
  	var current, expression, refinement, expressionList;

  	expression = readPrimary(parser);

  	if (!expression) {
  		return null;
  	}

  	while (expression) {
  		current = parser.pos;

  		if (refinement = shared_readRefinement(parser)) {
  			expression = {
  				t: MEMBER,
  				x: expression,
  				r: refinement
  			};
  		} else if (parser.matchString("(")) {
  			parser.allowWhitespace();
  			expressionList = shared_readExpressionList(parser);

  			parser.allowWhitespace();

  			if (!parser.matchString(")")) {
  				parser.error(expectedParen);
  			}

  			expression = {
  				t: INVOCATION,
  				x: expression
  			};

  			if (expressionList) {
  				expression.o = expressionList;
  			}
  		} else {
  			break;
  		}
  	}

  	return expression;
  };

  var readTypeOf, makePrefixSequenceMatcher;

  makePrefixSequenceMatcher = function (symbol, fallthrough) {
  	return function (parser) {
  		var expression;

  		if (expression = fallthrough(parser)) {
  			return expression;
  		}

  		if (!parser.matchString(symbol)) {
  			return null;
  		}

  		parser.allowWhitespace();

  		expression = converters_readExpression(parser);
  		if (!expression) {
  			parser.error(expectedExpression);
  		}

  		return {
  			s: symbol,
  			o: expression,
  			t: PREFIX_OPERATOR
  		};
  	};
  };

  // create all prefix sequence matchers, return readTypeOf
  (function () {
  	var i, len, matcher, prefixOperators, fallthrough;

  	prefixOperators = "! ~ + - typeof".split(" ");

  	fallthrough = readMemberOrInvocation;
  	for (i = 0, len = prefixOperators.length; i < len; i += 1) {
  		matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);
  		fallthrough = matcher;
  	}

  	// typeof operator is higher precedence than multiplication, so provides the
  	// fallthrough for the multiplication sequence matcher we're about to create
  	// (we're skipping void and delete)
  	readTypeOf = fallthrough;
  })();

  var readTypeof = readTypeOf;

  var readLogicalOr, makeInfixSequenceMatcher;

  makeInfixSequenceMatcher = function (symbol, fallthrough) {
  	return function (parser) {
  		var start, left, right;

  		left = fallthrough(parser);
  		if (!left) {
  			return null;
  		}

  		// Loop to handle left-recursion in a case like `a * b * c` and produce
  		// left association, i.e. `(a * b) * c`.  The matcher can't call itself
  		// to parse `left` because that would be infinite regress.
  		while (true) {
  			start = parser.pos;

  			parser.allowWhitespace();

  			if (!parser.matchString(symbol)) {
  				parser.pos = start;
  				return left;
  			}

  			// special case - in operator must not be followed by [a-zA-Z_$0-9]
  			if (symbol === "in" && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {
  				parser.pos = start;
  				return left;
  			}

  			parser.allowWhitespace();

  			// right operand must also consist of only higher-precedence operators
  			right = fallthrough(parser);
  			if (!right) {
  				parser.pos = start;
  				return left;
  			}

  			left = {
  				t: INFIX_OPERATOR,
  				s: symbol,
  				o: [left, right]
  			};

  			// Loop back around.  If we don't see another occurrence of the symbol,
  			// we'll return left.
  		}
  	};
  };

  // create all infix sequence matchers, and return readLogicalOr
  (function () {
  	var i, len, matcher, infixOperators, fallthrough;

  	// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
  	// Each sequence matcher will initially fall through to its higher precedence
  	// neighbour, and only attempt to match if one of the higher precedence operators
  	// (or, ultimately, a literal, reference, or bracketed expression) already matched
  	infixOperators = "* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||".split(" ");

  	// A typeof operator is higher precedence than multiplication
  	fallthrough = readTypeof;
  	for (i = 0, len = infixOperators.length; i < len; i += 1) {
  		matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);
  		fallthrough = matcher;
  	}

  	// Logical OR is the fallthrough for the conditional matcher
  	readLogicalOr = fallthrough;
  })();

  var expressions_readLogicalOr = readLogicalOr;

  // The conditional operator is the lowest precedence operator, so we start here
  var readConditional = getConditional;
  function getConditional(parser) {
  	var start, expression, ifTrue, ifFalse;

  	expression = expressions_readLogicalOr(parser);
  	if (!expression) {
  		return null;
  	}

  	start = parser.pos;

  	parser.allowWhitespace();

  	if (!parser.matchString("?")) {
  		parser.pos = start;
  		return expression;
  	}

  	parser.allowWhitespace();

  	ifTrue = converters_readExpression(parser);
  	if (!ifTrue) {
  		parser.error(expectedExpression);
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(":")) {
  		parser.error("Expected \":\"");
  	}

  	parser.allowWhitespace();

  	ifFalse = converters_readExpression(parser);
  	if (!ifFalse) {
  		parser.error(expectedExpression);
  	}

  	return {
  		t: CONDITIONAL,
  		o: [expression, ifTrue, ifFalse]
  	};
  }

  var converters_readExpression = readExpression;
  function readExpression(parser) {
  	// The conditional operator is the lowest precedence operator (except yield,
  	// assignment operators, and commas, none of which are supported), so we
  	// start there. If it doesn't match, it 'falls through' to progressively
  	// higher precedence operators, until it eventually matches (or fails to
  	// match) a 'primary' - a literal or a reference. This way, the abstract syntax
  	// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
  	return readConditional(parser);
  }

  var utils_flattenExpression = flattenExpression;

  function flattenExpression(expression) {
  	var refs;

  	extractRefs(expression, refs = []);

  	return {
  		r: refs,
  		s: stringify(expression)
  	};

  	function stringify(node) {
  		switch (node.t) {
  			case BOOLEAN_LITERAL:
  			case GLOBAL:
  			case NUMBER_LITERAL:
  			case REGEXP_LITERAL:
  				return node.v;

  			case STRING_LITERAL:
  				return JSON.stringify(String(node.v));

  			case ARRAY_LITERAL:
  				return "[" + (node.m ? node.m.map(stringify).join(",") : "") + "]";

  			case OBJECT_LITERAL:
  				return "{" + (node.m ? node.m.map(stringify).join(",") : "") + "}";

  			case KEY_VALUE_PAIR:
  				return node.k + ":" + stringify(node.v);

  			case PREFIX_OPERATOR:
  				return (node.s === "typeof" ? "typeof " : node.s) + stringify(node.o);

  			case INFIX_OPERATOR:
  				return stringify(node.o[0]) + (node.s.substr(0, 2) === "in" ? " " + node.s + " " : node.s) + stringify(node.o[1]);

  			case INVOCATION:
  				return stringify(node.x) + "(" + (node.o ? node.o.map(stringify).join(",") : "") + ")";

  			case BRACKETED:
  				return "(" + stringify(node.x) + ")";

  			case MEMBER:
  				return stringify(node.x) + stringify(node.r);

  			case REFINEMENT:
  				return node.n ? "." + node.n : "[" + stringify(node.x) + "]";

  			case CONDITIONAL:
  				return stringify(node.o[0]) + "?" + stringify(node.o[1]) + ":" + stringify(node.o[2]);

  			case REFERENCE:
  				return "_" + refs.indexOf(node.n);

  			default:
  				throw new Error("Expected legal JavaScript");
  		}
  	}
  }

  // TODO maybe refactor this?
  function extractRefs(node, refs) {
  	var i, list;

  	if (node.t === REFERENCE) {
  		if (refs.indexOf(node.n) === -1) {
  			refs.unshift(node.n);
  		}
  	}

  	list = node.o || node.m;
  	if (list) {
  		if (isObject(list)) {
  			extractRefs(list, refs);
  		} else {
  			i = list.length;
  			while (i--) {
  				extractRefs(list[i], refs);
  			}
  		}
  	}

  	if (node.x) {
  		extractRefs(node.x, refs);
  	}

  	if (node.r) {
  		extractRefs(node.r, refs);
  	}

  	if (node.v) {
  		extractRefs(node.v, refs);
  	}
  }

  var utils_refineExpression = refineExpression;

  var arrayMemberPattern = /^[0-9][1-9]*$/;
  function refineExpression(expression, mustache) {
  	var referenceExpression;

  	if (expression) {
  		while (expression.t === BRACKETED && expression.x) {
  			expression = expression.x;
  		}

  		// special case - integers should be treated as array members references,
  		// rather than as expressions in their own right
  		if (expression.t === REFERENCE) {
  			mustache.r = expression.n;
  		} else {
  			if (expression.t === NUMBER_LITERAL && arrayMemberPattern.test(expression.v)) {
  				mustache.r = expression.v;
  			} else if (referenceExpression = getReferenceExpression(expression)) {
  				mustache.rx = referenceExpression;
  			} else {
  				mustache.x = utils_flattenExpression(expression);
  			}
  		}

  		return mustache;
  	}
  }

  // TODO refactor this! it's bewildering
  function getReferenceExpression(expression) {
  	var members = [],
  	    refinement;

  	while (expression.t === MEMBER && expression.r.t === REFINEMENT) {
  		refinement = expression.r;

  		if (refinement.x) {
  			if (refinement.x.t === REFERENCE) {
  				members.unshift(refinement.x);
  			} else {
  				members.unshift(utils_flattenExpression(refinement.x));
  			}
  		} else {
  			members.unshift(refinement.n);
  		}

  		expression = expression.x;
  	}

  	if (expression.t !== REFERENCE) {
  		return null;
  	}

  	return {
  		r: expression.n,
  		m: members
  	};
  }

  var mustache_readTriple = readTriple;
  function readTriple(parser, tag) {
  	var expression = converters_readExpression(parser),
  	    triple;

  	if (!expression) {
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	triple = { t: TRIPLE };
  	utils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious

  	return triple;
  }

  var mustache_readUnescaped = readUnescaped;
  function readUnescaped(parser, tag) {
  	var expression, triple;

  	if (!parser.matchString("&")) {
  		return null;
  	}

  	parser.allowWhitespace();

  	expression = converters_readExpression(parser);

  	if (!expression) {
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	triple = { t: TRIPLE };
  	utils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious

  	return triple;
  }

  var mustache_readPartial = readPartial;
  function readPartial(parser, tag) {
  	var start, nameStart, expression, context, partial;

  	start = parser.pos;

  	if (!parser.matchString(">")) {
  		return null;
  	}

  	parser.allowWhitespace();
  	nameStart = parser.pos;

  	// Partial names can include hyphens, so we can't use readExpression
  	// blindly. Instead, we use the `relaxedNames` flag to indicate that
  	// `foo-bar` should be read as a single name, rather than 'subtract
  	// bar from foo'
  	parser.relaxedNames = true;
  	expression = converters_readExpression(parser);
  	parser.relaxedNames = false;

  	parser.allowWhitespace();
  	context = converters_readExpression(parser);
  	parser.allowWhitespace();

  	if (!expression) {
  		return null;
  	}

  	partial = { t: PARTIAL };
  	utils_refineExpression(expression, partial); // TODO...

  	parser.allowWhitespace();

  	// if we have another expression - e.g. `{{>foo bar}}` - then
  	// we turn it into `{{#with bar}}{{>foo}}{{/with}}`
  	if (context) {
  		partial = {
  			t: SECTION,
  			n: SECTION_WITH,
  			f: [partial]
  		};

  		utils_refineExpression(context, partial);
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return partial;
  }

  var readMustacheComment = readComment;
  function readComment(parser, tag) {
  	var index;

  	if (!parser.matchString("!")) {
  		return null;
  	}

  	index = parser.remaining().indexOf(tag.close);

  	if (index !== -1) {
  		parser.pos += index + tag.close.length;
  		return { t: COMMENT };
  	}
  }

  var converters_readExpressionOrReference = readExpressionOrReference;
  function readExpressionOrReference(parser, expectedFollowers) {
  	var start, expression, i;

  	start = parser.pos;
  	expression = converters_readExpression(parser);

  	if (!expression) {
  		return null;
  	}

  	for (i = 0; i < expectedFollowers.length; i += 1) {
  		if (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {
  			return expression;
  		}
  	}

  	parser.pos = start;
  	return primary_readReference(parser);
  }

  var mustache_readInterpolator = readInterpolator;
  function readInterpolator(parser, tag) {
  	var start, expression, interpolator, err;

  	start = parser.pos;

  	// TODO would be good for perf if we could do away with the try-catch
  	try {
  		expression = converters_readExpressionOrReference(parser, [tag.close]);
  	} catch (e) {
  		err = e;
  	}

  	if (!expression) {
  		if (parser.str.charAt(start) === "!") {
  			// special case - comment
  			parser.pos = start;
  			return null;
  		}

  		if (err) {
  			throw err;
  		}
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "' after reference");

  		if (!expression) {
  			// special case - comment
  			if (parser.nextChar() === "!") {
  				return null;
  			}

  			parser.error("Expected expression or legal reference");
  		}
  	}

  	interpolator = { t: INTERPOLATOR };
  	utils_refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious

  	return interpolator;
  }

  var mustache_readYielder = readYielder;
  var yieldPattern = /^yield\s*/;
  function readYielder(parser, tag) {
  	var start, name, yielder;

  	if (!parser.matchPattern(yieldPattern)) {
  		return null;
  	}

  	start = parser.pos;
  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\-]*/);

  	parser.allowWhitespace();

  	if (!parser.matchString(tag.close)) {
  		parser.error("expected legal partial name");
  	}

  	yielder = { t: YIELDER };

  	if (name) {
  		yielder.n = name;
  	}

  	return yielder;
  }

  var section_readClosing = readClosing;
  function readClosing(parser, tag) {
  	var start, remaining, index, closing;

  	start = parser.pos;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString("/")) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	remaining = parser.remaining();
  	index = remaining.indexOf(tag.close);

  	if (index !== -1) {
  		closing = {
  			t: CLOSING,
  			r: remaining.substr(0, index).split(" ")[0]
  		};

  		parser.pos += index;

  		if (!parser.matchString(tag.close)) {
  			parser.error("Expected closing delimiter '" + tag.close + "'");
  		}

  		return closing;
  	}

  	parser.pos = start;
  	return null;
  }

  var section_readElse = section_readElse__readElse;
  var section_readElse__elsePattern = /^\s*else\s*/;
  function section_readElse__readElse(parser, tag) {
  	var start = parser.pos;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	if (!parser.matchPattern(section_readElse__elsePattern)) {
  		parser.pos = start;
  		return null;
  	}

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return {
  		t: ELSE
  	};
  }

  var readElseIf = readElseIf__readElse;
  var readElseIf__elsePattern = /^\s*elseif\s+/;
  function readElseIf__readElse(parser, tag) {
  	var start = parser.pos,
  	    expression;

  	if (!parser.matchString(tag.open)) {
  		return null;
  	}

  	if (!parser.matchPattern(readElseIf__elsePattern)) {
  		parser.pos = start;
  		return null;
  	}

  	expression = converters_readExpression(parser);

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	return {
  		t: ELSEIF,
  		x: expression
  	};
  }

  var handlebarsBlockCodes = {
  	each: SECTION_EACH,
  	"if": SECTION_IF,
  	"if-with": SECTION_IF_WITH,
  	"with": SECTION_WITH,
  	unless: SECTION_UNLESS
  };

  var mustache_readSection = readSection;

  var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
      keyIndexRefPattern = /^\s*,\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
      handlebarsBlockPattern = new RegExp("^(" + Object.keys(handlebarsBlockCodes).join("|") + ")\\b");
  function readSection(parser, tag) {
  	var start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;

  	start = parser.pos;

  	if (parser.matchString("^")) {
  		section = { t: SECTION, f: [], n: SECTION_UNLESS };
  	} else if (parser.matchString("#")) {
  		section = { t: SECTION, f: [] };

  		if (parser.matchString("partial")) {
  			parser.pos = start - parser.standardDelimiters[0].length;
  			parser.error("Partial definitions can only be at the top level of the template, or immediately inside components");
  		}

  		if (block = parser.matchPattern(handlebarsBlockPattern)) {
  			expectedClose = block;
  			section.n = handlebarsBlockCodes[block];
  		}
  	} else {
  		return null;
  	}

  	parser.allowWhitespace();

  	expression = converters_readExpression(parser);

  	if (!expression) {
  		parser.error("Expected expression");
  	}

  	// optional index and key references
  	if (i = parser.matchPattern(indexRefPattern)) {
  		var extra = undefined;

  		if (extra = parser.matchPattern(keyIndexRefPattern)) {
  			section.i = i + "," + extra;
  		} else {
  			section.i = i;
  		}
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString(tag.close)) {
  		parser.error("Expected closing delimiter '" + tag.close + "'");
  	}

  	parser.sectionDepth += 1;
  	children = section.f;

  	conditions = [];

  	do {
  		if (child = section_readClosing(parser, tag)) {
  			if (expectedClose && child.r !== expectedClose) {
  				parser.error("Expected " + tag.open + "/" + expectedClose + "" + tag.close);
  			}

  			parser.sectionDepth -= 1;
  			closed = true;
  		} else if (child = readElseIf(parser, tag)) {
  			if (section.n === SECTION_UNLESS) {
  				parser.error("{{else}} not allowed in {{#unless}}");
  			}

  			if (hasElse) {
  				parser.error("illegal {{elseif...}} after {{else}}");
  			}

  			if (!unlessBlock) {
  				unlessBlock = createUnlessBlock(expression, section.n);
  			}

  			unlessBlock.f.push({
  				t: SECTION,
  				n: SECTION_IF,
  				x: utils_flattenExpression(mustache_readSection__combine(conditions.concat(child.x))),
  				f: children = []
  			});

  			conditions.push(invert(child.x));
  		} else if (child = section_readElse(parser, tag)) {
  			if (section.n === SECTION_UNLESS) {
  				parser.error("{{else}} not allowed in {{#unless}}");
  			}

  			if (hasElse) {
  				parser.error("there can only be one {{else}} block, at the end of a section");
  			}

  			hasElse = true;

  			// use an unless block if there's no elseif
  			if (!unlessBlock) {
  				unlessBlock = createUnlessBlock(expression, section.n);
  				children = unlessBlock.f;
  			} else {
  				unlessBlock.f.push({
  					t: SECTION,
  					n: SECTION_IF,
  					x: utils_flattenExpression(mustache_readSection__combine(conditions)),
  					f: children = []
  				});
  			}
  		} else {
  			child = parser.read(READERS);

  			if (!child) {
  				break;
  			}

  			children.push(child);
  		}
  	} while (!closed);

  	if (unlessBlock) {
  		// special case - `with` should become `if-with` (TODO is this right?
  		// seems to me that `with` ought to behave consistently, regardless
  		// of the presence/absence of `else`. In other words should always
  		// be `if-with`
  		if (section.n === SECTION_WITH) {
  			section.n = SECTION_IF_WITH;
  		}

  		section.l = unlessBlock;
  	}

  	utils_refineExpression(expression, section);

  	// TODO if a section is empty it should be discarded. Don't do
  	// that here though - we need to clean everything up first, as
  	// it may contain removeable whitespace. As a temporary measure,
  	// to pass the existing tests, remove empty `f` arrays
  	if (!section.f.length) {
  		delete section.f;
  	}

  	return section;
  }

  function createUnlessBlock(expression, sectionType) {
  	var unlessBlock;

  	if (sectionType === SECTION_WITH) {
  		// special case - a `{{#with foo}}` section will render if `foo` is
  		// truthy, so the `{{else}}` section needs to render if `foo` is falsy,
  		// rather than adhering to the normal `{{#unless foo}}` logic (which
  		// treats empty arrays/objects as falsy)
  		unlessBlock = {
  			t: SECTION,
  			n: SECTION_IF,
  			f: []
  		};

  		utils_refineExpression(invert(expression), unlessBlock);
  	} else {
  		unlessBlock = {
  			t: SECTION,
  			n: SECTION_UNLESS,
  			f: []
  		};

  		utils_refineExpression(expression, unlessBlock);
  	}

  	return unlessBlock;
  }

  function invert(expression) {
  	if (expression.t === PREFIX_OPERATOR && expression.s === "!") {
  		return expression.o;
  	}

  	return {
  		t: PREFIX_OPERATOR,
  		s: "!",
  		o: parensIfNecessary(expression)
  	};
  }

  function mustache_readSection__combine(expressions) {
  	if (expressions.length === 1) {
  		return expressions[0];
  	}

  	return {
  		t: INFIX_OPERATOR,
  		s: "&&",
  		o: [parensIfNecessary(expressions[0]), parensIfNecessary(mustache_readSection__combine(expressions.slice(1)))]
  	};
  }

  function parensIfNecessary(expression) {
  	// TODO only wrap if necessary
  	return {
  		t: BRACKETED,
  		x: expression
  	};
  }

  var converters_readHtmlComment = readHtmlComment;
  var OPEN_COMMENT = "<!--",
      CLOSE_COMMENT = "-->";
  function readHtmlComment(parser) {
  	var start, content, remaining, endIndex, comment;

  	start = parser.pos;

  	if (!parser.matchString(OPEN_COMMENT)) {
  		return null;
  	}

  	remaining = parser.remaining();
  	endIndex = remaining.indexOf(CLOSE_COMMENT);

  	if (endIndex === -1) {
  		parser.error("Illegal HTML - expected closing comment sequence ('-->')");
  	}

  	content = remaining.substr(0, endIndex);
  	parser.pos += endIndex + 3;

  	comment = {
  		t: COMMENT,
  		c: content
  	};

  	if (parser.includeLinePositions) {
  		comment.p = parser.getLinePos(start);
  	}

  	return comment;
  }

  var booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;

  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
  booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
  voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;

  htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 };
  controlCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];
  entityPattern = new RegExp("&(#?(?:x[\\w\\d]+|\\d+|" + Object.keys(htmlEntities).join("|") + "));?", "g");

  function decodeCharacterReferences(html) {
  	return html.replace(entityPattern, function (match, entity) {
  		var code;

  		// Handle named entities
  		if (entity[0] !== "#") {
  			code = htmlEntities[entity];
  		} else if (entity[1] === "x") {
  			code = parseInt(entity.substring(2), 16);
  		} else {
  			code = parseInt(entity.substring(1), 10);
  		}

  		if (!code) {
  			return match;
  		}

  		return String.fromCharCode(validateCode(code));
  	});
  }

  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal
  // code points with alternatives in some cases - since we're bypassing that mechanism, we need
  // to replace them ourselves
  //
  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
  function validateCode(code) {
  	if (!code) {
  		return 65533;
  	}

  	// line feed becomes generic whitespace
  	if (code === 10) {
  		return 32;
  	}

  	// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
  	if (code < 128) {
  		return code;
  	}

  	// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
  	// to correct the mistake or we'll end up with missing  signs and so on
  	if (code <= 159) {
  		return controlCharacters[code - 128];
  	}

  	// basic multilingual plane
  	if (code < 55296) {
  		return code;
  	}

  	// UTF-16 surrogate halves
  	if (code <= 57343) {
  		return 65533;
  	}

  	// rest of the basic multilingual plane
  	if (code <= 65535) {
  		return code;
  	}

  	return 65533;
  }

  lessThan = /</g;
  greaterThan = />/g;
  amp = /&/g;

  function escapeHtml(str) {
  	return str.replace(amp, "&amp;").replace(lessThan, "&lt;").replace(greaterThan, "&gt;");
  }

  var leadingLinebreak = /^\s*\r?\n/,
      trailingLinebreak = /\r?\n\s*$/;

  var stripStandalones = function (items) {
  	var i, current, backOne, backTwo, lastSectionItem;

  	for (i = 1; i < items.length; i += 1) {
  		current = items[i];
  		backOne = items[i - 1];
  		backTwo = items[i - 2];

  		// if we're at the end of a [text][comment][text] sequence...
  		if (isString(current) && isComment(backOne) && isString(backTwo)) {

  			// ... and the comment is a standalone (i.e. line breaks either side)...
  			if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {

  				// ... then we want to remove the whitespace after the first line break
  				items[i - 2] = backTwo.replace(trailingLinebreak, "\n");

  				// and the leading line break of the second text token
  				items[i] = current.replace(leadingLinebreak, "");
  			}
  		}

  		// if the current item is a section, and it is preceded by a linebreak, and
  		// its first item is a linebreak...
  		if (isSection(current) && isString(backOne)) {
  			if (trailingLinebreak.test(backOne) && isString(current.f[0]) && leadingLinebreak.test(current.f[0])) {
  				items[i - 1] = backOne.replace(trailingLinebreak, "\n");
  				current.f[0] = current.f[0].replace(leadingLinebreak, "");
  			}
  		}

  		// if the last item was a section, and it is followed by a linebreak, and
  		// its last item is a linebreak...
  		if (isString(current) && isSection(backOne)) {
  			lastSectionItem = lastItem(backOne.f);

  			if (isString(lastSectionItem) && trailingLinebreak.test(lastSectionItem) && leadingLinebreak.test(current)) {
  				backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, "\n");
  				items[i] = current.replace(leadingLinebreak, "");
  			}
  		}
  	}

  	return items;
  };

  function isString(item) {
  	return typeof item === "string";
  }

  function isComment(item) {
  	return item.t === COMMENT || item.t === DELIMCHANGE;
  }

  function isSection(item) {
  	return (item.t === SECTION || item.t === INVERTED) && item.f;
  }

  var trimWhitespace = function (items, leadingPattern, trailingPattern) {
  	var item;

  	if (leadingPattern) {
  		item = items[0];
  		if (typeof item === "string") {
  			item = item.replace(leadingPattern, "");

  			if (!item) {
  				items.shift();
  			} else {
  				items[0] = item;
  			}
  		}
  	}

  	if (trailingPattern) {
  		item = lastItem(items);
  		if (typeof item === "string") {
  			item = item.replace(trailingPattern, "");

  			if (!item) {
  				items.pop();
  			} else {
  				items[items.length - 1] = item;
  			}
  		}
  	}
  };

  var utils_cleanup = cleanup;
  var contiguousWhitespace = /[ \t\f\r\n]+/g;
  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;
  var utils_cleanup__leadingWhitespace = /^[ \t\f\r\n]+/;
  var trailingWhitespace = /[ \t\f\r\n]+$/;
  var leadingNewLine = /^(?:\r\n|\r|\n)/;
  var trailingNewLine = /(?:\r\n|\r|\n)$/;
  function cleanup(items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace) {
  	var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, key;

  	// First pass - remove standalones and comments etc
  	stripStandalones(items);

  	i = items.length;
  	while (i--) {
  		item = items[i];

  		// Remove delimiter changes, unsafe elements etc
  		if (item.exclude) {
  			items.splice(i, 1);
  		}

  		// Remove comments, unless we want to keep them
  		else if (stripComments && item.t === COMMENT) {
  			items.splice(i, 1);
  		}
  	}

  	// If necessary, remove leading and trailing whitespace
  	trimWhitespace(items, removeLeadingWhitespace ? utils_cleanup__leadingWhitespace : null, removeTrailingWhitespace ? trailingWhitespace : null);

  	i = items.length;
  	while (i--) {
  		item = items[i];

  		// Recurse
  		if (item.f) {
  			var isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test(item.e);
  			preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;

  			if (!preserveWhitespace && isPreserveWhitespaceElement) {
  				trimWhitespace(item.f, leadingNewLine, trailingNewLine);
  			}

  			if (!preserveWhitespaceInsideFragment) {
  				previousItem = items[i - 1];
  				nextItem = items[i + 1];

  				// if the previous item was a text item with trailing whitespace,
  				// remove leading whitespace inside the fragment
  				if (!previousItem || typeof previousItem === "string" && trailingWhitespace.test(previousItem)) {
  					removeLeadingWhitespaceInsideFragment = true;
  				}

  				// and vice versa
  				if (!nextItem || typeof nextItem === "string" && utils_cleanup__leadingWhitespace.test(nextItem)) {
  					removeTrailingWhitespaceInsideFragment = true;
  				}
  			}

  			cleanup(item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  		}

  		// Split if-else blocks into two (an if, and an unless)
  		if (item.l) {
  			cleanup(item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);

  			items.splice(i + 1, 0, item.l);
  			delete item.l; // TODO would be nice if there was a way around this
  		}

  		// Clean up element attributes
  		if (item.a) {
  			for (key in item.a) {
  				if (item.a.hasOwnProperty(key) && typeof item.a[key] !== "string") {
  					cleanup(item.a[key], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  				}
  			}
  		}

  		// Clean up conditional attributes
  		if (item.m) {
  			cleanup(item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  		}

  		// Clean up event handlers
  		if (item.v) {
  			for (key in item.v) {
  				if (item.v.hasOwnProperty(key)) {
  					// clean up names
  					if (isArray(item.v[key].n)) {
  						cleanup(item.v[key].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  					}

  					// clean up params
  					if (isArray(item.v[key].d)) {
  						cleanup(item.v[key].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);
  					}
  				}
  			}
  		}
  	}

  	// final pass - fuse text nodes together
  	i = items.length;
  	while (i--) {
  		if (typeof items[i] === "string") {
  			if (typeof items[i + 1] === "string") {
  				items[i] = items[i] + items[i + 1];
  				items.splice(i + 1, 1);
  			}

  			if (!preserveWhitespace) {
  				items[i] = items[i].replace(contiguousWhitespace, " ");
  			}

  			if (items[i] === "") {
  				items.splice(i, 1);
  			}
  		}
  	}
  }

  var element_readClosingTag = readClosingTag;
  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
  function readClosingTag(parser) {
  	var start, tag;

  	start = parser.pos;

  	// are we looking at a closing tag?
  	if (!parser.matchString("</")) {
  		return null;
  	}

  	if (tag = parser.matchPattern(closingTagPattern)) {
  		if (parser.inside && tag !== parser.inside) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: CLOSING_TAG,
  			e: tag
  		};
  	}

  	// We have an illegal closing tag, report it
  	parser.pos -= 2;
  	parser.error("Illegal closing tag");
  }

  var getLowestIndex = function (haystack, needles) {
  	var i, index, lowest;

  	i = needles.length;
  	while (i--) {
  		index = haystack.indexOf(needles[i]);

  		// short circuit
  		if (!index) {
  			return 0;
  		}

  		if (index === -1) {
  			continue;
  		}

  		if (!lowest || index < lowest) {
  			lowest = index;
  		}
  	}

  	return lowest || -1;
  };

  var element_readAttribute = readAttribute;

  var attributeNamePattern = /^[^\s"'>\/=]+/,
      unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
  function readAttribute(parser) {
  	var attr, name, value;

  	parser.allowWhitespace();

  	name = parser.matchPattern(attributeNamePattern);
  	if (!name) {
  		return null;
  	}

  	attr = { name: name };

  	value = readAttributeValue(parser);
  	if (value != null) {
  		// not null/undefined
  		attr.value = value;
  	}

  	return attr;
  }

  function readAttributeValue(parser) {
  	var start, valueStart, startDepth, value;

  	start = parser.pos;

  	// next character must be `=`, `/`, `>` or whitespace
  	if (!/[=\/>\s]/.test(parser.nextChar())) {
  		parser.error("Expected `=`, `/`, `>` or whitespace");
  	}

  	parser.allowWhitespace();

  	if (!parser.matchString("=")) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	valueStart = parser.pos;
  	startDepth = parser.sectionDepth;

  	value = readQuotedAttributeValue(parser, "'") || readQuotedAttributeValue(parser, "\"") || readUnquotedAttributeValue(parser);

  	if (value === null) {
  		parser.error("Expected valid attribute value");
  	}

  	if (parser.sectionDepth !== startDepth) {
  		parser.pos = valueStart;
  		parser.error("An attribute value must contain as many opening section tags as closing section tags");
  	}

  	if (!value.length) {
  		return "";
  	}

  	if (value.length === 1 && typeof value[0] === "string") {
  		return decodeCharacterReferences(value[0]);
  	}

  	return value;
  }

  function readUnquotedAttributeValueToken(parser) {
  	var start, text, haystack, needles, index;

  	start = parser.pos;

  	text = parser.matchPattern(unquotedAttributeValueTextPattern);

  	if (!text) {
  		return null;
  	}

  	haystack = text;
  	needles = parser.tags.map(function (t) {
  		return t.open;
  	}); // TODO refactor... we do this in readText.js as well

  	if ((index = getLowestIndex(haystack, needles)) !== -1) {
  		text = text.substr(0, index);
  		parser.pos = start + text.length;
  	}

  	return text;
  }

  function readUnquotedAttributeValue(parser) {
  	var tokens, token;

  	parser.inAttribute = true;

  	tokens = [];

  	token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);
  	while (token !== null) {
  		tokens.push(token);
  		token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);
  	}

  	if (!tokens.length) {
  		return null;
  	}

  	parser.inAttribute = false;
  	return tokens;
  }

  function readQuotedAttributeValue(parser, quoteMark) {
  	var start, tokens, token;

  	start = parser.pos;

  	if (!parser.matchString(quoteMark)) {
  		return null;
  	}

  	parser.inAttribute = quoteMark;

  	tokens = [];

  	token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);
  	while (token !== null) {
  		tokens.push(token);
  		token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);
  	}

  	if (!parser.matchString(quoteMark)) {
  		parser.pos = start;
  		return null;
  	}

  	parser.inAttribute = false;

  	return tokens;
  }

  function readQuotedStringToken(parser, quoteMark) {
  	var start, index, haystack, needles;

  	start = parser.pos;
  	haystack = parser.remaining();

  	needles = parser.tags.map(function (t) {
  		return t.open;
  	}); // TODO refactor... we do this in readText.js as well
  	needles.push(quoteMark);

  	index = getLowestIndex(haystack, needles);

  	if (index === -1) {
  		parser.error("Quoted attribute value must have a closing quote");
  	}

  	if (!index) {
  		return null;
  	}

  	parser.pos += index;
  	return haystack.substr(0, index);
  }

  var JsonParser, specials, specialsPattern, parseJSON__numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;

  specials = {
  	"true": true,
  	"false": false,
  	undefined: undefined,
  	"null": null
  };

  specialsPattern = new RegExp("^(?:" + Object.keys(specials).join("|") + ")");
  parseJSON__numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
  placeholderPattern = /\$\{([^\}]+)\}/g;
  placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
  onlyWhitespace = /^\s*$/;

  JsonParser = parse_Parser.extend({
  	init: function (str, options) {
  		this.values = options.values;
  		this.allowWhitespace();
  	},

  	postProcess: function (result) {
  		if (result.length !== 1 || !onlyWhitespace.test(this.leftover)) {
  			return null;
  		}

  		return { value: result[0].v };
  	},

  	converters: [function getPlaceholder(parser) {
  		var placeholder;

  		if (!parser.values) {
  			return null;
  		}

  		placeholder = parser.matchPattern(placeholderAtStartPattern);

  		if (placeholder && parser.values.hasOwnProperty(placeholder)) {
  			return { v: parser.values[placeholder] };
  		}
  	}, function getSpecial(parser) {
  		var special;

  		if (special = parser.matchPattern(specialsPattern)) {
  			return { v: specials[special] };
  		}
  	}, function getNumber(parser) {
  		var number;

  		if (number = parser.matchPattern(parseJSON__numberPattern)) {
  			return { v: +number };
  		}
  	}, function getString(parser) {
  		var stringLiteral = readStringLiteral(parser),
  		    values;

  		if (stringLiteral && (values = parser.values)) {
  			return {
  				v: stringLiteral.v.replace(placeholderPattern, function (match, $1) {
  					return $1 in values ? values[$1] : $1;
  				})
  			};
  		}

  		return stringLiteral;
  	}, function getObject(parser) {
  		var result, pair;

  		if (!parser.matchString("{")) {
  			return null;
  		}

  		result = {};

  		parser.allowWhitespace();

  		if (parser.matchString("}")) {
  			return { v: result };
  		}

  		while (pair = getKeyValuePair(parser)) {
  			result[pair.key] = pair.value;

  			parser.allowWhitespace();

  			if (parser.matchString("}")) {
  				return { v: result };
  			}

  			if (!parser.matchString(",")) {
  				return null;
  			}
  		}

  		return null;
  	}, function getArray(parser) {
  		var result, valueToken;

  		if (!parser.matchString("[")) {
  			return null;
  		}

  		result = [];

  		parser.allowWhitespace();

  		if (parser.matchString("]")) {
  			return { v: result };
  		}

  		while (valueToken = parser.read()) {
  			result.push(valueToken.v);

  			parser.allowWhitespace();

  			if (parser.matchString("]")) {
  				return { v: result };
  			}

  			if (!parser.matchString(",")) {
  				return null;
  			}

  			parser.allowWhitespace();
  		}

  		return null;
  	}]
  });

  function getKeyValuePair(parser) {
  	var key, valueToken, pair;

  	parser.allowWhitespace();

  	key = shared_readKey(parser);

  	if (!key) {
  		return null;
  	}

  	pair = { key: key };

  	parser.allowWhitespace();
  	if (!parser.matchString(":")) {
  		return null;
  	}
  	parser.allowWhitespace();

  	valueToken = parser.read();
  	if (!valueToken) {
  		return null;
  	}

  	pair.value = valueToken.v;

  	return pair;
  }

  var parseJSON = function (str, values) {
  	var parser = new JsonParser(str, {
  		values: values
  	});

  	return parser.result;
  };

  // TODO clean this up, it's shocking
  var element_processDirective = processDirective;
  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(/,
      methodCallExcessPattern = /\)\s*$/,
      ExpressionParser;

  ExpressionParser = parse_Parser.extend({
  	converters: [converters_readExpression]
  });
  function processDirective(tokens, parentParser) {
  	var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;

  	if (typeof tokens === "string") {
  		if (match = methodCallPattern.exec(tokens)) {
  			var end = tokens.lastIndexOf(")");

  			// check for invalid method calls
  			if (!methodCallExcessPattern.test(tokens)) {
  				parentParser.error("Invalid input after method call expression '" + tokens.slice(end + 1) + "'");
  			}

  			result = { m: match[1] };
  			args = "[" + tokens.slice(result.m.length + 1, end) + "]";

  			parser = new ExpressionParser(args);
  			result.a = utils_flattenExpression(parser.result[0]);

  			return result;
  		}

  		if (tokens.indexOf(":") === -1) {
  			return tokens.trim();
  		}

  		tokens = [tokens];
  	}

  	result = {};

  	directiveName = [];
  	directiveArgs = [];

  	if (tokens) {
  		while (tokens.length) {
  			token = tokens.shift();

  			if (typeof token === "string") {
  				colonIndex = token.indexOf(":");

  				if (colonIndex === -1) {
  					directiveName.push(token);
  				} else {

  					// is the colon the first character?
  					if (colonIndex) {
  						// no
  						directiveName.push(token.substr(0, colonIndex));
  					}

  					// if there is anything after the colon in this token, treat
  					// it as the first token of the directiveArgs fragment
  					if (token.length > colonIndex + 1) {
  						directiveArgs[0] = token.substring(colonIndex + 1);
  					}

  					break;
  				}
  			} else {
  				directiveName.push(token);
  			}
  		}

  		directiveArgs = directiveArgs.concat(tokens);
  	}

  	if (!directiveName.length) {
  		result = "";
  	} else if (directiveArgs.length || typeof directiveName !== "string") {
  		result = {
  			// TODO is this really necessary? just use the array
  			n: directiveName.length === 1 && typeof directiveName[0] === "string" ? directiveName[0] : directiveName
  		};

  		if (directiveArgs.length === 1 && typeof directiveArgs[0] === "string") {
  			parsed = parseJSON("[" + directiveArgs[0] + "]");
  			result.a = parsed ? parsed.value : directiveArgs[0].trim();
  		} else {
  			result.d = directiveArgs;
  		}
  	} else {
  		result = directiveName;
  	}

  	return result;
  }

  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
      validTagNameFollower = /^[\s\n\/>]/,
      onPattern = /^on/,
      proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/,
      reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,
      directives = { "intro-outro": "t0", intro: "t1", outro: "t2", decorator: "o" },
      exclude = { exclude: true },
      disallowedContents;

  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
  disallowedContents = {
  	li: ["li"],
  	dt: ["dt", "dd"],
  	dd: ["dt", "dd"],
  	p: "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "),
  	rt: ["rt", "rp"],
  	rp: ["rt", "rp"],
  	optgroup: ["optgroup"],
  	option: ["option", "optgroup"],
  	thead: ["tbody", "tfoot"],
  	tbody: ["tbody", "tfoot"],
  	tfoot: ["tbody"],
  	tr: ["tr", "tbody"],
  	td: ["td", "th", "tr"],
  	th: ["td", "th", "tr"]
  };

  var converters_readElement = readElement;

  function readElement(parser) {
  	var start, element, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag;

  	start = parser.pos;

  	if (parser.inside || parser.inAttribute) {
  		return null;
  	}

  	if (!parser.matchString("<")) {
  		return null;
  	}

  	// if this is a closing tag, abort straight away
  	if (parser.nextChar() === "/") {
  		return null;
  	}

  	element = {};
  	if (parser.includeLinePositions) {
  		element.p = parser.getLinePos(start);
  	}

  	if (parser.matchString("!")) {
  		element.t = DOCTYPE;
  		if (!parser.matchPattern(/^doctype/i)) {
  			parser.error("Expected DOCTYPE declaration");
  		}

  		element.a = parser.matchPattern(/^(.+?)>/);
  		return element;
  	}

  	element.t = ELEMENT;

  	// element name
  	element.e = parser.matchPattern(tagNamePattern);
  	if (!element.e) {
  		return null;
  	}

  	// next character must be whitespace, closing solidus or '>'
  	if (!validTagNameFollower.test(parser.nextChar())) {
  		parser.error("Illegal tag name");
  	}

  	addProxyEvent = function (name, directive) {
  		var directiveName = directive.n || directive;

  		if (reservedEventNames.test(directiveName)) {
  			parser.pos -= directiveName.length;
  			parser.error("Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)");
  		}

  		element.v[name] = directive;
  	};

  	parser.allowWhitespace();

  	// directives and attributes
  	while (attribute = converters_readMustache(parser) || element_readAttribute(parser)) {
  		// regular attributes
  		if (attribute.name) {
  			// intro, outro, decorator
  			if (directiveName = directives[attribute.name]) {
  				element[directiveName] = element_processDirective(attribute.value, parser);
  			}

  			// on-click etc
  			else if (match = proxyEventPattern.exec(attribute.name)) {
  				if (!element.v) element.v = {};
  				directive = element_processDirective(attribute.value, parser);
  				addProxyEvent(match[1], directive);
  			} else {
  				if (!parser.sanitizeEventAttributes || !onPattern.test(attribute.name)) {
  					if (!element.a) element.a = {};
  					element.a[attribute.name] = attribute.value || (attribute.value === "" ? "" : 0);
  				}
  			}
  		}

  		// {{#if foo}}class='foo'{{/if}}
  		else {
  			if (!element.m) element.m = [];
  			element.m.push(attribute);
  		}

  		parser.allowWhitespace();
  	}

  	// allow whitespace before closing solidus
  	parser.allowWhitespace();

  	// self-closing solidus?
  	if (parser.matchString("/")) {
  		selfClosing = true;
  	}

  	// closing angle bracket
  	if (!parser.matchString(">")) {
  		return null;
  	}

  	var lowerCaseName = element.e.toLowerCase();
  	var preserveWhitespace = parser.preserveWhitespace;

  	if (!selfClosing && !voidElementNames.test(element.e)) {
  		parser.elementStack.push(lowerCaseName);

  		// Special case - if we open a script element, further tags should
  		// be ignored unless they're a closing script element
  		if (lowerCaseName === "script" || lowerCaseName === "style") {
  			parser.inside = lowerCaseName;
  		}

  		children = [];
  		partials = create(null);

  		do {
  			pos = parser.pos;
  			remaining = parser.remaining();

  			// if for example we're in an <li> element, and we see another
  			// <li> tag, close the first so they become siblings
  			if (!canContain(lowerCaseName, remaining)) {
  				closed = true;
  			}

  			// closing tag
  			else if (closingTag = element_readClosingTag(parser)) {
  				closed = true;

  				var closingTagName = closingTag.e.toLowerCase();

  				// if this *isn't* the closing tag for the current element...
  				if (closingTagName !== lowerCaseName) {
  					// rewind parser
  					parser.pos = pos;

  					// if it doesn't close a parent tag, error
  					if (! ~parser.elementStack.indexOf(closingTagName)) {
  						var errorMessage = "Unexpected closing tag";

  						// add additional help for void elements, since component names
  						// might clash with them
  						if (voidElementNames.test(closingTagName)) {
  							errorMessage += " (<" + closingTagName + "> is a void element - it cannot contain children)";
  						}

  						parser.error(errorMessage);
  					}
  				}
  			}

  			// implicit close by closing section tag. TODO clean this up
  			else if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {
  				closed = true;
  				parser.pos = pos;
  			} else {
  				if (child = parser.read(PARTIAL_READERS)) {
  					if (partials[child.n]) {
  						parser.pos = pos;
  						parser.error("Duplicate partial definition");
  					}

  					utils_cleanup(child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);

  					partials[child.n] = child.f;
  					hasPartials = true;
  				} else {
  					if (child = parser.read(READERS)) {
  						children.push(child);
  					} else {
  						closed = true;
  					}
  				}
  			}
  		} while (!closed);

  		if (children.length) {
  			element.f = children;
  		}

  		if (hasPartials) {
  			element.p = partials;
  		}

  		parser.elementStack.pop();
  	}

  	parser.inside = null;

  	if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {
  		return exclude;
  	}

  	return element;
  }

  function canContain(name, remaining) {
  	var match, disallowed;

  	match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);
  	disallowed = disallowedContents[name];

  	if (!match || !disallowed) {
  		return true;
  	}

  	return ! ~disallowed.indexOf(match[1].toLowerCase());
  }

  var converters_readText = readText;
  function readText(parser) {
  	var index, remaining, disallowed, barrier;

  	remaining = parser.remaining();

  	barrier = parser.inside ? "</" + parser.inside : "<";

  	if (parser.inside && !parser.interpolate[parser.inside]) {
  		index = remaining.indexOf(barrier);
  	} else {
  		disallowed = parser.tags.map(function (t) {
  			return t.open;
  		});
  		disallowed = disallowed.concat(parser.tags.map(function (t) {
  			return "\\" + t.open;
  		}));

  		// http://developers.whatwg.org/syntax.html#syntax-attributes
  		if (parser.inAttribute === true) {
  			// we're inside an unquoted attribute value
  			disallowed.push("\"", "'", "=", "<", ">", "`");
  		} else if (parser.inAttribute) {
  			// quoted attribute value
  			disallowed.push(parser.inAttribute);
  		} else {
  			disallowed.push(barrier);
  		}

  		index = getLowestIndex(remaining, disallowed);
  	}

  	if (!index) {
  		return null;
  	}

  	if (index === -1) {
  		index = remaining.length;
  	}

  	parser.pos += index;

  	return parser.inside ? remaining.substr(0, index) : decodeCharacterReferences(remaining.substr(0, index));
  }

  var utils_escapeRegExp = escapeRegExp;
  var utils_escapeRegExp__pattern = /[-/\\^$*+?.()|[\]{}]/g;
  function escapeRegExp(str) {
  	return str.replace(utils_escapeRegExp__pattern, "\\$&");
  }

  var converters_readPartialDefinitionComment = readPartialDefinitionComment;

  var startPattern = /^<!--\s*/,
      namePattern = /s*>\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\s*/,
      finishPattern = /\s*-->/,
      child;

  function readPartialDefinitionComment(parser) {
  	var firstPos = parser.pos,
  	    open = parser.standardDelimiters[0],
  	    close = parser.standardDelimiters[1],
  	    content = undefined,
  	    closed = undefined;

  	if (!parser.matchPattern(startPattern) || !parser.matchString(open)) {
  		parser.pos = firstPos;
  		return null;
  	}

  	var name = parser.matchPattern(namePattern);

  	warnOnceIfDebug("Inline partial comments are deprecated.\nUse this...\n  {{#partial " + name + "}} ... {{/partial}}\n\n...instead of this:\n  <!-- {{>" + name + "}} --> ... <!-- {{/" + name + "}} -->'");

  	// make sure the rest of the comment is in the correct place
  	if (!parser.matchString(close) || !parser.matchPattern(finishPattern)) {
  		parser.pos = firstPos;
  		return null;
  	}

  	content = [];

  	var endPattern = new RegExp("^<!--\\s*" + utils_escapeRegExp(open) + "\\s*\\/\\s*" + name + "\\s*" + utils_escapeRegExp(close) + "\\s*-->");

  	do {
  		if (parser.matchPattern(endPattern)) {
  			closed = true;
  		} else {
  			child = parser.read(READERS);
  			if (!child) {
  				parser.error("expected closing comment ('<!-- " + open + "/" + name + "" + close + " -->')");
  			}

  			content.push(child);
  		}
  	} while (!closed);

  	return {
  		t: INLINE_PARTIAL,
  		f: content,
  		n: name
  	};
  }

  var converters_readPartialDefinitionSection = readPartialDefinitionSection;
  var partialDefinitionSectionPattern = /^#\s*partial\s+/;
  function readPartialDefinitionSection(parser) {
  	var start, name, content, child, closed;

  	start = parser.pos;

  	var delimiters = parser.standardDelimiters;

  	if (!parser.matchString(delimiters[0])) {
  		return null;
  	}

  	if (!parser.matchPattern(partialDefinitionSectionPattern)) {
  		parser.pos = start;
  		return null;
  	}

  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\-]*/);

  	if (!name) {
  		parser.error("expected legal partial name");
  	}

  	if (!parser.matchString(delimiters[1])) {
  		parser.error("Expected closing delimiter '" + delimiters[1] + "'");
  	}

  	content = [];

  	do {
  		// TODO clean this up
  		if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {
  			if (!child.r === "partial") {
  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);
  			}

  			closed = true;
  		} else {
  			child = parser.read(READERS);

  			if (!child) {
  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);
  			}

  			content.push(child);
  		}
  	} while (!closed);

  	return {
  		t: INLINE_PARTIAL,
  		n: name,
  		f: content
  	};
  }

  var converters_readTemplate = readTemplate;
  function readTemplate(parser) {
  	var fragment = [];
  	var partials = create(null);
  	var hasPartials = false;

  	var preserveWhitespace = parser.preserveWhitespace;

  	while (parser.pos < parser.str.length) {
  		var pos = parser.pos,
  		    item = undefined,
  		    partial = undefined;

  		if (partial = parser.read(PARTIAL_READERS)) {
  			if (partials[partial.n]) {
  				parser.pos = pos;
  				parser.error("Duplicated partial definition");
  			}

  			utils_cleanup(partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);

  			partials[partial.n] = partial.f;
  			hasPartials = true;
  		} else if (item = parser.read(READERS)) {
  			fragment.push(item);
  		} else {
  			parser.error("Unexpected template content");
  		}
  	}

  	var result = {
  		v: TEMPLATE_VERSION,
  		t: fragment
  	};

  	if (hasPartials) {
  		result.p = partials;
  	}

  	return result;
  }

  var _parse = parse;

  var STANDARD_READERS = [mustache_readPartial, mustache_readUnescaped, mustache_readSection, mustache_readYielder, mustache_readInterpolator, readMustacheComment];
  var TRIPLE_READERS = [mustache_readTriple];
  var STATIC_READERS = [mustache_readUnescaped, mustache_readSection, mustache_readInterpolator]; // TODO does it make sense to have a static section?

  var StandardParser = undefined;
  function parse(template, options) {
  	return new StandardParser(template, options || {}).result;
  }

  var READERS = [converters_readMustache, converters_readHtmlComment, converters_readElement, converters_readText];
  var PARTIAL_READERS = [converters_readPartialDefinitionComment, converters_readPartialDefinitionSection];

  StandardParser = parse_Parser.extend({
  	init: function (str, options) {
  		var tripleDelimiters = options.tripleDelimiters || ["{{{", "}}}"],
  		    staticDelimiters = options.staticDelimiters || ["[[", "]]"],
  		    staticTripleDelimiters = options.staticTripleDelimiters || ["[[[", "]]]"];

  		this.standardDelimiters = options.delimiters || ["{{", "}}"];

  		this.tags = [{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS }, { isStatic: false, isTriple: true, open: tripleDelimiters[0], close: tripleDelimiters[1], readers: TRIPLE_READERS }, { isStatic: true, isTriple: false, open: staticDelimiters[0], close: staticDelimiters[1], readers: STATIC_READERS }, { isStatic: true, isTriple: true, open: staticTripleDelimiters[0], close: staticTripleDelimiters[1], readers: TRIPLE_READERS }];

  		this.sortMustacheTags();

  		this.sectionDepth = 0;
  		this.elementStack = [];

  		this.interpolate = {
  			script: !options.interpolate || options.interpolate.script !== false,
  			style: !options.interpolate || options.interpolate.style !== false
  		};

  		if (options.sanitize === true) {
  			options.sanitize = {
  				// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
  				elements: "applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title".split(" "),
  				eventAttributes: true
  			};
  		}

  		this.stripComments = options.stripComments !== false;
  		this.preserveWhitespace = options.preserveWhitespace;
  		this.sanitizeElements = options.sanitize && options.sanitize.elements;
  		this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
  		this.includeLinePositions = options.includeLinePositions;
  	},

  	postProcess: function (result) {
  		// special case - empty string
  		if (!result.length) {
  			return { t: [], v: TEMPLATE_VERSION };
  		}

  		if (this.sectionDepth > 0) {
  			this.error("A section was left open");
  		}

  		utils_cleanup(result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace);

  		return result[0];
  	},

  	converters: [converters_readTemplate],

  	sortMustacheTags: function () {
  		// Sort in order of descending opening delimiter length (longer first),
  		// to protect against opening delimiters being substrings of each other
  		this.tags.sort(function (a, b) {
  			return b.open.length - a.open.length;
  		});
  	}
  });

  var parseOptions = ["preserveWhitespace", "sanitize", "stripComments", "delimiters", "tripleDelimiters", "interpolate"];

  var parser = {
  	fromId: fromId, isHashedId: isHashedId, isParsed: isParsed, getParseOptions: getParseOptions, createHelper: template_parser__createHelper,
  	parse: doParse
  };

  function template_parser__createHelper(parseOptions) {
  	var helper = create(parser);
  	helper.parse = function (template, options) {
  		return doParse(template, options || parseOptions);
  	};
  	return helper;
  }

  function doParse(template, parseOptions) {
  	if (!_parse) {
  		throw new Error("Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser");
  	}

  	return _parse(template, parseOptions || this.options);
  }

  function fromId(id, options) {
  	var template;

  	if (!isClient) {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Cannot retrieve template #" + id + " as Ractive is not running in a browser.");
  	}

  	if (isHashedId(id)) {
  		id = id.substring(1);
  	}

  	if (!(template = document.getElementById(id))) {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Could not find template element with id #" + id);
  	}

  	if (template.tagName.toUpperCase() !== "SCRIPT") {
  		if (options && options.noThrow) {
  			return;
  		}
  		throw new Error("Template element with id #" + id + ", must be a <script> element");
  	}

  	return "textContent" in template ? template.textContent : template.innerHTML;
  }

  function isHashedId(id) {
  	return id && id[0] === "#";
  }

  function isParsed(template) {
  	return !(typeof template === "string");
  }

  function getParseOptions(ractive) {
  	// Could be Ractive or a Component
  	if (ractive.defaults) {
  		ractive = ractive.defaults;
  	}

  	return parseOptions.reduce(function (val, key) {
  		val[key] = ractive[key];
  		return val;
  	}, {});
  }

  var template_parser = parser;

  var templateConfigurator = {
  	name: "template",

  	extend: function extend(Parent, proto, options) {
  		var template;

  		// only assign if exists
  		if ("template" in options) {
  			template = options.template;

  			if (typeof template === "function") {
  				proto.template = template;
  			} else {
  				proto.template = parseIfString(template, proto);
  			}
  		}
  	},

  	init: function init(Parent, ractive, options) {
  		var template, fn;

  		// TODO because of prototypal inheritance, we might just be able to use
  		// ractive.template, and not bother passing through the Parent object.
  		// At present that breaks the test mocks' expectations
  		template = "template" in options ? options.template : Parent.prototype.template;

  		if (typeof template === "function") {
  			fn = template;
  			template = getDynamicTemplate(ractive, fn);

  			ractive._config.template = {
  				fn: fn,
  				result: template
  			};
  		}

  		template = parseIfString(template, ractive);

  		// TODO the naming of this is confusing - ractive.template refers to [...],
  		// but Component.prototype.template refers to {v:1,t:[],p:[]}...
  		// it's unnecessary, because the developer never needs to access
  		// ractive.template
  		ractive.template = template.t;

  		if (template.p) {
  			extendPartials(ractive.partials, template.p);
  		}
  	},

  	reset: function (ractive) {
  		var result = resetValue(ractive),
  		    parsed;

  		if (result) {
  			parsed = parseIfString(result, ractive);

  			ractive.template = parsed.t;
  			extendPartials(ractive.partials, parsed.p, true);

  			return true;
  		}
  	}
  };

  function resetValue(ractive) {
  	var initial = ractive._config.template,
  	    result;

  	// If this isn't a dynamic template, there's nothing to do
  	if (!initial || !initial.fn) {
  		return;
  	}

  	result = getDynamicTemplate(ractive, initial.fn);

  	// TODO deep equality check to prevent unnecessary re-rendering
  	// in the case of already-parsed templates
  	if (result !== initial.result) {
  		initial.result = result;
  		result = parseIfString(result, ractive);
  		return result;
  	}
  }

  function getDynamicTemplate(ractive, fn) {
  	var helper = template_template__createHelper(template_parser.getParseOptions(ractive));
  	return fn.call(ractive, helper);
  }

  function template_template__createHelper(parseOptions) {
  	var helper = create(template_parser);
  	helper.parse = function (template, options) {
  		return template_parser.parse(template, options || parseOptions);
  	};
  	return helper;
  }

  function parseIfString(template, ractive) {
  	if (typeof template === "string") {
  		// ID of an element containing the template?
  		if (template[0] === "#") {
  			template = template_parser.fromId(template);
  		}

  		template = _parse(template, template_parser.getParseOptions(ractive));
  	}

  	// Check that the template even exists
  	else if (template == undefined) {
  		throw new Error("The template cannot be " + template + ".");
  	}

  	// Check the parsed template has a version at all
  	else if (typeof template.v !== "number") {
  		throw new Error("The template parser was passed a non-string template, but the template doesn't have a version.  Make sure you're passing in the template you think you are.");
  	}

  	// Check we're using the correct version
  	else if (template.v !== TEMPLATE_VERSION) {
  		throw new Error("Mismatched template version (expected " + TEMPLATE_VERSION + ", got " + template.v + ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app");
  	}

  	return template;
  }

  function extendPartials(existingPartials, newPartials, overwrite) {
  	if (!newPartials) return;

  	// TODO there's an ambiguity here - we need to overwrite in the `reset()`
  	// case, but not initially...

  	for (var key in newPartials) {
  		if (overwrite || !existingPartials.hasOwnProperty(key)) {
  			existingPartials[key] = newPartials[key];
  		}
  	}
  }

  var template_template = templateConfigurator;

  var config_registries__registryNames, Registry, registries;

  config_registries__registryNames = ["adaptors", "components", "computed", "decorators", "easing", "events", "interpolators", "partials", "transitions"];

  Registry = function (name, useDefaults) {
  	this.name = name;
  	this.useDefaults = useDefaults;
  };

  Registry.prototype = {
  	constructor: Registry,

  	extend: function (Parent, proto, options) {
  		this.configure(this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options);
  	},

  	init: function () {},

  	configure: function (Parent, target, options) {
  		var name = this.name,
  		    option = options[name],
  		    registry;

  		registry = create(Parent[name]);

  		for (var key in option) {
  			registry[key] = option[key];
  		}

  		target[name] = registry;
  	},

  	reset: function (ractive) {
  		var registry = ractive[this.name];
  		var changed = false;
  		Object.keys(registry).forEach(function (key) {
  			var item = registry[key];
  			if (item._fn) {
  				if (item._fn.isOwner) {
  					registry[key] = item._fn;
  				} else {
  					delete registry[key];
  				}
  				changed = true;
  			}
  		});
  		return changed;
  	}
  };

  registries = config_registries__registryNames.map(function (name) {
  	return new Registry(name, name === "computed");
  });

  var config_registries = registries;

  /*this.configure(
  	this.useDefaults ? Parent.defaults : Parent,
  	ractive,
  	options );*/

  var wrapPrototype = wrap;

  function wrap(parent, name, method) {
  	if (!/_super/.test(method)) {
  		return method;
  	}

  	var wrapper = function wrapSuper() {
  		var superMethod = getSuperMethod(wrapper._parent, name),
  		    hasSuper = ("_super" in this),
  		    oldSuper = this._super,
  		    result;

  		this._super = superMethod;

  		result = method.apply(this, arguments);

  		if (hasSuper) {
  			this._super = oldSuper;
  		} else {
  			delete this._super;
  		}

  		return result;
  	};

  	wrapper._parent = parent;
  	wrapper._method = method;

  	return wrapper;
  }

  function getSuperMethod(parent, name) {
  	var value, method;

  	if (name in parent) {
  		value = parent[name];

  		if (typeof value === "function") {
  			method = value;
  		} else {
  			method = function returnValue() {
  				return value;
  			};
  		}
  	} else {
  		method = noop;
  	}

  	return method;
  }

  var config_deprecate = deprecate;
  function getMessage(deprecated, correct, isError) {
  	return "options." + deprecated + " has been deprecated in favour of options." + correct + "." + (isError ? " You cannot specify both options, please use options." + correct + "." : "");
  }

  function deprecateOption(options, deprecatedOption, correct) {
  	if (deprecatedOption in options) {
  		if (!(correct in options)) {
  			warnIfDebug(getMessage(deprecatedOption, correct));
  			options[correct] = options[deprecatedOption];
  		} else {
  			throw new Error(getMessage(deprecatedOption, correct, true));
  		}
  	}
  }
  function deprecate(options) {
  	deprecateOption(options, "beforeInit", "onconstruct");
  	deprecateOption(options, "init", "onrender");
  	deprecateOption(options, "complete", "oncomplete");
  	deprecateOption(options, "eventDefinitions", "events");

  	// Using extend with Component instead of options,
  	// like Human.extend( Spider ) means adaptors as a registry
  	// gets copied to options. So we have to check if actually an array
  	if (isArray(options.adaptors)) {
  		deprecateOption(options, "adaptors", "adapt");
  	}
  }

  var config, order, defaultKeys, custom, isBlacklisted, isStandardKey;

  custom = {
  	adapt: custom_adapt,
  	css: css_css,
  	data: custom_data,
  	template: template_template
  };

  defaultKeys = Object.keys(config_defaults);

  isStandardKey = makeObj(defaultKeys.filter(function (key) {
  	return !custom[key];
  }));

  // blacklisted keys that we don't double extend
  isBlacklisted = makeObj(defaultKeys.concat(config_registries.map(function (r) {
  	return r.name;
  })));

  order = [].concat(defaultKeys.filter(function (key) {
  	return !config_registries[key] && !custom[key];
  }), config_registries, custom.data, custom.template, custom.css);

  config = {
  	extend: function (Parent, proto, options) {
  		return configure("extend", Parent, proto, options);
  	},

  	init: function (Parent, ractive, options) {
  		return configure("init", Parent, ractive, options);
  	},

  	reset: function (ractive) {
  		return order.filter(function (c) {
  			return c.reset && c.reset(ractive);
  		}).map(function (c) {
  			return c.name;
  		});
  	},

  	// this defines the order. TODO this isn't used anywhere in the codebase,
  	// only in the test suite - should get rid of it
  	order: order };

  function configure(method, Parent, target, options) {
  	config_deprecate(options);

  	for (var key in options) {
  		if (isStandardKey.hasOwnProperty(key)) {
  			var value = options[key];

  			// warn the developer if they passed a function and ignore its value

  			// NOTE: we allow some functions on "el" because we duck type element lists
  			// and some libraries or ef'ed-up virtual browsers (phantomJS) return a
  			// function object as the result of querySelector methods
  			if (key !== "el" && typeof value === "function") {
  				warnIfDebug("" + key + " is a Ractive option that does not expect a function and will be ignored", method === "init" ? target : null);
  			} else {
  				target[key] = value;
  			}
  		}
  	}

  	config_registries.forEach(function (registry) {
  		registry[method](Parent, target, options);
  	});

  	custom_adapt[method](Parent, target, options);
  	template_template[method](Parent, target, options);
  	css_css[method](Parent, target, options);

  	extendOtherMethods(Parent.prototype, target, options);
  }

  function extendOtherMethods(parent, target, options) {
  	for (var key in options) {
  		if (!isBlacklisted[key] && options.hasOwnProperty(key)) {
  			var member = options[key];

  			// if this is a method that overwrites a method, wrap it:
  			if (typeof member === "function") {
  				member = wrapPrototype(parent, key, member);
  			}

  			target[key] = member;
  		}
  	}
  }

  function makeObj(array) {
  	var obj = {};
  	array.forEach(function (x) {
  		return obj[x] = true;
  	});
  	return obj;
  }

  var config_config = config;

  var prototype_bubble = Fragment$bubble;

  function Fragment$bubble() {
  	this.dirtyValue = this.dirtyArgs = true;

  	if (this.bound && typeof this.owner.bubble === "function") {
  		this.owner.bubble();
  	}
  }

  var Fragment_prototype_detach = Fragment$detach;

  function Fragment$detach() {
  	var docFrag;

  	if (this.items.length === 1) {
  		return this.items[0].detach();
  	}

  	docFrag = document.createDocumentFragment();

  	this.items.forEach(function (item) {
  		var node = item.detach();

  		// TODO The if {...} wasn't previously required - it is now, because we're
  		// forcibly detaching everything to reorder sections after an update. That's
  		// a non-ideal brute force approach, implemented to get all the tests to pass
  		// - as soon as it's replaced with something more elegant, this should
  		// revert to `docFrag.appendChild( item.detach() )`
  		if (node) {
  			docFrag.appendChild(node);
  		}
  	});

  	return docFrag;
  }

  var Fragment_prototype_find = Fragment$find;

  function Fragment$find(selector) {
  	var i, len, item, queryResult;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.find && (queryResult = item.find(selector))) {
  				return queryResult;
  			}
  		}

  		return null;
  	}
  }

  var Fragment_prototype_findAll = Fragment$findAll;

  function Fragment$findAll(selector, query) {
  	var i, len, item;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findAll) {
  				item.findAll(selector, query);
  			}
  		}
  	}

  	return query;
  }

  var Fragment_prototype_findAllComponents = Fragment$findAllComponents;

  function Fragment$findAllComponents(selector, query) {
  	var i, len, item;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findAllComponents) {
  				item.findAllComponents(selector, query);
  			}
  		}
  	}

  	return query;
  }

  var Fragment_prototype_findComponent = Fragment$findComponent;

  function Fragment$findComponent(selector) {
  	var len, i, item, queryResult;

  	if (this.items) {
  		len = this.items.length;
  		for (i = 0; i < len; i += 1) {
  			item = this.items[i];

  			if (item.findComponent && (queryResult = item.findComponent(selector))) {
  				return queryResult;
  			}
  		}

  		return null;
  	}
  }

  var prototype_findNextNode = Fragment$findNextNode;

  function Fragment$findNextNode(item) {
  	var index = item.index,
  	    node;

  	if (this.items[index + 1]) {
  		node = this.items[index + 1].firstNode();
  	}

  	// if this is the root fragment, and there are no more items,
  	// it means we're at the end...
  	else if (this.owner === this.root) {
  		if (!this.owner.component) {
  			// TODO but something else could have been appended to
  			// this.root.el, no?
  			node = null;
  		}

  		// ...unless this is a component
  		else {
  			node = this.owner.component.findNextNode();
  		}
  	} else {
  		node = this.owner.findNextNode(this);
  	}

  	return node;
  }

  var prototype_firstNode = Fragment$firstNode;

  function Fragment$firstNode() {
  	if (this.items && this.items[0]) {
  		return this.items[0].firstNode();
  	}

  	return null;
  }

  var shared_processItems = processItems;

  function processItems(items, values, guid, counter) {
  	counter = counter || 0;

  	return items.map(function (item) {
  		var placeholderId, wrapped, value;

  		if (item.text) {
  			return item.text;
  		}

  		if (item.fragments) {
  			return item.fragments.map(function (fragment) {
  				return processItems(fragment.items, values, guid, counter);
  			}).join("");
  		}

  		placeholderId = guid + "-" + counter++;

  		if (item.keypath && (wrapped = item.root.viewmodel.wrapped[item.keypath.str])) {
  			value = wrapped.value;
  		} else {
  			value = item.getValue();
  		}

  		values[placeholderId] = value;

  		return "${" + placeholderId + "}";
  	}).join("");
  }

  var getArgsList = Fragment$getArgsList;
  function Fragment$getArgsList() {
  	var values, source, parsed, result;

  	if (this.dirtyArgs) {
  		source = shared_processItems(this.items, values = {}, this.root._guid);
  		parsed = parseJSON("[" + source + "]", values);

  		if (!parsed) {
  			result = [this.toString()];
  		} else {
  			result = parsed.value;
  		}

  		this.argsList = result;
  		this.dirtyArgs = false;
  	}

  	return this.argsList;
  }

  var getNode = Fragment$getNode;

  function Fragment$getNode() {
  	var fragment = this;

  	do {
  		if (fragment.pElement) {
  			return fragment.pElement.node;
  		}
  	} while (fragment = fragment.parent);

  	return this.root.detached || this.root.el;
  }

  var prototype_getValue = Fragment$getValue;
  function Fragment$getValue() {
  	var values, source, parsed, result;

  	if (this.dirtyValue) {
  		source = shared_processItems(this.items, values = {}, this.root._guid);
  		parsed = parseJSON(source, values);

  		if (!parsed) {
  			result = this.toString();
  		} else {
  			result = parsed.value;
  		}

  		this.value = result;
  		this.dirtyValue = false;
  	}

  	return this.value;
  }

  var shared_detach = function () {
  	return detachNode(this.node);
  };

  var Text = function (options) {
  	this.type = TEXT;
  	this.text = options.template;
  };

  Text.prototype = {
  	detach: shared_detach,

  	firstNode: function () {
  		return this.node;
  	},

  	render: function () {
  		if (!this.node) {
  			this.node = document.createTextNode(this.text);
  		}

  		return this.node;
  	},

  	toString: function (escape) {
  		return escape ? escapeHtml(this.text) : this.text;
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			return this.detach();
  		}
  	}
  };

  var items_Text = Text;

  var shared_unbind = shared_unbind__unbind;

  function shared_unbind__unbind() {
  	if (this.registered) {
  		// this was registered as a dependant
  		this.root.viewmodel.unregister(this.keypath, this);
  	}

  	if (this.resolver) {
  		this.resolver.unbind();
  	}
  }

  var Mustache_getValue = Mustache$getValue;

  function Mustache$getValue() {
  	return this.value;
  }

  var ReferenceResolver = function (owner, ref, callback) {
  	var keypath;

  	this.ref = ref;
  	this.resolved = false;

  	this.root = owner.root;
  	this.parentFragment = owner.parentFragment;
  	this.callback = callback;

  	keypath = shared_resolveRef(owner.root, ref, owner.parentFragment);
  	if (keypath != undefined) {
  		this.resolve(keypath);
  	} else {
  		global_runloop.addUnresolved(this);
  	}
  };

  ReferenceResolver.prototype = {
  	resolve: function (keypath) {
  		if (this.keypath && !keypath) {
  			// it was resolved, and now it's not. Can happen if e.g. `bar` in
  			// `{{foo[bar]}}` becomes undefined
  			global_runloop.addUnresolved(this);
  		}

  		this.resolved = true;

  		this.keypath = keypath;
  		this.callback(keypath);
  	},

  	forceResolution: function () {
  		this.resolve(getKeypath(this.ref));
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		var keypath;

  		if (this.keypath != undefined) {
  			keypath = this.keypath.replace(oldKeypath, newKeypath);
  			// was a new keypath created?
  			if (keypath !== undefined) {
  				// resolve it
  				this.resolve(keypath);
  			}
  		}
  	},

  	unbind: function () {
  		if (!this.resolved) {
  			global_runloop.removeUnresolved(this);
  		}
  	}
  };

  var Resolvers_ReferenceResolver = ReferenceResolver;

  var SpecialResolver = function (owner, ref, callback) {
  	this.parentFragment = owner.parentFragment;
  	this.ref = ref;
  	this.callback = callback;

  	this.rebind();
  };

  var props = {
  	"@keypath": { prefix: "c", prop: ["context"] },
  	"@index": { prefix: "i", prop: ["index"] },
  	"@key": { prefix: "k", prop: ["key", "index"] }
  };

  function getProp(target, prop) {
  	var value;
  	for (var i = 0; i < prop.prop.length; i++) {
  		if ((value = target[prop.prop[i]]) !== undefined) {
  			return value;
  		}
  	}
  }

  SpecialResolver.prototype = {
  	rebind: function () {
  		var ref = this.ref,
  		    fragment = this.parentFragment,
  		    prop = props[ref],
  		    value;

  		if (!prop) {
  			throw new Error("Unknown special reference \"" + ref + "\" - valid references are @index, @key and @keypath");
  		}

  		// have we already found the nearest parent?
  		if (this.cached) {
  			return this.callback(getKeypath("@" + prop.prefix + getProp(this.cached, prop)));
  		}

  		// special case for indices, which may cross component boundaries
  		if (prop.prop.indexOf("index") !== -1 || prop.prop.indexOf("key") !== -1) {
  			while (fragment) {
  				if (fragment.owner.currentSubtype === SECTION_EACH && (value = getProp(fragment, prop)) !== undefined) {
  					this.cached = fragment;

  					fragment.registerIndexRef(this);

  					return this.callback(getKeypath("@" + prop.prefix + value));
  				}

  				// watch for component boundaries
  				if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {
  					fragment = fragment.owner.component.parentFragment;
  				} else {
  					fragment = fragment.parent;
  				}
  			}
  		} else {
  			while (fragment) {
  				if ((value = getProp(fragment, prop)) !== undefined) {
  					return this.callback(getKeypath("@" + prop.prefix + value.str));
  				}

  				fragment = fragment.parent;
  			}
  		}
  	},

  	unbind: function () {
  		if (this.cached) {
  			this.cached.unregisterIndexRef(this);
  		}
  	}
  };

  var Resolvers_SpecialResolver = SpecialResolver;

  var IndexResolver = function (owner, ref, callback) {
  	this.parentFragment = owner.parentFragment;
  	this.ref = ref;
  	this.callback = callback;

  	ref.ref.fragment.registerIndexRef(this);

  	this.rebind();
  };

  IndexResolver.prototype = {
  	rebind: function () {
  		var index,
  		    ref = this.ref.ref;

  		if (ref.ref.t === "k") {
  			index = "k" + ref.fragment.key;
  		} else {
  			index = "i" + ref.fragment.index;
  		}

  		if (index !== undefined) {
  			this.callback(getKeypath("@" + index));
  		}
  	},

  	unbind: function () {
  		this.ref.ref.fragment.unregisterIndexRef(this);
  	}
  };

  var Resolvers_IndexResolver = IndexResolver;

  var Resolvers_findIndexRefs = findIndexRefs;

  function findIndexRefs(fragment, refName) {
  	var result = {},
  	    refs,
  	    fragRefs,
  	    ref,
  	    i,
  	    owner,
  	    hit = false;

  	if (!refName) {
  		result.refs = refs = {};
  	}

  	while (fragment) {
  		if ((owner = fragment.owner) && (fragRefs = owner.indexRefs)) {

  			// we're looking for a particular ref, and it's here
  			if (refName && (ref = owner.getIndexRef(refName))) {
  				result.ref = {
  					fragment: fragment,
  					ref: ref
  				};
  				return result;
  			}

  			// we're collecting refs up-tree
  			else if (!refName) {
  				for (i in fragRefs) {
  					ref = fragRefs[i];

  					// don't overwrite existing refs - they should shadow parents
  					if (!refs[ref.n]) {
  						hit = true;
  						refs[ref.n] = {
  							fragment: fragment,
  							ref: ref
  						};
  					}
  				}
  			}
  		}

  		// watch for component boundaries
  		if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {
  			result.componentBoundary = true;
  			fragment = fragment.owner.component.parentFragment;
  		} else {
  			fragment = fragment.parent;
  		}
  	}

  	if (!hit) {
  		return undefined;
  	} else {
  		return result;
  	}
  }

  findIndexRefs.resolve = function resolve(indices) {
  	var refs = {},
  	    k,
  	    ref;

  	for (k in indices.refs) {
  		ref = indices.refs[k];
  		refs[ref.ref.n] = ref.ref.t === "k" ? ref.fragment.key : ref.fragment.index;
  	}

  	return refs;
  };

  var Resolvers_createReferenceResolver = createReferenceResolver;
  function createReferenceResolver(owner, ref, callback) {
  	var indexRef;

  	if (ref.charAt(0) === "@") {
  		return new Resolvers_SpecialResolver(owner, ref, callback);
  	}

  	if (indexRef = Resolvers_findIndexRefs(owner.parentFragment, ref)) {
  		return new Resolvers_IndexResolver(owner, indexRef, callback);
  	}

  	return new Resolvers_ReferenceResolver(owner, ref, callback);
  }

  var shared_getFunctionFromString = getFunctionFromString;
  var cache = {};
  function getFunctionFromString(str, i) {
  	var fn, args;

  	if (cache[str]) {
  		return cache[str];
  	}

  	args = [];
  	while (i--) {
  		args[i] = "_" + i;
  	}

  	fn = new Function(args.join(","), "return(" + str + ")");

  	cache[str] = fn;
  	return fn;
  }

  var ExpressionResolver,
      Resolvers_ExpressionResolver__bind = Function.prototype.bind;

  ExpressionResolver = function (owner, parentFragment, expression, callback) {
  	var _this = this;

  	var ractive;

  	ractive = owner.root;

  	this.root = ractive;
  	this.parentFragment = parentFragment;
  	this.callback = callback;
  	this.owner = owner;
  	this.str = expression.s;
  	this.keypaths = [];

  	// Create resolvers for each reference
  	this.pending = expression.r.length;
  	this.refResolvers = expression.r.map(function (ref, i) {
  		return Resolvers_createReferenceResolver(_this, ref, function (keypath) {
  			_this.resolve(i, keypath);
  		});
  	});

  	this.ready = true;
  	this.bubble();
  };

  ExpressionResolver.prototype = {
  	bubble: function () {
  		if (!this.ready) {
  			return;
  		}

  		this.uniqueString = getUniqueString(this.str, this.keypaths);
  		this.keypath = createExpressionKeypath(this.uniqueString);

  		this.createEvaluator();
  		this.callback(this.keypath);
  	},

  	unbind: function () {
  		var resolver;

  		while (resolver = this.refResolvers.pop()) {
  			resolver.unbind();
  		}
  	},

  	resolve: function (index, keypath) {
  		this.keypaths[index] = keypath;
  		this.bubble();
  	},

  	createEvaluator: function () {
  		var _this = this;

  		var computation, valueGetters, signature, keypath, fn;

  		keypath = this.keypath;
  		computation = this.root.viewmodel.computations[keypath.str];

  		// only if it doesn't exist yet!
  		if (!computation) {
  			fn = shared_getFunctionFromString(this.str, this.refResolvers.length);

  			valueGetters = this.keypaths.map(function (keypath) {
  				var value;

  				if (keypath === "undefined") {
  					return function () {
  						return undefined;
  					};
  				}

  				// 'special' keypaths encode a value
  				if (keypath.isSpecial) {
  					value = keypath.value;
  					return function () {
  						return value;
  					};
  				}

  				return function () {
  					var value = _this.root.viewmodel.get(keypath, { noUnwrap: true, fullRootGet: true });
  					if (typeof value === "function") {
  						value = wrapFunction(value, _this.root);
  					}
  					return value;
  				};
  			});

  			signature = {
  				deps: this.keypaths.filter(isValidDependency),
  				getter: function () {
  					var args = valueGetters.map(call);
  					return fn.apply(null, args);
  				}
  			};

  			computation = this.root.viewmodel.compute(keypath, signature);
  		} else {
  			this.root.viewmodel.mark(keypath);
  		}
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		// TODO only bubble once, no matter how many references are affected by the rebind
  		this.refResolvers.forEach(function (r) {
  			return r.rebind(oldKeypath, newKeypath);
  		});
  	}
  };

  var Resolvers_ExpressionResolver = ExpressionResolver;

  function call(value) {
  	return value.call();
  }

  function getUniqueString(str, keypaths) {
  	// get string that is unique to this expression
  	return str.replace(/_([0-9]+)/g, function (match, $1) {
  		var keypath, value;

  		// make sure we're not replacing a non-keypath _[0-9]
  		if (+$1 >= keypaths.length) {
  			return "_" + $1;
  		}

  		keypath = keypaths[$1];

  		if (keypath === undefined) {
  			return "undefined";
  		}

  		if (keypath.isSpecial) {
  			value = keypath.value;
  			return typeof value === "number" ? value : "\"" + value + "\"";
  		}

  		return keypath.str;
  	});
  }

  function createExpressionKeypath(uniqueString) {
  	// Sanitize by removing any periods or square brackets. Otherwise
  	// we can't split the keypath into keys!
  	// Remove asterisks too, since they mess with pattern observers
  	return getKeypath("${" + uniqueString.replace(/[\.\[\]]/g, "-").replace(/\*/, "#MUL#") + "}");
  }

  function isValidDependency(keypath) {
  	return keypath !== undefined && keypath[0] !== "@";
  }

  function wrapFunction(fn, ractive) {
  	var wrapped, prop, key;

  	if (fn.__ractive_nowrap) {
  		return fn;
  	}

  	prop = "__ractive_" + ractive._guid;
  	wrapped = fn[prop];

  	if (wrapped) {
  		return wrapped;
  	} else if (/this/.test(fn.toString())) {
  		defineProperty(fn, prop, {
  			value: Resolvers_ExpressionResolver__bind.call(fn, ractive),
  			configurable: true
  		});

  		// Add properties/methods to wrapped function
  		for (key in fn) {
  			if (fn.hasOwnProperty(key)) {
  				fn[prop][key] = fn[key];
  			}
  		}

  		ractive._boundFunctions.push({
  			fn: fn,
  			prop: prop
  		});

  		return fn[prop];
  	}

  	defineProperty(fn, "__ractive_nowrap", {
  		value: fn
  	});

  	return fn.__ractive_nowrap;
  }

  var MemberResolver = function (template, resolver, parentFragment) {
  	var _this = this;

  	this.resolver = resolver;
  	this.root = resolver.root;
  	this.parentFragment = parentFragment;
  	this.viewmodel = resolver.root.viewmodel;

  	if (typeof template === "string") {
  		this.value = template;
  	}

  	// Simple reference?
  	else if (template.t === REFERENCE) {
  		this.refResolver = Resolvers_createReferenceResolver(this, template.n, function (keypath) {
  			_this.resolve(keypath);
  		});
  	}

  	// Otherwise we have an expression in its own right
  	else {
  		new Resolvers_ExpressionResolver(resolver, parentFragment, template, function (keypath) {
  			_this.resolve(keypath);
  		});
  	}
  };

  MemberResolver.prototype = {
  	resolve: function (keypath) {
  		if (this.keypath) {
  			this.viewmodel.unregister(this.keypath, this);
  		}

  		this.keypath = keypath;
  		this.value = this.viewmodel.get(keypath);

  		this.bind();

  		this.resolver.bubble();
  	},

  	bind: function () {
  		this.viewmodel.register(this.keypath, this);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		if (this.refResolver) {
  			this.refResolver.rebind(oldKeypath, newKeypath);
  		}
  	},

  	setValue: function (value) {
  		this.value = value;
  		this.resolver.bubble();
  	},

  	unbind: function () {
  		if (this.keypath) {
  			this.viewmodel.unregister(this.keypath, this);
  		}

  		if (this.refResolver) {
  			this.refResolver.unbind();
  		}
  	},

  	forceResolution: function () {
  		if (this.refResolver) {
  			this.refResolver.forceResolution();
  		}
  	}
  };

  var ReferenceExpressionResolver_MemberResolver = MemberResolver;

  var ReferenceExpressionResolver = function (mustache, template, callback) {
  	var _this = this;

  	var ractive, ref, keypath, parentFragment;

  	this.parentFragment = parentFragment = mustache.parentFragment;
  	this.root = ractive = mustache.root;
  	this.mustache = mustache;

  	this.ref = ref = template.r;
  	this.callback = callback;

  	this.unresolved = [];

  	// Find base keypath
  	if (keypath = shared_resolveRef(ractive, ref, parentFragment)) {
  		this.base = keypath;
  	} else {
  		this.baseResolver = new Resolvers_ReferenceResolver(this, ref, function (keypath) {
  			_this.base = keypath;
  			_this.baseResolver = null;
  			_this.bubble();
  		});
  	}

  	// Find values for members, or mark them as unresolved
  	this.members = template.m.map(function (template) {
  		return new ReferenceExpressionResolver_MemberResolver(template, _this, parentFragment);
  	});

  	this.ready = true;
  	this.bubble(); // trigger initial resolution if possible
  };

  ReferenceExpressionResolver.prototype = {
  	getKeypath: function () {
  		var values = this.members.map(ReferenceExpressionResolver_ReferenceExpressionResolver__getValue);

  		if (!values.every(isDefined) || this.baseResolver) {
  			return null;
  		}

  		return this.base.join(values.join("."));
  	},

  	bubble: function () {
  		if (!this.ready || this.baseResolver) {
  			return;
  		}

  		this.callback(this.getKeypath());
  	},

  	unbind: function () {
  		this.members.forEach(methodCallers__unbind);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		var changed;

  		if (this.base) {
  			var newBase = this.base.replace(oldKeypath, newKeypath);
  			if (newBase && newBase !== this.base) {
  				this.base = newBase;
  				changed = true;
  			}
  		}

  		this.members.forEach(function (members) {
  			if (members.rebind(oldKeypath, newKeypath)) {
  				changed = true;
  			}
  		});

  		if (changed) {
  			this.bubble();
  		}
  	},

  	forceResolution: function () {
  		if (this.baseResolver) {
  			this.base = getKeypath(this.ref);

  			this.baseResolver.unbind();
  			this.baseResolver = null;
  		}

  		this.members.forEach(forceResolution);
  		this.bubble();
  	}
  };

  function ReferenceExpressionResolver_ReferenceExpressionResolver__getValue(member) {
  	return member.value;
  }

  function isDefined(value) {
  	return value != undefined;
  }

  function forceResolution(member) {
  	member.forceResolution();
  }

  var ReferenceExpressionResolver_ReferenceExpressionResolver = ReferenceExpressionResolver;

  var Mustache_initialise = Mustache$init;
  function Mustache$init(mustache, options) {

  	var ref, parentFragment, template;

  	parentFragment = options.parentFragment;
  	template = options.template;

  	mustache.root = parentFragment.root;
  	mustache.parentFragment = parentFragment;
  	mustache.pElement = parentFragment.pElement;

  	mustache.template = options.template;
  	mustache.index = options.index || 0;
  	mustache.isStatic = options.template.s;

  	mustache.type = options.template.t;

  	mustache.registered = false;

  	// if this is a simple mustache, with a reference, we just need to resolve
  	// the reference to a keypath
  	if (ref = template.r) {
  		mustache.resolver = Resolvers_createReferenceResolver(mustache, ref, resolve);
  	}

  	// if it's an expression, we have a bit more work to do
  	if (options.template.x) {
  		mustache.resolver = new Resolvers_ExpressionResolver(mustache, parentFragment, options.template.x, resolveAndRebindChildren);
  	}

  	if (options.template.rx) {
  		mustache.resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(mustache, options.template.rx, resolveAndRebindChildren);
  	}

  	// Special case - inverted sections
  	if (mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty("value")) {
  		mustache.setValue(undefined);
  	}

  	function resolve(keypath) {
  		mustache.resolve(keypath);
  	}

  	function resolveAndRebindChildren(newKeypath) {
  		var oldKeypath = mustache.keypath;

  		if (newKeypath != oldKeypath) {
  			mustache.resolve(newKeypath);

  			if (oldKeypath !== undefined) {
  				mustache.fragments && mustache.fragments.forEach(function (f) {
  					f.rebind(oldKeypath, newKeypath);
  				});
  			}
  		}
  	}
  }

  var Mustache_resolve = Mustache$resolve;

  function Mustache$resolve(keypath) {
  	var wasResolved, value, twowayBinding;

  	// 'Special' keypaths, e.g. @foo or @7, encode a value
  	if (keypath && keypath.isSpecial) {
  		this.keypath = keypath;
  		this.setValue(keypath.value);
  		return;
  	}

  	// If we resolved previously, we need to unregister
  	if (this.registered) {
  		// undefined or null
  		this.root.viewmodel.unregister(this.keypath, this);
  		this.registered = false;

  		wasResolved = true;
  	}

  	this.keypath = keypath;

  	// If the new keypath exists, we need to register
  	// with the viewmodel
  	if (keypath != undefined) {
  		// undefined or null
  		value = this.root.viewmodel.get(keypath);
  		this.root.viewmodel.register(keypath, this);

  		this.registered = true;
  	}

  	// Either way we need to queue up a render (`value`
  	// will be `undefined` if there's no keypath)
  	this.setValue(value);

  	// Two-way bindings need to point to their new target keypath
  	if (wasResolved && (twowayBinding = this.twowayBinding)) {
  		twowayBinding.rebound();
  	}
  }

  var Mustache_rebind = Mustache$rebind;

  function Mustache$rebind(oldKeypath, newKeypath) {
  	// Children first
  	if (this.fragments) {
  		this.fragments.forEach(function (f) {
  			return f.rebind(oldKeypath, newKeypath);
  		});
  	}

  	// Expression mustache?
  	if (this.resolver) {
  		this.resolver.rebind(oldKeypath, newKeypath);
  	}
  }

  var Mustache = {
  	getValue: Mustache_getValue,
  	init: Mustache_initialise,
  	resolve: Mustache_resolve,
  	rebind: Mustache_rebind
  };

  var Interpolator = function (options) {
  	this.type = INTERPOLATOR;
  	Mustache.init(this, options);
  };

  Interpolator.prototype = {
  	update: function () {
  		this.node.data = this.value == undefined ? "" : this.value;
  	},
  	resolve: Mustache.resolve,
  	rebind: Mustache.rebind,
  	detach: shared_detach,

  	unbind: shared_unbind,

  	render: function () {
  		if (!this.node) {
  			this.node = document.createTextNode(safeToStringValue(this.value));
  		}

  		return this.node;
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			detachNode(this.node);
  		}
  	},

  	getValue: Mustache.getValue,

  	// TEMP
  	setValue: function (value) {
  		var wrapper;

  		// TODO is there a better way to approach this?
  		if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {
  			value = wrapper.get();
  		}

  		if (!isEqual(value, this.value)) {
  			this.value = value;
  			this.parentFragment.bubble();

  			if (this.node) {
  				global_runloop.addView(this);
  			}
  		}
  	},

  	firstNode: function () {
  		return this.node;
  	},

  	toString: function (escape) {
  		var string = "" + safeToStringValue(this.value);
  		return escape ? escapeHtml(string) : string;
  	}
  };

  var items_Interpolator = Interpolator;

  var Section_prototype_bubble = Section$bubble;

  function Section$bubble() {
  	this.parentFragment.bubble();
  }

  var Section_prototype_detach = Section$detach;

  function Section$detach() {
  	var docFrag;

  	if (this.fragments.length === 1) {
  		return this.fragments[0].detach();
  	}

  	docFrag = document.createDocumentFragment();

  	this.fragments.forEach(function (item) {
  		docFrag.appendChild(item.detach());
  	});

  	return docFrag;
  }

  var find = Section$find;

  function Section$find(selector) {
  	var i, len, queryResult;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		if (queryResult = this.fragments[i].find(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var findAll = Section$findAll;

  function Section$findAll(selector, query) {
  	var i, len;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		this.fragments[i].findAll(selector, query);
  	}
  }

  var findAllComponents = Section$findAllComponents;

  function Section$findAllComponents(selector, query) {
  	var i, len;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		this.fragments[i].findAllComponents(selector, query);
  	}
  }

  var findComponent = Section$findComponent;

  function Section$findComponent(selector) {
  	var i, len, queryResult;

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		if (queryResult = this.fragments[i].findComponent(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var findNextNode = Section$findNextNode;

  function Section$findNextNode(fragment) {
  	if (this.fragments[fragment.index + 1]) {
  		return this.fragments[fragment.index + 1].firstNode();
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var firstNode = Section$firstNode;

  function Section$firstNode() {
  	var len, i, node;

  	if (len = this.fragments.length) {
  		for (i = 0; i < len; i += 1) {
  			if (node = this.fragments[i].firstNode()) {
  				return node;
  			}
  		}
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var shuffle = Section$shuffle;

  function Section$shuffle(newIndices) {
  	var _this = this;

  	var parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;

  	// short circuit any double-updates, and ensure that this isn't applied to
  	// non-list sections
  	if (this.shuffling || this.unbound || this.currentSubtype !== SECTION_EACH) {
  		return;
  	}

  	this.shuffling = true;
  	global_runloop.scheduleTask(function () {
  		return _this.shuffling = false;
  	});

  	parentFragment = this.parentFragment;

  	reboundFragments = [];

  	// TODO: need to update this
  	// first, rebind existing fragments
  	newIndices.forEach(function (newIndex, oldIndex) {
  		var fragment, by, oldKeypath, newKeypath, deps;

  		if (newIndex === oldIndex) {
  			reboundFragments[newIndex] = _this.fragments[oldIndex];
  			return;
  		}

  		fragment = _this.fragments[oldIndex];

  		if (firstChange === undefined) {
  			firstChange = oldIndex;
  		}

  		// does this fragment need to be torn down?
  		if (newIndex === -1) {
  			_this.fragmentsToUnrender.push(fragment);
  			fragment.unbind();
  			return;
  		}

  		// Otherwise, it needs to be rebound to a new index
  		by = newIndex - oldIndex;
  		oldKeypath = _this.keypath.join(oldIndex);
  		newKeypath = _this.keypath.join(newIndex);

  		fragment.index = newIndex;

  		// notify any registered index refs directly
  		if (deps = fragment.registeredIndexRefs) {
  			deps.forEach(shuffle__blindRebind);
  		}

  		fragment.rebind(oldKeypath, newKeypath);
  		reboundFragments[newIndex] = fragment;
  	});

  	newLength = this.root.viewmodel.get(this.keypath).length;

  	// If nothing changed with the existing fragments, then we start adding
  	// new fragments at the end...
  	if (firstChange === undefined) {
  		// ...unless there are no new fragments to add
  		if (this.length === newLength) {
  			return;
  		}

  		firstChange = this.length;
  	}

  	this.length = this.fragments.length = newLength;

  	if (this.rendered) {
  		global_runloop.addView(this);
  	}

  	// Prepare new fragment options
  	fragmentOptions = {
  		template: this.template.f,
  		root: this.root,
  		owner: this
  	};

  	// Add as many new fragments as we need to, or add back existing
  	// (detached) fragments
  	for (i = firstChange; i < newLength; i += 1) {
  		fragment = reboundFragments[i];

  		if (!fragment) {
  			this.fragmentsToCreate.push(i);
  		}

  		this.fragments[i] = fragment;
  	}
  }

  function shuffle__blindRebind(dep) {
  	// the keypath doesn't actually matter here as it won't have changed
  	dep.rebind("", "");
  }

  var prototype_rebind = function (oldKeypath, newKeypath) {
  	Mustache.rebind.call(this, oldKeypath, newKeypath);
  };

  var Section_prototype_render = Section$render;

  function Section$render() {
  	var _this = this;

  	this.docFrag = document.createDocumentFragment();

  	this.fragments.forEach(function (f) {
  		return _this.docFrag.appendChild(f.render());
  	});

  	this.renderedFragments = this.fragments.slice();
  	this.fragmentsToRender = [];

  	this.rendered = true;
  	return this.docFrag;
  }

  var setValue = Section$setValue;

  function Section$setValue(value) {
  	var _this = this;

  	var wrapper, fragmentOptions;

  	if (this.updating) {
  		// If a child of this section causes a re-evaluation - for example, an
  		// expression refers to a function that mutates the array that this
  		// section depends on - we'll end up with a double rendering bug (see
  		// https://github.com/ractivejs/ractive/issues/748). This prevents it.
  		return;
  	}

  	this.updating = true;

  	// with sections, we need to get the fake value if we have a wrapped object
  	if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {
  		value = wrapper.get();
  	}

  	// If any fragments are awaiting creation after a splice,
  	// this is the place to do it
  	if (this.fragmentsToCreate.length) {
  		fragmentOptions = {
  			template: this.template.f || [],
  			root: this.root,
  			pElement: this.pElement,
  			owner: this
  		};

  		this.fragmentsToCreate.forEach(function (index) {
  			var fragment;

  			fragmentOptions.context = _this.keypath.join(index);
  			fragmentOptions.index = index;

  			fragment = new virtualdom_Fragment(fragmentOptions);
  			_this.fragmentsToRender.push(_this.fragments[index] = fragment);
  		});

  		this.fragmentsToCreate.length = 0;
  	} else if (reevaluateSection(this, value)) {
  		this.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}

  	this.value = value;
  	this.updating = false;
  }

  function changeCurrentSubtype(section, value, obj) {
  	if (value === SECTION_EACH) {
  		// make sure ref type is up to date for key or value indices
  		if (section.indexRefs && section.indexRefs[0]) {
  			var ref = section.indexRefs[0];

  			// when switching flavors, make sure the section gets updated
  			if (obj && ref.t === "i" || !obj && ref.t === "k") {
  				// if switching from object to list, unbind all of the old fragments
  				if (!obj) {
  					section.length = 0;
  					section.fragmentsToUnrender = section.fragments.slice(0);
  					section.fragmentsToUnrender.forEach(function (f) {
  						return f.unbind();
  					});
  				}
  			}

  			ref.t = obj ? "k" : "i";
  		}
  	}

  	section.currentSubtype = value;
  }

  function reevaluateSection(section, value) {
  	var fragmentOptions = {
  		template: section.template.f || [],
  		root: section.root,
  		pElement: section.parentFragment.pElement,
  		owner: section
  	};

  	section.hasContext = true;

  	// If we already know the section type, great
  	// TODO can this be optimised? i.e. pick an reevaluateSection function during init
  	// and avoid doing this each time?
  	if (section.subtype) {
  		switch (section.subtype) {
  			case SECTION_IF:
  				section.hasContext = false;
  				return reevaluateConditionalSection(section, value, false, fragmentOptions);

  			case SECTION_UNLESS:
  				section.hasContext = false;
  				return reevaluateConditionalSection(section, value, true, fragmentOptions);

  			case SECTION_WITH:
  				return reevaluateContextSection(section, fragmentOptions);

  			case SECTION_IF_WITH:
  				return reevaluateConditionalContextSection(section, value, fragmentOptions);

  			case SECTION_EACH:
  				if (isObject(value)) {
  					changeCurrentSubtype(section, section.subtype, true);
  					return reevaluateListObjectSection(section, value, fragmentOptions);
  				}

  				// Fallthrough - if it's a conditional or an array we need to continue
  		}
  	}

  	// Otherwise we need to work out what sort of section we're dealing with
  	section.ordered = !!isArrayLike(value);

  	// Ordered list section
  	if (section.ordered) {
  		changeCurrentSubtype(section, SECTION_EACH, false);
  		return reevaluateListSection(section, value, fragmentOptions);
  	}

  	// Unordered list, or context
  	if (isObject(value) || typeof value === "function") {
  		// Index reference indicates section should be treated as a list
  		if (section.template.i) {
  			changeCurrentSubtype(section, SECTION_EACH, true);
  			return reevaluateListObjectSection(section, value, fragmentOptions);
  		}

  		// Otherwise, object provides context for contents
  		changeCurrentSubtype(section, SECTION_WITH, false);
  		return reevaluateContextSection(section, fragmentOptions);
  	}

  	// Conditional section
  	changeCurrentSubtype(section, SECTION_IF, false);
  	section.hasContext = false;
  	return reevaluateConditionalSection(section, value, false, fragmentOptions);
  }

  function reevaluateListSection(section, value, fragmentOptions) {
  	var i, length, fragment;

  	length = value.length;

  	if (length === section.length) {
  		// Nothing to do
  		return false;
  	}

  	// if the array is shorter than it was previously, remove items
  	if (length < section.length) {
  		section.fragmentsToUnrender = section.fragments.splice(length, section.length - length);
  		section.fragmentsToUnrender.forEach(methodCallers__unbind);
  	}

  	// otherwise...
  	else {
  		if (length > section.length) {
  			// add any new ones
  			for (i = section.length; i < length; i += 1) {
  				// append list item to context stack
  				fragmentOptions.context = section.keypath.join(i);
  				fragmentOptions.index = i;

  				fragment = new virtualdom_Fragment(fragmentOptions);
  				section.fragmentsToRender.push(section.fragments[i] = fragment);
  			}
  		}
  	}

  	section.length = length;
  	return true;
  }

  function reevaluateListObjectSection(section, value, fragmentOptions) {
  	var id, i, hasKey, fragment, changed, deps;

  	hasKey = section.hasKey || (section.hasKey = {});

  	// remove any fragments that should no longer exist
  	i = section.fragments.length;
  	while (i--) {
  		fragment = section.fragments[i];

  		if (!(fragment.key in value)) {
  			changed = true;

  			fragment.unbind();
  			section.fragmentsToUnrender.push(fragment);
  			section.fragments.splice(i, 1);

  			hasKey[fragment.key] = false;
  		}
  	}

  	// notify any dependents about changed indices
  	i = section.fragments.length;
  	while (i--) {
  		fragment = section.fragments[i];

  		if (fragment.index !== i) {
  			fragment.index = i;
  			if (deps = fragment.registeredIndexRefs) {
  				deps.forEach(setValue__blindRebind);
  			}
  		}
  	}

  	// add any that haven't been created yet
  	i = section.fragments.length;
  	for (id in value) {
  		if (!hasKey[id]) {
  			changed = true;

  			fragmentOptions.context = section.keypath.join(id);
  			fragmentOptions.key = id;
  			fragmentOptions.index = i++;

  			fragment = new virtualdom_Fragment(fragmentOptions);

  			section.fragmentsToRender.push(fragment);
  			section.fragments.push(fragment);
  			hasKey[id] = true;
  		}
  	}

  	section.length = section.fragments.length;
  	return changed;
  }

  function reevaluateConditionalContextSection(section, value, fragmentOptions) {
  	if (value) {
  		return reevaluateContextSection(section, fragmentOptions);
  	} else {
  		return removeSectionFragments(section);
  	}
  }

  function reevaluateContextSection(section, fragmentOptions) {
  	var fragment;

  	// ...then if it isn't rendered, render it, adding section.keypath to the context stack
  	// (if it is already rendered, then any children dependent on the context stack
  	// will update themselves without any prompting)
  	if (!section.length) {
  		// append this section to the context stack
  		fragmentOptions.context = section.keypath;
  		fragmentOptions.index = 0;

  		fragment = new virtualdom_Fragment(fragmentOptions);

  		section.fragmentsToRender.push(section.fragments[0] = fragment);
  		section.length = 1;

  		return true;
  	}
  }

  function reevaluateConditionalSection(section, value, inverted, fragmentOptions) {
  	var doRender, emptyArray, emptyObject, fragment, name;

  	emptyArray = isArrayLike(value) && value.length === 0;
  	emptyObject = false;
  	if (!isArrayLike(value) && isObject(value)) {
  		emptyObject = true;
  		for (name in value) {
  			emptyObject = false;
  			break;
  		}
  	}

  	if (inverted) {
  		doRender = emptyArray || emptyObject || !value;
  	} else {
  		doRender = value && !emptyArray && !emptyObject;
  	}

  	if (doRender) {
  		if (!section.length) {
  			// no change to context stack
  			fragmentOptions.index = 0;

  			fragment = new virtualdom_Fragment(fragmentOptions);
  			section.fragmentsToRender.push(section.fragments[0] = fragment);
  			section.length = 1;

  			return true;
  		}

  		if (section.length > 1) {
  			section.fragmentsToUnrender = section.fragments.splice(1);
  			section.fragmentsToUnrender.forEach(methodCallers__unbind);

  			return true;
  		}
  	} else {
  		return removeSectionFragments(section);
  	}
  }

  function removeSectionFragments(section) {
  	if (section.length) {
  		section.fragmentsToUnrender = section.fragments.splice(0, section.fragments.length).filter(isRendered);
  		section.fragmentsToUnrender.forEach(methodCallers__unbind);
  		section.length = section.fragmentsToRender.length = 0;
  		return true;
  	}
  }

  function isRendered(fragment) {
  	return fragment.rendered;
  }

  function setValue__blindRebind(dep) {
  	// the keypath doesn't actually matter here as it won't have changed
  	dep.rebind("", "");
  }

  var prototype_toString = Section$toString;

  function Section$toString(escape) {
  	var str, i, len;

  	str = "";

  	i = 0;
  	len = this.length;

  	for (i = 0; i < len; i += 1) {
  		str += this.fragments[i].toString(escape);
  	}

  	return str;
  }

  var prototype_unbind = Section$unbind;
  function Section$unbind() {
  	var _this = this;

  	this.fragments.forEach(methodCallers__unbind);
  	this.fragmentsToRender.forEach(function (f) {
  		return removeFromArray(_this.fragments, f);
  	});
  	this.fragmentsToRender = [];
  	shared_unbind.call(this);

  	this.length = 0;
  	this.unbound = true;
  }

  var prototype_unrender = Section$unrender;

  function Section$unrender(shouldDestroy) {
  	this.fragments.forEach(shouldDestroy ? unrenderAndDestroy : prototype_unrender__unrender);
  	this.renderedFragments = [];
  	this.rendered = false;
  }

  function unrenderAndDestroy(fragment) {
  	fragment.unrender(true);
  }

  function prototype_unrender__unrender(fragment) {
  	fragment.unrender(false);
  }

  var prototype_update = Section$update;

  function Section$update() {
  	var fragment, renderIndex, renderedFragments, anchor, target, i, len;

  	// `this.renderedFragments` is in the order of the previous render.
  	// If fragments have shuffled about, this allows us to quickly
  	// reinsert them in the correct place
  	renderedFragments = this.renderedFragments;

  	// Remove fragments that have been marked for destruction
  	while (fragment = this.fragmentsToUnrender.pop()) {
  		fragment.unrender(true);
  		renderedFragments.splice(renderedFragments.indexOf(fragment), 1);
  	}

  	// Render new fragments (but don't insert them yet)
  	while (fragment = this.fragmentsToRender.shift()) {
  		fragment.render();
  	}

  	if (this.rendered) {
  		target = this.parentFragment.getNode();
  	}

  	len = this.fragments.length;
  	for (i = 0; i < len; i += 1) {
  		fragment = this.fragments[i];
  		renderIndex = renderedFragments.indexOf(fragment, i); // search from current index - it's guaranteed to be the same or higher

  		if (renderIndex === i) {
  			// already in the right place. insert accumulated nodes (if any) and carry on
  			if (this.docFrag.childNodes.length) {
  				anchor = fragment.firstNode();
  				target.insertBefore(this.docFrag, anchor);
  			}

  			continue;
  		}

  		this.docFrag.appendChild(fragment.detach());

  		// update renderedFragments
  		if (renderIndex !== -1) {
  			renderedFragments.splice(renderIndex, 1);
  		}
  		renderedFragments.splice(i, 0, fragment);
  	}

  	if (this.rendered && this.docFrag.childNodes.length) {
  		anchor = this.parentFragment.findNextNode(this);
  		target.insertBefore(this.docFrag, anchor);
  	}

  	// Save the rendering order for next time
  	this.renderedFragments = this.fragments.slice();
  }

  var Section = function (options) {
  	this.type = SECTION;
  	this.subtype = this.currentSubtype = options.template.n;
  	this.inverted = this.subtype === SECTION_UNLESS;

  	this.pElement = options.pElement;

  	this.fragments = [];
  	this.fragmentsToCreate = [];
  	this.fragmentsToRender = [];
  	this.fragmentsToUnrender = [];

  	if (options.template.i) {
  		this.indexRefs = options.template.i.split(",").map(function (k, i) {
  			return { n: k, t: i === 0 ? "k" : "i" };
  		});
  	}

  	this.renderedFragments = [];

  	this.length = 0; // number of times this section is rendered

  	Mustache.init(this, options);
  };

  Section.prototype = {
  	bubble: Section_prototype_bubble,
  	detach: Section_prototype_detach,
  	find: find,
  	findAll: findAll,
  	findAllComponents: findAllComponents,
  	findComponent: findComponent,
  	findNextNode: findNextNode,
  	firstNode: firstNode,
  	getIndexRef: function (name) {
  		if (this.indexRefs) {
  			var i = this.indexRefs.length;
  			while (i--) {
  				var ref = this.indexRefs[i];
  				if (ref.n === name) {
  					return ref;
  				}
  			}
  		}
  	},
  	getValue: Mustache.getValue,
  	shuffle: shuffle,
  	rebind: prototype_rebind,
  	render: Section_prototype_render,
  	resolve: Mustache.resolve,
  	setValue: setValue,
  	toString: prototype_toString,
  	unbind: prototype_unbind,
  	unrender: prototype_unrender,
  	update: prototype_update
  };

  var _Section = Section;

  var Triple_prototype_detach = Triple$detach;

  function Triple$detach() {
  	var len, i;

  	if (this.docFrag) {
  		len = this.nodes.length;
  		for (i = 0; i < len; i += 1) {
  			this.docFrag.appendChild(this.nodes[i]);
  		}

  		return this.docFrag;
  	}
  }

  var Triple_prototype_find = Triple$find;
  function Triple$find(selector) {
  	var i, len, node, queryResult;

  	len = this.nodes.length;
  	for (i = 0; i < len; i += 1) {
  		node = this.nodes[i];

  		if (node.nodeType !== 1) {
  			continue;
  		}

  		if (matches(node, selector)) {
  			return node;
  		}

  		if (queryResult = node.querySelector(selector)) {
  			return queryResult;
  		}
  	}

  	return null;
  }

  var Triple_prototype_findAll = Triple$findAll;
  function Triple$findAll(selector, queryResult) {
  	var i, len, node, queryAllResult, numNodes, j;

  	len = this.nodes.length;
  	for (i = 0; i < len; i += 1) {
  		node = this.nodes[i];

  		if (node.nodeType !== 1) {
  			continue;
  		}

  		if (matches(node, selector)) {
  			queryResult.push(node);
  		}

  		if (queryAllResult = node.querySelectorAll(selector)) {
  			numNodes = queryAllResult.length;
  			for (j = 0; j < numNodes; j += 1) {
  				queryResult.push(queryAllResult[j]);
  			}
  		}
  	}
  }

  var Triple_prototype_firstNode = Triple$firstNode;

  function Triple$firstNode() {
  	if (this.rendered && this.nodes[0]) {
  		return this.nodes[0];
  	}

  	return this.parentFragment.findNextNode(this);
  }

  var elementCache = {},
      ieBug,
      ieBlacklist;

  try {
  	createElement("table").innerHTML = "foo";
  } catch (err) {
  	ieBug = true;

  	ieBlacklist = {
  		TABLE: ["<table class=\"x\">", "</table>"],
  		THEAD: ["<table><thead class=\"x\">", "</thead></table>"],
  		TBODY: ["<table><tbody class=\"x\">", "</tbody></table>"],
  		TR: ["<table><tr class=\"x\">", "</tr></table>"],
  		SELECT: ["<select class=\"x\">", "</select>"]
  	};
  }

  var insertHtml = function (html, node, docFrag) {
  	var container,
  	    nodes = [],
  	    wrapper,
  	    selectedOption,
  	    child,
  	    i;

  	// render 0 and false
  	if (html != null && html !== "") {
  		if (ieBug && (wrapper = ieBlacklist[node.tagName])) {
  			container = element("DIV");
  			container.innerHTML = wrapper[0] + html + wrapper[1];
  			container = container.querySelector(".x");

  			if (container.tagName === "SELECT") {
  				selectedOption = container.options[container.selectedIndex];
  			}
  		} else if (node.namespaceURI === namespaces.svg) {
  			container = element("DIV");
  			container.innerHTML = "<svg class=\"x\">" + html + "</svg>";
  			container = container.querySelector(".x");
  		} else {
  			container = element(node.tagName);
  			container.innerHTML = html;

  			if (container.tagName === "SELECT") {
  				selectedOption = container.options[container.selectedIndex];
  			}
  		}

  		while (child = container.firstChild) {
  			nodes.push(child);
  			docFrag.appendChild(child);
  		}

  		// This is really annoying. Extracting <option> nodes from the
  		// temporary container <select> causes the remaining ones to
  		// become selected. So now we have to deselect them. IE8, you
  		// amaze me. You really do
  		// ...and now Chrome too
  		if (node.tagName === "SELECT") {
  			i = nodes.length;
  			while (i--) {
  				if (nodes[i] !== selectedOption) {
  					nodes[i].selected = false;
  				}
  			}
  		}
  	}

  	return nodes;
  };

  function element(tagName) {
  	return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));
  }

  var helpers_updateSelect = updateSelect;

  function updateSelect(parentElement) {
  	var selectedOptions, option, value;

  	if (!parentElement || parentElement.name !== "select" || !parentElement.binding) {
  		return;
  	}

  	selectedOptions = toArray(parentElement.node.options).filter(isSelected);

  	// If one of them had a `selected` attribute, we need to sync
  	// the model to the view
  	if (parentElement.getAttribute("multiple")) {
  		value = selectedOptions.map(function (o) {
  			return o.value;
  		});
  	} else if (option = selectedOptions[0]) {
  		value = option.value;
  	}

  	if (value !== undefined) {
  		parentElement.binding.setValue(value);
  	}

  	parentElement.bubble();
  }

  function isSelected(option) {
  	return option.selected;
  }

  var Triple_prototype_render = Triple$render;
  function Triple$render() {
  	if (this.rendered) {
  		throw new Error("Attempted to render an item that was already rendered");
  	}

  	this.docFrag = document.createDocumentFragment();
  	this.nodes = insertHtml(this.value, this.parentFragment.getNode(), this.docFrag);

  	// Special case - we're inserting the contents of a <select>
  	helpers_updateSelect(this.pElement);

  	this.rendered = true;
  	return this.docFrag;
  }

  var prototype_setValue = Triple$setValue;
  function Triple$setValue(value) {
  	var wrapper;

  	// TODO is there a better way to approach this?
  	if (wrapper = this.root.viewmodel.wrapped[this.keypath.str]) {
  		value = wrapper.get();
  	}

  	if (value !== this.value) {
  		this.value = value;
  		this.parentFragment.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}
  }

  var Triple_prototype_toString = Triple$toString;
  function Triple$toString() {
  	return this.value != undefined ? decodeCharacterReferences("" + this.value) : "";
  }

  var Triple_prototype_unrender = Triple$unrender;
  function Triple$unrender(shouldDestroy) {
  	if (this.rendered && shouldDestroy) {
  		this.nodes.forEach(detachNode);
  		this.rendered = false;
  	}

  	// TODO update live queries
  }

  var Triple_prototype_update = Triple$update;
  function Triple$update() {
  	var node, parentNode;

  	if (!this.rendered) {
  		return;
  	}

  	// Remove existing nodes
  	while (this.nodes && this.nodes.length) {
  		node = this.nodes.pop();
  		node.parentNode.removeChild(node);
  	}

  	// Insert new nodes
  	parentNode = this.parentFragment.getNode();

  	this.nodes = insertHtml(this.value, parentNode, this.docFrag);
  	parentNode.insertBefore(this.docFrag, this.parentFragment.findNextNode(this));

  	// Special case - we're inserting the contents of a <select>
  	helpers_updateSelect(this.pElement);
  }

  var Triple = function (options) {
  	this.type = TRIPLE;
  	Mustache.init(this, options);
  };

  Triple.prototype = {
  	detach: Triple_prototype_detach,
  	find: Triple_prototype_find,
  	findAll: Triple_prototype_findAll,
  	firstNode: Triple_prototype_firstNode,
  	getValue: Mustache.getValue,
  	rebind: Mustache.rebind,
  	render: Triple_prototype_render,
  	resolve: Mustache.resolve,
  	setValue: prototype_setValue,
  	toString: Triple_prototype_toString,
  	unbind: shared_unbind,
  	unrender: Triple_prototype_unrender,
  	update: Triple_prototype_update
  };

  var _Triple = Triple;

  var Element_prototype_bubble = function () {
  	this.parentFragment.bubble();
  };

  var Element_prototype_detach = Element$detach;

  function Element$detach() {
  	var node = this.node,
  	    parentNode;

  	if (node) {
  		// need to check for parent node - DOM may have been altered
  		// by something other than Ractive! e.g. jQuery UI...
  		if (parentNode = node.parentNode) {
  			parentNode.removeChild(node);
  		}

  		return node;
  	}
  }

  var Element_prototype_find = function (selector) {
  	if (!this.node) {
  		// this element hasn't been rendered yet
  		return null;
  	}

  	if (matches(this.node, selector)) {
  		return this.node;
  	}

  	if (this.fragment && this.fragment.find) {
  		return this.fragment.find(selector);
  	}
  };

  var Element_prototype_findAll = function (selector, query) {
  	// Add this node to the query, if applicable, and register the
  	// query on this element
  	if (query._test(this, true) && query.live) {
  		(this.liveQueries || (this.liveQueries = [])).push(query);
  	}

  	if (this.fragment) {
  		this.fragment.findAll(selector, query);
  	}
  };

  var Element_prototype_findAllComponents = function (selector, query) {
  	if (this.fragment) {
  		this.fragment.findAllComponents(selector, query);
  	}
  };

  var Element_prototype_findComponent = function (selector) {
  	if (this.fragment) {
  		return this.fragment.findComponent(selector);
  	}
  };

  var Element_prototype_findNextNode = Element$findNextNode;

  function Element$findNextNode() {
  	return null;
  }

  var Element_prototype_firstNode = Element$firstNode;

  function Element$firstNode() {
  	return this.node;
  }

  var getAttribute = Element$getAttribute;

  function Element$getAttribute(name) {
  	if (!this.attributes || !this.attributes[name]) {
  		return;
  	}

  	return this.attributes[name].value;
  }

  var truthy = /^true|on|yes|1$/i;
  var processBindingAttributes__isNumeric = /^[0-9]+$/;

  var processBindingAttributes = function (element, template) {
  	var val, attrs, attributes;

  	attributes = template.a || {};
  	attrs = {};

  	// attributes that are present but don't have a value (=)
  	// will be set to the number 0, which we condider to be true
  	// the string '0', however is false

  	val = attributes.twoway;
  	if (val !== undefined) {
  		attrs.twoway = val === 0 || truthy.test(val);
  	}

  	val = attributes.lazy;
  	if (val !== undefined) {
  		// check for timeout value
  		if (val !== 0 && processBindingAttributes__isNumeric.test(val)) {
  			attrs.lazy = parseInt(val);
  		} else {
  			attrs.lazy = val === 0 || truthy.test(val);
  		}
  	}

  	return attrs;
  };

  var Attribute_prototype_bubble = Attribute$bubble;
  function Attribute$bubble() {
  	var value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();

  	// TODO this can register the attribute multiple times (see render test
  	// 'Attribute with nested mustaches')
  	if (!isEqual(value, this.value)) {

  		// Need to clear old id from ractive.nodes
  		if (this.name === "id" && this.value) {
  			delete this.root.nodes[this.value];
  		}

  		this.value = value;

  		if (this.name === "value" && this.node) {
  			// We need to store the value on the DOM like this so we
  			// can retrieve it later without it being coerced to a string
  			this.node._ractive.value = value;
  		}

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	}
  }

  var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
  svgCamelCaseElements = "altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern".split(" ");
  svgCamelCaseAttributes = "attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan".split(" ");

  createMap = function (items) {
  	var map = {},
  	    i = items.length;
  	while (i--) {
  		map[items[i].toLowerCase()] = items[i];
  	}
  	return map;
  };

  map = createMap(svgCamelCaseElements.concat(svgCamelCaseAttributes));

  var enforceCase = function (elementName) {
  	var lowerCaseElementName = elementName.toLowerCase();
  	return map[lowerCaseElementName] || lowerCaseElementName;
  };

  var determineNameAndNamespace = function (attribute, name) {
  	var colonIndex, namespacePrefix;

  	// are we dealing with a namespaced attribute, e.g. xlink:href?
  	colonIndex = name.indexOf(":");
  	if (colonIndex !== -1) {

  		// looks like we are, yes...
  		namespacePrefix = name.substr(0, colonIndex);

  		// ...unless it's a namespace *declaration*, which we ignore (on the assumption
  		// that only valid namespaces will be used)
  		if (namespacePrefix !== "xmlns") {
  			name = name.substring(colonIndex + 1);

  			attribute.name = enforceCase(name);
  			attribute.namespace = namespaces[namespacePrefix.toLowerCase()];
  			attribute.namespacePrefix = namespacePrefix;

  			if (!attribute.namespace) {
  				throw "Unknown namespace (\"" + namespacePrefix + "\")";
  			}

  			return;
  		}
  	}

  	// SVG attribute names are case sensitive
  	attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase(name) : name;
  };

  var helpers_getInterpolator = getInterpolator;
  function getInterpolator(attribute) {
  	var items = attribute.fragment.items;

  	if (items.length !== 1) {
  		return;
  	}

  	if (items[0].type === INTERPOLATOR) {
  		return items[0];
  	}
  }

  var prototype_init = Attribute$init;
  function Attribute$init(options) {
  	this.type = ATTRIBUTE;
  	this.element = options.element;
  	this.root = options.root;

  	determineNameAndNamespace(this, options.name);
  	this.isBoolean = booleanAttributes.test(this.name);

  	// if it's an empty attribute, or just a straight key-value pair, with no
  	// mustache shenanigans, set the attribute accordingly and go home
  	if (!options.value || typeof options.value === "string") {
  		this.value = this.isBoolean ? true : options.value || "";
  		return;
  	}

  	// otherwise we need to do some work

  	// share parentFragment with parent element
  	this.parentFragment = this.element.parentFragment;

  	this.fragment = new virtualdom_Fragment({
  		template: options.value,
  		root: this.root,
  		owner: this
  	});

  	// TODO can we use this.fragment.toString() in some cases? It's quicker
  	this.value = this.fragment.getValue();

  	// Store a reference to this attribute's interpolator, if its fragment
  	// takes the form `{{foo}}`. This is necessary for two-way binding and
  	// for correctly rendering HTML later
  	this.interpolator = helpers_getInterpolator(this);
  	this.isBindable = !!this.interpolator && !this.interpolator.isStatic;

  	// mark as ready
  	this.ready = true;
  }

  var Attribute_prototype_rebind = Attribute$rebind;

  function Attribute$rebind(oldKeypath, newKeypath) {
  	if (this.fragment) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	}
  }

  var Attribute_prototype_render = Attribute$render;
  var propertyNames = {
  	"accept-charset": "acceptCharset",
  	accesskey: "accessKey",
  	bgcolor: "bgColor",
  	"class": "className",
  	codebase: "codeBase",
  	colspan: "colSpan",
  	contenteditable: "contentEditable",
  	datetime: "dateTime",
  	dirname: "dirName",
  	"for": "htmlFor",
  	"http-equiv": "httpEquiv",
  	ismap: "isMap",
  	maxlength: "maxLength",
  	novalidate: "noValidate",
  	pubdate: "pubDate",
  	readonly: "readOnly",
  	rowspan: "rowSpan",
  	tabindex: "tabIndex",
  	usemap: "useMap"
  };
  function Attribute$render(node) {
  	var propertyName;

  	this.node = node;

  	// should we use direct property access, or setAttribute?
  	if (!node.namespaceURI || node.namespaceURI === namespaces.html) {
  		propertyName = propertyNames[this.name] || this.name;

  		if (node[propertyName] !== undefined) {
  			this.propertyName = propertyName;
  		}

  		// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
  		// node.selected = true rather than node.setAttribute( 'selected', '' )
  		if (this.isBoolean || this.isTwoway) {
  			this.useProperty = true;
  		}

  		if (propertyName === "value") {
  			node._ractive.value = this.value;
  		}
  	}

  	this.rendered = true;
  	this.update();
  }

  var Attribute_prototype_toString = Attribute$toString;

  function Attribute$toString() {
  	var _ref = this;

  	var name = _ref.name;
  	var namespacePrefix = _ref.namespacePrefix;
  	var value = _ref.value;
  	var interpolator = _ref.interpolator;
  	var fragment = _ref.fragment;

  	// Special case - select and textarea values (should not be stringified)
  	if (name === "value" && (this.element.name === "select" || this.element.name === "textarea")) {
  		return;
  	}

  	// Special case - content editable
  	if (name === "value" && this.element.getAttribute("contenteditable") !== undefined) {
  		return;
  	}

  	// Special case - radio names
  	if (name === "name" && this.element.name === "input" && interpolator) {
  		return "name={{" + (interpolator.keypath.str || interpolator.ref) + "}}";
  	}

  	// Boolean attributes
  	if (this.isBoolean) {
  		return value ? name : "";
  	}

  	if (fragment) {
  		// special case - this catches undefined/null values (#1211)
  		if (fragment.items.length === 1 && fragment.items[0].value == null) {
  			return "";
  		}

  		value = fragment.toString();
  	}

  	if (namespacePrefix) {
  		name = namespacePrefix + ":" + name;
  	}

  	return value ? name + "=\"" + Attribute_prototype_toString__escape(value) + "\"" : name;
  }

  function Attribute_prototype_toString__escape(value) {
  	return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }

  var Attribute_prototype_unbind = Attribute$unbind;

  function Attribute$unbind() {
  	// ignore non-dynamic attributes
  	if (this.fragment) {
  		this.fragment.unbind();
  	}

  	if (this.name === "id") {
  		delete this.root.nodes[this.value];
  	}
  }

  var updateSelectValue = Attribute$updateSelect;

  function Attribute$updateSelect() {
  	var value = this.value,
  	    options,
  	    option,
  	    optionValue,
  	    i;

  	if (!this.locked) {
  		this.node._ractive.value = value;

  		options = this.node.options;
  		i = options.length;

  		while (i--) {
  			option = options[i];
  			optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive

  			if (optionValue == value) {
  				// double equals as we may be comparing numbers with strings
  				option.selected = true;
  				break;
  			}
  		}
  	}

  	// if we're still here, it means the new value didn't match any of the options...
  	// TODO figure out what to do in this situation
  }

  var updateMultipleSelectValue = Attribute$updateMultipleSelect;
  function Attribute$updateMultipleSelect() {
  	var value = this.value,
  	    options,
  	    i,
  	    option,
  	    optionValue;

  	if (!isArray(value)) {
  		value = [value];
  	}

  	options = this.node.options;
  	i = options.length;

  	while (i--) {
  		option = options[i];
  		optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive
  		option.selected = arrayContains(value, optionValue);
  	}
  }

  var updateRadioName = Attribute$updateRadioName;

  function Attribute$updateRadioName() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	node.checked = value == node._ractive.value;
  }

  var updateRadioValue = Attribute$updateRadioValue;
  function Attribute$updateRadioValue() {
  	var wasChecked,
  	    node = this.node,
  	    binding,
  	    bindings,
  	    i;

  	wasChecked = node.checked;

  	node.value = this.element.getAttribute("value");
  	node.checked = this.element.getAttribute("value") === this.element.getAttribute("name");

  	// This is a special case - if the input was checked, and the value
  	// changed so that it's no longer checked, the twoway binding is
  	// most likely out of date. To fix it we have to jump through some
  	// hoops... this is a little kludgy but it works
  	if (wasChecked && !node.checked && this.element.binding) {
  		bindings = this.element.binding.siblings;

  		if (i = bindings.length) {
  			while (i--) {
  				binding = bindings[i];

  				if (!binding.element.node) {
  					// this is the initial render, siblings are still rendering!
  					// we'll come back later...
  					return;
  				}

  				if (binding.element.node.checked) {
  					global_runloop.addRactive(binding.root);
  					return binding.handleChange();
  				}
  			}

  			this.root.viewmodel.set(binding.keypath, undefined);
  		}
  	}
  }

  var updateCheckboxName = Attribute$updateCheckboxName;
  function Attribute$updateCheckboxName() {
  	var _ref = this;

  	var element = _ref.element;
  	var node = _ref.node;
  	var value = _ref.value;var binding = element.binding;var valueAttribute;var i;

  	valueAttribute = element.getAttribute("value");

  	if (!isArray(value)) {
  		binding.isChecked = node.checked = value == valueAttribute;
  	} else {
  		i = value.length;
  		while (i--) {
  			if (valueAttribute == value[i]) {
  				binding.isChecked = node.checked = true;
  				return;
  			}
  		}
  		binding.isChecked = node.checked = false;
  	}
  }

  var updateClassName = Attribute$updateClassName;
  function Attribute$updateClassName() {
  	this.node.className = safeToStringValue(this.value);
  }

  var updateIdAttribute = Attribute$updateIdAttribute;

  function Attribute$updateIdAttribute() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	this.root.nodes[value] = node;
  	node.id = value;
  }

  var updateIEStyleAttribute = Attribute$updateIEStyleAttribute;

  function Attribute$updateIEStyleAttribute() {
  	var node, value;

  	node = this.node;
  	value = this.value;

  	if (value === undefined) {
  		value = "";
  	}

  	node.style.setAttribute("cssText", value);
  }

  var updateContentEditableValue = Attribute$updateContentEditableValue;

  function Attribute$updateContentEditableValue() {
  	var value = this.value;

  	if (value === undefined) {
  		value = "";
  	}

  	if (!this.locked) {
  		this.node.innerHTML = value;
  	}
  }

  var updateValue = Attribute$updateValue;

  function Attribute$updateValue() {
  	var _ref = this;

  	var node = _ref.node;
  	var value = _ref.value;

  	// store actual value, so it doesn't get coerced to a string
  	node._ractive.value = value;

  	// with two-way binding, only update if the change wasn't initiated by the user
  	// otherwise the cursor will often be sent to the wrong place
  	if (!this.locked) {
  		node.value = value == undefined ? "" : value;
  	}
  }

  var updateBoolean = Attribute$updateBooleanAttribute;

  function Attribute$updateBooleanAttribute() {
  	// with two-way binding, only update if the change wasn't initiated by the user
  	// otherwise the cursor will often be sent to the wrong place
  	if (!this.locked) {
  		this.node[this.propertyName] = this.value;
  	}
  }

  var updateEverythingElse = Attribute$updateEverythingElse;

  function Attribute$updateEverythingElse() {
  	var _ref = this;

  	var node = _ref.node;
  	var namespace = _ref.namespace;
  	var name = _ref.name;
  	var value = _ref.value;
  	var fragment = _ref.fragment;

  	if (namespace) {
  		node.setAttributeNS(namespace, name, (fragment || value).toString());
  	} else if (!this.isBoolean) {
  		if (value == null) {
  			node.removeAttribute(name);
  		} else {
  			node.setAttribute(name, (fragment || value).toString());
  		}
  	}

  	// Boolean attributes - truthy becomes '', falsy means 'remove attribute'
  	else {
  		if (value) {
  			node.setAttribute(name, "");
  		} else {
  			node.removeAttribute(name);
  		}
  	}
  }

  // There are a few special cases when it comes to updating attributes. For this reason,
  // the prototype .update() method points to this method, which waits until the
  // attribute has finished initialising, then replaces the prototype method with a more
  // suitable one. That way, we save ourselves doing a bunch of tests on each call
  var Attribute_prototype_update = Attribute$update;
  function Attribute$update() {
  	var _ref = this;

  	var name = _ref.name;
  	var element = _ref.element;
  	var node = _ref.node;var type;var updateMethod;

  	if (name === "id") {
  		updateMethod = updateIdAttribute;
  	} else if (name === "value") {
  		// special case - selects
  		if (element.name === "select" && name === "value") {
  			updateMethod = element.getAttribute("multiple") ? updateMultipleSelectValue : updateSelectValue;
  		} else if (element.name === "textarea") {
  			updateMethod = updateValue;
  		}

  		// special case - contenteditable
  		else if (element.getAttribute("contenteditable") != null) {
  			updateMethod = updateContentEditableValue;
  		}

  		// special case - <input>
  		else if (element.name === "input") {
  			type = element.getAttribute("type");

  			// type='file' value='{{fileList}}'>
  			if (type === "file") {
  				updateMethod = noop; // read-only
  			}

  			// type='radio' name='{{twoway}}'
  			else if (type === "radio" && element.binding && element.binding.name === "name") {
  				updateMethod = updateRadioValue;
  			} else {
  				updateMethod = updateValue;
  			}
  		}
  	}

  	// special case - <input type='radio' name='{{twoway}}' value='foo'>
  	else if (this.isTwoway && name === "name") {
  		if (node.type === "radio") {
  			updateMethod = updateRadioName;
  		} else if (node.type === "checkbox") {
  			updateMethod = updateCheckboxName;
  		}
  	}

  	// special case - style attributes in Internet Exploder
  	else if (name === "style" && node.style.setAttribute) {
  		updateMethod = updateIEStyleAttribute;
  	}

  	// special case - class names. IE fucks things up, again
  	else if (name === "class" && (!node.namespaceURI || node.namespaceURI === namespaces.html)) {
  		updateMethod = updateClassName;
  	} else if (this.useProperty) {
  		updateMethod = updateBoolean;
  	}

  	if (!updateMethod) {
  		updateMethod = updateEverythingElse;
  	}

  	this.update = updateMethod;
  	this.update();
  }

  var Attribute = function (options) {
  	this.init(options);
  };

  Attribute.prototype = {
  	bubble: Attribute_prototype_bubble,
  	init: prototype_init,
  	rebind: Attribute_prototype_rebind,
  	render: Attribute_prototype_render,
  	toString: Attribute_prototype_toString,
  	unbind: Attribute_prototype_unbind,
  	update: Attribute_prototype_update
  };

  var _Attribute = Attribute;

  var createAttributes = function (element, attributes) {
  	var name,
  	    attribute,
  	    result = [];

  	for (name in attributes) {
  		// skip binding attributes
  		if (name === "twoway" || name === "lazy") {
  			continue;
  		}

  		if (attributes.hasOwnProperty(name)) {
  			attribute = new _Attribute({
  				element: element,
  				name: name,
  				value: attributes[name],
  				root: element.root
  			});

  			result[name] = attribute;

  			if (name !== "value") {
  				result.push(attribute);
  			}
  		}
  	}

  	// value attribute goes last. This is because it
  	// may get clamped on render otherwise, e.g. in
  	// `<input type='range' value='999' min='0' max='1000'>`
  	// since default max is 100
  	if (attribute = result.value) {
  		result.push(attribute);
  	}

  	return result;
  };

  var _ConditionalAttribute__div;

  if (typeof document !== "undefined") {
  	_ConditionalAttribute__div = createElement("div");
  }

  var ConditionalAttribute = function (element, template) {
  	this.element = element;
  	this.root = element.root;
  	this.parentFragment = element.parentFragment;

  	this.attributes = [];

  	this.fragment = new virtualdom_Fragment({
  		root: element.root,
  		owner: this,
  		template: [template]
  	});
  };

  ConditionalAttribute.prototype = {
  	bubble: function () {
  		if (this.node) {
  			this.update();
  		}

  		this.element.bubble();
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	render: function (node) {
  		this.node = node;
  		this.isSvg = node.namespaceURI === namespaces.svg;

  		this.update();
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	},

  	update: function () {
  		var _this = this;

  		var str, attrs;

  		str = this.fragment.toString();
  		attrs = parseAttributes(str, this.isSvg);

  		// any attributes that previously existed but no longer do
  		// must be removed
  		this.attributes.filter(function (a) {
  			return notIn(attrs, a);
  		}).forEach(function (a) {
  			_this.node.removeAttribute(a.name);
  		});

  		attrs.forEach(function (a) {
  			_this.node.setAttribute(a.name, a.value);
  		});

  		this.attributes = attrs;
  	},

  	toString: function () {
  		return this.fragment.toString();
  	}
  };

  var _ConditionalAttribute = ConditionalAttribute;

  function parseAttributes(str, isSvg) {
  	var tag = isSvg ? "svg" : "div";
  	_ConditionalAttribute__div.innerHTML = "<" + tag + " " + str + "></" + tag + ">";

  	return toArray(_ConditionalAttribute__div.childNodes[0].attributes);
  }

  function notIn(haystack, needle) {
  	var i = haystack.length;

  	while (i--) {
  		if (haystack[i].name === needle.name) {
  			return false;
  		}
  	}

  	return true;
  }

  var createConditionalAttributes = function (element, attributes) {
  	if (!attributes) {
  		return [];
  	}

  	return attributes.map(function (a) {
  		return new _ConditionalAttribute(element, a);
  	});
  };

  var Binding = function (element) {
  	var interpolator, keypath, value, parentForm;

  	this.element = element;
  	this.root = element.root;
  	this.attribute = element.attributes[this.name || "value"];

  	interpolator = this.attribute.interpolator;
  	interpolator.twowayBinding = this;

  	if (keypath = interpolator.keypath) {
  		if (keypath.str.slice(-1) === "}") {
  			warnOnceIfDebug("Two-way binding does not work with expressions (`%s` on <%s>)", interpolator.resolver.uniqueString, element.name, { ractive: this.root });
  			return false;
  		}

  		if (keypath.isSpecial) {
  			warnOnceIfDebug("Two-way binding does not work with %s", interpolator.resolver.ref, { ractive: this.root });
  			return false;
  		}
  	} else {
  		// A mustache may be *ambiguous*. Let's say we were given
  		// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
  		// *wasn't* `undefined`, the keypath would be `foo.bar`.
  		// Then, any user input would result in `foo.bar` being updated.
  		//
  		// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
  		// left with an unresolved partial keypath - so we are forced to make an
  		// assumption. That assumption is that the input in question should
  		// be forced to resolve to `bar`, and any user input would affect `bar`
  		// and not `foo.bar`.
  		//
  		// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
  		// be explicit when using two-way data-binding about what keypath you're
  		// updating. Using it in lists is probably a recipe for confusion...
  		var ref = interpolator.template.r ? "'" + interpolator.template.r + "' reference" : "expression";
  		warnIfDebug("The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity", ref, { ractive: this.root });
  		interpolator.resolver.forceResolution();
  		keypath = interpolator.keypath;
  	}

  	this.attribute.isTwoway = true;
  	this.keypath = keypath;

  	// initialise value, if it's undefined
  	value = this.root.viewmodel.get(keypath);

  	if (value === undefined && this.getInitialValue) {
  		value = this.getInitialValue();

  		if (value !== undefined) {
  			this.root.viewmodel.set(keypath, value);
  		}
  	}

  	if (parentForm = findParentForm(element)) {
  		this.resetValue = value;
  		parentForm.formBindings.push(this);
  	}
  };

  Binding.prototype = {
  	handleChange: function () {
  		var _this = this;

  		global_runloop.start(this.root);
  		this.attribute.locked = true;
  		this.root.viewmodel.set(this.keypath, this.getValue());
  		global_runloop.scheduleTask(function () {
  			return _this.attribute.locked = false;
  		});
  		global_runloop.end();
  	},

  	rebound: function () {
  		var bindings, oldKeypath, newKeypath;

  		oldKeypath = this.keypath;
  		newKeypath = this.attribute.interpolator.keypath;

  		// The attribute this binding is linked to has already done the work
  		if (oldKeypath === newKeypath) {
  			return;
  		}

  		removeFromArray(this.root._twowayBindings[oldKeypath.str], this);

  		this.keypath = newKeypath;

  		bindings = this.root._twowayBindings[newKeypath.str] || (this.root._twowayBindings[newKeypath.str] = []);
  		bindings.push(this);
  	},

  	unbind: function () {}
  };

  Binding.extend = function (properties) {
  	var Parent = this,
  	    SpecialisedBinding;

  	SpecialisedBinding = function (element) {
  		Binding.call(this, element);

  		if (this.init) {
  			this.init();
  		}
  	};

  	SpecialisedBinding.prototype = create(Parent.prototype);
  	utils_object__extend(SpecialisedBinding.prototype, properties);

  	SpecialisedBinding.extend = Binding.extend;

  	return SpecialisedBinding;
  };

  var Binding_Binding = Binding;

  function findParentForm(element) {
  	while (element = element.parent) {
  		if (element.name === "form") {
  			return element;
  		}
  	}
  }

  // this is called when the element is unbound.
  // Specialised bindings can override it

  // This is the handler for DOM events that would lead to a change in the model
  // (i.e. change, sometimes, input, and occasionally click and keyup)
  var handleDomEvent = handleChange;

  function handleChange() {
  	this._ractive.binding.handleChange();
  }

  var GenericBinding;

  GenericBinding = Binding_Binding.extend({
  	getInitialValue: function () {
  		return "";
  	},

  	getValue: function () {
  		return this.element.node.value;
  	},

  	render: function () {
  		var node = this.element.node,
  		    lazy,
  		    timeout = false;
  		this.rendered = true;

  		// any lazy setting for this element overrides the root
  		// if the value is a number, it's a timeout
  		lazy = this.root.lazy;
  		if (this.element.lazy === true) {
  			lazy = true;
  		} else if (this.element.lazy === false) {
  			lazy = false;
  		} else if (is__isNumeric(this.element.lazy)) {
  			lazy = false;
  			timeout = +this.element.lazy;
  		} else if (is__isNumeric(lazy || "")) {
  			timeout = +lazy;
  			lazy = false;

  			// make sure the timeout is available to the handler
  			this.element.lazy = timeout;
  		}

  		this.handler = timeout ? handleDelay : handleDomEvent;

  		node.addEventListener("change", handleDomEvent, false);

  		if (!lazy) {
  			node.addEventListener("input", this.handler, false);

  			if (node.attachEvent) {
  				node.addEventListener("keyup", this.handler, false);
  			}
  		}

  		node.addEventListener("blur", handleBlur, false);
  	},

  	unrender: function () {
  		var node = this.element.node;
  		this.rendered = false;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("input", this.handler, false);
  		node.removeEventListener("keyup", this.handler, false);
  		node.removeEventListener("blur", handleBlur, false);
  	}
  });

  var Binding_GenericBinding = GenericBinding;

  function handleBlur() {
  	var value;

  	handleDomEvent.call(this);

  	value = this._ractive.root.viewmodel.get(this._ractive.binding.keypath);
  	this.value = value == undefined ? "" : value;
  }

  function handleDelay() {
  	var binding = this._ractive.binding,
  	    el = this;

  	if (!!binding._timeout) clearTimeout(binding._timeout);

  	binding._timeout = setTimeout(function () {
  		if (binding.rendered) handleDomEvent.call(el);
  		binding._timeout = undefined;
  	}, binding.element.lazy);
  }

  var ContentEditableBinding = Binding_GenericBinding.extend({
  	getInitialValue: function () {
  		return this.element.fragment ? this.element.fragment.toString() : "";
  	},

  	getValue: function () {
  		return this.element.node.innerHTML;
  	}
  });

  var Binding_ContentEditableBinding = ContentEditableBinding;

  var shared_getSiblings = getSiblings;
  var sets = {};
  function getSiblings(id, group, keypath) {
  	var hash = id + group + keypath;
  	return sets[hash] || (sets[hash] = []);
  }

  var RadioBinding = Binding_Binding.extend({
  	name: "checked",

  	init: function () {
  		this.siblings = shared_getSiblings(this.root._guid, "radio", this.element.getAttribute("name"));
  		this.siblings.push(this);
  	},

  	render: function () {
  		var node = this.element.node;

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	handleChange: function () {
  		global_runloop.start(this.root);

  		this.siblings.forEach(function (binding) {
  			binding.root.viewmodel.set(binding.keypath, binding.getValue());
  		});

  		global_runloop.end();
  	},

  	getValue: function () {
  		return this.element.node.checked;
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	}
  });

  var Binding_RadioBinding = RadioBinding;

  var RadioNameBinding = Binding_Binding.extend({
  	name: "name",

  	init: function () {
  		this.siblings = shared_getSiblings(this.root._guid, "radioname", this.keypath.str);
  		this.siblings.push(this);

  		this.radioName = true; // so that ractive.updateModel() knows what to do with this
  	},

  	getInitialValue: function () {
  		if (this.element.getAttribute("checked")) {
  			return this.element.getAttribute("value");
  		}
  	},

  	render: function () {
  		var node = this.element.node;

  		node.name = "{{" + this.keypath.str + "}}";
  		node.checked = this.root.viewmodel.get(this.keypath) == this.element.getAttribute("value");

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	getValue: function () {
  		var node = this.element.node;
  		return node._ractive ? node._ractive.value : node.value;
  	},

  	handleChange: function () {
  		// If this <input> is the one that's checked, then the value of its
  		// `name` keypath gets set to its value
  		if (this.element.node.checked) {
  			Binding_Binding.prototype.handleChange.call(this);
  		}
  	},

  	rebound: function (oldKeypath, newKeypath) {
  		var node;

  		Binding_Binding.prototype.rebound.call(this, oldKeypath, newKeypath);

  		if (node = this.element.node) {
  			node.name = "{{" + this.keypath.str + "}}";
  		}
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	}
  });

  var Binding_RadioNameBinding = RadioNameBinding;

  var CheckboxNameBinding = Binding_Binding.extend({
  	name: "name",

  	getInitialValue: function () {
  		// This only gets called once per group (of inputs that
  		// share a name), because it only gets called if there
  		// isn't an initial value. By the same token, we can make
  		// a note of that fact that there was no initial value,
  		// and populate it using any `checked` attributes that
  		// exist (which users should avoid, but which we should
  		// support anyway to avoid breaking expectations)
  		this.noInitialValue = true;
  		return [];
  	},

  	init: function () {
  		var existingValue, bindingValue;

  		this.checkboxName = true; // so that ractive.updateModel() knows what to do with this

  		// Each input has a reference to an array containing it and its
  		// siblings, as two-way binding depends on being able to ascertain
  		// the status of all inputs within the group
  		this.siblings = shared_getSiblings(this.root._guid, "checkboxes", this.keypath.str);
  		this.siblings.push(this);

  		if (this.noInitialValue) {
  			this.siblings.noInitialValue = true;
  		}

  		// If no initial value was set, and this input is checked, we
  		// update the model
  		if (this.siblings.noInitialValue && this.element.getAttribute("checked")) {
  			existingValue = this.root.viewmodel.get(this.keypath);
  			bindingValue = this.element.getAttribute("value");

  			existingValue.push(bindingValue);
  		}
  	},

  	unbind: function () {
  		removeFromArray(this.siblings, this);
  	},

  	render: function () {
  		var node = this.element.node,
  		    existingValue,
  		    bindingValue;

  		existingValue = this.root.viewmodel.get(this.keypath);
  		bindingValue = this.element.getAttribute("value");

  		if (isArray(existingValue)) {
  			this.isChecked = arrayContains(existingValue, bindingValue);
  		} else {
  			this.isChecked = existingValue == bindingValue;
  		}

  		node.name = "{{" + this.keypath.str + "}}";
  		node.checked = this.isChecked;

  		node.addEventListener("change", handleDomEvent, false);

  		// in case of IE emergency, bind to click event as well
  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	changed: function () {
  		var wasChecked = !!this.isChecked;
  		this.isChecked = this.element.node.checked;
  		return this.isChecked === wasChecked;
  	},

  	handleChange: function () {
  		this.isChecked = this.element.node.checked;
  		Binding_Binding.prototype.handleChange.call(this);
  	},

  	getValue: function () {
  		return this.siblings.filter(isChecked).map(Binding_CheckboxNameBinding__getValue);
  	}
  });

  function isChecked(binding) {
  	return binding.isChecked;
  }

  function Binding_CheckboxNameBinding__getValue(binding) {
  	return binding.element.getAttribute("value");
  }

  var Binding_CheckboxNameBinding = CheckboxNameBinding;

  var CheckboxBinding = Binding_Binding.extend({
  	name: "checked",

  	render: function () {
  		var node = this.element.node;

  		node.addEventListener("change", handleDomEvent, false);

  		if (node.attachEvent) {
  			node.addEventListener("click", handleDomEvent, false);
  		}
  	},

  	unrender: function () {
  		var node = this.element.node;

  		node.removeEventListener("change", handleDomEvent, false);
  		node.removeEventListener("click", handleDomEvent, false);
  	},

  	getValue: function () {
  		return this.element.node.checked;
  	}
  });

  var Binding_CheckboxBinding = CheckboxBinding;

  var SelectBinding = Binding_Binding.extend({
  	getInitialValue: function () {
  		var options = this.element.options,
  		    len,
  		    i,
  		    value,
  		    optionWasSelected;

  		if (this.element.getAttribute("value") !== undefined) {
  			return;
  		}

  		i = len = options.length;

  		if (!len) {
  			return;
  		}

  		// take the final selected option...
  		while (i--) {
  			if (options[i].getAttribute("selected")) {
  				value = options[i].getAttribute("value");
  				optionWasSelected = true;
  				break;
  			}
  		}

  		// or the first non-disabled option, if none are selected
  		if (!optionWasSelected) {
  			while (++i < len) {
  				if (!options[i].getAttribute("disabled")) {
  					value = options[i].getAttribute("value");
  					break;
  				}
  			}
  		}

  		// This is an optimisation (aka hack) that allows us to forgo some
  		// other more expensive work
  		if (value !== undefined) {
  			this.element.attributes.value.value = value;
  		}

  		return value;
  	},

  	render: function () {
  		this.element.node.addEventListener("change", handleDomEvent, false);
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	// TODO this method is an anomaly... is it necessary?
  	setValue: function (value) {
  		this.root.viewmodel.set(this.keypath, value);
  	},

  	getValue: function () {
  		var options, i, len, option, optionValue;

  		options = this.element.node.options;
  		len = options.length;

  		for (i = 0; i < len; i += 1) {
  			option = options[i];

  			if (options[i].selected) {
  				optionValue = option._ractive ? option._ractive.value : option.value;
  				return optionValue;
  			}
  		}
  	},

  	forceUpdate: function () {
  		var _this = this;

  		var value = this.getValue();

  		if (value !== undefined) {
  			this.attribute.locked = true;
  			global_runloop.scheduleTask(function () {
  				return _this.attribute.locked = false;
  			});
  			this.root.viewmodel.set(this.keypath, value);
  		}
  	}
  });

  var Binding_SelectBinding = SelectBinding;

  var MultipleSelectBinding = Binding_SelectBinding.extend({
  	getInitialValue: function () {
  		return this.element.options.filter(function (option) {
  			return option.getAttribute("selected");
  		}).map(function (option) {
  			return option.getAttribute("value");
  		});
  	},

  	render: function () {
  		var valueFromModel;

  		this.element.node.addEventListener("change", handleDomEvent, false);

  		valueFromModel = this.root.viewmodel.get(this.keypath);

  		if (valueFromModel === undefined) {
  			// get value from DOM, if possible
  			this.handleChange();
  		}
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	setValue: function () {
  		throw new Error("TODO not implemented yet");
  	},

  	getValue: function () {
  		var selectedValues, options, i, len, option, optionValue;

  		selectedValues = [];
  		options = this.element.node.options;
  		len = options.length;

  		for (i = 0; i < len; i += 1) {
  			option = options[i];

  			if (option.selected) {
  				optionValue = option._ractive ? option._ractive.value : option.value;
  				selectedValues.push(optionValue);
  			}
  		}

  		return selectedValues;
  	},

  	handleChange: function () {
  		var attribute, previousValue, value;

  		attribute = this.attribute;
  		previousValue = attribute.value;

  		value = this.getValue();

  		if (previousValue === undefined || !arrayContentsMatch(value, previousValue)) {
  			Binding_SelectBinding.prototype.handleChange.call(this);
  		}

  		return this;
  	},

  	forceUpdate: function () {
  		var _this = this;

  		var value = this.getValue();

  		if (value !== undefined) {
  			this.attribute.locked = true;
  			global_runloop.scheduleTask(function () {
  				return _this.attribute.locked = false;
  			});
  			this.root.viewmodel.set(this.keypath, value);
  		}
  	},

  	updateModel: function () {
  		if (this.attribute.value === undefined || !this.attribute.value.length) {
  			this.root.viewmodel.set(this.keypath, this.initialValue);
  		}
  	}
  });

  var Binding_MultipleSelectBinding = MultipleSelectBinding;

  var FileListBinding = Binding_Binding.extend({
  	render: function () {
  		this.element.node.addEventListener("change", handleDomEvent, false);
  	},

  	unrender: function () {
  		this.element.node.removeEventListener("change", handleDomEvent, false);
  	},

  	getValue: function () {
  		return this.element.node.files;
  	}
  });

  var Binding_FileListBinding = FileListBinding;

  var NumericBinding = Binding_GenericBinding.extend({
  	getInitialValue: function () {
  		return undefined;
  	},

  	getValue: function () {
  		var value = parseFloat(this.element.node.value);
  		return isNaN(value) ? undefined : value;
  	}
  });

  var init_createTwowayBinding = createTwowayBinding;

  function createTwowayBinding(element) {
  	var attributes = element.attributes,
  	    type,
  	    Binding,
  	    bindName,
  	    bindChecked,
  	    binding;

  	// if this is a late binding, and there's already one, it
  	// needs to be torn down
  	if (element.binding) {
  		element.binding.teardown();
  		element.binding = null;
  	}

  	// contenteditable
  	if (
  	// if the contenteditable attribute is true or is bindable and may thus become true
  	(element.getAttribute("contenteditable") || !!attributes.contenteditable && isBindable(attributes.contenteditable)) && isBindable(attributes.value)) {
  		Binding = Binding_ContentEditableBinding;
  	}

  	// <input>
  	else if (element.name === "input") {
  		type = element.getAttribute("type");

  		if (type === "radio" || type === "checkbox") {
  			bindName = isBindable(attributes.name);
  			bindChecked = isBindable(attributes.checked);

  			// we can either bind the name attribute, or the checked attribute - not both
  			if (bindName && bindChecked) {
  				warnIfDebug("A radio input can have two-way binding on its name attribute, or its checked attribute - not both", { ractive: element.root });
  			}

  			if (bindName) {
  				Binding = type === "radio" ? Binding_RadioNameBinding : Binding_CheckboxNameBinding;
  			} else if (bindChecked) {
  				Binding = type === "radio" ? Binding_RadioBinding : Binding_CheckboxBinding;
  			}
  		} else if (type === "file" && isBindable(attributes.value)) {
  			Binding = Binding_FileListBinding;
  		} else if (isBindable(attributes.value)) {
  			Binding = type === "number" || type === "range" ? NumericBinding : Binding_GenericBinding;
  		}
  	}

  	// <select>
  	else if (element.name === "select" && isBindable(attributes.value)) {
  		Binding = element.getAttribute("multiple") ? Binding_MultipleSelectBinding : Binding_SelectBinding;
  	}

  	// <textarea>
  	else if (element.name === "textarea" && isBindable(attributes.value)) {
  		Binding = Binding_GenericBinding;
  	}

  	if (Binding && (binding = new Binding(element)) && binding.keypath) {
  		return binding;
  	}
  }

  function isBindable(attribute) {
  	return attribute && attribute.isBindable;
  }

  // and this element also has a value attribute to bind

  var EventHandler_prototype_bubble = EventHandler$bubble;

  function EventHandler$bubble() {
  	var hasAction = this.getAction();

  	if (hasAction && !this.hasListener) {
  		this.listen();
  	} else if (!hasAction && this.hasListener) {
  		this.unrender();
  	}
  }

  // This function may be overwritten, if the event directive
  // includes parameters
  var EventHandler_prototype_fire = EventHandler$fire;
  function EventHandler$fire(event) {
  	shared_fireEvent(this.root, this.getAction(), { event: event });
  }

  var getAction = EventHandler$getAction;

  function EventHandler$getAction() {
  	return this.action.toString().trim();
  }

  var EventHandler_prototype_init = EventHandler$init;

  var eventPattern = /^event(?:\.(.+))?/;
  function EventHandler$init(element, name, template) {
  	var _this = this;

  	var action, refs, ractive;

  	this.element = element;
  	this.root = element.root;
  	this.parentFragment = element.parentFragment;
  	this.name = name;

  	if (name.indexOf("*") !== -1) {
  		fatal("Only component proxy-events may contain \"*\" wildcards, <%s on-%s=\"...\"/> is not valid", element.name, name);
  		this.invalid = true;
  	}

  	if (template.m) {
  		refs = template.a.r;

  		// This is a method call
  		this.method = template.m;
  		this.keypaths = [];
  		this.fn = shared_getFunctionFromString(template.a.s, refs.length);

  		this.parentFragment = element.parentFragment;
  		ractive = this.root;

  		// Create resolvers for each reference
  		this.refResolvers = [];
  		refs.forEach(function (ref, i) {
  			var match = undefined;

  			// special case - the `event` object
  			if (match = eventPattern.exec(ref)) {
  				_this.keypaths[i] = {
  					eventObject: true,
  					refinements: match[1] ? match[1].split(".") : []
  				};
  			} else {
  				_this.refResolvers.push(Resolvers_createReferenceResolver(_this, ref, function (keypath) {
  					return _this.resolve(i, keypath);
  				}));
  			}
  		});

  		this.fire = fireMethodCall;
  	} else {
  		// Get action ('foo' in 'on-click='foo')
  		action = template.n || template;
  		if (typeof action !== "string") {
  			action = new virtualdom_Fragment({
  				template: action,
  				root: this.root,
  				owner: this
  			});
  		}

  		this.action = action;

  		// Get parameters
  		if (template.d) {
  			this.dynamicParams = new virtualdom_Fragment({
  				template: template.d,
  				root: this.root,
  				owner: this.element
  			});

  			this.fire = fireEventWithDynamicParams;
  		} else if (template.a) {
  			this.params = template.a;
  			this.fire = fireEventWithParams;
  		}
  	}
  }

  function fireMethodCall(event) {
  	var ractive, values, args;

  	ractive = this.root;

  	if (typeof ractive[this.method] !== "function") {
  		throw new Error("Attempted to call a non-existent method (\"" + this.method + "\")");
  	}

  	values = this.keypaths.map(function (keypath) {
  		var value, len, i;

  		if (keypath === undefined) {
  			// not yet resolved
  			return undefined;
  		}

  		// TODO the refinements stuff would be better handled at parse time
  		if (keypath.eventObject) {
  			value = event;

  			if (len = keypath.refinements.length) {
  				for (i = 0; i < len; i += 1) {
  					value = value[keypath.refinements[i]];
  				}
  			}
  		} else {
  			value = ractive.viewmodel.get(keypath);
  		}

  		return value;
  	});

  	shared_eventStack.enqueue(ractive, event);

  	args = this.fn.apply(null, values);
  	ractive[this.method].apply(ractive, args);

  	shared_eventStack.dequeue(ractive);
  }

  function fireEventWithParams(event) {
  	shared_fireEvent(this.root, this.getAction(), { event: event, args: this.params });
  }

  function fireEventWithDynamicParams(event) {
  	var args = this.dynamicParams.getArgsList();

  	// need to strip [] from ends if a string!
  	if (typeof args === "string") {
  		args = args.substr(1, args.length - 2);
  	}

  	shared_fireEvent(this.root, this.getAction(), { event: event, args: args });
  }

  var shared_genericHandler = genericHandler;
  function genericHandler(event) {
  	var storage,
  	    handler,
  	    indices,
  	    index = {};

  	storage = this._ractive;
  	handler = storage.events[event.type];

  	if (indices = Resolvers_findIndexRefs(handler.element.parentFragment)) {
  		index = Resolvers_findIndexRefs.resolve(indices);
  	}

  	handler.fire({
  		node: this,
  		original: event,
  		index: index,
  		keypath: storage.keypath.str,
  		context: storage.root.viewmodel.get(storage.keypath)
  	});
  }

  var listen = EventHandler$listen;

  var customHandlers = {},
      touchEvents = {
  	touchstart: true,
  	touchmove: true,
  	touchend: true,
  	touchcancel: true,
  	//not w3c, but supported in some browsers
  	touchleave: true
  };
  function EventHandler$listen() {
  	var definition,
  	    name = this.name;

  	if (this.invalid) {
  		return;
  	}

  	if (definition = findInViewHierarchy("events", this.root, name)) {
  		this.custom = definition(this.node, getCustomHandler(name));
  	} else {
  		// Looks like we're dealing with a standard DOM event... but let's check
  		if (!("on" + name in this.node) && !(window && "on" + name in window) && !isJsdom) {

  			// okay to use touch events if this browser doesn't support them
  			if (!touchEvents[name]) {
  				warnOnceIfDebug(missingPlugin(name, "event"), { node: this.node });
  			}

  			return;
  		}

  		this.node.addEventListener(name, shared_genericHandler, false);
  	}

  	this.hasListener = true;
  }

  function getCustomHandler(name) {
  	if (!customHandlers[name]) {
  		customHandlers[name] = function (event) {
  			var storage = event.node._ractive;

  			event.index = storage.index;
  			event.keypath = storage.keypath.str;
  			event.context = storage.root.viewmodel.get(storage.keypath);

  			storage.events[name].fire(event);
  		};
  	}

  	return customHandlers[name];
  }

  var EventHandler_prototype_rebind = EventHandler$rebind;

  function EventHandler$rebind(oldKeypath, newKeypath) {
  	var fragment;
  	if (this.method) {
  		fragment = this.element.parentFragment;
  		this.refResolvers.forEach(rebind);

  		return;
  	}

  	if (typeof this.action !== "string") {
  		rebind(this.action);
  	}

  	if (this.dynamicParams) {
  		rebind(this.dynamicParams);
  	}

  	function rebind(thing) {
  		thing && thing.rebind(oldKeypath, newKeypath);
  	}
  }

  var EventHandler_prototype_render = EventHandler$render;

  function EventHandler$render() {
  	this.node = this.element.node;
  	// store this on the node itself, so it can be retrieved by a
  	// universal handler
  	this.node._ractive.events[this.name] = this;

  	if (this.method || this.getAction()) {
  		this.listen();
  	}
  }

  var prototype_resolve = EventHandler$resolve;

  function EventHandler$resolve(index, keypath) {
  	this.keypaths[index] = keypath;
  }

  var EventHandler_prototype_unbind = EventHandler$unbind;
  function EventHandler$unbind() {
  	if (this.method) {
  		this.refResolvers.forEach(methodCallers__unbind);
  		return;
  	}

  	// Tear down dynamic name
  	if (typeof this.action !== "string") {
  		this.action.unbind();
  	}

  	// Tear down dynamic parameters
  	if (this.dynamicParams) {
  		this.dynamicParams.unbind();
  	}
  }

  var EventHandler_prototype_unrender = EventHandler$unrender;
  function EventHandler$unrender() {

  	if (this.custom) {
  		this.custom.teardown();
  	} else {
  		this.node.removeEventListener(this.name, shared_genericHandler, false);
  	}

  	this.hasListener = false;
  }

  var EventHandler = function (element, name, template) {
  	this.init(element, name, template);
  };

  EventHandler.prototype = {
  	bubble: EventHandler_prototype_bubble,
  	fire: EventHandler_prototype_fire,
  	getAction: getAction,
  	init: EventHandler_prototype_init,
  	listen: listen,
  	rebind: EventHandler_prototype_rebind,
  	render: EventHandler_prototype_render,
  	resolve: prototype_resolve,
  	unbind: EventHandler_prototype_unbind,
  	unrender: EventHandler_prototype_unrender
  };

  var _EventHandler = EventHandler;

  var createEventHandlers = function (element, template) {
  	var i,
  	    name,
  	    names,
  	    handler,
  	    result = [];

  	for (name in template) {
  		if (template.hasOwnProperty(name)) {
  			names = name.split("-");
  			i = names.length;

  			while (i--) {
  				handler = new _EventHandler(element, names[i], template[name]);
  				result.push(handler);
  			}
  		}
  	}

  	return result;
  };

  var Decorator = function (element, template) {
  	var self = this,
  	    ractive,
  	    name,
  	    fragment;

  	this.element = element;
  	this.root = ractive = element.root;

  	name = template.n || template;

  	if (typeof name !== "string") {
  		fragment = new virtualdom_Fragment({
  			template: name,
  			root: ractive,
  			owner: element
  		});

  		name = fragment.toString();
  		fragment.unbind();

  		if (name === "") {
  			// empty string okay, just no decorator
  			return;
  		}
  	}

  	if (template.a) {
  		this.params = template.a;
  	} else if (template.d) {
  		this.fragment = new virtualdom_Fragment({
  			template: template.d,
  			root: ractive,
  			owner: element
  		});

  		this.params = this.fragment.getArgsList();

  		this.fragment.bubble = function () {
  			this.dirtyArgs = this.dirtyValue = true;
  			self.params = this.getArgsList();

  			if (self.ready) {
  				self.update();
  			}
  		};
  	}

  	this.fn = findInViewHierarchy("decorators", ractive, name);

  	if (!this.fn) {
  		fatal(missingPlugin(name, "decorator"));
  	}
  };

  Decorator.prototype = {
  	init: function () {
  		var node, result, args;

  		node = this.element.node;

  		if (this.params) {
  			args = [node].concat(this.params);
  			result = this.fn.apply(this.root, args);
  		} else {
  			result = this.fn.call(this.root, node);
  		}

  		if (!result || !result.teardown) {
  			throw new Error("Decorator definition must return an object with a teardown method");
  		}

  		// TODO does this make sense?
  		this.actual = result;
  		this.ready = true;
  	},

  	update: function () {
  		if (this.actual.update) {
  			this.actual.update.apply(this.root, this.params);
  		} else {
  			this.actual.teardown(true);
  			this.init();
  		}
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		if (this.fragment) {
  			this.fragment.rebind(oldKeypath, newKeypath);
  		}
  	},

  	teardown: function (updating) {
  		this.torndown = true;
  		if (this.ready) {
  			this.actual.teardown();
  		}

  		if (!updating && this.fragment) {
  			this.fragment.unbind();
  		}
  	}
  };

  var _Decorator = Decorator;

  function select__bubble() {
  	var _this = this;

  	if (!this.dirty) {
  		this.dirty = true;

  		global_runloop.scheduleTask(function () {
  			sync(_this);
  			_this.dirty = false;
  		});
  	}

  	this.parentFragment.bubble(); // default behaviour
  }

  function sync(selectElement) {
  	var selectNode, selectValue, isMultiple, options, optionWasSelected;

  	selectNode = selectElement.node;

  	if (!selectNode) {
  		return;
  	}

  	options = toArray(selectNode.options);

  	selectValue = selectElement.getAttribute("value");
  	isMultiple = selectElement.getAttribute("multiple");

  	// If the <select> has a specified value, that should override
  	// these options
  	if (selectValue !== undefined) {
  		options.forEach(function (o) {
  			var optionValue, shouldSelect;

  			optionValue = o._ractive ? o._ractive.value : o.value;
  			shouldSelect = isMultiple ? valueContains(selectValue, optionValue) : selectValue == optionValue;

  			if (shouldSelect) {
  				optionWasSelected = true;
  			}

  			o.selected = shouldSelect;
  		});

  		if (!optionWasSelected) {
  			if (options[0]) {
  				options[0].selected = true;
  			}

  			if (selectElement.binding) {
  				selectElement.binding.forceUpdate();
  			}
  		}
  	}

  	// Otherwise the value should be initialised according to which
  	// <option> element is selected, if twoway binding is in effect
  	else if (selectElement.binding) {
  		selectElement.binding.forceUpdate();
  	}
  }

  function valueContains(selectValue, optionValue) {
  	var i = selectValue.length;
  	while (i--) {
  		if (selectValue[i] == optionValue) {
  			return true;
  		}
  	}
  }

  function special_option__init(option, template) {
  	option.select = findParentSelect(option.parent);

  	// we might be inside a <datalist> element
  	if (!option.select) {
  		return;
  	}

  	option.select.options.push(option);

  	// If the value attribute is missing, use the element's content
  	if (!template.a) {
  		template.a = {};
  	}

  	// ...as long as it isn't disabled
  	if (template.a.value === undefined && !template.a.hasOwnProperty("disabled")) {
  		template.a.value = template.f;
  	}

  	// If there is a `selected` attribute, but the <select>
  	// already has a value, delete it
  	if ("selected" in template.a && option.select.getAttribute("value") !== undefined) {
  		delete template.a.selected;
  	}
  }

  function special_option__unbind(option) {
  	if (option.select) {
  		removeFromArray(option.select.options, option);
  	}
  }

  function findParentSelect(element) {
  	if (!element) {
  		return;
  	}

  	do {
  		if (element.name === "select") {
  			return element;
  		}
  	} while (element = element.parent);
  }

  var Element_prototype_init = Element$init;
  function Element$init(options) {
  	var parentFragment, template, ractive, binding, bindings, twoway, bindingAttrs;

  	this.type = ELEMENT;

  	// stuff we'll need later
  	parentFragment = this.parentFragment = options.parentFragment;
  	template = this.template = options.template;

  	this.parent = options.pElement || parentFragment.pElement;

  	this.root = ractive = parentFragment.root;
  	this.index = options.index;
  	this.key = options.key;

  	this.name = enforceCase(template.e);

  	// Special case - <option> elements
  	if (this.name === "option") {
  		special_option__init(this, template);
  	}

  	// Special case - <select> elements
  	if (this.name === "select") {
  		this.options = [];
  		this.bubble = select__bubble; // TODO this is a kludge
  	}

  	// Special case - <form> elements
  	if (this.name === "form") {
  		this.formBindings = [];
  	}

  	// handle binding attributes first (twoway, lazy)
  	bindingAttrs = processBindingAttributes(this, template);

  	// create attributes
  	this.attributes = createAttributes(this, template.a);
  	this.conditionalAttributes = createConditionalAttributes(this, template.m);

  	// append children, if there are any
  	if (template.f) {
  		this.fragment = new virtualdom_Fragment({
  			template: template.f,
  			root: ractive,
  			owner: this,
  			pElement: this,
  			cssIds: null
  		});
  	}

  	// the element setting should override the ractive setting
  	twoway = ractive.twoway;
  	if (bindingAttrs.twoway === false) twoway = false;else if (bindingAttrs.twoway === true) twoway = true;

  	this.twoway = twoway;
  	this.lazy = bindingAttrs.lazy;

  	// create twoway binding
  	if (twoway && (binding = init_createTwowayBinding(this, template.a))) {
  		this.binding = binding;

  		// register this with the root, so that we can do ractive.updateModel()
  		bindings = this.root._twowayBindings[binding.keypath.str] || (this.root._twowayBindings[binding.keypath.str] = []);
  		bindings.push(binding);
  	}

  	// create event proxies
  	if (template.v) {
  		this.eventHandlers = createEventHandlers(this, template.v);
  	}

  	// create decorator
  	if (template.o) {
  		this.decorator = new _Decorator(this, template.o);
  	}

  	// create transitions
  	this.intro = template.t0 || template.t1;
  	this.outro = template.t0 || template.t2;
  }

  var Element_prototype_rebind = Element$rebind;
  function Element$rebind(oldKeypath, newKeypath) {
  	var i, storage, liveQueries, ractive;

  	if (this.attributes) {
  		this.attributes.forEach(rebind);
  	}

  	if (this.conditionalAttributes) {
  		this.conditionalAttributes.forEach(rebind);
  	}

  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(rebind);
  	}

  	if (this.decorator) {
  		rebind(this.decorator);
  	}

  	// rebind children
  	if (this.fragment) {
  		rebind(this.fragment);
  	}

  	// Update live queries, if necessary
  	if (liveQueries = this.liveQueries) {
  		ractive = this.root;

  		i = liveQueries.length;
  		while (i--) {
  			liveQueries[i]._makeDirty();
  		}
  	}

  	if (this.node && (storage = this.node._ractive)) {

  		// adjust keypath if needed
  		assignNewKeypath(storage, "keypath", oldKeypath, newKeypath);
  	}

  	function rebind(thing) {
  		thing.rebind(oldKeypath, newKeypath);
  	}
  }

  function special_img__render(img) {
  	var loadHandler;

  	// if this is an <img>, and we're in a crap browser, we may need to prevent it
  	// from overriding width and height when it loads the src
  	if (img.attributes.width || img.attributes.height) {
  		img.node.addEventListener("load", loadHandler = function () {
  			var width = img.getAttribute("width"),
  			    height = img.getAttribute("height");

  			if (width !== undefined) {
  				img.node.setAttribute("width", width);
  			}

  			if (height !== undefined) {
  				img.node.setAttribute("height", height);
  			}

  			img.node.removeEventListener("load", loadHandler, false);
  		}, false);
  	}
  }

  function form__render(element) {
  	element.node.addEventListener("reset", handleReset, false);
  }

  function form__unrender(element) {
  	element.node.removeEventListener("reset", handleReset, false);
  }

  function handleReset() {
  	var element = this._ractive.proxy;

  	global_runloop.start();
  	element.formBindings.forEach(updateModel);
  	global_runloop.end();
  }

  function updateModel(binding) {
  	binding.root.viewmodel.set(binding.keypath, binding.resetValue);
  }

  var Transition_prototype_init = Transition$init;
  function Transition$init(element, template, isIntro) {
  	var ractive, name, fragment;

  	this.element = element;
  	this.root = ractive = element.root;
  	this.isIntro = isIntro;

  	name = template.n || template;

  	if (typeof name !== "string") {
  		fragment = new virtualdom_Fragment({
  			template: name,
  			root: ractive,
  			owner: element
  		});

  		name = fragment.toString();
  		fragment.unbind();

  		if (name === "") {
  			// empty string okay, just no transition
  			return;
  		}
  	}

  	this.name = name;

  	if (template.a) {
  		this.params = template.a;
  	} else if (template.d) {
  		// TODO is there a way to interpret dynamic arguments without all the
  		// 'dependency thrashing'?
  		fragment = new virtualdom_Fragment({
  			template: template.d,
  			root: ractive,
  			owner: element
  		});

  		this.params = fragment.getArgsList();
  		fragment.unbind();
  	}

  	this._fn = findInViewHierarchy("transitions", ractive, name);

  	if (!this._fn) {
  		warnOnceIfDebug(missingPlugin(name, "transition"), { ractive: this.root });
  	}
  }

  var camelCase = function (hyphenatedStr) {
  	return hyphenatedStr.replace(/-([a-zA-Z])/g, function (match, $1) {
  		return $1.toUpperCase();
  	});
  };

  var helpers_prefix__prefix, prefixCache, helpers_prefix__testStyle;

  if (!isClient) {
  	helpers_prefix__prefix = null;
  } else {
  	prefixCache = {};
  	helpers_prefix__testStyle = createElement("div").style;

  	helpers_prefix__prefix = function (prop) {
  		var i, vendor, capped;

  		prop = camelCase(prop);

  		if (!prefixCache[prop]) {
  			if (helpers_prefix__testStyle[prop] !== undefined) {
  				prefixCache[prop] = prop;
  			} else {
  				// test vendors...
  				capped = prop.charAt(0).toUpperCase() + prop.substring(1);

  				i = vendors.length;
  				while (i--) {
  					vendor = vendors[i];
  					if (helpers_prefix__testStyle[vendor + capped] !== undefined) {
  						prefixCache[prop] = vendor + capped;
  						break;
  					}
  				}
  			}
  		}

  		return prefixCache[prop];
  	};
  }

  var helpers_prefix = helpers_prefix__prefix;

  var getStyle, prototype_getStyle__getComputedStyle;

  if (!isClient) {
  	getStyle = null;
  } else {
  	prototype_getStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;

  	getStyle = function (props) {
  		var computedStyle, styles, i, prop, value;

  		computedStyle = prototype_getStyle__getComputedStyle(this.node);

  		if (typeof props === "string") {
  			value = computedStyle[helpers_prefix(props)];
  			if (value === "0px") {
  				value = 0;
  			}
  			return value;
  		}

  		if (!isArray(props)) {
  			throw new Error("Transition$getStyle must be passed a string, or an array of strings representing CSS properties");
  		}

  		styles = {};

  		i = props.length;
  		while (i--) {
  			prop = props[i];
  			value = computedStyle[helpers_prefix(prop)];
  			if (value === "0px") {
  				value = 0;
  			}
  			styles[prop] = value;
  		}

  		return styles;
  	};
  }

  var prototype_getStyle = getStyle;

  var setStyle = function (style, value) {
  	var prop;

  	if (typeof style === "string") {
  		this.node.style[helpers_prefix(style)] = value;
  	} else {
  		for (prop in style) {
  			if (style.hasOwnProperty(prop)) {
  				this.node.style[helpers_prefix(prop)] = style[prop];
  			}
  		}
  	}

  	return this;
  };

  var Ticker = function (options) {
  	var easing;

  	this.duration = options.duration;
  	this.step = options.step;
  	this.complete = options.complete;

  	// easing
  	if (typeof options.easing === "string") {
  		easing = options.root.easing[options.easing];

  		if (!easing) {
  			warnOnceIfDebug(missingPlugin(options.easing, "easing"));
  			easing = linear;
  		}
  	} else if (typeof options.easing === "function") {
  		easing = options.easing;
  	} else {
  		easing = linear;
  	}

  	this.easing = easing;

  	this.start = utils_getTime();
  	this.end = this.start + this.duration;

  	this.running = true;
  	shared_animations.add(this);
  };

  Ticker.prototype = {
  	tick: function (now) {
  		var elapsed, eased;

  		if (!this.running) {
  			return false;
  		}

  		if (now > this.end) {
  			if (this.step) {
  				this.step(1);
  			}

  			if (this.complete) {
  				this.complete(1);
  			}

  			return false;
  		}

  		elapsed = now - this.start;
  		eased = this.easing(elapsed / this.duration);

  		if (this.step) {
  			this.step(eased);
  		}

  		return true;
  	},

  	stop: function () {
  		if (this.abort) {
  			this.abort();
  		}

  		this.running = false;
  	}
  };

  var shared_Ticker = Ticker;
  function linear(t) {
  	return t;
  }

  var unprefixPattern = new RegExp("^-(?:" + vendors.join("|") + ")-");

  var unprefix = function (prop) {
  	return prop.replace(unprefixPattern, "");
  };

  var vendorPattern = new RegExp("^(?:" + vendors.join("|") + ")([A-Z])");

  var hyphenate = function (str) {
  	var hyphenated;

  	if (!str) {
  		return ""; // edge case
  	}

  	if (vendorPattern.test(str)) {
  		str = "-" + str;
  	}

  	hyphenated = str.replace(/[A-Z]/g, function (match) {
  		return "-" + match.toLowerCase();
  	});

  	return hyphenated;
  };

  var createTransitions,
      animateStyle_createTransitions__testStyle,
      TRANSITION,
      TRANSITIONEND,
      CSS_TRANSITIONS_ENABLED,
      TRANSITION_DURATION,
      TRANSITION_PROPERTY,
      TRANSITION_TIMING_FUNCTION,
      canUseCssTransitions = {},
      cannotUseCssTransitions = {};

  if (!isClient) {
  	createTransitions = null;
  } else {
  	animateStyle_createTransitions__testStyle = createElement("div").style;

  	// determine some facts about our environment
  	(function () {
  		if (animateStyle_createTransitions__testStyle.transition !== undefined) {
  			TRANSITION = "transition";
  			TRANSITIONEND = "transitionend";
  			CSS_TRANSITIONS_ENABLED = true;
  		} else if (animateStyle_createTransitions__testStyle.webkitTransition !== undefined) {
  			TRANSITION = "webkitTransition";
  			TRANSITIONEND = "webkitTransitionEnd";
  			CSS_TRANSITIONS_ENABLED = true;
  		} else {
  			CSS_TRANSITIONS_ENABLED = false;
  		}
  	})();

  	if (TRANSITION) {
  		TRANSITION_DURATION = TRANSITION + "Duration";
  		TRANSITION_PROPERTY = TRANSITION + "Property";
  		TRANSITION_TIMING_FUNCTION = TRANSITION + "TimingFunction";
  	}

  	createTransitions = function (t, to, options, changedProperties, resolve) {

  		// Wait a beat (otherwise the target styles will be applied immediately)
  		// TODO use a fastdom-style mechanism?
  		setTimeout(function () {

  			var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;

  			checkComplete = function () {
  				if (jsTransitionsComplete && cssTransitionsComplete) {
  					// will changes to events and fire have an unexpected consequence here?
  					t.root.fire(t.name + ":end", t.node, t.isIntro);
  					resolve();
  				}
  			};

  			// this is used to keep track of which elements can use CSS to animate
  			// which properties
  			hashPrefix = (t.node.namespaceURI || "") + t.node.tagName;

  			t.node.style[TRANSITION_PROPERTY] = changedProperties.map(helpers_prefix).map(hyphenate).join(",");
  			t.node.style[TRANSITION_TIMING_FUNCTION] = hyphenate(options.easing || "linear");
  			t.node.style[TRANSITION_DURATION] = options.duration / 1000 + "s";

  			transitionEndHandler = function (event) {
  				var index;

  				index = changedProperties.indexOf(camelCase(unprefix(event.propertyName)));
  				if (index !== -1) {
  					changedProperties.splice(index, 1);
  				}

  				if (changedProperties.length) {
  					// still transitioning...
  					return;
  				}

  				t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);

  				cssTransitionsComplete = true;
  				checkComplete();
  			};

  			t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);

  			setTimeout(function () {
  				var i = changedProperties.length,
  				    hash,
  				    originalValue,
  				    index,
  				    propertiesToTransitionInJs = [],
  				    prop,
  				    suffix;

  				while (i--) {
  					prop = changedProperties[i];
  					hash = hashPrefix + prop;

  					if (CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {
  						t.node.style[helpers_prefix(prop)] = to[prop];

  						// If we're not sure if CSS transitions are supported for
  						// this tag/property combo, find out now
  						if (!canUseCssTransitions[hash]) {
  							originalValue = t.getStyle(prop);

  							// if this property is transitionable in this browser,
  							// the current style will be different from the target style
  							canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];
  							cannotUseCssTransitions[hash] = !canUseCssTransitions[hash];

  							// Reset, if we're going to use timers after all
  							if (cannotUseCssTransitions[hash]) {
  								t.node.style[helpers_prefix(prop)] = originalValue;
  							}
  						}
  					}

  					if (!CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {
  						// we need to fall back to timer-based stuff
  						if (originalValue === undefined) {
  							originalValue = t.getStyle(prop);
  						}

  						// need to remove this from changedProperties, otherwise transitionEndHandler
  						// will get confused
  						index = changedProperties.indexOf(prop);
  						if (index === -1) {
  							warnIfDebug("Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!", { node: t.node });
  						} else {
  							changedProperties.splice(index, 1);
  						}

  						// TODO Determine whether this property is animatable at all

  						suffix = /[^\d]*$/.exec(to[prop])[0];

  						// ...then kick off a timer-based transition
  						propertiesToTransitionInJs.push({
  							name: helpers_prefix(prop),
  							interpolator: shared_interpolate(parseFloat(originalValue), parseFloat(to[prop])),
  							suffix: suffix
  						});
  					}
  				}

  				// javascript transitions
  				if (propertiesToTransitionInJs.length) {
  					new shared_Ticker({
  						root: t.root,
  						duration: options.duration,
  						easing: camelCase(options.easing || ""),
  						step: function (pos) {
  							var prop, i;

  							i = propertiesToTransitionInJs.length;
  							while (i--) {
  								prop = propertiesToTransitionInJs[i];
  								t.node.style[prop.name] = prop.interpolator(pos) + prop.suffix;
  							}
  						},
  						complete: function () {
  							jsTransitionsComplete = true;
  							checkComplete();
  						}
  					});
  				} else {
  					jsTransitionsComplete = true;
  				}

  				if (!changedProperties.length) {
  					// We need to cancel the transitionEndHandler, and deal with
  					// the fact that it will never fire
  					t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);
  					cssTransitionsComplete = true;
  					checkComplete();
  				}
  			}, 0);
  		}, options.delay || 0);
  	};
  }

  var animateStyle_createTransitions = createTransitions;

  var hidden, vendor, animateStyle_visibility__prefix, animateStyle_visibility__i, visibility;

  if (typeof document !== "undefined") {
  	hidden = "hidden";

  	visibility = {};

  	if (hidden in document) {
  		animateStyle_visibility__prefix = "";
  	} else {
  		animateStyle_visibility__i = vendors.length;
  		while (animateStyle_visibility__i--) {
  			vendor = vendors[animateStyle_visibility__i];
  			hidden = vendor + "Hidden";

  			if (hidden in document) {
  				animateStyle_visibility__prefix = vendor;
  			}
  		}
  	}

  	if (animateStyle_visibility__prefix !== undefined) {
  		document.addEventListener(animateStyle_visibility__prefix + "visibilitychange", onChange);

  		// initialise
  		onChange();
  	} else {
  		// gah, we're in an old browser
  		if ("onfocusout" in document) {
  			document.addEventListener("focusout", onHide);
  			document.addEventListener("focusin", onShow);
  		} else {
  			window.addEventListener("pagehide", onHide);
  			window.addEventListener("blur", onHide);

  			window.addEventListener("pageshow", onShow);
  			window.addEventListener("focus", onShow);
  		}

  		visibility.hidden = false; // until proven otherwise. Not ideal but hey
  	}
  }

  function onChange() {
  	visibility.hidden = document[hidden];
  }

  function onHide() {
  	visibility.hidden = true;
  }

  function onShow() {
  	visibility.hidden = false;
  }

  var animateStyle_visibility = visibility;

  var animateStyle, _animateStyle__getComputedStyle, resolved;

  if (!isClient) {
  	animateStyle = null;
  } else {
  	_animateStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;

  	animateStyle = function (style, value, options) {
  		var _this = this;

  		var to;

  		if (arguments.length === 4) {
  			throw new Error("t.animateStyle() returns a promise - use .then() instead of passing a callback");
  		}

  		// Special case - page isn't visible. Don't animate anything, because
  		// that way you'll never get CSS transitionend events
  		if (animateStyle_visibility.hidden) {
  			this.setStyle(style, value);
  			return resolved || (resolved = utils_Promise.resolve());
  		}

  		if (typeof style === "string") {
  			to = {};
  			to[style] = value;
  		} else {
  			to = style;

  			// shuffle arguments
  			options = value;
  		}

  		// As of 0.3.9, transition authors should supply an `option` object with
  		// `duration` and `easing` properties (and optional `delay`), plus a
  		// callback function that gets called after the animation completes

  		// TODO remove this check in a future version
  		if (!options) {
  			warnOnceIfDebug("The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340", this.name);
  			options = this;
  		}

  		var promise = new utils_Promise(function (resolve) {
  			var propertyNames, changedProperties, computedStyle, current, from, i, prop;

  			// Edge case - if duration is zero, set style synchronously and complete
  			if (!options.duration) {
  				_this.setStyle(to);
  				resolve();
  				return;
  			}

  			// Get a list of the properties we're animating
  			propertyNames = Object.keys(to);
  			changedProperties = [];

  			// Store the current styles
  			computedStyle = _animateStyle__getComputedStyle(_this.node);

  			from = {};
  			i = propertyNames.length;
  			while (i--) {
  				prop = propertyNames[i];
  				current = computedStyle[helpers_prefix(prop)];

  				if (current === "0px") {
  					current = 0;
  				}

  				// we need to know if we're actually changing anything
  				if (current != to[prop]) {
  					// use != instead of !==, so we can compare strings with numbers
  					changedProperties.push(prop);

  					// make the computed style explicit, so we can animate where
  					// e.g. height='auto'
  					_this.node.style[helpers_prefix(prop)] = current;
  				}
  			}

  			// If we're not actually changing anything, the transitionend event
  			// will never fire! So we complete early
  			if (!changedProperties.length) {
  				resolve();
  				return;
  			}

  			animateStyle_createTransitions(_this, to, options, changedProperties, resolve);
  		});

  		return promise;
  	};
  }

  var _animateStyle = animateStyle;

  var processParams = function (params, defaults) {
  	if (typeof params === "number") {
  		params = { duration: params };
  	} else if (typeof params === "string") {
  		if (params === "slow") {
  			params = { duration: 600 };
  		} else if (params === "fast") {
  			params = { duration: 200 };
  		} else {
  			params = { duration: 400 };
  		}
  	} else if (!params) {
  		params = {};
  	}

  	return fillGaps({}, params, defaults);
  };

  var prototype_start = Transition$start;

  function Transition$start() {
  	var _this = this;

  	var node, originalStyle, completed;

  	node = this.node = this.element.node;
  	originalStyle = node.getAttribute("style");

  	// create t.complete() - we don't want this on the prototype,
  	// because we don't want `this` silliness when passing it as
  	// an argument
  	this.complete = function (noReset) {
  		if (completed) {
  			return;
  		}

  		if (!noReset && _this.isIntro) {
  			resetStyle(node, originalStyle);
  		}

  		node._ractive.transition = null;
  		_this._manager.remove(_this);

  		completed = true;
  	};

  	// If the transition function doesn't exist, abort
  	if (!this._fn) {
  		this.complete();
  		return;
  	}

  	this._fn.apply(this.root, [this].concat(this.params));
  }

  function resetStyle(node, style) {
  	if (style) {
  		node.setAttribute("style", style);
  	} else {

  		// Next line is necessary, to remove empty style attribute!
  		// See http://stackoverflow.com/a/7167553
  		node.getAttribute("style");
  		node.removeAttribute("style");
  	}
  }

  var Transition = function (owner, template, isIntro) {
  	this.init(owner, template, isIntro);
  };

  Transition.prototype = {
  	init: Transition_prototype_init,
  	start: prototype_start,
  	getStyle: prototype_getStyle,
  	setStyle: setStyle,
  	animateStyle: _animateStyle,
  	processParams: processParams
  };

  var _Transition = Transition;

  var Element_prototype_render = Element$render;

  var updateCss, updateScript;

  updateCss = function () {
  	var node = this.node,
  	    content = this.fragment.toString(false);

  	// IE8 has no styleSheet unless there's a type text/css
  	if (window && window.appearsToBeIELessEqual8) {
  		node.type = "text/css";
  	}

  	if (node.styleSheet) {
  		node.styleSheet.cssText = content;
  	} else {

  		while (node.hasChildNodes()) {
  			node.removeChild(node.firstChild);
  		}

  		node.appendChild(document.createTextNode(content));
  	}
  };

  updateScript = function () {
  	if (!this.node.type || this.node.type === "text/javascript") {
  		warnIfDebug("Script tag was updated. This does not cause the code to be re-evaluated!", { ractive: this.root });
  		// As it happens, we ARE in a position to re-evaluate the code if we wanted
  		// to - we could eval() it, or insert it into a fresh (temporary) script tag.
  		// But this would be a terrible idea with unpredictable results, so let's not.
  	}

  	this.node.text = this.fragment.toString(false);
  };
  function Element$render() {
  	var _this = this;

  	var root = this.root,
  	    namespace,
  	    node,
  	    transition;

  	namespace = getNamespace(this);
  	node = this.node = createElement(this.name, namespace);

  	// Is this a top-level node of a component? If so, we may need to add
  	// a data-ractive-css attribute, for CSS encapsulation
  	if (this.parentFragment.cssIds) {
  		this.node.setAttribute("data-ractive-css", this.parentFragment.cssIds.map(function (x) {
  			return "{" + x + "}";
  		}).join(" "));
  	}

  	// Add _ractive property to the node - we use this object to store stuff
  	// related to proxy events, two-way bindings etc
  	defineProperty(this.node, "_ractive", {
  		value: {
  			proxy: this,
  			keypath: getInnerContext(this.parentFragment),
  			events: create(null),
  			root: root
  		}
  	});

  	// Render attributes
  	this.attributes.forEach(function (a) {
  		return a.render(node);
  	});
  	this.conditionalAttributes.forEach(function (a) {
  		return a.render(node);
  	});

  	// Render children
  	if (this.fragment) {
  		// Special case - <script> element
  		if (this.name === "script") {
  			this.bubble = updateScript;
  			this.node.text = this.fragment.toString(false); // bypass warning initially
  			this.fragment.unrender = noop; // TODO this is a kludge
  		}

  		// Special case - <style> element
  		else if (this.name === "style") {
  			this.bubble = updateCss;
  			this.bubble();
  			this.fragment.unrender = noop;
  		}

  		// Special case - contenteditable
  		else if (this.binding && this.getAttribute("contenteditable")) {
  			this.fragment.unrender = noop;
  		} else {
  			this.node.appendChild(this.fragment.render());
  		}
  	}

  	// deal with two-way bindings
  	if (this.binding) {
  		this.binding.render();
  		this.node._ractive.binding = this.binding;
  	}

  	// Add proxy event handlers
  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(function (h) {
  			return h.render();
  		});
  	}

  	if (this.name === "option") {
  		processOption(this);
  	}

  	// Special cases
  	if (this.name === "img") {
  		// if this is an <img>, and we're in a crap browser, we may
  		// need to prevent it from overriding width and height when
  		// it loads the src
  		special_img__render(this);
  	} else if (this.name === "form") {
  		// forms need to keep track of their bindings, in case of reset
  		form__render(this);
  	} else if (this.name === "input" || this.name === "textarea") {
  		// inputs and textareas should store their initial value as
  		// `defaultValue` in case of reset
  		this.node.defaultValue = this.node.value;
  	} else if (this.name === "option") {
  		// similarly for option nodes
  		this.node.defaultSelected = this.node.selected;
  	}

  	// apply decorator(s)
  	if (this.decorator && this.decorator.fn) {
  		global_runloop.scheduleTask(function () {
  			if (!_this.decorator.torndown) {
  				_this.decorator.init();
  			}
  		}, true);
  	}

  	// trigger intro transition
  	if (root.transitionsEnabled && this.intro) {
  		transition = new _Transition(this, this.intro, true);
  		global_runloop.registerTransition(transition);
  		global_runloop.scheduleTask(function () {
  			return transition.start();
  		}, true);

  		this.transition = transition;
  	}

  	if (this.node.autofocus) {
  		// Special case. Some browsers (*cough* Firefix *cough*) have a problem
  		// with dynamically-generated elements having autofocus, and they won't
  		// allow you to programmatically focus the element until it's in the DOM
  		global_runloop.scheduleTask(function () {
  			return _this.node.focus();
  		}, true);
  	}

  	updateLiveQueries(this);
  	return this.node;
  }

  function getNamespace(element) {
  	var namespace, xmlns, parent;

  	// Use specified namespace...
  	if (xmlns = element.getAttribute("xmlns")) {
  		namespace = xmlns;
  	}

  	// ...or SVG namespace, if this is an <svg> element
  	else if (element.name === "svg") {
  		namespace = namespaces.svg;
  	} else if (parent = element.parent) {
  		// ...or HTML, if the parent is a <foreignObject>
  		if (parent.name === "foreignObject") {
  			namespace = namespaces.html;
  		}

  		// ...or inherit from the parent node
  		else {
  			namespace = parent.node.namespaceURI;
  		}
  	} else {
  		namespace = element.root.el.namespaceURI;
  	}

  	return namespace;
  }

  function processOption(option) {
  	var optionValue, selectValue, i;

  	if (!option.select) {
  		return;
  	}

  	selectValue = option.select.getAttribute("value");
  	if (selectValue === undefined) {
  		return;
  	}

  	optionValue = option.getAttribute("value");

  	if (option.select.node.multiple && isArray(selectValue)) {
  		i = selectValue.length;
  		while (i--) {
  			if (optionValue == selectValue[i]) {
  				option.node.selected = true;
  				break;
  			}
  		}
  	} else {
  		option.node.selected = optionValue == selectValue;
  	}
  }

  function updateLiveQueries(element) {
  	var instance, liveQueries, i, selector, query;

  	// Does this need to be added to any live queries?
  	instance = element.root;

  	do {
  		liveQueries = instance._liveQueries;

  		i = liveQueries.length;
  		while (i--) {
  			selector = liveQueries[i];
  			query = liveQueries["_" + selector];

  			if (query._test(element)) {
  				// keep register of applicable selectors, for when we teardown
  				(element.liveQueries || (element.liveQueries = [])).push(query);
  			}
  		}
  	} while (instance = instance.parent);
  }

  var Element_prototype_toString = function () {
  	var str, escape;

  	if (this.template.y) {
  		// DOCTYPE declaration
  		return "<!DOCTYPE" + this.template.dd + ">";
  	}

  	str = "<" + this.template.e;

  	str += this.attributes.map(stringifyAttribute).join("") + this.conditionalAttributes.map(stringifyAttribute).join("");

  	// Special case - selected options
  	if (this.name === "option" && optionIsSelected(this)) {
  		str += " selected";
  	}

  	// Special case - two-way radio name bindings
  	if (this.name === "input" && inputIsCheckedRadio(this)) {
  		str += " checked";
  	}

  	str += ">";

  	// Special case - textarea
  	if (this.name === "textarea" && this.getAttribute("value") !== undefined) {
  		str += escapeHtml(this.getAttribute("value"));
  	}

  	// Special case - contenteditable
  	else if (this.getAttribute("contenteditable") !== undefined) {
  		str += this.getAttribute("value") || "";
  	}

  	if (this.fragment) {
  		escape = this.name !== "script" && this.name !== "style";
  		str += this.fragment.toString(escape);
  	}

  	// add a closing tag if this isn't a void element
  	if (!voidElementNames.test(this.template.e)) {
  		str += "</" + this.template.e + ">";
  	}

  	return str;
  };

  function optionIsSelected(element) {
  	var optionValue, selectValue, i;

  	optionValue = element.getAttribute("value");

  	if (optionValue === undefined || !element.select) {
  		return false;
  	}

  	selectValue = element.select.getAttribute("value");

  	if (selectValue == optionValue) {
  		return true;
  	}

  	if (element.select.getAttribute("multiple") && isArray(selectValue)) {
  		i = selectValue.length;
  		while (i--) {
  			if (selectValue[i] == optionValue) {
  				return true;
  			}
  		}
  	}
  }

  function inputIsCheckedRadio(element) {
  	var attributes, typeAttribute, valueAttribute, nameAttribute;

  	attributes = element.attributes;

  	typeAttribute = attributes.type;
  	valueAttribute = attributes.value;
  	nameAttribute = attributes.name;

  	if (!typeAttribute || typeAttribute.value !== "radio" || !valueAttribute || !nameAttribute.interpolator) {
  		return;
  	}

  	if (valueAttribute.value === nameAttribute.interpolator.value) {
  		return true;
  	}
  }

  function stringifyAttribute(attribute) {
  	var str = attribute.toString();
  	return str ? " " + str : "";
  }

  var Element_prototype_unbind = Element$unbind;
  function Element$unbind() {
  	if (this.fragment) {
  		this.fragment.unbind();
  	}

  	if (this.binding) {
  		this.binding.unbind();
  	}

  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(methodCallers__unbind);
  	}

  	// Special case - <option>
  	if (this.name === "option") {
  		special_option__unbind(this);
  	}

  	this.attributes.forEach(methodCallers__unbind);
  	this.conditionalAttributes.forEach(methodCallers__unbind);
  }

  var Element_prototype_unrender = Element$unrender;

  function Element$unrender(shouldDestroy) {
  	var binding, bindings, transition;

  	if (transition = this.transition) {
  		transition.complete();
  	}

  	// Detach as soon as we can
  	if (this.name === "option") {
  		// <option> elements detach immediately, so that
  		// their parent <select> element syncs correctly, and
  		// since option elements can't have transitions anyway
  		this.detach();
  	} else if (shouldDestroy) {
  		global_runloop.detachWhenReady(this);
  	}

  	// Children first. that way, any transitions on child elements will be
  	// handled by the current transitionManager
  	if (this.fragment) {
  		this.fragment.unrender(false);
  	}

  	if (binding = this.binding) {
  		this.binding.unrender();

  		this.node._ractive.binding = null;
  		bindings = this.root._twowayBindings[binding.keypath.str];
  		bindings.splice(bindings.indexOf(binding), 1);
  	}

  	// Remove event handlers
  	if (this.eventHandlers) {
  		this.eventHandlers.forEach(methodCallers__unrender);
  	}

  	if (this.decorator) {
  		global_runloop.registerDecorator(this.decorator);
  	}

  	// trigger outro transition if necessary
  	if (this.root.transitionsEnabled && this.outro) {
  		transition = new _Transition(this, this.outro, false);
  		global_runloop.registerTransition(transition);
  		global_runloop.scheduleTask(function () {
  			return transition.start();
  		});
  	}

  	// Remove this node from any live queries
  	if (this.liveQueries) {
  		removeFromLiveQueries(this);
  	}

  	if (this.name === "form") {
  		form__unrender(this);
  	}
  }

  function removeFromLiveQueries(element) {
  	var query, selector, i;

  	i = element.liveQueries.length;
  	while (i--) {
  		query = element.liveQueries[i];
  		selector = query.selector;

  		query._remove(element.node);
  	}
  }

  var Element = function (options) {
  	this.init(options);
  };

  Element.prototype = {
  	bubble: Element_prototype_bubble,
  	detach: Element_prototype_detach,
  	find: Element_prototype_find,
  	findAll: Element_prototype_findAll,
  	findAllComponents: Element_prototype_findAllComponents,
  	findComponent: Element_prototype_findComponent,
  	findNextNode: Element_prototype_findNextNode,
  	firstNode: Element_prototype_firstNode,
  	getAttribute: getAttribute,
  	init: Element_prototype_init,
  	rebind: Element_prototype_rebind,
  	render: Element_prototype_render,
  	toString: Element_prototype_toString,
  	unbind: Element_prototype_unbind,
  	unrender: Element_prototype_unrender
  };

  var _Element = Element;

  var deIndent__empty = /^\s*$/,
      deIndent__leadingWhitespace = /^\s*/;

  var deIndent = function (str) {
  	var lines, firstLine, lastLine, minIndent;

  	lines = str.split("\n");

  	// remove first and last line, if they only contain whitespace
  	firstLine = lines[0];
  	if (firstLine !== undefined && deIndent__empty.test(firstLine)) {
  		lines.shift();
  	}

  	lastLine = lastItem(lines);
  	if (lastLine !== undefined && deIndent__empty.test(lastLine)) {
  		lines.pop();
  	}

  	minIndent = lines.reduce(reducer, null);

  	if (minIndent) {
  		str = lines.map(function (line) {
  			return line.replace(minIndent, "");
  		}).join("\n");
  	}

  	return str;
  };

  function reducer(previous, line) {
  	var lineIndent = deIndent__leadingWhitespace.exec(line)[0];

  	if (previous === null || lineIndent.length < previous.length) {
  		return lineIndent;
  	}

  	return previous;
  }

  var Partial_getPartialTemplate = getPartialTemplate;

  function getPartialTemplate(ractive, name, parentFragment) {
  	var partial;

  	// If the partial in instance or view heirarchy instances, great
  	if (partial = getPartialFromRegistry(ractive, name, parentFragment || {})) {
  		return partial;
  	}

  	// Does it exist on the page as a script tag?
  	partial = template_parser.fromId(name, { noThrow: true });

  	if (partial) {
  		// is this necessary?
  		partial = deIndent(partial);

  		// parse and register to this ractive instance
  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(ractive));

  		// register (and return main partial if there are others in the template)
  		return ractive.partials[name] = parsed.t;
  	}
  }

  function getPartialFromRegistry(ractive, name, parentFragment) {
  	var fn = undefined,
  	    partial = findParentPartial(name, parentFragment.owner);

  	// if there was an instance up-hierarchy, cool
  	if (partial) return partial;

  	// find first instance in the ractive or view hierarchy that has this partial
  	var instance = findInstance("partials", ractive, name);

  	if (!instance) {
  		return;
  	}

  	partial = instance.partials[name];

  	// partial is a function?
  	if (typeof partial === "function") {
  		fn = partial.bind(instance);
  		fn.isOwner = instance.partials.hasOwnProperty(name);
  		partial = fn.call(ractive, template_parser);
  	}

  	if (!partial && partial !== "") {
  		warnIfDebug(noRegistryFunctionReturn, name, "partial", "partial", { ractive: ractive });
  		return;
  	}

  	// If this was added manually to the registry,
  	// but hasn't been parsed, parse it now
  	if (!template_parser.isParsed(partial)) {

  		// use the parseOptions of the ractive instance on which it was found
  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(instance));

  		// Partials cannot contain nested partials!
  		// TODO add a test for this
  		if (parsed.p) {
  			warnIfDebug("Partials ({{>%s}}) cannot contain nested inline partials", name, { ractive: ractive });
  		}

  		// if fn, use instance to store result, otherwise needs to go
  		// in the correct point in prototype chain on instance or constructor
  		var target = fn ? instance : findOwner(instance, name);

  		// may be a template with partials, which need to be registered and main template extracted
  		target.partials[name] = partial = parsed.t;
  	}

  	// store for reset
  	if (fn) {
  		partial._fn = fn;
  	}

  	return partial.v ? partial.t : partial;
  }

  function findOwner(ractive, key) {
  	return ractive.partials.hasOwnProperty(key) ? ractive : findConstructor(ractive.constructor, key);
  }

  function findConstructor(constructor, key) {
  	if (!constructor) {
  		return;
  	}
  	return constructor.partials.hasOwnProperty(key) ? constructor : findConstructor(constructor._Parent, key);
  }

  function findParentPartial(name, parent) {
  	if (parent) {
  		if (parent.template && parent.template.p && parent.template.p[name]) {
  			return parent.template.p[name];
  		} else if (parent.parentFragment && parent.parentFragment.owner) {
  			return findParentPartial(name, parent.parentFragment.owner);
  		}
  	}
  }

  var applyIndent = function (string, indent) {
  	var indented;

  	if (!indent) {
  		return string;
  	}

  	indented = string.split("\n").map(function (line, notFirstLine) {
  		return notFirstLine ? indent + line : line;
  	}).join("\n");

  	return indented;
  };

  var missingPartialMessage = "Could not find template for partial \"%s\"";

  var Partial = function (options) {
  	var parentFragment, template;

  	parentFragment = this.parentFragment = options.parentFragment;

  	this.root = parentFragment.root;
  	this.type = PARTIAL;
  	this.index = options.index;
  	this.name = options.template.r;
  	this.rendered = false;

  	this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;

  	Mustache.init(this, options);

  	// If this didn't resolve, it most likely means we have a named partial
  	// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial
  	// whose name is the value of `foo`')
  	if (!this.keypath) {
  		if (template = Partial_getPartialTemplate(this.root, this.name, parentFragment)) {
  			shared_unbind.call(this); // prevent any further changes
  			this.isNamed = true;
  			this.setTemplate(template);
  		} else {
  			warnOnceIfDebug(missingPartialMessage, this.name);
  		}
  	}
  };

  Partial.prototype = {
  	bubble: function () {
  		this.parentFragment.bubble();
  	},

  	detach: function () {
  		return this.fragment.detach();
  	},

  	find: function (selector) {
  		return this.fragment.find(selector);
  	},

  	findAll: function (selector, query) {
  		return this.fragment.findAll(selector, query);
  	},

  	findComponent: function (selector) {
  		return this.fragment.findComponent(selector);
  	},

  	findAllComponents: function (selector, query) {
  		return this.fragment.findAllComponents(selector, query);
  	},

  	firstNode: function () {
  		return this.fragment.firstNode();
  	},

  	findNextNode: function () {
  		return this.parentFragment.findNextNode(this);
  	},

  	getPartialName: function () {
  		if (this.isNamed && this.name) return this.name;else if (this.value === undefined) return this.name;else return this.value;
  	},

  	getValue: function () {
  		return this.fragment.getValue();
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		// named partials aren't bound, so don't rebind
  		if (!this.isNamed) {
  			Mustache_rebind.call(this, oldKeypath, newKeypath);
  		}

  		if (this.fragment) {
  			this.fragment.rebind(oldKeypath, newKeypath);
  		}
  	},

  	render: function () {
  		this.docFrag = document.createDocumentFragment();
  		this.update();

  		this.rendered = true;
  		return this.docFrag;
  	},

  	resolve: Mustache.resolve,

  	setValue: function (value) {
  		var template;

  		if (value !== undefined && value === this.value) {
  			// nothing has changed, so no work to be done
  			return;
  		}

  		if (value !== undefined) {
  			template = Partial_getPartialTemplate(this.root, "" + value, this.parentFragment);
  		}

  		// we may be here if we have a partial like `{{>foo}}` and `foo` is the
  		// name of both a data property (whose value ISN'T the name of a partial)
  		// and a partial. In those cases, this becomes a named partial
  		if (!template && this.name && (template = Partial_getPartialTemplate(this.root, this.name, this.parentFragment))) {
  			shared_unbind.call(this);
  			this.isNamed = true;
  		}

  		if (!template) {
  			warnOnceIfDebug(missingPartialMessage, this.name, { ractive: this.root });
  		}

  		this.value = value;

  		this.setTemplate(template || []);

  		this.bubble();

  		if (this.rendered) {
  			global_runloop.addView(this);
  		}
  	},

  	setTemplate: function (template) {
  		if (this.fragment) {
  			this.fragment.unbind();
  			if (this.rendered) {
  				this.fragmentToUnrender = this.fragment;
  			}
  		}

  		this.fragment = new virtualdom_Fragment({
  			template: template,
  			root: this.root,
  			owner: this,
  			pElement: this.parentFragment.pElement
  		});

  		this.fragmentToRender = this.fragment;
  	},

  	toString: function (toString) {
  		var string, previousItem, lastLine, match;

  		string = this.fragment.toString(toString);

  		previousItem = this.parentFragment.items[this.index - 1];

  		if (!previousItem || previousItem.type !== TEXT) {
  			return string;
  		}

  		lastLine = previousItem.text.split("\n").pop();

  		if (match = /^\s+$/.exec(lastLine)) {
  			return applyIndent(string, match[0]);
  		}

  		return string;
  	},

  	unbind: function () {
  		if (!this.isNamed) {
  			// dynamic partial - need to unbind self
  			shared_unbind.call(this);
  		}

  		if (this.fragment) {
  			this.fragment.unbind();
  		}
  	},

  	unrender: function (shouldDestroy) {
  		if (this.rendered) {
  			if (this.fragment) {
  				this.fragment.unrender(shouldDestroy);
  			}
  			this.rendered = false;
  		}
  	},

  	update: function () {
  		var target, anchor;

  		if (this.fragmentToUnrender) {
  			this.fragmentToUnrender.unrender(true);
  			this.fragmentToUnrender = null;
  		}

  		if (this.fragmentToRender) {
  			this.docFrag.appendChild(this.fragmentToRender.render());
  			this.fragmentToRender = null;
  		}

  		if (this.rendered) {
  			target = this.parentFragment.getNode();
  			anchor = this.parentFragment.findNextNode(this);
  			target.insertBefore(this.docFrag, anchor);
  		}
  	}
  };

  var _Partial = Partial;

  // finds the component constructor in the registry or view hierarchy registries

  var Component_getComponent = getComponent;
  function getComponent(ractive, name) {

  	var Component,
  	    instance = findInstance("components", ractive, name);

  	if (instance) {
  		Component = instance.components[name];

  		// best test we have for not Ractive.extend
  		if (!Component._Parent) {
  			// function option, execute and store for reset
  			var fn = Component.bind(instance);
  			fn.isOwner = instance.components.hasOwnProperty(name);
  			Component = fn();

  			if (!Component) {
  				warnIfDebug(noRegistryFunctionReturn, name, "component", "component", { ractive: ractive });

  				return;
  			}

  			if (typeof Component === "string") {
  				// allow string lookup
  				Component = getComponent(ractive, Component);
  			}

  			Component._fn = fn;
  			instance.components[name] = Component;
  		}
  	}

  	return Component;
  }

  var Component_prototype_detach = Component$detach;
  var Component_prototype_detach__detachHook = new hooks_Hook("detach");
  function Component$detach() {
  	var detached = this.instance.fragment.detach();
  	Component_prototype_detach__detachHook.fire(this.instance);
  	return detached;
  }

  var Component_prototype_find = Component$find;

  function Component$find(selector) {
  	return this.instance.fragment.find(selector);
  }

  var Component_prototype_findAll = Component$findAll;

  function Component$findAll(selector, query) {
  	return this.instance.fragment.findAll(selector, query);
  }

  var Component_prototype_findAllComponents = Component$findAllComponents;

  function Component$findAllComponents(selector, query) {
  	query._test(this, true);

  	if (this.instance.fragment) {
  		this.instance.fragment.findAllComponents(selector, query);
  	}
  }

  var Component_prototype_findComponent = Component$findComponent;

  function Component$findComponent(selector) {
  	if (!selector || selector === this.name) {
  		return this.instance;
  	}

  	if (this.instance.fragment) {
  		return this.instance.fragment.findComponent(selector);
  	}

  	return null;
  }

  var Component_prototype_findNextNode = Component$findNextNode;

  function Component$findNextNode() {
  	return this.parentFragment.findNextNode(this);
  }

  var Component_prototype_firstNode = Component$firstNode;

  function Component$firstNode() {
  	if (this.rendered) {
  		return this.instance.fragment.firstNode();
  	}

  	return null;
  }

  var processWrapper = function (wrapper, array, methodName, newIndices) {
  	var root = wrapper.root;
  	var keypath = wrapper.keypath;

  	if (!!newIndices) {
  		root.viewmodel.smartUpdate(keypath, array, newIndices);
  	} else {
  		// If this is a sort or reverse, we just do root.set()...
  		// TODO use merge logic?
  		root.viewmodel.mark(keypath);
  	}
  };

  var patchedArrayProto = [],
      mutatorMethods = ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],
      testObj,
      patchArrayMethods,
      unpatchArrayMethods;

  mutatorMethods.forEach(function (methodName) {
  	var method = function () {
  		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
  			args[_key] = arguments[_key];
  		}

  		var newIndices, result, wrapper, i;

  		newIndices = shared_getNewIndices(this, methodName, args);

  		// apply the underlying method
  		result = Array.prototype[methodName].apply(this, arguments);

  		// trigger changes
  		global_runloop.start();

  		this._ractive.setting = true;
  		i = this._ractive.wrappers.length;
  		while (i--) {
  			wrapper = this._ractive.wrappers[i];

  			global_runloop.addRactive(wrapper.root);
  			processWrapper(wrapper, this, methodName, newIndices);
  		}

  		global_runloop.end();

  		this._ractive.setting = false;
  		return result;
  	};

  	defineProperty(patchedArrayProto, methodName, {
  		value: method
  	});
  });

  // can we use prototype chain injection?
  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
  testObj = {};

  if (testObj.__proto__) {
  	// yes, we can
  	patchArrayMethods = function (array) {
  		array.__proto__ = patchedArrayProto;
  	};

  	unpatchArrayMethods = function (array) {
  		array.__proto__ = Array.prototype;
  	};
  } else {
  	// no, we can't
  	patchArrayMethods = function (array) {
  		var i, methodName;

  		i = mutatorMethods.length;
  		while (i--) {
  			methodName = mutatorMethods[i];
  			defineProperty(array, methodName, {
  				value: patchedArrayProto[methodName],
  				configurable: true
  			});
  		}
  	};

  	unpatchArrayMethods = function (array) {
  		var i;

  		i = mutatorMethods.length;
  		while (i--) {
  			delete array[mutatorMethods[i]];
  		}
  	};
  }

  patchArrayMethods.unpatch = unpatchArrayMethods;
  var patch = patchArrayMethods;

  var arrayAdaptor,

  // helpers
  ArrayWrapper, array_index__errorMessage;

  arrayAdaptor = {
  	filter: function (object) {
  		// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
  		// or the array didn't trigger the get() itself
  		return isArray(object) && (!object._ractive || !object._ractive.setting);
  	},
  	wrap: function (ractive, array, keypath) {
  		return new ArrayWrapper(ractive, array, keypath);
  	}
  };

  ArrayWrapper = function (ractive, array, keypath) {
  	this.root = ractive;
  	this.value = array;
  	this.keypath = getKeypath(keypath);

  	// if this array hasn't already been ractified, ractify it
  	if (!array._ractive) {

  		// define a non-enumerable _ractive property to store the wrappers
  		defineProperty(array, "_ractive", {
  			value: {
  				wrappers: [],
  				instances: [],
  				setting: false
  			},
  			configurable: true
  		});

  		patch(array);
  	}

  	// store the ractive instance, so we can handle transitions later
  	if (!array._ractive.instances[ractive._guid]) {
  		array._ractive.instances[ractive._guid] = 0;
  		array._ractive.instances.push(ractive);
  	}

  	array._ractive.instances[ractive._guid] += 1;
  	array._ractive.wrappers.push(this);
  };

  ArrayWrapper.prototype = {
  	get: function () {
  		return this.value;
  	},
  	teardown: function () {
  		var array, storage, wrappers, instances, index;

  		array = this.value;
  		storage = array._ractive;
  		wrappers = storage.wrappers;
  		instances = storage.instances;

  		// if teardown() was invoked because we're clearing the cache as a result of
  		// a change that the array itself triggered, we can save ourselves the teardown
  		// and immediate setup
  		if (storage.setting) {
  			return false; // so that we don't remove it from this.root.viewmodel.wrapped
  		}

  		index = wrappers.indexOf(this);
  		if (index === -1) {
  			throw new Error(array_index__errorMessage);
  		}

  		wrappers.splice(index, 1);

  		// if nothing else depends on this array, we can revert it to its
  		// natural state
  		if (!wrappers.length) {
  			delete array._ractive;
  			patch.unpatch(this.value);
  		} else {
  			// remove ractive instance if possible
  			instances[this.root._guid] -= 1;
  			if (!instances[this.root._guid]) {
  				index = instances.indexOf(this.root);

  				if (index === -1) {
  					throw new Error(array_index__errorMessage);
  				}

  				instances.splice(index, 1);
  			}
  		}
  	}
  };

  array_index__errorMessage = "Something went wrong in a rather interesting way";
  var array_index = arrayAdaptor;

  var numeric = /^\s*[0-9]+\s*$/;

  var createBranch = function (key) {
  	return numeric.test(key) ? [] : {};
  };

  var magicAdaptor, MagicWrapper;

  try {
  	Object.defineProperty({}, "test", { value: 0 });

  	magicAdaptor = {
  		filter: function (object, keypath, ractive) {
  			var parentWrapper, parentValue;

  			if (!keypath) {
  				return false;
  			}

  			keypath = getKeypath(keypath);

  			// If the parent value is a wrapper, other than a magic wrapper,
  			// we shouldn't wrap this property
  			if ((parentWrapper = ractive.viewmodel.wrapped[keypath.parent.str]) && !parentWrapper.magic) {
  				return false;
  			}

  			parentValue = ractive.viewmodel.get(keypath.parent);

  			// if parentValue is an array that doesn't include this member,
  			// we should return false otherwise lengths will get messed up
  			if (isArray(parentValue) && /^[0-9]+$/.test(keypath.lastKey)) {
  				return false;
  			}

  			return parentValue && (typeof parentValue === "object" || typeof parentValue === "function");
  		},
  		wrap: function (ractive, property, keypath) {
  			return new MagicWrapper(ractive, property, keypath);
  		}
  	};

  	MagicWrapper = function (ractive, value, keypath) {
  		var objKeypath, template, siblings;

  		keypath = getKeypath(keypath);

  		this.magic = true;

  		this.ractive = ractive;
  		this.keypath = keypath;
  		this.value = value;

  		this.prop = keypath.lastKey;

  		objKeypath = keypath.parent;
  		this.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get(objKeypath);

  		template = this.originalDescriptor = Object.getOwnPropertyDescriptor(this.obj, this.prop);

  		// Has this property already been wrapped?
  		if (template && template.set && (siblings = template.set._ractiveWrappers)) {

  			// Yes. Register this wrapper to this property, if it hasn't been already
  			if (siblings.indexOf(this) === -1) {
  				siblings.push(this);
  			}

  			return; // already wrapped
  		}

  		// No, it hasn't been wrapped
  		createAccessors(this, value, template);
  	};

  	MagicWrapper.prototype = {
  		get: function () {
  			return this.value;
  		},
  		reset: function (value) {
  			if (this.updating) {
  				return;
  			}

  			this.updating = true;
  			this.obj[this.prop] = value; // trigger set() accessor
  			global_runloop.addRactive(this.ractive);
  			this.ractive.viewmodel.mark(this.keypath, { keepExistingWrapper: true });
  			this.updating = false;
  			return true;
  		},
  		set: function (key, value) {
  			if (this.updating) {
  				return;
  			}

  			if (!this.obj[this.prop]) {
  				this.updating = true;
  				this.obj[this.prop] = createBranch(key);
  				this.updating = false;
  			}

  			this.obj[this.prop][key] = value;
  		},
  		teardown: function () {
  			var template, set, value, wrappers, index;

  			// If this method was called because the cache was being cleared as a
  			// result of a set()/update() call made by this wrapper, we return false
  			// so that it doesn't get torn down
  			if (this.updating) {
  				return false;
  			}

  			template = Object.getOwnPropertyDescriptor(this.obj, this.prop);
  			set = template && template.set;

  			if (!set) {
  				// most likely, this was an array member that was spliced out
  				return;
  			}

  			wrappers = set._ractiveWrappers;

  			index = wrappers.indexOf(this);
  			if (index !== -1) {
  				wrappers.splice(index, 1);
  			}

  			// Last one out, turn off the lights
  			if (!wrappers.length) {
  				value = this.obj[this.prop];

  				Object.defineProperty(this.obj, this.prop, this.originalDescriptor || {
  					writable: true,
  					enumerable: true,
  					configurable: true
  				});

  				this.obj[this.prop] = value;
  			}
  		}
  	};
  } catch (err) {
  	magicAdaptor = false; // no magic in this browser
  }

  var adaptors_magic = magicAdaptor;

  function createAccessors(originalWrapper, value, template) {

  	var object, property, oldGet, oldSet, get, set;

  	object = originalWrapper.obj;
  	property = originalWrapper.prop;

  	// Is this template configurable?
  	if (template && !template.configurable) {
  		// Special case - array length
  		if (property === "length") {
  			return;
  		}

  		throw new Error("Cannot use magic mode with property \"" + property + "\" - object is not configurable");
  	}

  	// Time to wrap this property
  	if (template) {
  		oldGet = template.get;
  		oldSet = template.set;
  	}

  	get = oldGet || function () {
  		return value;
  	};

  	set = function (v) {
  		if (oldSet) {
  			oldSet(v);
  		}

  		value = oldGet ? oldGet() : v;
  		set._ractiveWrappers.forEach(updateWrapper);
  	};

  	function updateWrapper(wrapper) {
  		var keypath, ractive;

  		wrapper.value = value;

  		if (wrapper.updating) {
  			return;
  		}

  		ractive = wrapper.ractive;
  		keypath = wrapper.keypath;

  		wrapper.updating = true;
  		global_runloop.start(ractive);

  		ractive.viewmodel.mark(keypath);

  		global_runloop.end();
  		wrapper.updating = false;
  	}

  	// Create an array of wrappers, in case other keypaths/ractives depend on this property.
  	// Handily, we can store them as a property of the set function. Yay JavaScript.
  	set._ractiveWrappers = [originalWrapper];
  	Object.defineProperty(object, property, { get: get, set: set, enumerable: true, configurable: true });
  }

  var magicArrayAdaptor, MagicArrayWrapper;

  if (adaptors_magic) {
  	magicArrayAdaptor = {
  		filter: function (object, keypath, ractive) {
  			return adaptors_magic.filter(object, keypath, ractive) && array_index.filter(object);
  		},

  		wrap: function (ractive, array, keypath) {
  			return new MagicArrayWrapper(ractive, array, keypath);
  		}
  	};

  	MagicArrayWrapper = function (ractive, array, keypath) {
  		this.value = array;

  		this.magic = true;

  		this.magicWrapper = adaptors_magic.wrap(ractive, array, keypath);
  		this.arrayWrapper = array_index.wrap(ractive, array, keypath);
  	};

  	MagicArrayWrapper.prototype = {
  		get: function () {
  			return this.value;
  		},
  		teardown: function () {
  			this.arrayWrapper.teardown();
  			this.magicWrapper.teardown();
  		},
  		reset: function (value) {
  			return this.magicWrapper.reset(value);
  		}
  	};
  }

  var magicArray = magicArrayAdaptor;

  var prototype_adapt = Viewmodel$adapt;

  var prefixers = {};
  function Viewmodel$adapt(keypath, value) {
  	var len, i, adaptor, wrapped;

  	if (!this.adaptors) return;

  	// Do we have an adaptor for this value?
  	len = this.adaptors.length;
  	for (i = 0; i < len; i += 1) {
  		adaptor = this.adaptors[i];

  		if (adaptor.filter(value, keypath, this.ractive)) {
  			wrapped = this.wrapped[keypath] = adaptor.wrap(this.ractive, value, keypath, getPrefixer(keypath));
  			wrapped.value = value;
  			return;
  		}
  	}
  }

  function prefixKeypath(obj, prefix) {
  	var prefixed = {},
  	    key;

  	if (!prefix) {
  		return obj;
  	}

  	prefix += ".";

  	for (key in obj) {
  		if (obj.hasOwnProperty(key)) {
  			prefixed[prefix + key] = obj[key];
  		}
  	}

  	return prefixed;
  }

  function getPrefixer(rootKeypath) {
  	var rootDot;

  	if (!prefixers[rootKeypath]) {
  		rootDot = rootKeypath ? rootKeypath + "." : "";

  		prefixers[rootKeypath] = function (relativeKeypath, value) {
  			var obj;

  			if (typeof relativeKeypath === "string") {
  				obj = {};
  				obj[rootDot + relativeKeypath] = value;
  				return obj;
  			}

  			if (typeof relativeKeypath === "object") {
  				// 'relativeKeypath' is in fact a hash, not a keypath
  				return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;
  			}
  		};
  	}

  	return prefixers[rootKeypath];
  }

  // TEMP

  var helpers_getUpstreamChanges = getUpstreamChanges;
  function getUpstreamChanges(changes) {
  	var upstreamChanges = [rootKeypath],
  	    i,
  	    keypath;

  	i = changes.length;
  	while (i--) {
  		keypath = changes[i].parent;

  		while (keypath && !keypath.isRoot) {
  			if (changes.indexOf(keypath) === -1) {
  				addToArray(upstreamChanges, keypath);
  			}
  			keypath = keypath.parent;
  		}
  	}

  	return upstreamChanges;
  }

  var applyChanges_notifyPatternObservers = notifyPatternObservers;

  function notifyPatternObservers(viewmodel, keypath, onlyDirect) {
  	var potentialWildcardMatches;

  	updateMatchingPatternObservers(viewmodel, keypath);

  	if (onlyDirect) {
  		return;
  	}

  	potentialWildcardMatches = keypath.wildcardMatches();
  	potentialWildcardMatches.forEach(function (upstreamPattern) {
  		cascade(viewmodel, upstreamPattern, keypath);
  	});
  }

  function cascade(viewmodel, upstreamPattern, keypath) {
  	var group, map, actualChildKeypath;

  	// TODO should be one or the other
  	upstreamPattern = upstreamPattern.str || upstreamPattern;

  	group = viewmodel.depsMap.patternObservers;
  	map = group && group[upstreamPattern];

  	if (!map) {
  		return;
  	}

  	map.forEach(function (childKeypath) {
  		actualChildKeypath = keypath.join(childKeypath.lastKey); // 'foo.bar.baz'

  		updateMatchingPatternObservers(viewmodel, actualChildKeypath);
  		cascade(viewmodel, childKeypath, actualChildKeypath);
  	});
  }

  function updateMatchingPatternObservers(viewmodel, keypath) {
  	viewmodel.patternObservers.forEach(function (observer) {
  		if (observer.regex.test(keypath.str)) {
  			observer.update(keypath);
  		}
  	});
  }

  var applyChanges = Viewmodel$applyChanges;

  function Viewmodel$applyChanges() {
  	var _this = this;

  	var self = this,
  	    changes,
  	    upstreamChanges,
  	    hash = {},
  	    bindings;

  	changes = this.changes;

  	if (!changes.length) {
  		// TODO we end up here on initial render. Perhaps we shouldn't?
  		return;
  	}

  	function invalidateComputation(computation) {
  		var key = computation.key;

  		if (computation.viewmodel === self) {
  			self.clearCache(key.str);
  			computation.invalidate();

  			changes.push(key);
  			cascade(key);
  		} else {
  			computation.viewmodel.mark(key);
  		}
  	}

  	function cascade(keypath) {
  		var map, computations;

  		if (self.noCascade.hasOwnProperty(keypath.str)) {
  			return;
  		}

  		if (computations = self.deps.computed[keypath.str]) {
  			computations.forEach(invalidateComputation);
  		}

  		if (map = self.depsMap.computed[keypath.str]) {
  			map.forEach(cascade);
  		}
  	}

  	changes.slice().forEach(cascade);

  	upstreamChanges = helpers_getUpstreamChanges(changes);
  	upstreamChanges.forEach(function (keypath) {
  		var computations;

  		// make sure we haven't already been down this particular keypath in this turn
  		if (changes.indexOf(keypath) === -1 && (computations = self.deps.computed[keypath.str])) {
  			computations.forEach(invalidateComputation);
  		}
  	});

  	this.changes = [];

  	// Pattern observers are a weird special case
  	if (this.patternObservers.length) {
  		upstreamChanges.forEach(function (keypath) {
  			return applyChanges_notifyPatternObservers(_this, keypath, true);
  		});
  		changes.forEach(function (keypath) {
  			return applyChanges_notifyPatternObservers(_this, keypath);
  		});
  	}

  	if (this.deps.observers) {
  		upstreamChanges.forEach(function (keypath) {
  			return notifyUpstreamDependants(_this, null, keypath, "observers");
  		});
  		notifyAllDependants(this, changes, "observers");
  	}

  	if (this.deps["default"]) {
  		bindings = [];
  		upstreamChanges.forEach(function (keypath) {
  			return notifyUpstreamDependants(_this, bindings, keypath, "default");
  		});

  		if (bindings.length) {
  			notifyBindings(this, bindings, changes);
  		}

  		notifyAllDependants(this, changes, "default");
  	}

  	// Return a hash of keypaths to updated values
  	changes.forEach(function (keypath) {
  		hash[keypath.str] = _this.get(keypath);
  	});

  	this.implicitChanges = {};
  	this.noCascade = {};

  	return hash;
  }

  function notifyUpstreamDependants(viewmodel, bindings, keypath, groupName) {
  	var dependants, value;

  	if (dependants = findDependants(viewmodel, keypath, groupName)) {
  		value = viewmodel.get(keypath);

  		dependants.forEach(function (d) {
  			// don't "set" the parent value, refine it
  			// i.e. not data = value, but data[foo] = fooValue
  			if (bindings && d.refineValue) {
  				bindings.push(d);
  			} else {
  				d.setValue(value);
  			}
  		});
  	}
  }

  function notifyBindings(viewmodel, bindings, changes) {

  	bindings.forEach(function (binding) {
  		var useSet = false,
  		    i = 0,
  		    length = changes.length,
  		    refinements = [];

  		while (i < length) {
  			var keypath = changes[i];

  			if (keypath === binding.keypath) {
  				useSet = true;
  				break;
  			}

  			if (keypath.slice(0, binding.keypath.length) === binding.keypath) {
  				refinements.push(keypath);
  			}

  			i++;
  		}

  		if (useSet) {
  			binding.setValue(viewmodel.get(binding.keypath));
  		}

  		if (refinements.length) {
  			binding.refineValue(refinements);
  		}
  	});
  }

  function notifyAllDependants(viewmodel, keypaths, groupName) {
  	var queue = [];

  	addKeypaths(keypaths);
  	queue.forEach(dispatch);

  	function addKeypaths(keypaths) {
  		keypaths.forEach(addKeypath);
  		keypaths.forEach(cascade);
  	}

  	function addKeypath(keypath) {
  		var deps = findDependants(viewmodel, keypath, groupName);

  		if (deps) {
  			queue.push({
  				keypath: keypath,
  				deps: deps
  			});
  		}
  	}

  	function cascade(keypath) {
  		var childDeps;

  		if (childDeps = viewmodel.depsMap[groupName][keypath.str]) {
  			addKeypaths(childDeps);
  		}
  	}

  	function dispatch(set) {
  		var value = viewmodel.get(set.keypath);
  		set.deps.forEach(function (d) {
  			return d.setValue(value);
  		});
  	}
  }

  function findDependants(viewmodel, keypath, groupName) {
  	var group = viewmodel.deps[groupName];
  	return group ? group[keypath.str] : null;
  }

  var capture = Viewmodel$capture;

  function Viewmodel$capture() {
  	this.captureGroups.push([]);
  }

  var clearCache = Viewmodel$clearCache;

  function Viewmodel$clearCache(keypath, keepExistingWrapper) {
  	var cacheMap, wrapper;

  	if (!keepExistingWrapper) {
  		// Is there a wrapped property at this keypath?
  		if (wrapper = this.wrapped[keypath]) {
  			// Did we unwrap it?
  			if (wrapper.teardown() !== false) {
  				// Is this right?
  				// What's the meaning of returning false from teardown?
  				// Could there be a GC ramification if this is a "real" ractive.teardown()?
  				this.wrapped[keypath] = null;
  			}
  		}
  	}

  	this.cache[keypath] = undefined;

  	if (cacheMap = this.cacheMap[keypath]) {
  		while (cacheMap.length) {
  			this.clearCache(cacheMap.pop());
  		}
  	}
  }

  var UnresolvedDependency = function (computation, ref) {
  	this.computation = computation;
  	this.viewmodel = computation.viewmodel;
  	this.ref = ref;

  	// TODO this seems like a red flag!
  	this.root = this.viewmodel.ractive;
  	this.parentFragment = this.root.component && this.root.component.parentFragment;
  };

  UnresolvedDependency.prototype = {
  	resolve: function (keypath) {
  		this.computation.softDeps.push(keypath);
  		this.computation.unresolvedDeps[keypath.str] = null;
  		this.viewmodel.register(keypath, this.computation, "computed");
  	}
  };

  var Computation_UnresolvedDependency = UnresolvedDependency;

  var Computation = function (key, signature) {
  	this.key = key;

  	this.getter = signature.getter;
  	this.setter = signature.setter;

  	this.hardDeps = signature.deps || [];
  	this.softDeps = [];
  	this.unresolvedDeps = {};

  	this.depValues = {};

  	this._dirty = this._firstRun = true;
  };

  Computation.prototype = {
  	constructor: Computation,

  	init: function (viewmodel) {
  		var _this = this;

  		var initial;

  		this.viewmodel = viewmodel;
  		this.bypass = true;

  		initial = viewmodel.get(this.key);
  		viewmodel.clearCache(this.key.str);

  		this.bypass = false;

  		if (this.setter && initial !== undefined) {
  			this.set(initial);
  		}

  		if (this.hardDeps) {
  			this.hardDeps.forEach(function (d) {
  				return viewmodel.register(d, _this, "computed");
  			});
  		}
  	},

  	invalidate: function () {
  		this._dirty = true;
  	},

  	get: function () {
  		var _this = this;

  		var newDeps,
  		    dependenciesChanged,
  		    dependencyValuesChanged = false;

  		if (this.getting) {
  			// prevent double-computation (e.g. caused by array mutation inside computation)
  			var msg = "The " + this.key.str + " computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by `array.sort(...)` - if that's the case, clone the array first with `array.slice().sort(...)`";
  			warnOnce(msg);
  			return this.value;
  		}

  		this.getting = true;

  		if (this._dirty) {
  			// determine whether the inputs have changed, in case this depends on
  			// other computed values
  			if (this._firstRun || !this.hardDeps.length && !this.softDeps.length) {
  				dependencyValuesChanged = true;
  			} else {
  				[this.hardDeps, this.softDeps].forEach(function (deps) {
  					var keypath, value, i;

  					if (dependencyValuesChanged) {
  						return;
  					}

  					i = deps.length;
  					while (i--) {
  						keypath = deps[i];
  						value = _this.viewmodel.get(keypath);

  						if (!isEqual(value, _this.depValues[keypath.str])) {
  							_this.depValues[keypath.str] = value;
  							dependencyValuesChanged = true;

  							return;
  						}
  					}
  				});
  			}

  			if (dependencyValuesChanged) {
  				this.viewmodel.capture();

  				try {
  					this.value = this.getter();
  				} catch (err) {
  					warnIfDebug("Failed to compute \"%s\"", this.key.str);
  					logIfDebug(err.stack || err);

  					this.value = void 0;
  				}

  				newDeps = this.viewmodel.release();
  				dependenciesChanged = this.updateDependencies(newDeps);

  				if (dependenciesChanged) {
  					[this.hardDeps, this.softDeps].forEach(function (deps) {
  						deps.forEach(function (keypath) {
  							_this.depValues[keypath.str] = _this.viewmodel.get(keypath);
  						});
  					});
  				}
  			}

  			this._dirty = false;
  		}

  		this.getting = this._firstRun = false;
  		return this.value;
  	},

  	set: function (value) {
  		if (this.setting) {
  			this.value = value;
  			return;
  		}

  		if (!this.setter) {
  			throw new Error("Computed properties without setters are read-only. (This may change in a future version of Ractive!)");
  		}

  		this.setter(value);
  	},

  	updateDependencies: function (newDeps) {
  		var i, oldDeps, keypath, dependenciesChanged, unresolved;

  		oldDeps = this.softDeps;

  		// remove dependencies that are no longer used
  		i = oldDeps.length;
  		while (i--) {
  			keypath = oldDeps[i];

  			if (newDeps.indexOf(keypath) === -1) {
  				dependenciesChanged = true;
  				this.viewmodel.unregister(keypath, this, "computed");
  			}
  		}

  		// create references for any new dependencies
  		i = newDeps.length;
  		while (i--) {
  			keypath = newDeps[i];

  			if (oldDeps.indexOf(keypath) === -1 && (!this.hardDeps || this.hardDeps.indexOf(keypath) === -1)) {
  				dependenciesChanged = true;

  				// if this keypath is currently unresolved, we need to mark
  				// it as such. TODO this is a bit muddy...
  				if (isUnresolved(this.viewmodel, keypath) && !this.unresolvedDeps[keypath.str]) {
  					unresolved = new Computation_UnresolvedDependency(this, keypath.str);
  					newDeps.splice(i, 1);

  					this.unresolvedDeps[keypath.str] = unresolved;
  					global_runloop.addUnresolved(unresolved);
  				} else {
  					this.viewmodel.register(keypath, this, "computed");
  				}
  			}
  		}

  		if (dependenciesChanged) {
  			this.softDeps = newDeps.slice();
  		}

  		return dependenciesChanged;
  	}
  };

  function isUnresolved(viewmodel, keypath) {
  	var key = keypath.firstKey;

  	return !(key in viewmodel.data) && !(key in viewmodel.computations) && !(key in viewmodel.mappings);
  }

  var Computation_Computation = Computation;

  var compute = Viewmodel$compute;
  function Viewmodel$compute(key, signature) {
  	var computation = new Computation_Computation(key, signature);

  	if (this.ready) {
  		computation.init(this);
  	}

  	return this.computations[key.str] = computation;
  }

  var FAILED_LOOKUP = { FAILED_LOOKUP: true };

  var viewmodel_prototype_get = Viewmodel$get;

  var viewmodel_prototype_get__empty = {};
  function Viewmodel$get(keypath, options) {
  	var cache = this.cache,
  	    value,
  	    computation,
  	    wrapped,
  	    captureGroup,
  	    keypathStr = keypath.str,
  	    key;

  	options = options || viewmodel_prototype_get__empty;

  	// capture the keypath, if we're inside a computation
  	if (options.capture && (captureGroup = lastItem(this.captureGroups))) {
  		if (! ~captureGroup.indexOf(keypath)) {
  			captureGroup.push(keypath);
  		}
  	}

  	if (hasOwn.call(this.mappings, keypath.firstKey)) {
  		return this.mappings[keypath.firstKey].get(keypath, options);
  	}

  	if (keypath.isSpecial) {
  		return keypath.value;
  	}

  	if (cache[keypathStr] === undefined) {

  		// Is this a computed property?
  		if ((computation = this.computations[keypathStr]) && !computation.bypass) {
  			value = computation.get();
  			this.adapt(keypathStr, value);
  		}

  		// Is this a wrapped property?
  		else if (wrapped = this.wrapped[keypathStr]) {
  			value = wrapped.value;
  		}

  		// Is it the root?
  		else if (keypath.isRoot) {
  			this.adapt("", this.data);
  			value = this.data;
  		}

  		// No? Then we need to retrieve the value one key at a time
  		else {
  			value = retrieve(this, keypath);
  		}

  		cache[keypathStr] = value;
  	} else {
  		value = cache[keypathStr];
  	}

  	if (!options.noUnwrap && (wrapped = this.wrapped[keypathStr])) {
  		value = wrapped.get();
  	}

  	if (keypath.isRoot && options.fullRootGet) {
  		for (key in this.mappings) {
  			value[key] = this.mappings[key].getValue();
  		}
  	}

  	return value === FAILED_LOOKUP ? void 0 : value;
  }

  function retrieve(viewmodel, keypath) {

  	var parentValue, cacheMap, value, wrapped;

  	parentValue = viewmodel.get(keypath.parent);

  	if (wrapped = viewmodel.wrapped[keypath.parent.str]) {
  		parentValue = wrapped.get();
  	}

  	if (parentValue === null || parentValue === undefined) {
  		return;
  	}

  	// update cache map
  	if (!(cacheMap = viewmodel.cacheMap[keypath.parent.str])) {
  		viewmodel.cacheMap[keypath.parent.str] = [keypath.str];
  	} else {
  		if (cacheMap.indexOf(keypath.str) === -1) {
  			cacheMap.push(keypath.str);
  		}
  	}

  	// If this property doesn't exist, we return a sentinel value
  	// so that we know to query parent scope (if such there be)
  	if (typeof parentValue === "object" && !(keypath.lastKey in parentValue)) {
  		return viewmodel.cache[keypath.str] = FAILED_LOOKUP;
  	}

  	value = parentValue[keypath.lastKey];

  	// Do we have an adaptor for this value?
  	viewmodel.adapt(keypath.str, value, false);

  	// Update cache
  	viewmodel.cache[keypath.str] = value;
  	return value;
  }

  var viewmodel_prototype_init = Viewmodel$init;

  function Viewmodel$init() {
  	var key;

  	for (key in this.computations) {
  		this.computations[key].init(this);
  	}
  }

  var prototype_map = Viewmodel$map;

  function Viewmodel$map(key, options) {
  	var mapping = this.mappings[key.str] = new Mapping(key, options);
  	mapping.initViewmodel(this);
  	return mapping;
  }

  var Mapping = function (localKey, options) {
  	this.localKey = localKey;
  	this.keypath = options.keypath;
  	this.origin = options.origin;

  	this.deps = [];
  	this.unresolved = [];

  	this.resolved = false;
  };

  Mapping.prototype = {
  	forceResolution: function () {
  		// TODO warn, as per #1692?
  		this.keypath = this.localKey;
  		this.setup();
  	},

  	get: function (keypath, options) {
  		if (!this.resolved) {
  			return undefined;
  		}
  		return this.origin.get(this.map(keypath), options);
  	},

  	getValue: function () {
  		if (!this.keypath) {
  			return undefined;
  		}
  		return this.origin.get(this.keypath);
  	},

  	initViewmodel: function (viewmodel) {
  		this.local = viewmodel;
  		this.setup();
  	},

  	map: function (keypath) {
  		if (typeof this.keypath === undefined) {
  			return this.localKey;
  		}
  		return keypath.replace(this.localKey, this.keypath);
  	},

  	register: function (keypath, dependant, group) {
  		this.deps.push({ keypath: keypath, dep: dependant, group: group });

  		if (this.resolved) {
  			this.origin.register(this.map(keypath), dependant, group);
  		}
  	},

  	resolve: function (keypath) {
  		if (this.keypath !== undefined) {
  			this.unbind(true);
  		}

  		this.keypath = keypath;
  		this.setup();
  	},

  	set: function (keypath, value) {
  		if (!this.resolved) {
  			this.forceResolution();
  		}

  		this.origin.set(this.map(keypath), value);
  	},

  	setup: function () {
  		var _this = this;

  		if (this.keypath === undefined) {
  			return;
  		}

  		this.resolved = true;

  		// accumulated dependants can now be registered
  		if (this.deps.length) {
  			this.deps.forEach(function (d) {
  				var keypath = _this.map(d.keypath);
  				_this.origin.register(keypath, d.dep, d.group);

  				// TODO this is a bit of a red flag... all deps should be the same?
  				if (d.dep.setValue) {
  					d.dep.setValue(_this.origin.get(keypath));
  				} else if (d.dep.invalidate) {
  					d.dep.invalidate();
  				} else {
  					throw new Error("An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");
  				}
  			});

  			this.origin.mark(this.keypath);
  		}
  	},

  	setValue: function (value) {
  		if (!this.keypath) {
  			throw new Error("Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");
  		}

  		this.origin.set(this.keypath, value);
  	},

  	unbind: function (keepLocal) {
  		var _this = this;

  		if (!keepLocal) {
  			delete this.local.mappings[this.localKey];
  		}

  		if (!this.resolved) {
  			return;
  		}

  		this.deps.forEach(function (d) {
  			_this.origin.unregister(_this.map(d.keypath), d.dep, d.group);
  		});

  		if (this.tracker) {
  			this.origin.unregister(this.keypath, this.tracker);
  		}
  	},

  	unregister: function (keypath, dependant, group) {
  		var deps, i;

  		if (!this.resolved) {
  			return;
  		}

  		deps = this.deps;
  		i = deps.length;

  		while (i--) {
  			if (deps[i].dep === dependant) {
  				deps.splice(i, 1);
  				break;
  			}
  		}
  		this.origin.unregister(this.map(keypath), dependant, group);
  	}
  };

  var mark = Viewmodel$mark;

  function Viewmodel$mark(keypath, options) {
  	var computation,
  	    keypathStr = keypath.str;

  	// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
  	// should not be picked up by pattern observers
  	if (options) {
  		if (options.implicit) {
  			this.implicitChanges[keypathStr] = true;
  		}
  		if (options.noCascade) {
  			this.noCascade[keypathStr] = true;
  		}
  	}

  	if (computation = this.computations[keypathStr]) {
  		computation.invalidate();
  	}

  	if (this.changes.indexOf(keypath) === -1) {
  		this.changes.push(keypath);
  	}

  	// pass on keepExistingWrapper, if we can
  	var keepExistingWrapper = options ? options.keepExistingWrapper : false;

  	this.clearCache(keypathStr, keepExistingWrapper);

  	if (this.ready) {
  		this.onchange();
  	}
  }

  var mapOldToNewIndex = function (oldArray, newArray) {
  	var usedIndices, firstUnusedIndex, newIndices, changed;

  	usedIndices = {};
  	firstUnusedIndex = 0;

  	newIndices = oldArray.map(function (item, i) {
  		var index, start, len;

  		start = firstUnusedIndex;
  		len = newArray.length;

  		do {
  			index = newArray.indexOf(item, start);

  			if (index === -1) {
  				changed = true;
  				return -1;
  			}

  			start = index + 1;
  		} while (usedIndices[index] && start < len);

  		// keep track of the first unused index, so we don't search
  		// the whole of newArray for each item in oldArray unnecessarily
  		if (index === firstUnusedIndex) {
  			firstUnusedIndex += 1;
  		}

  		if (index !== i) {
  			changed = true;
  		}

  		usedIndices[index] = true;
  		return index;
  	});

  	return newIndices;
  };

  var merge = Viewmodel$merge;

  var comparators = {};
  function Viewmodel$merge(keypath, currentArray, array, options) {
  	var oldArray, newArray, comparator, newIndices;

  	this.mark(keypath);

  	if (options && options.compare) {

  		comparator = getComparatorFunction(options.compare);

  		try {
  			oldArray = currentArray.map(comparator);
  			newArray = array.map(comparator);
  		} catch (err) {
  			// fallback to an identity check - worst case scenario we have
  			// to do more DOM manipulation than we thought...
  			warnIfDebug("merge(): \"%s\" comparison failed. Falling back to identity checking", keypath);

  			oldArray = currentArray;
  			newArray = array;
  		}
  	} else {
  		oldArray = currentArray;
  		newArray = array;
  	}

  	// find new indices for members of oldArray
  	newIndices = mapOldToNewIndex(oldArray, newArray);

  	this.smartUpdate(keypath, array, newIndices, currentArray.length !== array.length);
  }

  function stringify(item) {
  	return JSON.stringify(item);
  }

  function getComparatorFunction(comparator) {
  	// If `compare` is `true`, we use JSON.stringify to compare
  	// objects that are the same shape, but non-identical - i.e.
  	// { foo: 'bar' } !== { foo: 'bar' }
  	if (comparator === true) {
  		return stringify;
  	}

  	if (typeof comparator === "string") {
  		if (!comparators[comparator]) {
  			comparators[comparator] = function (item) {
  				return item[comparator];
  			};
  		}

  		return comparators[comparator];
  	}

  	if (typeof comparator === "function") {
  		return comparator;
  	}

  	throw new Error("The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)");
  }

  var register = Viewmodel$register;

  function Viewmodel$register(keypath, dependant) {
  	var group = arguments[2] === undefined ? "default" : arguments[2];

  	var mapping, depsByKeypath, deps;

  	if (dependant.isStatic) {
  		return; // TODO we should never get here if a dependant is static...
  	}

  	if (mapping = this.mappings[keypath.firstKey]) {
  		mapping.register(keypath, dependant, group);
  	} else {
  		depsByKeypath = this.deps[group] || (this.deps[group] = {});
  		deps = depsByKeypath[keypath.str] || (depsByKeypath[keypath.str] = []);

  		deps.push(dependant);

  		if (!this.depsMap[group]) {
  			this.depsMap[group] = {};
  		}

  		if (!keypath.isRoot) {
  			register__updateDependantsMap(this, keypath, group);
  		}
  	}
  }

  function register__updateDependantsMap(viewmodel, keypath, group) {
  	var map, parent, keypathStr;

  	// update dependants map
  	while (!keypath.isRoot) {
  		map = viewmodel.depsMap[group];
  		parent = map[keypath.parent.str] || (map[keypath.parent.str] = []);

  		keypathStr = keypath.str;

  		// TODO find an alternative to this nasty approach
  		if (parent["_" + keypathStr] === undefined) {
  			parent["_" + keypathStr] = 0;
  			parent.push(keypath);
  		}

  		parent["_" + keypathStr] += 1;
  		keypath = keypath.parent;
  	}
  }

  var release = Viewmodel$release;

  function Viewmodel$release() {
  	return this.captureGroups.pop();
  }

  var reset = Viewmodel$reset;

  function Viewmodel$reset(data) {
  	this.data = data;
  	this.clearCache("");
  }

  var prototype_set = Viewmodel$set;

  function Viewmodel$set(keypath, value) {
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	var mapping, computation, wrapper, keepExistingWrapper;

  	// unless data is being set for data tracking purposes
  	if (!options.noMapping) {
  		// If this data belongs to a different viewmodel,
  		// pass the change along
  		if (mapping = this.mappings[keypath.firstKey]) {
  			return mapping.set(keypath, value);
  		}
  	}

  	computation = this.computations[keypath.str];
  	if (computation) {
  		if (computation.setting) {
  			// let the other computation set() handle things...
  			return;
  		}
  		computation.set(value);
  		value = computation.get();
  	}

  	if (isEqual(this.cache[keypath.str], value)) {
  		return;
  	}

  	wrapper = this.wrapped[keypath.str];

  	// If we have a wrapper with a `reset()` method, we try and use it. If the
  	// `reset()` method returns false, the wrapper should be torn down, and
  	// (most likely) a new one should be created later
  	if (wrapper && wrapper.reset) {
  		keepExistingWrapper = wrapper.reset(value) !== false;

  		if (keepExistingWrapper) {
  			value = wrapper.get();
  		}
  	}

  	if (!computation && !keepExistingWrapper) {
  		resolveSet(this, keypath, value);
  	}

  	if (!options.silent) {
  		this.mark(keypath);
  	} else {
  		// We're setting a parent of the original target keypath (i.e.
  		// creating a fresh branch) - we need to clear the cache, but
  		// not mark it as a change
  		this.clearCache(keypath.str);
  	}
  }

  function resolveSet(viewmodel, keypath, value) {
  	var wrapper, parentValue, wrapperSet, valueSet;

  	wrapperSet = function () {
  		if (wrapper.set) {
  			wrapper.set(keypath.lastKey, value);
  		} else {
  			parentValue = wrapper.get();
  			valueSet();
  		}
  	};

  	valueSet = function () {
  		if (!parentValue) {
  			parentValue = createBranch(keypath.lastKey);
  			viewmodel.set(keypath.parent, parentValue, { silent: true });
  		}
  		parentValue[keypath.lastKey] = value;
  	};

  	wrapper = viewmodel.wrapped[keypath.parent.str];

  	if (wrapper) {
  		wrapperSet();
  	} else {
  		parentValue = viewmodel.get(keypath.parent);

  		// may have been wrapped via the above .get()
  		// call on viewmodel if this is first access via .set()!
  		if (wrapper = viewmodel.wrapped[keypath.parent.str]) {
  			wrapperSet();
  		} else {
  			valueSet();
  		}
  	}
  }

  var smartUpdate = Viewmodel$smartUpdate;

  var implicitOption = { implicit: true },
      noCascadeOption = { noCascade: true };
  function Viewmodel$smartUpdate(keypath, array, newIndices) {
  	var _this = this;

  	var dependants, oldLength, i;

  	oldLength = newIndices.length;

  	// Indices that are being removed should be marked as dirty
  	newIndices.forEach(function (newIndex, oldIndex) {
  		if (newIndex === -1) {
  			_this.mark(keypath.join(oldIndex), noCascadeOption);
  		}
  	});

  	// Update the model
  	// TODO allow existing array to be updated in place, rather than replaced?
  	this.set(keypath, array, { silent: true });

  	if (dependants = this.deps["default"][keypath.str]) {
  		dependants.filter(canShuffle).forEach(function (d) {
  			return d.shuffle(newIndices, array);
  		});
  	}

  	if (oldLength !== array.length) {
  		this.mark(keypath.join("length"), implicitOption);

  		for (i = newIndices.touchedFrom; i < array.length; i += 1) {
  			this.mark(keypath.join(i));
  		}

  		// don't allow removed indexes beyond end of new array to trigger recomputations
  		// TODO is this still necessary, now that computations are lazy?
  		for (i = array.length; i < oldLength; i += 1) {
  			this.mark(keypath.join(i), noCascadeOption);
  		}
  	}
  }

  function canShuffle(dependant) {
  	return typeof dependant.shuffle === "function";
  }

  var prototype_teardown = Viewmodel$teardown;

  function Viewmodel$teardown() {
  	var _this = this;

  	var unresolvedImplicitDependency;

  	// Clear entire cache - this has the desired side-effect
  	// of unwrapping adapted values (e.g. arrays)
  	Object.keys(this.cache).forEach(function (keypath) {
  		return _this.clearCache(keypath);
  	});

  	// Teardown any failed lookups - we don't need them to resolve any more
  	while (unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop()) {
  		unresolvedImplicitDependency.teardown();
  	}
  }

  var unregister = Viewmodel$unregister;

  function Viewmodel$unregister(keypath, dependant) {
  	var group = arguments[2] === undefined ? "default" : arguments[2];

  	var mapping, deps, index;

  	if (dependant.isStatic) {
  		return;
  	}

  	if (mapping = this.mappings[keypath.firstKey]) {
  		return mapping.unregister(keypath, dependant, group);
  	}

  	deps = this.deps[group][keypath.str];
  	index = deps.indexOf(dependant);

  	if (index === -1) {
  		throw new Error("Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks");
  	}

  	deps.splice(index, 1);

  	if (keypath.isRoot) {
  		return;
  	}

  	unregister__updateDependantsMap(this, keypath, group);
  }

  function unregister__updateDependantsMap(viewmodel, keypath, group) {
  	var map, parent;

  	// update dependants map
  	while (!keypath.isRoot) {
  		map = viewmodel.depsMap[group];
  		parent = map[keypath.parent.str];

  		parent["_" + keypath.str] -= 1;

  		if (!parent["_" + keypath.str]) {
  			// remove from parent deps map
  			removeFromArray(parent, keypath);
  			parent["_" + keypath.str] = undefined;
  		}

  		keypath = keypath.parent;
  	}
  }

  var Viewmodel = function (options) {
  	var adapt = options.adapt;
  	var data = options.data;
  	var ractive = options.ractive;
  	var computed = options.computed;
  	var mappings = options.mappings;
  	var key;
  	var mapping;

  	// TODO is it possible to remove this reference?
  	this.ractive = ractive;

  	this.adaptors = adapt;
  	this.onchange = options.onchange;

  	this.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null
  	this.cacheMap = create(null);

  	this.deps = {
  		computed: create(null),
  		"default": create(null)
  	};
  	this.depsMap = {
  		computed: create(null),
  		"default": create(null)
  	};

  	this.patternObservers = [];

  	this.specials = create(null);

  	this.wrapped = create(null);
  	this.computations = create(null);

  	this.captureGroups = [];
  	this.unresolvedImplicitDependencies = [];

  	this.changes = [];
  	this.implicitChanges = {};
  	this.noCascade = {};

  	this.data = data;

  	// set up explicit mappings
  	this.mappings = create(null);
  	for (key in mappings) {
  		this.map(getKeypath(key), mappings[key]);
  	}

  	if (data) {
  		// if data exists locally, but is missing on the parent,
  		// we transfer ownership to the parent
  		for (key in data) {
  			if ((mapping = this.mappings[key]) && mapping.getValue() === undefined) {
  				mapping.setValue(data[key]);
  			}
  		}
  	}

  	for (key in computed) {
  		if (mappings && key in mappings) {
  			fatal("Cannot map to a computed property ('%s')", key);
  		}

  		this.compute(getKeypath(key), computed[key]);
  	}

  	this.ready = true;
  };

  Viewmodel.prototype = {
  	adapt: prototype_adapt,
  	applyChanges: applyChanges,
  	capture: capture,
  	clearCache: clearCache,
  	compute: compute,
  	get: viewmodel_prototype_get,
  	init: viewmodel_prototype_init,
  	map: prototype_map,
  	mark: mark,
  	merge: merge,
  	register: register,
  	release: release,
  	reset: reset,
  	set: prototype_set,
  	smartUpdate: smartUpdate,
  	teardown: prototype_teardown,
  	unregister: unregister
  };

  var viewmodel_Viewmodel = Viewmodel;

  function HookQueue(event) {
  	this.hook = new hooks_Hook(event);
  	this.inProcess = {};
  	this.queue = {};
  }

  HookQueue.prototype = {

  	constructor: HookQueue,

  	begin: function (ractive) {
  		this.inProcess[ractive._guid] = true;
  	},

  	end: function (ractive) {

  		var parent = ractive.parent;

  		// If this is *isn't* a child of a component that's in process,
  		// it should call methods or fire at this point
  		if (!parent || !this.inProcess[parent._guid]) {
  			fire(this, ractive);
  		}
  		// elsewise, handoff to parent to fire when ready
  		else {
  			getChildQueue(this.queue, parent).push(ractive);
  		}

  		delete this.inProcess[ractive._guid];
  	}
  };

  function getChildQueue(queue, ractive) {
  	return queue[ractive._guid] || (queue[ractive._guid] = []);
  }

  function fire(hookQueue, ractive) {

  	var childQueue = getChildQueue(hookQueue.queue, ractive);

  	hookQueue.hook.fire(ractive);

  	// queue is "live" because components can end up being
  	// added while hooks fire on parents that modify data values.
  	while (childQueue.length) {
  		fire(hookQueue, childQueue.shift());
  	}

  	delete hookQueue.queue[ractive._guid];
  }

  var hooks_HookQueue = HookQueue;

  var helpers_getComputationSignatures = getComputationSignatures;

  var helpers_getComputationSignatures__pattern = /\$\{([^\}]+)\}/g;
  function getComputationSignatures(ractive, computed) {
  	var signatures = {},
  	    key;

  	for (key in computed) {
  		signatures[key] = getComputationSignature(ractive, key, computed[key]);
  	}

  	return signatures;
  }

  function getComputationSignature(ractive, key, signature) {
  	var getter, setter;

  	if (typeof signature === "function") {
  		getter = helpers_getComputationSignatures__bind(signature, ractive);
  	}

  	if (typeof signature === "string") {
  		getter = createFunctionFromString(ractive, signature);
  	}

  	if (typeof signature === "object") {
  		if (typeof signature.get === "string") {
  			getter = createFunctionFromString(ractive, signature.get);
  		} else if (typeof signature.get === "function") {
  			getter = helpers_getComputationSignatures__bind(signature.get, ractive);
  		} else {
  			fatal("`%s` computation must have a `get()` method", key);
  		}

  		if (typeof signature.set === "function") {
  			setter = helpers_getComputationSignatures__bind(signature.set, ractive);
  		}
  	}

  	return { getter: getter, setter: setter };
  }

  function createFunctionFromString(ractive, str) {
  	var functionBody, hasThis, fn;

  	functionBody = "return (" + str.replace(helpers_getComputationSignatures__pattern, function (match, keypath) {
  		hasThis = true;
  		return "__ractive.get(\"" + keypath + "\")";
  	}) + ");";

  	if (hasThis) {
  		functionBody = "var __ractive = this; " + functionBody;
  	}

  	fn = new Function(functionBody);
  	return hasThis ? fn.bind(ractive) : fn;
  }

  function helpers_getComputationSignatures__bind(fn, context) {
  	return /this/.test(fn.toString()) ? fn.bind(context) : fn;
  }

  var constructHook = new hooks_Hook("construct");
  var configHook = new hooks_Hook("config");
  var initHook = new hooks_HookQueue("init");
  var initialise__uid = 0;

  var initialise__registryNames = ["adaptors", "components", "decorators", "easing", "events", "interpolators", "partials", "transitions"];

  var initialise = initialiseRactiveInstance;

  function initialiseRactiveInstance(ractive) {
  	var userOptions = arguments[1] === undefined ? {} : arguments[1];
  	var options = arguments[2] === undefined ? {} : arguments[2];

  	var el, viewmodel;

  	if (_Ractive.DEBUG) {
  		welcome();
  	}

  	initialiseProperties(ractive, options);

  	// TODO remove this, eventually
  	defineProperty(ractive, "data", { get: deprecateRactiveData });

  	// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it
  	constructHook.fire(ractive, userOptions);

  	// Add registries
  	initialise__registryNames.forEach(function (name) {
  		ractive[name] = utils_object__extend(create(ractive.constructor[name] || null), userOptions[name]);
  	});

  	// Create a viewmodel
  	viewmodel = new viewmodel_Viewmodel({
  		adapt: getAdaptors(ractive, ractive.adapt, userOptions),
  		data: custom_data.init(ractive.constructor, ractive, userOptions),
  		computed: helpers_getComputationSignatures(ractive, utils_object__extend(create(ractive.constructor.prototype.computed), userOptions.computed)),
  		mappings: options.mappings,
  		ractive: ractive,
  		onchange: function () {
  			return global_runloop.addRactive(ractive);
  		}
  	});

  	ractive.viewmodel = viewmodel;

  	// This can't happen earlier, because computed properties may call `ractive.get()`, etc
  	viewmodel.init();

  	// init config from Parent and options
  	config_config.init(ractive.constructor, ractive, userOptions);

  	configHook.fire(ractive);
  	initHook.begin(ractive);

  	// // If this is a component with a function `data` property, call the function
  	// // with `ractive` as context (unless the child was also a function)
  	// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {
  	// 	viewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );
  	// }

  	// Render virtual DOM
  	if (ractive.template) {
  		var cssIds = undefined;

  		if (options.cssIds || ractive.cssId) {
  			cssIds = options.cssIds ? options.cssIds.slice() : [];

  			if (ractive.cssId) {
  				cssIds.push(ractive.cssId);
  			}
  		}

  		ractive.fragment = new virtualdom_Fragment({
  			template: ractive.template,
  			root: ractive,
  			owner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on
  			cssIds: cssIds
  		});
  	}

  	initHook.end(ractive);

  	// render automatically ( if `el` is specified )
  	if (el = getElement(ractive.el)) {
  		var promise = ractive.render(el, ractive.append);

  		if (_Ractive.DEBUG_PROMISES) {
  			promise["catch"](function (err) {
  				warnOnceIfDebug("Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\n  Ractive.DEBUG_PROMISES = false;");
  				warnIfDebug("An error happened during rendering", { ractive: ractive });
  				err.stack && logIfDebug(err.stack);

  				throw err;
  			});
  		}
  	}
  }

  function getAdaptors(ractive, protoAdapt, userOptions) {
  	var adapt, magic, modifyArrays;

  	protoAdapt = protoAdapt.map(lookup);
  	adapt = ensureArray(userOptions.adapt).map(lookup);

  	adapt = initialise__combine(protoAdapt, adapt);

  	magic = "magic" in userOptions ? userOptions.magic : ractive.magic;
  	modifyArrays = "modifyArrays" in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;

  	if (magic) {
  		if (!environment__magic) {
  			throw new Error("Getters and setters (magic mode) are not supported in this browser");
  		}

  		if (modifyArrays) {
  			adapt.push(magicArray);
  		}

  		adapt.push(adaptors_magic);
  	}

  	if (modifyArrays) {
  		adapt.push(array_index);
  	}

  	return adapt;

  	function lookup(adaptor) {
  		if (typeof adaptor === "string") {
  			adaptor = findInViewHierarchy("adaptors", ractive, adaptor);

  			if (!adaptor) {
  				fatal(missingPlugin(adaptor, "adaptor"));
  			}
  		}

  		return adaptor;
  	}
  }

  function initialise__combine(a, b) {
  	var c = a.slice(),
  	    i = b.length;

  	while (i--) {
  		if (! ~c.indexOf(b[i])) {
  			c.push(b[i]);
  		}
  	}

  	return c;
  }

  function initialiseProperties(ractive, options) {
  	// Generate a unique identifier, for places where you'd use a weak map if it
  	// existed
  	ractive._guid = "r-" + initialise__uid++;

  	// events
  	ractive._subs = create(null);

  	// storage for item configuration from instantiation to reset,
  	// like dynamic functions or original values
  	ractive._config = {};

  	// two-way bindings
  	ractive._twowayBindings = create(null);

  	// animations (so we can stop any in progress at teardown)
  	ractive._animations = [];

  	// nodes registry
  	ractive.nodes = {};

  	// live queries
  	ractive._liveQueries = [];
  	ractive._liveComponentQueries = [];

  	// bound data functions
  	ractive._boundFunctions = [];

  	// observers
  	ractive._observers = [];

  	// properties specific to inline components
  	if (options.component) {
  		ractive.parent = options.parent;
  		ractive.container = options.container || null;
  		ractive.root = ractive.parent.root;

  		ractive.component = options.component;
  		options.component.instance = ractive;

  		// for hackability, this could be an open option
  		// for any ractive instance, but for now, just
  		// for components and just for ractive...
  		ractive._inlinePartials = options.inlinePartials;
  	} else {
  		ractive.root = ractive;
  		ractive.parent = ractive.container = null;
  	}
  }

  function deprecateRactiveData() {
  	throw new Error("Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead");
  }

  function ComplexParameter(component, template, callback) {
  	this.parentFragment = component.parentFragment;
  	this.callback = callback;

  	this.fragment = new virtualdom_Fragment({
  		template: template,
  		root: component.root,
  		owner: this
  	});

  	this.update();
  }

  var initialise_ComplexParameter = ComplexParameter;

  ComplexParameter.prototype = {
  	bubble: function () {
  		if (!this.dirty) {
  			this.dirty = true;
  			global_runloop.addView(this);
  		}
  	},

  	update: function () {
  		this.callback(this.fragment.getValue());
  		this.dirty = false;
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	}
  };

  var createInstance = function (component, Component, attributes, yieldTemplate, partials) {
  	var instance,
  	    parentFragment,
  	    ractive,
  	    fragment,
  	    container,
  	    inlinePartials = {},
  	    data = {},
  	    mappings = {},
  	    ready,
  	    resolvers = [];

  	parentFragment = component.parentFragment;
  	ractive = component.root;

  	partials = partials || {};
  	utils_object__extend(inlinePartials, partials);

  	// Make contents available as a {{>content}} partial
  	partials.content = yieldTemplate || [];

  	// set a default partial for yields with no name
  	inlinePartials[""] = partials.content;

  	if (Component.defaults.el) {
  		warnIfDebug("The <%s/> component has a default `el` property; it has been disregarded", component.name);
  	}

  	// find container
  	fragment = parentFragment;
  	while (fragment) {
  		if (fragment.owner.type === YIELDER) {
  			container = fragment.owner.container;
  			break;
  		}

  		fragment = fragment.parent;
  	}

  	// each attribute represents either a) data or b) a mapping
  	if (attributes) {
  		Object.keys(attributes).forEach(function (key) {
  			var attribute = attributes[key],
  			    parsed,
  			    resolver;

  			if (typeof attribute === "string") {
  				// it's static data
  				parsed = parseJSON(attribute);
  				data[key] = parsed ? parsed.value : attribute;
  			} else if (attribute === 0) {
  				// it had no '=', so we'll call it true
  				data[key] = true;
  			} else if (isArray(attribute)) {
  				// this represents dynamic data
  				if (isSingleInterpolator(attribute)) {
  					mappings[key] = {
  						origin: component.root.viewmodel,
  						keypath: undefined
  					};

  					resolver = createResolver(component, attribute[0], function (keypath) {
  						if (keypath.isSpecial) {
  							if (ready) {
  								instance.set(key, keypath.value); // TODO use viewmodel?
  							} else {
  								data[key] = keypath.value;

  								// TODO errr.... would be better if we didn't have to do this
  								delete mappings[key];
  							}
  						} else {
  							if (ready) {
  								instance.viewmodel.mappings[key].resolve(keypath);
  							} else {
  								// resolved immediately
  								mappings[key].keypath = keypath;
  							}
  						}
  					});
  				} else {
  					resolver = new initialise_ComplexParameter(component, attribute, function (value) {
  						if (ready) {
  							instance.set(key, value); // TODO use viewmodel?
  						} else {
  							data[key] = value;
  						}
  					});
  				}

  				resolvers.push(resolver);
  			} else {
  				throw new Error("erm wut");
  			}
  		});
  	}

  	instance = create(Component.prototype);

  	initialise(instance, {
  		el: null,
  		append: true,
  		data: data,
  		partials: partials,
  		magic: ractive.magic || Component.defaults.magic,
  		modifyArrays: ractive.modifyArrays,
  		// need to inherit runtime parent adaptors
  		adapt: ractive.adapt
  	}, {
  		parent: ractive,
  		component: component,
  		container: container,
  		mappings: mappings,
  		inlinePartials: inlinePartials,
  		cssIds: parentFragment.cssIds
  	});

  	ready = true;
  	component.resolvers = resolvers;

  	return instance;
  };

  function createResolver(component, template, callback) {
  	var resolver;

  	if (template.r) {
  		resolver = Resolvers_createReferenceResolver(component, template.r, callback);
  	} else if (template.x) {
  		resolver = new Resolvers_ExpressionResolver(component, component.parentFragment, template.x, callback);
  	} else if (template.rx) {
  		resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(component, template.rx, callback);
  	}

  	return resolver;
  }

  function isSingleInterpolator(template) {
  	return template.length === 1 && template[0].t === INTERPOLATOR;
  }

  // TODO how should event arguments be handled? e.g.
  // <widget on-foo='bar:1,2,3'/>
  // The event 'bar' will be fired on the parent instance
  // when 'foo' fires on the child, but the 1,2,3 arguments
  // will be lost

  var initialise_propagateEvents = propagateEvents;

  function propagateEvents(component, eventsDescriptor) {
  	var eventName;

  	for (eventName in eventsDescriptor) {
  		if (eventsDescriptor.hasOwnProperty(eventName)) {
  			propagateEvent(component.instance, component.root, eventName, eventsDescriptor[eventName]);
  		}
  	}
  }

  function propagateEvent(childInstance, parentInstance, eventName, proxyEventName) {
  	if (typeof proxyEventName !== "string") {
  		fatal("Components currently only support simple events - you cannot include arguments. Sorry!");
  	}

  	childInstance.on(eventName, function () {
  		var event, args;

  		// semi-weak test, but what else? tag the event obj ._isEvent ?
  		if (arguments.length && arguments[0] && arguments[0].node) {
  			event = Array.prototype.shift.call(arguments);
  		}

  		args = Array.prototype.slice.call(arguments);

  		shared_fireEvent(parentInstance, proxyEventName, { event: event, args: args });

  		// cancel bubbling
  		return false;
  	});
  }

  var initialise_updateLiveQueries = function (component) {
  	var ancestor, query;

  	// If there's a live query for this component type, add it
  	ancestor = component.root;
  	while (ancestor) {
  		if (query = ancestor._liveComponentQueries["_" + component.name]) {
  			query.push(component.instance);
  		}

  		ancestor = ancestor.parent;
  	}
  };

  var Component_prototype_init = Component$init;
  function Component$init(options, Component) {
  	var parentFragment, root;

  	if (!Component) {
  		throw new Error("Component \"" + this.name + "\" not found");
  	}

  	parentFragment = this.parentFragment = options.parentFragment;
  	root = parentFragment.root;

  	this.root = root;
  	this.type = COMPONENT;
  	this.name = options.template.e;
  	this.index = options.index;
  	this.indexRefBindings = {};
  	this.yielders = {};
  	this.resolvers = [];

  	createInstance(this, Component, options.template.a, options.template.f, options.template.p);
  	initialise_propagateEvents(this, options.template.v);

  	// intro, outro and decorator directives have no effect
  	if (options.template.t0 || options.template.t1 || options.template.t2 || options.template.o) {
  		warnIfDebug("The \"intro\", \"outro\" and \"decorator\" directives have no effect on components", { ractive: this.instance });
  	}

  	initialise_updateLiveQueries(this);
  }

  var Component_prototype_rebind = Component$rebind;

  function Component$rebind(oldKeypath, newKeypath) {
  	var query;

  	this.resolvers.forEach(rebind);

  	for (var k in this.yielders) {
  		if (this.yielders[k][0]) {
  			rebind(this.yielders[k][0]);
  		}
  	}

  	if (query = this.root._liveComponentQueries["_" + this.name]) {
  		query._makeDirty();
  	}

  	function rebind(x) {
  		x.rebind(oldKeypath, newKeypath);
  	}
  }

  var Component_prototype_render = Component$render;

  function Component$render() {
  	var instance = this.instance;

  	instance.render(this.parentFragment.getNode());

  	this.rendered = true;
  	return instance.fragment.detach();
  }

  var Component_prototype_toString = Component$toString;

  function Component$toString() {
  	return this.instance.fragment.toString();
  }

  var Component_prototype_unbind = Component$unbind;

  var Component_prototype_unbind__teardownHook = new hooks_Hook("teardown");
  function Component$unbind() {
  	var instance = this.instance;

  	this.resolvers.forEach(methodCallers__unbind);

  	removeFromLiveComponentQueries(this);

  	instance._observers.forEach(cancel);

  	// teardown the instance
  	instance.fragment.unbind();
  	instance.viewmodel.teardown();

  	if (instance.fragment.rendered && instance.el.__ractive_instances__) {
  		removeFromArray(instance.el.__ractive_instances__, instance);
  	}

  	Component_prototype_unbind__teardownHook.fire(instance);
  }

  function removeFromLiveComponentQueries(component) {
  	var instance, query;

  	instance = component.root;

  	do {
  		if (query = instance._liveComponentQueries["_" + component.name]) {
  			query._remove(component);
  		}
  	} while (instance = instance.parent);
  }

  var Component_prototype_unrender = Component$unrender;

  function Component$unrender(shouldDestroy) {
  	this.shouldDestroy = shouldDestroy;
  	this.instance.unrender();
  }

  var Component = function (options, Constructor) {
  	this.init(options, Constructor);
  };

  Component.prototype = {
  	detach: Component_prototype_detach,
  	find: Component_prototype_find,
  	findAll: Component_prototype_findAll,
  	findAllComponents: Component_prototype_findAllComponents,
  	findComponent: Component_prototype_findComponent,
  	findNextNode: Component_prototype_findNextNode,
  	firstNode: Component_prototype_firstNode,
  	init: Component_prototype_init,
  	rebind: Component_prototype_rebind,
  	render: Component_prototype_render,
  	toString: Component_prototype_toString,
  	unbind: Component_prototype_unbind,
  	unrender: Component_prototype_unrender
  };

  var _Component = Component;

  var Comment = function (options) {
  	this.type = COMMENT;
  	this.value = options.template.c;
  };

  Comment.prototype = {
  	detach: shared_detach,

  	firstNode: function () {
  		return this.node;
  	},

  	render: function () {
  		if (!this.node) {
  			this.node = document.createComment(this.value);
  		}

  		return this.node;
  	},

  	toString: function () {
  		return "<!--" + this.value + "-->";
  	},

  	unrender: function (shouldDestroy) {
  		if (shouldDestroy) {
  			this.node.parentNode.removeChild(this.node);
  		}
  	}
  };

  var items_Comment = Comment;

  var Yielder = function (options) {
  	var container, component;

  	this.type = YIELDER;

  	this.container = container = options.parentFragment.root;
  	this.component = component = container.component;

  	this.container = container;
  	this.containerFragment = options.parentFragment;
  	this.parentFragment = component.parentFragment;

  	var name = this.name = options.template.n || "";

  	var template = container._inlinePartials[name];

  	if (!template) {
  		warnIfDebug("Could not find template for partial \"" + name + "\"", { ractive: options.root });
  		template = [];
  	}

  	this.fragment = new virtualdom_Fragment({
  		owner: this,
  		root: container.parent,
  		template: template,
  		pElement: this.containerFragment.pElement
  	});

  	// even though only one yielder is allowed, we need to have an array of them
  	// as it's possible to cause a yielder to be created before the last one
  	// was destroyed in the same turn of the runloop
  	if (!isArray(component.yielders[name])) {
  		component.yielders[name] = [this];
  	} else {
  		component.yielders[name].push(this);
  	}

  	global_runloop.scheduleTask(function () {
  		if (component.yielders[name].length > 1) {
  			throw new Error("A component template can only have one {{yield" + (name ? " " + name : "") + "}} declaration at a time");
  		}
  	});
  };

  Yielder.prototype = {
  	detach: function () {
  		return this.fragment.detach();
  	},

  	find: function (selector) {
  		return this.fragment.find(selector);
  	},

  	findAll: function (selector, query) {
  		return this.fragment.findAll(selector, query);
  	},

  	findComponent: function (selector) {
  		return this.fragment.findComponent(selector);
  	},

  	findAllComponents: function (selector, query) {
  		return this.fragment.findAllComponents(selector, query);
  	},

  	findNextNode: function () {
  		return this.containerFragment.findNextNode(this);
  	},

  	firstNode: function () {
  		return this.fragment.firstNode();
  	},

  	getValue: function (options) {
  		return this.fragment.getValue(options);
  	},

  	render: function () {
  		return this.fragment.render();
  	},

  	unbind: function () {
  		this.fragment.unbind();
  	},

  	unrender: function (shouldDestroy) {
  		this.fragment.unrender(shouldDestroy);
  		removeFromArray(this.component.yielders[this.name], this);
  	},

  	rebind: function (oldKeypath, newKeypath) {
  		this.fragment.rebind(oldKeypath, newKeypath);
  	},

  	toString: function () {
  		return this.fragment.toString();
  	}
  };

  var items_Yielder = Yielder;

  var Doctype = function (options) {
  	this.declaration = options.template.a;
  };

  Doctype.prototype = {
  	init: noop,
  	render: noop,
  	unrender: noop,
  	teardown: noop,
  	toString: function () {
  		return "<!DOCTYPE" + this.declaration + ">";
  	}
  };

  var items_Doctype = Doctype;

  var Fragment_prototype_init = Fragment$init;

  function Fragment$init(options) {
  	var _this = this;

  	this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute
  	this.parent = this.owner.parentFragment;

  	// inherited properties
  	this.root = options.root;
  	this.pElement = options.pElement;
  	this.context = options.context;
  	this.index = options.index;
  	this.key = options.key;
  	this.registeredIndexRefs = [];

  	// encapsulated styles should be inherited until they get applied by an element
  	this.cssIds = "cssIds" in options ? options.cssIds : this.parent ? this.parent.cssIds : null;

  	this.items = options.template.map(function (template, i) {
  		return createItem({
  			parentFragment: _this,
  			pElement: options.pElement,
  			template: template,
  			index: i
  		});
  	});

  	this.value = this.argsList = null;
  	this.dirtyArgs = this.dirtyValue = true;

  	this.bound = true;
  }

  function createItem(options) {
  	if (typeof options.template === "string") {
  		return new items_Text(options);
  	}

  	switch (options.template.t) {
  		case YIELDER:
  			return new items_Yielder(options);
  		case INTERPOLATOR:
  			return new items_Interpolator(options);
  		case SECTION:
  			return new _Section(options);
  		case TRIPLE:
  			return new _Triple(options);
  		case ELEMENT:
  			var constructor = undefined;
  			if (constructor = Component_getComponent(options.parentFragment.root, options.template.e)) {
  				return new _Component(options, constructor);
  			}
  			return new _Element(options);
  		case PARTIAL:
  			return new _Partial(options);
  		case COMMENT:
  			return new items_Comment(options);
  		case DOCTYPE:
  			return new items_Doctype(options);

  		default:
  			throw new Error("Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!");
  	}
  }

  var Fragment_prototype_rebind = Fragment$rebind;
  function Fragment$rebind(oldKeypath, newKeypath) {

  	// assign new context keypath if needed
  	if (!this.owner || this.owner.hasContext) {
  		assignNewKeypath(this, "context", oldKeypath, newKeypath);
  	}

  	this.items.forEach(function (item) {
  		if (item.rebind) {
  			item.rebind(oldKeypath, newKeypath);
  		}
  	});
  }

  var Fragment_prototype_render = Fragment$render;

  function Fragment$render() {
  	var result;

  	if (this.items.length === 1) {
  		result = this.items[0].render();
  	} else {
  		result = document.createDocumentFragment();

  		this.items.forEach(function (item) {
  			result.appendChild(item.render());
  		});
  	}

  	this.rendered = true;
  	return result;
  }

  var Fragment_prototype_toString = Fragment$toString;

  function Fragment$toString(escape) {
  	if (!this.items) {
  		return "";
  	}

  	return this.items.map(escape ? toEscapedString : Fragment_prototype_toString__toString).join("");
  }

  function Fragment_prototype_toString__toString(item) {
  	return item.toString();
  }

  function toEscapedString(item) {
  	return item.toString(true);
  }

  var Fragment_prototype_unbind = Fragment$unbind;

  function Fragment$unbind() {
  	if (!this.bound) {
  		return;
  	}

  	this.items.forEach(unbindItem);
  	this.bound = false;
  }

  function unbindItem(item) {
  	if (item.unbind) {
  		item.unbind();
  	}
  }

  var Fragment_prototype_unrender = Fragment$unrender;

  function Fragment$unrender(shouldDestroy) {
  	if (!this.rendered) {
  		throw new Error("Attempted to unrender a fragment that was not rendered");
  	}

  	this.items.forEach(function (i) {
  		return i.unrender(shouldDestroy);
  	});
  	this.rendered = false;
  }

  var Fragment = function (options) {
  	this.init(options);
  };

  Fragment.prototype = {
  	bubble: prototype_bubble,
  	detach: Fragment_prototype_detach,
  	find: Fragment_prototype_find,
  	findAll: Fragment_prototype_findAll,
  	findAllComponents: Fragment_prototype_findAllComponents,
  	findComponent: Fragment_prototype_findComponent,
  	findNextNode: prototype_findNextNode,
  	firstNode: prototype_firstNode,
  	getArgsList: getArgsList,
  	getNode: getNode,
  	getValue: prototype_getValue,
  	init: Fragment_prototype_init,
  	rebind: Fragment_prototype_rebind,
  	registerIndexRef: function (idx) {
  		var idxs = this.registeredIndexRefs;
  		if (idxs.indexOf(idx) === -1) {
  			idxs.push(idx);
  		}
  	},
  	render: Fragment_prototype_render,
  	toString: Fragment_prototype_toString,
  	unbind: Fragment_prototype_unbind,
  	unregisterIndexRef: function (idx) {
  		var idxs = this.registeredIndexRefs;
  		idxs.splice(idxs.indexOf(idx), 1);
  	},
  	unrender: Fragment_prototype_unrender
  };

  var virtualdom_Fragment = Fragment;

  var prototype_reset = Ractive$reset;
  var shouldRerender = ["template", "partials", "components", "decorators", "events"],
      resetHook = new hooks_Hook("reset");
  function Ractive$reset(data) {
  	var promise, wrapper, changes, i, rerender;

  	data = data || {};

  	if (typeof data !== "object") {
  		throw new Error("The reset method takes either no arguments, or an object containing new data");
  	}

  	// If the root object is wrapped, try and use the wrapper's reset value
  	if ((wrapper = this.viewmodel.wrapped[""]) && wrapper.reset) {
  		if (wrapper.reset(data) === false) {
  			// reset was rejected, we need to replace the object
  			this.viewmodel.reset(data);
  		}
  	} else {
  		this.viewmodel.reset(data);
  	}

  	// reset config items and track if need to rerender
  	changes = config_config.reset(this);

  	i = changes.length;
  	while (i--) {
  		if (shouldRerender.indexOf(changes[i]) > -1) {
  			rerender = true;
  			break;
  		}
  	}

  	if (rerender) {
  		var component = undefined;

  		this.viewmodel.mark(rootKeypath);

  		// Is this is a component, we need to set the `shouldDestroy`
  		// flag, otherwise it will assume by default that a parent node
  		// will be detached, and therefore it doesn't need to bother
  		// detaching its own nodes
  		if (component = this.component) {
  			component.shouldDestroy = true;
  		}

  		this.unrender();

  		if (component) {
  			component.shouldDestroy = false;
  		}

  		// If the template changed, we need to destroy the parallel DOM
  		// TODO if we're here, presumably it did?
  		if (this.fragment.template !== this.template) {
  			this.fragment.unbind();

  			this.fragment = new virtualdom_Fragment({
  				template: this.template,
  				root: this,
  				owner: this
  			});
  		}

  		promise = this.render(this.el, this.anchor);
  	} else {
  		promise = global_runloop.start(this, true);
  		this.viewmodel.mark(rootKeypath);
  		global_runloop.end();
  	}

  	resetHook.fire(this, data);

  	return promise;
  }

  var resetPartial = function (name, partial) {
  	var promise,
  	    collection = [];

  	function collect(source, dest, ractive) {
  		// if this is a component and it has its own partial, bail
  		if (ractive && ractive.partials[name]) return;

  		source.forEach(function (item) {
  			// queue to rerender if the item is a partial and the current name matches
  			if (item.type === PARTIAL && item.getPartialName() === name) {
  				dest.push(item);
  			}

  			// if it has a fragment, process its items
  			if (item.fragment) {
  				collect(item.fragment.items, dest, ractive);
  			}

  			// or if it has fragments
  			if (isArray(item.fragments)) {
  				collect(item.fragments, dest, ractive);
  			}

  			// or if it is itself a fragment, process its items
  			else if (isArray(item.items)) {
  				collect(item.items, dest, ractive);
  			}

  			// or if it is a component, step in and process its items
  			else if (item.type === COMPONENT && item.instance) {
  				collect(item.instance.fragment.items, dest, item.instance);
  			}

  			// if the item is an element, process its attributes too
  			if (item.type === ELEMENT) {
  				if (isArray(item.attributes)) {
  					collect(item.attributes, dest, ractive);
  				}

  				if (isArray(item.conditionalAttributes)) {
  					collect(item.conditionalAttributes, dest, ractive);
  				}
  			}
  		});
  	}

  	collect(this.fragment.items, collection);
  	this.partials[name] = partial;

  	promise = global_runloop.start(this, true);

  	collection.forEach(function (item) {
  		item.value = undefined;
  		item.setValue(name);
  	});

  	global_runloop.end();

  	return promise;
  };

  // TODO should resetTemplate be asynchronous? i.e. should it be a case
  // of outro, update template, intro? I reckon probably not, since that
  // could be achieved with unrender-resetTemplate-render. Also, it should
  // conceptually be similar to resetPartial, which couldn't be async

  var resetTemplate = Ractive$resetTemplate;
  function Ractive$resetTemplate(template) {
  	var transitionsEnabled, component;

  	template_template.init(null, this, { template: template });

  	transitionsEnabled = this.transitionsEnabled;
  	this.transitionsEnabled = false;

  	// Is this is a component, we need to set the `shouldDestroy`
  	// flag, otherwise it will assume by default that a parent node
  	// will be detached, and therefore it doesn't need to bother
  	// detaching its own nodes
  	if (component = this.component) {
  		component.shouldDestroy = true;
  	}

  	this.unrender();

  	if (component) {
  		component.shouldDestroy = false;
  	}

  	// remove existing fragment and create new one
  	this.fragment.unbind();
  	this.fragment = new virtualdom_Fragment({
  		template: this.template,
  		root: this,
  		owner: this
  	});

  	this.render(this.el, this.anchor);

  	this.transitionsEnabled = transitionsEnabled;
  }

  var reverse = makeArrayMethod("reverse");

  var Ractive_prototype_set = Ractive$set;

  function Ractive$set(keypath, value) {
  	var map, promise;

  	promise = global_runloop.start(this, true);

  	// Set multiple keypaths in one go
  	if (isObject(keypath)) {
  		map = keypath;

  		for (keypath in map) {
  			if (map.hasOwnProperty(keypath)) {
  				value = map[keypath];
  				set(this, keypath, value);
  			}
  		}
  	}

  	// Set a single keypath
  	else {
  		set(this, keypath, value);
  	}

  	global_runloop.end();

  	return promise;
  }

  function set(ractive, keypath, value) {
  	keypath = getKeypath(normalise(keypath));

  	if (keypath.isPattern) {
  		getMatchingKeypaths(ractive, keypath).forEach(function (keypath) {
  			ractive.viewmodel.set(keypath, value);
  		});
  	} else {
  		ractive.viewmodel.set(keypath, value);
  	}
  }

  var shift = makeArrayMethod("shift");

  var prototype_sort = makeArrayMethod("sort");

  var splice = makeArrayMethod("splice");

  var subtract = Ractive$subtract;
  function Ractive$subtract(keypath, d) {
  	return shared_add(this, keypath, d === undefined ? -1 : -d);
  }

  // Teardown. This goes through the root fragment and all its children, removing observers
  // and generally cleaning up after itself

  var Ractive_prototype_teardown = Ractive$teardown;

  var Ractive_prototype_teardown__teardownHook = new hooks_Hook("teardown");
  function Ractive$teardown() {
  	var promise;

  	this.fragment.unbind();
  	this.viewmodel.teardown();

  	this._observers.forEach(cancel);

  	if (this.fragment.rendered && this.el.__ractive_instances__) {
  		removeFromArray(this.el.__ractive_instances__, this);
  	}

  	this.shouldDestroy = true;
  	promise = this.fragment.rendered ? this.unrender() : utils_Promise.resolve();

  	Ractive_prototype_teardown__teardownHook.fire(this);

  	this._boundFunctions.forEach(deleteFunctionCopy);

  	return promise;
  }

  function deleteFunctionCopy(bound) {
  	delete bound.fn[bound.prop];
  }

  var toggle = Ractive$toggle;
  function Ractive$toggle(keypath) {
  	var _this = this;

  	if (typeof keypath !== "string") {
  		throw new TypeError(badArguments);
  	}

  	var changes = undefined;

  	if (/\*/.test(keypath)) {
  		changes = {};

  		getMatchingKeypaths(this, getKeypath(normalise(keypath))).forEach(function (keypath) {
  			changes[keypath.str] = !_this.viewmodel.get(keypath);
  		});

  		return this.set(changes);
  	}

  	return this.set(keypath, !this.get(keypath));
  }

  var toHTML = Ractive$toHTML;

  function Ractive$toHTML() {
  	return this.fragment.toString(true);
  }

  var Ractive_prototype_unrender = Ractive$unrender;
  var unrenderHook = new hooks_Hook("unrender");
  function Ractive$unrender() {
  	var promise, shouldDestroy;

  	if (!this.fragment.rendered) {
  		warnIfDebug("ractive.unrender() was called on a Ractive instance that was not rendered");
  		return utils_Promise.resolve();
  	}

  	promise = global_runloop.start(this, true);

  	// If this is a component, and the component isn't marked for destruction,
  	// don't detach nodes from the DOM unnecessarily
  	shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;

  	// Cancel any animations in progress
  	while (this._animations[0]) {
  		this._animations[0].stop(); // it will remove itself from the index
  	}

  	this.fragment.unrender(shouldDestroy);

  	removeFromArray(this.el.__ractive_instances__, this);

  	unrenderHook.fire(this);

  	global_runloop.end();
  	return promise;
  }

  var unshift = makeArrayMethod("unshift");

  var Ractive_prototype_update = Ractive$update;
  var updateHook = new hooks_Hook("update");
  function Ractive$update(keypath) {
  	var promise;

  	keypath = getKeypath(keypath) || rootKeypath;

  	promise = global_runloop.start(this, true);
  	this.viewmodel.mark(keypath);
  	global_runloop.end();

  	updateHook.fire(this, keypath);

  	return promise;
  }

  var prototype_updateModel = Ractive$updateModel;

  function Ractive$updateModel(keypath, cascade) {
  	var values, key, bindings;

  	if (typeof keypath === "string" && !cascade) {
  		bindings = this._twowayBindings[keypath];
  	} else {
  		bindings = [];

  		for (key in this._twowayBindings) {
  			if (!keypath || getKeypath(key).equalsOrStartsWith(keypath)) {
  				// TODO is this right?
  				bindings.push.apply(bindings, this._twowayBindings[key]);
  			}
  		}
  	}

  	values = consolidate(this, bindings);
  	return this.set(values);
  }

  function consolidate(ractive, bindings) {
  	var values = {},
  	    checkboxGroups = [];

  	bindings.forEach(function (b) {
  		var oldValue, newValue;

  		// special case - radio name bindings
  		if (b.radioName && !b.element.node.checked) {
  			return;
  		}

  		// special case - checkbox name bindings come in groups, so
  		// we want to get the value once at most
  		if (b.checkboxName) {
  			if (!checkboxGroups[b.keypath.str] && !b.changed()) {
  				checkboxGroups.push(b.keypath);
  				checkboxGroups[b.keypath.str] = b;
  			}

  			return;
  		}

  		oldValue = b.attribute.value;
  		newValue = b.getValue();

  		if (arrayContentsMatch(oldValue, newValue)) {
  			return;
  		}

  		if (!isEqual(oldValue, newValue)) {
  			values[b.keypath.str] = newValue;
  		}
  	});

  	// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
  	if (checkboxGroups.length) {
  		checkboxGroups.forEach(function (keypath) {
  			var binding, oldValue, newValue;

  			binding = checkboxGroups[keypath.str]; // one to represent the entire group
  			oldValue = binding.attribute.value;
  			newValue = binding.getValue();

  			if (!arrayContentsMatch(oldValue, newValue)) {
  				values[keypath.str] = newValue;
  			}
  		});
  	}

  	return values;
  }

  var prototype = {
  	add: prototype_add,
  	animate: prototype_animate,
  	detach: prototype_detach,
  	find: prototype_find,
  	findAll: prototype_findAll,
  	findAllComponents: prototype_findAllComponents,
  	findComponent: prototype_findComponent,
  	findContainer: findContainer,
  	findParent: findParent,
  	fire: prototype_fire,
  	get: prototype_get,
  	insert: insert,
  	merge: prototype_merge,
  	observe: observe,
  	observeOnce: observeOnce,
  	off: off,
  	on: on,
  	once: once,
  	pop: pop,
  	push: push,
  	render: prototype_render,
  	reset: prototype_reset,
  	resetPartial: resetPartial,
  	resetTemplate: resetTemplate,
  	reverse: reverse,
  	set: Ractive_prototype_set,
  	shift: shift,
  	sort: prototype_sort,
  	splice: splice,
  	subtract: subtract,
  	teardown: Ractive_prototype_teardown,
  	toggle: toggle,
  	toHTML: toHTML,
  	toHtml: toHTML,
  	unrender: Ractive_prototype_unrender,
  	unshift: unshift,
  	update: Ractive_prototype_update,
  	updateModel: prototype_updateModel
  };

  var wrapMethod = function (method, superMethod, force) {

  	if (force || needsSuper(method, superMethod)) {

  		return function () {

  			var hasSuper = ("_super" in this),
  			    _super = this._super,
  			    result;

  			this._super = superMethod;

  			result = method.apply(this, arguments);

  			if (hasSuper) {
  				this._super = _super;
  			}

  			return result;
  		};
  	} else {
  		return method;
  	}
  };

  function needsSuper(method, superMethod) {
  	return typeof superMethod === "function" && /_super/.test(method);
  }

  var unwrapExtended = unwrap;

  function unwrap(Child) {
  	var options = {};

  	while (Child) {
  		addRegistries(Child, options);
  		addOtherOptions(Child, options);

  		if (Child._Parent !== _Ractive) {
  			Child = Child._Parent;
  		} else {
  			Child = false;
  		}
  	}

  	return options;
  }

  function addRegistries(Child, options) {
  	config_registries.forEach(function (r) {
  		addRegistry(r.useDefaults ? Child.prototype : Child, options, r.name);
  	});
  }

  function addRegistry(target, options, name) {
  	var registry,
  	    keys = Object.keys(target[name]);

  	if (!keys.length) {
  		return;
  	}

  	if (!(registry = options[name])) {
  		registry = options[name] = {};
  	}

  	keys.filter(function (key) {
  		return !(key in registry);
  	}).forEach(function (key) {
  		return registry[key] = target[name][key];
  	});
  }

  function addOtherOptions(Child, options) {
  	Object.keys(Child.prototype).forEach(function (key) {
  		if (key === "computed") {
  			return;
  		}

  		var value = Child.prototype[key];

  		if (!(key in options)) {
  			options[key] = value._method ? value._method : value;
  		}

  		// is it a wrapped function?
  		else if (typeof options[key] === "function" && typeof value === "function" && options[key]._method) {

  			var result = undefined,
  			    needsSuper = value._method;

  			if (needsSuper) {
  				value = value._method;
  			}

  			// rewrap bound directly to parent fn
  			result = wrapMethod(options[key]._method, value);

  			if (needsSuper) {
  				result._method = result;
  			}

  			options[key] = result;
  		}
  	});
  }

  var _extend = _extend__extend;

  function _extend__extend() {
  	for (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {
  		options[_key] = arguments[_key];
  	}

  	if (!options.length) {
  		return extendOne(this);
  	} else {
  		return options.reduce(extendOne, this);
  	}
  }

  function extendOne(Parent) {
  	var options = arguments[1] === undefined ? {} : arguments[1];

  	var Child, proto;

  	// if we're extending with another Ractive instance...
  	//
  	//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);
  	//   var Spiderman = Human.extend( Spider );
  	//
  	// ...inherit prototype methods and default options as well
  	if (options.prototype instanceof _Ractive) {
  		options = unwrapExtended(options);
  	}

  	Child = function (options) {
  		if (!(this instanceof Child)) return new Child(options);
  		initialise(this, options);
  	};

  	proto = create(Parent.prototype);
  	proto.constructor = Child;

  	// Static properties
  	defineProperties(Child, {
  		// alias prototype as defaults
  		defaults: { value: proto },

  		// extendable
  		extend: { value: _extend__extend, writable: true, configurable: true },

  		// Parent - for IE8, can't use Object.getPrototypeOf
  		_Parent: { value: Parent }
  	});

  	// extend configuration
  	config_config.extend(Parent, proto, options);

  	custom_data.extend(Parent, proto, options);

  	if (options.computed) {
  		proto.computed = utils_object__extend(create(Parent.prototype.computed), options.computed);
  	}

  	Child.prototype = proto;

  	return Child;
  }

  var getNodeInfo = function (node) {
  	var info = {},
  	    priv,
  	    indices;

  	if (!node || !(priv = node._ractive)) {
  		return info;
  	}

  	info.ractive = priv.root;
  	info.keypath = priv.keypath.str;
  	info.index = {};

  	// find all index references and resolve them
  	if (indices = Resolvers_findIndexRefs(priv.proxy.parentFragment)) {
  		info.index = Resolvers_findIndexRefs.resolve(indices);
  	}

  	return info;
  };

  var Ractive, properties;

  // Main Ractive required object
  Ractive = function (options) {
  	if (!(this instanceof Ractive)) return new Ractive(options);
  	initialise(this, options);
  };

  // Ractive properties
  properties = {

  	// debug flag
  	DEBUG: { writable: true, value: true },
  	DEBUG_PROMISES: { writable: true, value: true },

  	// static methods:
  	extend: { value: _extend },
  	getNodeInfo: { value: getNodeInfo },
  	parse: { value: _parse },

  	// Namespaced constructors
  	Promise: { value: utils_Promise },

  	// support
  	svg: { value: svg },
  	magic: { value: environment__magic },

  	// version
  	VERSION: { value: "0.7.3" },

  	// Plugins
  	adaptors: { writable: true, value: {} },
  	components: { writable: true, value: {} },
  	decorators: { writable: true, value: {} },
  	easing: { writable: true, value: static_easing },
  	events: { writable: true, value: {} },
  	interpolators: { writable: true, value: static_interpolators },
  	partials: { writable: true, value: {} },
  	transitions: { writable: true, value: {} }
  };

  // Ractive properties
  defineProperties(Ractive, properties);

  Ractive.prototype = utils_object__extend(prototype, config_defaults);

  Ractive.prototype.constructor = Ractive;

  // alias prototype as defaults
  Ractive.defaults = Ractive.prototype;

  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In
  // older browsers, these are made available via a shim - here, we do a quick
  // pre-flight check to make sure that either a) we're not in a shit browser,
  // or b) we're using a Ractive-legacy.js build
  var FUNCTION = "function";

  if (typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== "undefined" && typeof window.addEventListener !== FUNCTION) {
  	throw new Error("It looks like you're attempting to use Ractive.js in an older browser. You'll need to use one of the 'legacy builds' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.");
  }

  var _Ractive = Ractive;

  return _Ractive;

}));


},{}],7:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.Sparkline = factory();
  }
}(this, function () {


    function extend(specific, general){
        var obj = {};
        for(var key in general){
            obj[key] = key in specific ? specific[key] : general[key];
        }
        return obj;
    }

    function Sparkline(element, options){
        this.element = element;
        this.options = extend(options || {}, Sparkline.options);

        init: {
            this.element.innerHTML = "<canvas></canvas>";
            this.canvas = this.element.firstChild;
            this.context = this.canvas.getContext("2d");
            this.ratio = window.devicePixelRatio || 1;
            
            if(this.options.tooltip){
                this.canvas.style.position = "relative";
                this.canvas.onmousemove = showTooltip.bind(this);
            }
        }
    }

    Sparkline.options = {
        width: 100,
        lineColor: "black",
        lineWidth: 1,
        startColor: "transparent",
        endColor: "red",
        maxColor: "transparent",
        minColor: "transparent",
        minValue: null,
        maxValue: null,
        dotRadius: 2.5,
        tooltip: null
    };

    Sparkline.init = function(element, options){
        return new Sparkline(element, options);
    };

    Sparkline.draw = function(element, points, options){
        var sparkline = new Sparkline(element, options);
        sparkline.draw(points);
        return sparkline;
    }

    function getY(minValue, maxValue, offsetY, height, index){
        var range = maxValue - minValue;
        if(range == 0){
          return offsetY + height/2;
        }else{
          return (offsetY + height) - ((this[index] - minValue) / range)*height;
        }
    }

    function drawDot(radius, color, x, y){
        this.beginPath();
        this.fillStyle = color;
        this.arc(x, y, radius, 0, Math.PI*2, false);
        this.fill();
    }
  
    function showTooltip(e){
        var x = e.offsetX || e.layerX || 0;
        var delta = ((this.options.width - this.options.dotRadius*2) / (this.points.length - 1));
        var index = minmax(0, Math.round((x - this.options.dotRadius)/delta), this.points.length - 1);
        
        this.canvas.title = this.options.tooltip(this.points[index], index, this.points);
    }

    Sparkline.prototype.draw = function(points){

        points = points || [];
        this.points = points;
        
        this.canvas.width = this.options.width * this.ratio;
        this.canvas.height = this.element.offsetHeight * this.ratio;
        this.canvas.style.width = this.options.width + 'px';
        this.canvas.style.height = this.element.offsetHeight + 'px';

        var offsetX = this.options.dotRadius*this.ratio;
        var offsetY = this.options.dotRadius*this.ratio;
        var width = this.canvas.width - offsetX*2;
        var height = this.canvas.height - offsetY*2;

        var minValue = this.options.minValue || Math.min.apply(Math, points);
        var maxValue = this.options.maxValue || Math.max.apply(Math, points);
        var minX = offsetX;
        var maxX = offsetX;

        var x = offsetX;
        var y = getY.bind(points, minValue, maxValue, offsetY, height);
        var delta = width / (points.length - 1);

        var dot = drawDot.bind(this.context, this.options.dotRadius*this.ratio);


        this.context.beginPath();
        this.context.strokeStyle = this.options.lineColor;
        this.context.lineWidth = this.options.lineWidth*this.ratio;

        this.context.moveTo(x, y(0));
        for(var i=1; i<points.length; i++){
            x += delta;
            this.context.lineTo(x, y(i));

            minX = points[i] == minValue ? x : minX;
            maxX = points[i] == maxValue ? x : maxX;
        }
        this.context.stroke();

        dot(this.options.startColor, offsetX + (points.length == 1 ? width/2 : 0), y(0));
        dot(this.options.endColor, offsetX + (points.length == 1 ? width/2 : width), y(i - 1));
        dot(this.options.minColor, minX + (points.length == 1 ? width/2 : 0), y(points.indexOf(minValue)));
        dot(this.options.maxColor, maxX + (points.length == 1 ? width/2 : 0), y(points.indexOf(maxValue)));
    }
    
    function minmax(a, b, c){
        return Math.max(a, Math.min(b, c));
    }

    return Sparkline;
}));
},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjYXIuanMiLCJpbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXQtZ3VpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RhdC1ndWkvdmVuZG9yL2RhdC5jb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9kYXQtZ3VpL3ZlbmRvci9kYXQuZ3VpLmpzIiwibm9kZV9tb2R1bGVzL3JhY3RpdmUvcmFjdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9zcGFya2xpbmVzL3NvdXJjZS9zcGFya2xpbmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMza0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzdWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgUmFjdGl2ZSA9IHJlcXVpcmUoXCJyYWN0aXZlXCIpO1xuXG52YXIgdHBsQ2FyID0gJzxpbWFnZSBjbGFzcz1cImNhclwiIHhsaW5rOmhyZWY9XCJjYXIuc3ZnXCIgeT1cInt7IHkgfX1cIiB4PVwie3sgeCB9fVwiIHRyYW5zZm9ybT1cInJvdGF0ZSh7eyBhIH19IHt7IHggfX0ge3sgeSB9fSlcIiBoZWlnaHQ9XCI0MFwiIHdpZHRoPVwiMTAwXCIgLz4nO1xuXG52YXIgUkNhciA9IFJhY3RpdmUuZXh0ZW5kKHtcbiAgdGVtcGxhdGU6IHRwbENhclxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUkNhcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgVEFVID0gMiAqIE1hdGguUEk7XG52YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbnZhciBSQWN0aXZlID0gcmVxdWlyZShcInJhY3RpdmVcIik7XG52YXIgU3BhcmtsaW5lcyA9IHJlcXVpcmUoXCJzcGFya2xpbmVzXCIpO1xudmFyIGRhdCA9IHJlcXVpcmUoXCJkYXQtZ3VpXCIpO1xudmFyIFJDYXIgPSByZXF1aXJlKFwiLi9jYXJcIik7XG5cbmZ1bmN0aW9uIGNsYW1wKHYsIG1pbiwgbWF4KSB7XG4gIHJldHVybiB2IDwgbWluID8gbWluIDogdiA+IG1heCA/IG1heCA6IHY7XG59XG5cbnZhciBkYXRhID0ge1xuICBjYXI6IHtcbiAgICBhOiAwLFxuICAgIHg6IDAsXG4gICAgeTogMjUsXG4gICAgc3RlZXJpbmdBbmdsZTogMCxcbiAgICBtYXhTdGVlcmluZ0FuZ2xlOiAzMCxcbiAgICBzcGVlZDogMVxuICB9LFxuICByb2FkOiB7XG4gICAgeTogMzAwXG4gIH0sXG4gIGNpcmNsZXM6IFtdLFxuICBzdG9wOiB7XG4gICAgYWN0aW9uOiBcIlN0b3BcIlxuICB9LFxuICB0ZXJtczoge1xuICAgIHRpbWVDaGFuZ2U6IFwiMFwiLFxuICAgIGVycjogXCIwXCIsXG4gICAgZEVycjogXCIwXCIsXG4gICAgZXJyU3VtOiBcIjBcIixcbiAgICBvdXRwdXQ6IFwiMFwiLFxuICAgIHBUZXJtOiBcIjBcIixcbiAgICBpVGVybTogXCIwXCIsXG4gICAgZFRlcm06IFwiMFwiXG4gIH1cbn07XG5cbndpbmRvdy5kYXRhID0gZGF0YTtcblxudmFyIGRhdEd1aSA9IG5ldyBkYXQuR1VJKCk7XG5kYXRHdWkuYWRkKGRhdGEuY2FyLCBcInhcIikubGlzdGVuKCk7XG5kYXRHdWkuYWRkKGRhdGEuY2FyLCBcInlcIikubGlzdGVuKCk7XG5kYXRHdWkuYWRkKGRhdGEuY2FyLCBcInN0ZWVyaW5nQW5nbGVcIikubGlzdGVuKCk7XG5kYXRHdWkuYWRkKGRhdGEuY2FyLCBcImFcIikubGlzdGVuKCk7XG5kYXRHdWkuYWRkKGRhdGEuY2FyLCBcInNwZWVkXCIsIDAsIDUwKTtcbmRhdEd1aS5hZGQoZGF0YS5yb2FkLCBcInlcIiwgMCwgNTAwKTtcbmRhdEd1aS5hZGQoZGF0YS50ZXJtcywgXCJ0aW1lQ2hhbmdlXCIpLmxpc3RlbigpO1xuZGF0R3VpLmFkZChkYXRhLnRlcm1zLCBcImVyclwiKS5saXN0ZW4oKTtcbmRhdEd1aS5hZGQoZGF0YS50ZXJtcywgXCJkRXJyXCIpLmxpc3RlbigpO1xuZGF0R3VpLmFkZChkYXRhLnRlcm1zLCBcImVyclN1bVwiKS5saXN0ZW4oKTtcbmRhdEd1aS5hZGQoZGF0YS50ZXJtcywgXCJwVGVybVwiKS5saXN0ZW4oKTtcbmRhdEd1aS5hZGQoZGF0YS50ZXJtcywgXCJpVGVybVwiKS5saXN0ZW4oKTtcbmRhdEd1aS5hZGQoZGF0YS50ZXJtcywgXCJkVGVybVwiKS5saXN0ZW4oKTtcbmRhdEd1aS5hZGQoZGF0YS50ZXJtcywgXCJvdXRwdXRcIikubGlzdGVuKCk7XG5cbnZhciBlbFJvYWQgPSBuZXcgUkFjdGl2ZSh7XG4gIGFwcGVuZDogdHJ1ZSxcbiAgZWw6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIiksXG4gIHRlbXBsYXRlOiAnPHJlY3QgaWQ9XCJyb2FkXCIgeT1cInt7IHJvYWQueSB9fVwiPjwvcmVjdD4nLFxuICBkYXRhOiBkYXRhXG59KTtcblxudmFyIGVsQ2FyID0gbmV3IFJDYXIoe1xuICBhcHBlbmQ6IHRydWUsXG4gIGVsOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpLFxuICBkYXRhOiBkYXRhLmNhclxufSk7XG5cbnZhciBlbFJvYWREaXN0YW5jZSA9IG5ldyBSQWN0aXZlKHtcbiAgYXBwZW5kOiB0cnVlLFxuICBlbDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInN2Z1wiKSxcbiAgdGVtcGxhdGU6ICc8ZGl2IGlkPVwicm9hZC1pbmRpY2F0b3JcIiBzdHlsZT1cImxlZnQ6IHt7IGNhci54IH19cHg7IHRvcDoge3sgY2FyLnkgKyAoKHJvYWQueSAtIGNhci55ICkgLyAyKSB9fXB4O1wiPnt7IE1hdGgucm91bmQocm9hZC55IC0gY2FyLnkpIH19PC9kaXY+JyxcbiAgZGF0YTogZGF0YVxufSk7XG5cbnZhciBzdG9wID0gZmFsc2U7XG5cbnZhciBlbFN0b3AgPSBuZXcgUkFjdGl2ZSh7XG4gIGFwcGVuZDogdHJ1ZSxcbiAgZWw6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIiksXG4gIHRlbXBsYXRlOiAnPGRpdiBvbi1jbGljaz1cInN0YXJ0c3RvcFwiPnt7IGFjdGlvbiB9fTwvZGl2PjxkaXYgb24tY2xpY2s9XCJzZXRcIj5SZXNldDwvZGl2PicsXG4gIGRhdGE6IGRhdGEuc3RvcFxufSk7XG5cbmVsU3RvcC5vbihcInNldFwiLCBmdW5jdGlvbigpIHtcbiAgZGF0YS5jYXIueCA9IGRhdGEuY2FyLmEgPSAwO1xuICBkYXRhLmNhci55ID0gNTA7XG59KTtcblxuZWxTdG9wLm9uKFwic3RhcnRzdG9wXCIsIGZ1bmN0aW9uKCkge1xuICBzdG9wID0gIXN0b3A7XG5cbiAgZGF0YS5zdG9wLmFjdGlvbiA9IHN0b3AgPyBcIlN0YXJ0XCIgOiBcIlN0b3BcIjtcbiAgZWxTdG9wLnVwZGF0ZShcImFjdGlvblwiKTtcblxuICBpZighc3RvcCkge1xuICAgIGFuaW1hdGUoKTtcbiAgfVxufSk7XG5cbnZhciBlbEhpZ2hsaWdodGVyID0gbmV3IFJBY3RpdmUoe1xuICBhcHBlbmQ6IHRydWUsXG4gIGVsOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpLFxuICB0ZW1wbGF0ZTogJzxzdmcgaWQ9XCJoaWdobGlnaHRcIiBzdHlsZT1cImxlZnQ6IHt7IGNhci54IC0gNDAgfX1weDsgdG9wOiB7eyBjYXIueSAtIDQwfX1weDtcIj5cXFxuICAgIHt7I2NpcmNsZXN9fTxjaXJjbGUgY3g9XCJ7eyB4IH19XCIgY3k9XCJ7eyB5IH19XCIgcj1cIjFcIiAvPnt7L319XFxcbiAgPC9zdmc+JyxcbiAgZGF0YTogZGF0YVxufSk7XG5cbnZhciBzdGVwID0gMC4xO1xudmFyIGFuZ2xlID0gMDtcbndoaWxlKGFuZ2xlIDwgVEFVKSB7XG4gIHZhciB4ID0gOTAgKyAoNjAgKiBNYXRoLmNvcyhhbmdsZSkpO1xuICB2YXIgeSA9IDY4ICsgKDYwICogTWF0aC5zaW4oYW5nbGUpKTtcblxuICBkYXRhLmNpcmNsZXMucHVzaCh7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pO1xuXG4gIGFuZ2xlICs9IHN0ZXA7XG59XG5cbmVsSGlnaGxpZ2h0ZXIudXBkYXRlKFwiY2lyY2xlc1wiKTtcblxudmFyIGVsSW5kaWNhdG9yQW5nbGUgPSBuZXcgUkFjdGl2ZSh7XG4gIGFwcGVuZDogdHJ1ZSxcbiAgZWw6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIiksXG4gIHRlbXBsYXRlOiAnPGltYWdlIGlkPVwiYXJyb3dfYW5nbGVcIiB4bGluazpocmVmPVwiYXJyb3cuc3ZnXCIgdHJhbnNmb3JtPVwicm90YXRlKHt7IChjYXIuYSArIGNhci5zdGVlcmluZ0FuZ2xlKSAtIDkwIH19IHt7IGNhci54IH19IHt7IGNhci55ICsgNDAgfX0pXCIgeD1cInt7IGNhci54IH19XCIgeT1cInt7IGNhci55ICsgNDAgfX1cIiBoZWlnaHQ9XCIxMDBcIiB3aWR0aD1cIjMwXCIgLz4nLFxuICBkYXRhOiBkYXRhXG59KTtcblxudmFyIHRhID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRleHRhcmVhXCIpO1xuXG52YXIgdXBkYXRlUElERnVuY3Rpb24gPSB0cnVlO1xuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRleHRhcmVhXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmdW5jdGlvbihlKSB7XG4gIGNvbnNvbGUubG9nKGUua2V5Q29kZSk7XG4gIGlmKGUua2V5Q29kZSA+PSAzMikge1xuICAgIHVwZGF0ZVBJREZ1bmN0aW9uID0gdHJ1ZTtcbiAgfVxufSwgZmFsc2UpO1xuXG52YXIgZm5QSUQgPSBmdW5jdGlvbigpe307XG5cbnZhciBzcGFya0VyciA9IG5ldyBTcGFya2xpbmVzKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuY2hhcnRzLmVyclwiKSwge1xuICBsaW5lQ29sb3I6IFwiYmx1ZVwiLFxuICBoZWlnaHQ6IDEwMCxcbiAgbWF4Q29sb3I6IFwiZ3JlZW5cIixcbiAgbWluQ29sb3I6IFwicmVkXCIsXG4gIHdpZHRoOiA1MDBcbn0pO1xuXG52YXIgc3BhcmtTZXQgPSBuZXcgU3BhcmtsaW5lcyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmNoYXJ0cy5zZXRcIiksIHtcbiAgbGluZUNvbG9yOiBcInJlZFwiLFxuICBoZWlnaHQ6IDEwMCxcbiAgbWF4Q29sb3I6IFwiZ3JlZW5cIixcbiAgbWluQ29sb3I6IFwicmVkXCIsXG4gIHdpZHRoOiA1MDBcbn0pO1xuXG52YXIgc3BhcmtFcnJEYXRhID0gW107XG52YXIgc3BhcmtTZXREYXRhID0gW107XG5cbmZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gIHZhciB2WCA9IChkYXRhLmNhci5zcGVlZCAqIDYpICogTWF0aC5jb3MoZGF0YS5jYXIuYSAqIChNYXRoLlBJIC8gMTgwKSk7XG4gIHZhciB2WSA9IChkYXRhLmNhci5zcGVlZCAqIDYpICogTWF0aC5zaW4oZGF0YS5jYXIuYSAqIChNYXRoLlBJIC8gMTgwKSk7XG5cbiAgZGF0YS5jYXIueCArPSB2WDtcbiAgZGF0YS5jYXIueSArPSB2WTtcbiAgZGF0YS5jYXIuYSArPSBkYXRhLmNhci5zdGVlcmluZ0FuZ2xlICogMC4xO1xuXG4gIGlmKGRhdGEuY2FyLnggPiA2NTApIHtcbiAgICBkYXRhLmNhci54ID0gMDtcbiAgfVxuXG4gIHZhciBzeW50YXhPSyA9IHRydWU7XG5cbiAgaWYodXBkYXRlUElERnVuY3Rpb24pIHtcbiAgICB0cnkge1xuICAgICAgZm5QSUQgPSBldmFsKFwiKGZ1bmN0aW9uKCkgeyBcIiArIHRhLnZhbHVlLnRyaW0oKSArIFwifSkoKVwiKTtcbiAgICAgIHVwZGF0ZVBJREZ1bmN0aW9uID0gZmFsc2U7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBzeW50YXhPSyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHNwYXJrRXJyRGF0YS5wdXNoKGRhdGEuY2FyLnkgLSA0MCk7XG4gIHNwYXJrU2V0RGF0YS5wdXNoKGRhdGEucm9hZC55KTtcblxuICBzcGFya0Vyci5kcmF3KHNwYXJrRXJyRGF0YSk7XG4gIHNwYXJrU2V0LmRyYXcoc3BhcmtTZXREYXRhKTtcblxuICBpZihzeW50YXhPSykge1xuICAgIHRyeSB7XG4gICAgICBkYXRhLmNhci5zdGVlcmluZ0FuZ2xlID0gY2xhbXAoZm5QSUQoKGRhdGEucm9hZC55IC0gZGF0YS5jYXIueSksIGRhdGEuY2FyLnN0ZWVyaW5nQW5nbGUpLCAtZGF0YS5jYXIubWF4U3RlZXJpbmdBbmdsZSwgZGF0YS5jYXIubWF4U3RlZXJpbmdBbmdsZSk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgfVxuICB9XG5cbiAgZWxDYXIudXBkYXRlKCk7XG4gIGVsUm9hZC51cGRhdGUoKTtcbiAgZWxSb2FkRGlzdGFuY2UudXBkYXRlKCk7XG4gIGVsSW5kaWNhdG9yQW5nbGUudXBkYXRlKFwiY2FyXCIpO1xuICBlbEhpZ2hsaWdodGVyLnVwZGF0ZShcImNhclwiKTtcblxuICBpZihzdG9wICE9PSB0cnVlKSB7XG4gICAgcmFmKGFuaW1hdGUpO1xuICB9XG59XG5cbmFuaW1hdGUoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi92ZW5kb3IvZGF0Lmd1aScpXG5tb2R1bGUuZXhwb3J0cy5jb2xvciA9IHJlcXVpcmUoJy4vdmVuZG9yL2RhdC5jb2xvcicpIiwiLyoqXG4gKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuICpcbiAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbi8qKiBAbmFtZXNwYWNlICovXG52YXIgZGF0ID0gbW9kdWxlLmV4cG9ydHMgPSBkYXQgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuY29sb3IgPSBkYXQuY29sb3IgfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQudXRpbHMgPSBkYXQudXRpbHMgfHwge307XG5cbmRhdC51dGlscy5jb21tb24gPSAoZnVuY3Rpb24gKCkge1xuICBcbiAgdmFyIEFSUl9FQUNIID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gIHZhciBBUlJfU0xJQ0UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIEJhbmQtYWlkIG1ldGhvZHMgZm9yIHRoaW5ncyB0aGF0IHNob3VsZCBiZSBhIGxvdCBlYXNpZXIgaW4gSmF2YVNjcmlwdC5cbiAgICogSW1wbGVtZW50YXRpb24gYW5kIHN0cnVjdHVyZSBpbnNwaXJlZCBieSB1bmRlcnNjb3JlLmpzXG4gICAqIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZS9cbiAgICovXG5cbiAgcmV0dXJuIHsgXG4gICAgXG4gICAgQlJFQUs6IHt9LFxuICBcbiAgICBleHRlbmQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgXG4gICAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgIGlmICghdGhpcy5pc1VuZGVmaW5lZChvYmpba2V5XSkpIFxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgZGVmYXVsdHM6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgXG4gICAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKHRhcmdldFtrZXldKSkgXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIFxuICAgIH0sXG4gICAgXG4gICAgY29tcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9DYWxsID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdG9DYWxsLmxlbmd0aCAtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gW3RvQ2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ciwgc2NvcGUpIHtcblxuICAgICAgXG4gICAgICBpZiAoQVJSX0VBQ0ggJiYgb2JqLmZvckVhY2ggPT09IEFSUl9FQUNIKSB7IFxuICAgICAgICBcbiAgICAgICAgb2JqLmZvckVhY2goaXRyLCBzY29wZSk7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSBvYmoubGVuZ3RoICsgMCkgeyAvLyBJcyBudW1iZXIgYnV0IG5vdCBOYU5cbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBrZXkgPCBsOyBrZXkrKylcbiAgICAgICAgICBpZiAoa2V5IGluIG9iaiAmJiBpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspIFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIFxuICAgICAgICAgIGlmIChpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgIH1cbiAgICAgICAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgZGVmZXI6IGZ1bmN0aW9uKGZuYykge1xuICAgICAgc2V0VGltZW91dChmbmMsIDApO1xuICAgIH0sXG4gICAgXG4gICAgdG9BcnJheTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqLnRvQXJyYXkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuICAgICAgcmV0dXJuIEFSUl9TTElDRS5jYWxsKG9iaik7XG4gICAgfSxcblxuICAgIGlzVW5kZWZpbmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIFxuICAgIGlzTnVsbDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICAgIH0sXG4gICAgXG4gICAgaXNOYU46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gb2JqO1xuICAgIH0sXG4gICAgXG4gICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5O1xuICAgIH0sXG4gICAgXG4gICAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gICAgfSxcbiAgICBcbiAgICBpc051bWJlcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBvYmorMDtcbiAgICB9LFxuICAgIFxuICAgIGlzU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG9iaisnJztcbiAgICB9LFxuICAgIFxuICAgIGlzQm9vbGVhbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBmYWxzZSB8fCBvYmogPT09IHRydWU7XG4gICAgfSxcbiAgICBcbiAgICBpc0Z1bmN0aW9uOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gIFxuICB9O1xuICAgIFxufSkoKTtcblxuXG5kYXQuY29sb3IudG9TdHJpbmcgPSAoZnVuY3Rpb24gKGNvbW1vbikge1xuXG4gIHJldHVybiBmdW5jdGlvbihjb2xvcikge1xuXG4gICAgaWYgKGNvbG9yLmEgPT0gMSB8fCBjb21tb24uaXNVbmRlZmluZWQoY29sb3IuYSkpIHtcblxuICAgICAgdmFyIHMgPSBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICAgICAgd2hpbGUgKHMubGVuZ3RoIDwgNikge1xuICAgICAgICBzID0gJzAnICsgcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcjJyArIHM7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZXR1cm4gJ3JnYmEoJyArIE1hdGgucm91bmQoY29sb3IucikgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmcpICsgJywnICsgTWF0aC5yb3VuZChjb2xvci5iKSArICcsJyArIGNvbG9yLmEgKyAnKSc7XG5cbiAgICB9XG5cbiAgfVxuXG59KShkYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuQ29sb3IgPSBkYXQuY29sb3IuQ29sb3IgPSAoZnVuY3Rpb24gKGludGVycHJldCwgbWF0aCwgdG9TdHJpbmcsIGNvbW1vbikge1xuXG4gIHZhciBDb2xvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5fX3N0YXRlID0gaW50ZXJwcmV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGhpcy5fX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgJ0ZhaWxlZCB0byBpbnRlcnByZXQgY29sb3IgYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICB0aGlzLl9fc3RhdGUuYSA9IHRoaXMuX19zdGF0ZS5hIHx8IDE7XG5cblxuICB9O1xuXG4gIENvbG9yLkNPTVBPTkVOVFMgPSBbJ3InLCdnJywnYicsJ2gnLCdzJywndicsJ2hleCcsJ2EnXTtcblxuICBjb21tb24uZXh0ZW5kKENvbG9yLnByb3RvdHlwZSwge1xuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b09yaWdpbmFsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuY29udmVyc2lvbi53cml0ZSh0aGlzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3InLCAyKTtcbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2cnLCAxKTtcbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2InLCAwKTtcblxuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnaCcpO1xuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncycpO1xuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAndicpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdhJywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuYTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLl9fc3RhdGUuYSA9IHY7XG4gICAgfVxuXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdoZXgnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoIXRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hFWCcpIHtcbiAgICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IG1hdGgucmdiX3RvX2hleCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5oZXg7XG5cbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIRVgnO1xuICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IHY7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVmaW5lUkdCQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ1JHQicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICAgIH1cblxuICAgICAgICByZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgIH0sXG5cbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdSR0InKSB7XG4gICAgICAgICAgcmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG4gICAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ1JHQic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVIU1ZDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgICByZWNhbGN1bGF0ZUhTVih0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgIH0sXG5cbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIU1YnKSB7XG4gICAgICAgICAgcmVjYWxjdWxhdGVIU1YodGhpcyk7XG4gICAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hTVic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZVJHQihjb2xvciwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuXG4gICAgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIRVgnKSB7XG5cbiAgICAgIGNvbG9yLl9fc3RhdGVbY29tcG9uZW50XSA9IG1hdGguY29tcG9uZW50X2Zyb21faGV4KGNvbG9yLl9fc3RhdGUuaGV4LCBjb21wb25lbnRIZXhJbmRleCk7XG5cbiAgICB9IGVsc2UgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKSB7XG5cbiAgICAgIGNvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSwgbWF0aC5oc3ZfdG9fcmdiKGNvbG9yLl9fc3RhdGUuaCwgY29sb3IuX19zdGF0ZS5zLCBjb2xvci5fX3N0YXRlLnYpKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRocm93ICdDb3JydXB0ZWQgY29sb3Igc3RhdGUnO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZUhTVihjb2xvcikge1xuXG4gICAgdmFyIHJlc3VsdCA9IG1hdGgucmdiX3RvX2hzdihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcblxuICAgIGNvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSxcbiAgICAgICAge1xuICAgICAgICAgIHM6IHJlc3VsdC5zLFxuICAgICAgICAgIHY6IHJlc3VsdC52XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFjb21tb24uaXNOYU4ocmVzdWx0LmgpKSB7XG4gICAgICBjb2xvci5fX3N0YXRlLmggPSByZXN1bHQuaDtcbiAgICB9IGVsc2UgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5fX3N0YXRlLmgpKSB7XG4gICAgICBjb2xvci5fX3N0YXRlLmggPSAwO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIENvbG9yO1xuXG59KShkYXQuY29sb3IuaW50ZXJwcmV0ID0gKGZ1bmN0aW9uICh0b1N0cmluZywgY29tbW9uKSB7XG5cbiAgdmFyIHJlc3VsdCwgdG9SZXR1cm47XG5cbiAgdmFyIGludGVycHJldCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdG9SZXR1cm4gPSBmYWxzZTtcblxuICAgIHZhciBvcmlnaW5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gY29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXTtcblxuICAgIGNvbW1vbi5lYWNoKElOVEVSUFJFVEFUSU9OUywgZnVuY3Rpb24oZmFtaWx5KSB7XG5cbiAgICAgIGlmIChmYW1pbHkubGl0bXVzKG9yaWdpbmFsKSkge1xuXG4gICAgICAgIGNvbW1vbi5lYWNoKGZhbWlseS5jb252ZXJzaW9ucywgZnVuY3Rpb24oY29udmVyc2lvbiwgY29udmVyc2lvbk5hbWUpIHtcblxuICAgICAgICAgIHJlc3VsdCA9IGNvbnZlcnNpb24ucmVhZChvcmlnaW5hbCk7XG5cbiAgICAgICAgICBpZiAodG9SZXR1cm4gPT09IGZhbHNlICYmIHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRvUmV0dXJuID0gcmVzdWx0O1xuICAgICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb25OYW1lID0gY29udmVyc2lvbk5hbWU7XG4gICAgICAgICAgICByZXN1bHQuY29udmVyc2lvbiA9IGNvbnZlcnNpb247XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uLkJSRUFLO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjb21tb24uQlJFQUs7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvUmV0dXJuO1xuXG4gIH07XG5cbiAgdmFyIElOVEVSUFJFVEFUSU9OUyA9IFtcblxuICAgIC8vIFN0cmluZ3NcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzU3RyaW5nLFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFRIUkVFX0NIQVJfSEVYOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XSkoW0EtRjAtOV0pKFtBLUYwLTldKSQvaSk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogcGFyc2VJbnQoXG4gICAgICAgICAgICAgICAgICAnMHgnICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzFdLnRvU3RyaW5nKCkgKyB0ZXN0WzFdLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFszXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIFNJWF9DSEFSX0hFWDoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIENTU19SR0I6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgQ1NTX1JHQkE6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JhXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCxcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKSxcbiAgICAgICAgICAgICAgYTogcGFyc2VGbG9hdCh0ZXN0WzRdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBOdW1iZXJzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc051bWJlcixcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBIRVg6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IG9yaWdpbmFsLFxuICAgICAgICAgICAgICBjb252ZXJzaW9uTmFtZTogJ0hFWCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sb3IuaGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gQXJyYXlzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc0FycmF5LFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFJHQl9BUlJBWToge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9IDMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgICAgICBiOiBvcmlnaW5hbFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIFJHQkFfQVJSQVk6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPSA0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICAgICAgYjogb3JpZ2luYWxbMl0sXG4gICAgICAgICAgICAgIGE6IG9yaWdpbmFsWzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYV07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIE9iamVjdHNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzT2JqZWN0LFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFJHQkFfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgICAgIGI6IG9yaWdpbmFsLmIsXG4gICAgICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYixcbiAgICAgICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBSR0JfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgICAgIGI6IG9yaWdpbmFsLmJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSFNWQV9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICAgICAgdjogb3JpZ2luYWwudixcbiAgICAgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgICAgICB2OiBjb2xvci52LFxuICAgICAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIEhTVl9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICAgICAgdjogb3JpZ2luYWwudlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICAgICAgdjogY29sb3IudlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuXG4gIF07XG5cbiAgcmV0dXJuIGludGVycHJldDtcblxuXG59KShkYXQuY29sb3IudG9TdHJpbmcsXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5jb2xvci5tYXRoID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdG1wQ29tcG9uZW50O1xuXG4gIHJldHVybiB7XG5cbiAgICBoc3ZfdG9fcmdiOiBmdW5jdGlvbihoLCBzLCB2KSB7XG5cbiAgICAgIHZhciBoaSA9IE1hdGguZmxvb3IoaCAvIDYwKSAlIDY7XG5cbiAgICAgIHZhciBmID0gaCAvIDYwIC0gTWF0aC5mbG9vcihoIC8gNjApO1xuICAgICAgdmFyIHAgPSB2ICogKDEuMCAtIHMpO1xuICAgICAgdmFyIHEgPSB2ICogKDEuMCAtIChmICogcykpO1xuICAgICAgdmFyIHQgPSB2ICogKDEuMCAtICgoMS4wIC0gZikgKiBzKSk7XG4gICAgICB2YXIgYyA9IFtcbiAgICAgICAgW3YsIHQsIHBdLFxuICAgICAgICBbcSwgdiwgcF0sXG4gICAgICAgIFtwLCB2LCB0XSxcbiAgICAgICAgW3AsIHEsIHZdLFxuICAgICAgICBbdCwgcCwgdl0sXG4gICAgICAgIFt2LCBwLCBxXVxuICAgICAgXVtoaV07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHI6IGNbMF0gKiAyNTUsXG4gICAgICAgIGc6IGNbMV0gKiAyNTUsXG4gICAgICAgIGI6IGNbMl0gKiAyNTVcbiAgICAgIH07XG5cbiAgICB9LFxuXG4gICAgcmdiX3RvX2hzdjogZnVuY3Rpb24ociwgZywgYikge1xuXG4gICAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICAgICAgaCwgcztcblxuICAgICAgaWYgKG1heCAhPSAwKSB7XG4gICAgICAgIHMgPSBkZWx0YSAvIG1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaDogTmFOLFxuICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgdjogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAociA9PSBtYXgpIHtcbiAgICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSBpZiAoZyA9PSBtYXgpIHtcbiAgICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICAgIH1cbiAgICAgIGggLz0gNjtcbiAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICBoICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGg6IGggKiAzNjAsXG4gICAgICAgIHM6IHMsXG4gICAgICAgIHY6IG1heCAvIDI1NVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmdiX3RvX2hleDogZnVuY3Rpb24ociwgZywgYikge1xuICAgICAgdmFyIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KDAsIDIsIHIpO1xuICAgICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAxLCBnKTtcbiAgICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMCwgYik7XG4gICAgICByZXR1cm4gaGV4O1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRfZnJvbV9oZXg6IGZ1bmN0aW9uKGhleCwgY29tcG9uZW50SW5kZXgpIHtcbiAgICAgIHJldHVybiAoaGV4ID4+IChjb21wb25lbnRJbmRleCAqIDgpKSAmIDB4RkY7XG4gICAgfSxcblxuICAgIGhleF93aXRoX2NvbXBvbmVudDogZnVuY3Rpb24oaGV4LCBjb21wb25lbnRJbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PCAodG1wQ29tcG9uZW50ID0gY29tcG9uZW50SW5kZXggKiA4KSB8IChoZXggJiB+ICgweEZGIDw8IHRtcENvbXBvbmVudCkpO1xuICAgIH1cblxuICB9XG5cbn0pKCksXG5kYXQuY29sb3IudG9TdHJpbmcsXG5kYXQudXRpbHMuY29tbW9uKTsiLCIvKipcbiAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuLyoqIEBuYW1lc3BhY2UgKi9cbnZhciBkYXQgPSBtb2R1bGUuZXhwb3J0cyA9IGRhdCB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5ndWkgPSBkYXQuZ3VpIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LnV0aWxzID0gZGF0LnV0aWxzIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LmNvbnRyb2xsZXJzID0gZGF0LmNvbnRyb2xsZXJzIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LmRvbSA9IGRhdC5kb20gfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuY29sb3IgPSBkYXQuY29sb3IgfHwge307XG5cbmRhdC51dGlscy5jc3MgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIGxvYWQ6IGZ1bmN0aW9uICh1cmwsIGRvYykge1xuICAgICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuICAgICAgdmFyIGxpbmsgPSBkb2MuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgbGluay50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuICAgICAgbGluay5ocmVmID0gdXJsO1xuICAgICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobGluayk7XG4gICAgfSxcbiAgICBpbmplY3Q6IGZ1bmN0aW9uKGNzcywgZG9jKSB7XG4gICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgICB2YXIgaW5qZWN0ZWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgaW5qZWN0ZWQudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICBpbmplY3RlZC5pbm5lckhUTUwgPSBjc3M7XG4gICAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChpbmplY3RlZCk7XG4gICAgfVxuICB9XG59KSgpO1xuXG5cbmRhdC51dGlscy5jb21tb24gPSAoZnVuY3Rpb24gKCkge1xuICBcbiAgdmFyIEFSUl9FQUNIID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gIHZhciBBUlJfU0xJQ0UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIEJhbmQtYWlkIG1ldGhvZHMgZm9yIHRoaW5ncyB0aGF0IHNob3VsZCBiZSBhIGxvdCBlYXNpZXIgaW4gSmF2YVNjcmlwdC5cbiAgICogSW1wbGVtZW50YXRpb24gYW5kIHN0cnVjdHVyZSBpbnNwaXJlZCBieSB1bmRlcnNjb3JlLmpzXG4gICAqIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZS9cbiAgICovXG5cbiAgcmV0dXJuIHsgXG4gICAgXG4gICAgQlJFQUs6IHt9LFxuICBcbiAgICBleHRlbmQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgXG4gICAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgIGlmICghdGhpcy5pc1VuZGVmaW5lZChvYmpba2V5XSkpIFxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgZGVmYXVsdHM6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgXG4gICAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKHRhcmdldFtrZXldKSkgXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIFxuICAgIH0sXG4gICAgXG4gICAgY29tcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9DYWxsID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdG9DYWxsLmxlbmd0aCAtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gW3RvQ2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ciwgc2NvcGUpIHtcblxuICAgICAgXG4gICAgICBpZiAoQVJSX0VBQ0ggJiYgb2JqLmZvckVhY2ggPT09IEFSUl9FQUNIKSB7IFxuICAgICAgICBcbiAgICAgICAgb2JqLmZvckVhY2goaXRyLCBzY29wZSk7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSBvYmoubGVuZ3RoICsgMCkgeyAvLyBJcyBudW1iZXIgYnV0IG5vdCBOYU5cbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBrZXkgPCBsOyBrZXkrKylcbiAgICAgICAgICBpZiAoa2V5IGluIG9iaiAmJiBpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspIFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIFxuICAgICAgICAgIGlmIChpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgIH1cbiAgICAgICAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgZGVmZXI6IGZ1bmN0aW9uKGZuYykge1xuICAgICAgc2V0VGltZW91dChmbmMsIDApO1xuICAgIH0sXG4gICAgXG4gICAgdG9BcnJheTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqLnRvQXJyYXkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuICAgICAgcmV0dXJuIEFSUl9TTElDRS5jYWxsKG9iaik7XG4gICAgfSxcblxuICAgIGlzVW5kZWZpbmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIFxuICAgIGlzTnVsbDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICAgIH0sXG4gICAgXG4gICAgaXNOYU46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gb2JqO1xuICAgIH0sXG4gICAgXG4gICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5O1xuICAgIH0sXG4gICAgXG4gICAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gICAgfSxcbiAgICBcbiAgICBpc051bWJlcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBvYmorMDtcbiAgICB9LFxuICAgIFxuICAgIGlzU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG9iaisnJztcbiAgICB9LFxuICAgIFxuICAgIGlzQm9vbGVhbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBmYWxzZSB8fCBvYmogPT09IHRydWU7XG4gICAgfSxcbiAgICBcbiAgICBpc0Z1bmN0aW9uOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gIFxuICB9O1xuICAgIFxufSkoKTtcblxuXG5kYXQuY29udHJvbGxlcnMuQ29udHJvbGxlciA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBBbiBcImFic3RyYWN0XCIgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIENvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG5cbiAgICAvKipcbiAgICAgKiBUaG9zZSB3aG8gZXh0ZW5kIHRoaXMgY2xhc3Mgd2lsbCBwdXQgdGhlaXIgRE9NIGVsZW1lbnRzIGluIGhlcmUuXG4gICAgICogQHR5cGUge0RPTUVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IHRvIG1hbmlwdWxhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIG1hbmlwdWxhdGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gY2hhbmdlLlxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX29uQ2hhbmdlID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBmaW5pc2hpbmcgY2hhbmdlLlxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlID0gdW5kZWZpbmVkO1xuXG4gIH07XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIC8qKiBAbGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIucHJvdG90eXBlICovXG4gICAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgdGhhdCBhIGZ1bmN0aW9uIGZpcmUgZXZlcnkgdGltZSBzb21lb25lIGNoYW5nZXMgdGhlIHZhbHVlIHdpdGhcbiAgICAgICAgICogdGhpcyBDb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbmMgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWVcbiAgICAgICAgICogaXMgbW9kaWZpZWQgdmlhIHRoaXMgQ29udHJvbGxlci5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24oZm5jKSB7XG4gICAgICAgICAgdGhpcy5fX29uQ2hhbmdlID0gZm5jO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IHRoYXQgYSBmdW5jdGlvbiBmaXJlIGV2ZXJ5IHRpbWUgc29tZW9uZSBcImZpbmlzaGVzXCIgY2hhbmdpbmdcbiAgICAgICAgICogdGhlIHZhbHVlIHdpaCB0aGlzIENvbnRyb2xsZXIuIFVzZWZ1bCBmb3IgdmFsdWVzIHRoYXQgY2hhbmdlXG4gICAgICAgICAqIGluY3JlbWVudGFsbHkgbGlrZSBudW1iZXJzIG9yIHN0cmluZ3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuYyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyXG4gICAgICAgICAqIHNvbWVvbmUgXCJmaW5pc2hlc1wiIGNoYW5naW5nIHRoZSB2YWx1ZSB2aWEgdGhpcyBDb250cm9sbGVyLlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG9uRmluaXNoQ2hhbmdlOiBmdW5jdGlvbihmbmMpIHtcbiAgICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSBmbmM7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZSB0aGUgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICovXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uQ2hhbmdlLmNhbGwodGhpcywgbmV3VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGN1cnJlbnQgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICovXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RbdGhpcy5wcm9wZXJ0eV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2hlcyB0aGUgdmlzdWFsIGRpc3BsYXkgb2YgYSBDb250cm9sbGVyIGluIG9yZGVyIHRvIGtlZXAgc3luY1xuICAgICAgICAgKiB3aXRoIHRoZSBvYmplY3QncyBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgdmFsdWUgaGFzIGRldmlhdGVkIGZyb20gaW5pdGlhbFZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBpc01vZGlmaWVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsVmFsdWUgIT09IHRoaXMuZ2V0VmFsdWUoKVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBDb250cm9sbGVyO1xuXG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5kb20uZG9tID0gKGZ1bmN0aW9uIChjb21tb24pIHtcblxuICB2YXIgRVZFTlRfTUFQID0ge1xuICAgICdIVE1MRXZlbnRzJzogWydjaGFuZ2UnXSxcbiAgICAnTW91c2VFdmVudHMnOiBbJ2NsaWNrJywnbW91c2Vtb3ZlJywnbW91c2Vkb3duJywnbW91c2V1cCcsICdtb3VzZW92ZXInXSxcbiAgICAnS2V5Ym9hcmRFdmVudHMnOiBbJ2tleWRvd24nXVxuICB9O1xuXG4gIHZhciBFVkVOVF9NQVBfSU5WID0ge307XG4gIGNvbW1vbi5lYWNoKEVWRU5UX01BUCwgZnVuY3Rpb24odiwgaykge1xuICAgIGNvbW1vbi5lYWNoKHYsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIEVWRU5UX01BUF9JTlZbZV0gPSBrO1xuICAgIH0pO1xuICB9KTtcblxuICB2YXIgQ1NTX1ZBTFVFX1BJWEVMUyA9IC8oXFxkKyhcXC5cXGQrKT8pcHgvO1xuXG4gIGZ1bmN0aW9uIGNzc1ZhbHVlVG9QaXhlbHModmFsKSB7XG5cbiAgICBpZiAodmFsID09PSAnMCcgfHwgY29tbW9uLmlzVW5kZWZpbmVkKHZhbCkpIHJldHVybiAwO1xuXG4gICAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKENTU19WQUxVRV9QSVhFTFMpO1xuXG4gICAgaWYgKCFjb21tb24uaXNOdWxsKG1hdGNoKSkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLi4uZW1zPyAlP1xuXG4gICAgcmV0dXJuIDA7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXIgZGF0LmRvbVxuICAgKi9cbiAgdmFyIGRvbSA9IHtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIHNlbGVjdGFibGVcbiAgICAgKi9cbiAgICBtYWtlU2VsZWN0YWJsZTogZnVuY3Rpb24oZWxlbSwgc2VsZWN0YWJsZSkge1xuXG4gICAgICBpZiAoZWxlbSA9PT0gdW5kZWZpbmVkIHx8IGVsZW0uc3R5bGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICBlbGVtLm9uc2VsZWN0c3RhcnQgPSBzZWxlY3RhYmxlID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgIH07XG5cbiAgICAgIGVsZW0uc3R5bGUuTW96VXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgICBlbGVtLnN0eWxlLktodG1sVXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgICBlbGVtLnVuc2VsZWN0YWJsZSA9IHNlbGVjdGFibGUgPyAnb24nIDogJ29mZic7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBob3Jpem9udGFsXG4gICAgICogQHBhcmFtIHZlcnRpY2FsXG4gICAgICovXG4gICAgbWFrZUZ1bGxzY3JlZW46IGZ1bmN0aW9uKGVsZW0sIGhvcml6b250YWwsIHZlcnRpY2FsKSB7XG5cbiAgICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQoaG9yaXpvbnRhbCkpIGhvcml6b250YWwgPSB0cnVlO1xuICAgICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZCh2ZXJ0aWNhbCkpIHZlcnRpY2FsID0gdHJ1ZTtcblxuICAgICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgIGVsZW0uc3R5bGUubGVmdCA9IDA7XG4gICAgICAgIGVsZW0uc3R5bGUucmlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGVsZW0uc3R5bGUudG9wID0gMDtcbiAgICAgICAgZWxlbS5zdHlsZS5ib3R0b20gPSAwO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIGZha2VFdmVudDogZnVuY3Rpb24oZWxlbSwgZXZlbnRUeXBlLCBwYXJhbXMsIGF1eCkge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IEVWRU5UX01BUF9JTlZbZXZlbnRUeXBlXTtcbiAgICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgdHlwZSAnICsgZXZlbnRUeXBlICsgJyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgfVxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KGNsYXNzTmFtZSk7XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlICdNb3VzZUV2ZW50cyc6XG4gICAgICAgICAgdmFyIGNsaWVudFggPSBwYXJhbXMueCB8fCBwYXJhbXMuY2xpZW50WCB8fCAwO1xuICAgICAgICAgIHZhciBjbGllbnRZID0gcGFyYW1zLnkgfHwgcGFyYW1zLmNsaWVudFkgfHwgMDtcbiAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSwgd2luZG93LCBwYXJhbXMuY2xpY2tDb3VudCB8fCAxLFxuICAgICAgICAgICAgICAwLCAvL3NjcmVlbiBYXG4gICAgICAgICAgICAgIDAsIC8vc2NyZWVuIFlcbiAgICAgICAgICAgICAgY2xpZW50WCwgLy9jbGllbnQgWFxuICAgICAgICAgICAgICBjbGllbnRZLCAvL2NsaWVudCBZXG4gICAgICAgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS2V5Ym9hcmRFdmVudHMnOlxuICAgICAgICAgIHZhciBpbml0ID0gZXZ0LmluaXRLZXlib2FyZEV2ZW50IHx8IGV2dC5pbml0S2V5RXZlbnQ7IC8vIHdlYmtpdCB8fCBtb3pcbiAgICAgICAgICBjb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICAgICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICAgICAgICBrZXlDb2RlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGFyQ29kZTogdW5kZWZpbmVkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5pdChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLFxuICAgICAgICAgICAgICBwYXJhbXMuY2FuY2VsYWJsZSwgd2luZG93LFxuICAgICAgICAgICAgICBwYXJhbXMuY3RybEtleSwgcGFyYW1zLmFsdEtleSxcbiAgICAgICAgICAgICAgcGFyYW1zLnNoaWZ0S2V5LCBwYXJhbXMubWV0YUtleSxcbiAgICAgICAgICAgICAgcGFyYW1zLmtleUNvZGUsIHBhcmFtcy5jaGFyQ29kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLFxuICAgICAgICAgICAgICBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbW1vbi5kZWZhdWx0cyhldnQsIGF1eCk7XG4gICAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICogQHBhcmFtIGJvb2xcbiAgICAgKi9cbiAgICBiaW5kOiBmdW5jdGlvbihlbGVtLCBldmVudCwgZnVuYywgYm9vbCkge1xuICAgICAgYm9vbCA9IGJvb2wgfHwgZmFsc2U7XG4gICAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKVxuICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xuICAgICAgZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudClcbiAgICAgICAgZWxlbS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZ1bmMpO1xuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICogQHBhcmFtIGJvb2xcbiAgICAgKi9cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uKGVsZW0sIGV2ZW50LCBmdW5jLCBib29sKSB7XG4gICAgICBib29sID0gYm9vbCB8fCBmYWxzZTtcbiAgICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpXG4gICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgICBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KVxuICAgICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgICAqL1xuICAgIGFkZENsYXNzOiBmdW5jdGlvbihlbGVtLCBjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgfSBlbHNlIGlmIChlbGVtLmNsYXNzTmFtZSAhPT0gY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoLyArLyk7XG4gICAgICAgIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA9PSAtMSkge1xuICAgICAgICAgIGNsYXNzZXMucHVzaChjbGFzc05hbWUpO1xuICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJykucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gY2xhc3NOYW1lXG4gICAgICovXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGVsZW0uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW0uY2xhc3NOYW1lID09PSBjbGFzc05hbWUpIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgICAgIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xuICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJyg/Ol58XFxcXHMrKScgKyBjbGFzc05hbWUgKyAnKD86XFxcXHMrfCQpJykudGVzdChlbGVtLmNsYXNzTmFtZSkgfHwgZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKi9cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oZWxlbSkge1xuXG4gICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuXG4gICAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLWxlZnQtd2lkdGgnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1yaWdodC13aWR0aCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1sZWZ0J10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXJpZ2h0J10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWyd3aWR0aCddKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqL1xuICAgIGdldEhlaWdodDogZnVuY3Rpb24oZWxlbSkge1xuXG4gICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuXG4gICAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXRvcC13aWR0aCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLWJvdHRvbS13aWR0aCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy10b3AnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydoZWlnaHQnXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKi9cbiAgICBnZXRPZmZzZXQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHZhciBvZmZzZXQgPSB7bGVmdDogMCwgdG9wOjB9O1xuICAgICAgaWYgKGVsZW0ub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvZmZzZXQubGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XG4gICAgICAgICAgb2Zmc2V0LnRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICAgICAgfSB3aGlsZSAoZWxlbSA9IGVsZW0ub2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9wb3N0cy8yNjg0NTYxL3JldmlzaW9uc1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICovXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiApO1xuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBkb207XG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5PcHRpb25Db250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUHJvdmlkZXMgYSBzZWxlY3QgaW5wdXQgdG8gYWx0ZXIgdGhlIHByb3BlcnR5IG9mIGFuIG9iamVjdCwgdXNpbmcgYVxuICAgKiBsaXN0IG9mIGFjY2VwdGVkIHZhbHVlcy5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nW119IG9wdGlvbnMgQSBtYXAgb2YgbGFiZWxzIHRvIGFjY2VwdGFibGUgdmFsdWVzLCBvclxuICAgKiBhIGxpc3Qgb2YgYWNjZXB0YWJsZSBzdHJpbmcgdmFsdWVzLlxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIE9wdGlvbkNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBvcHRpb25zKSB7XG5cbiAgICBPcHRpb25Db250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZHJvcCBkb3duIG1lbnVcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuXG4gICAgaWYgKGNvbW1vbi5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbWFwID0ge307XG4gICAgICBjb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIG1hcFtlbGVtZW50XSA9IGVsZW1lbnQ7XG4gICAgICB9KTtcbiAgICAgIG9wdGlvbnMgPSBtYXA7XG4gICAgfVxuXG4gICAgY29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXG4gICAgICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICBvcHQuaW5uZXJIVE1MID0ga2V5O1xuICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gICAgICBfdGhpcy5fX3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuXG4gICAgfSk7XG5cbiAgICAvLyBBY2tub3dsZWRnZSBvcmlnaW5hbCB2YWx1ZVxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX3NlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRlc2lyZWRWYWx1ZSA9IHRoaXMub3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoZGVzaXJlZFZhbHVlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fc2VsZWN0KTtcblxuICB9O1xuXG4gIE9wdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFyIHRvUmV0dXJuID0gT3B0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS5zZXRWYWx1ZS5jYWxsKHRoaXMsIHYpO1xuICAgICAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgIHJldHVybiBPcHRpb25Db250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gT3B0aW9uQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFJlcHJlc2VudHMgYSBnaXZlbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdGhhdCBpcyBhIG51bWJlci5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWluXSBNaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWF4XSBNYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuc3RlcF0gSW5jcmVtZW50IGJ5IHdoaWNoIHRvIGNoYW5nZSB2YWx1ZVxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIE51bWJlckNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcblxuICAgIE51bWJlckNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgdGhpcy5fX21pbiA9IHBhcmFtcy5taW47XG4gICAgdGhpcy5fX21heCA9IHBhcmFtcy5tYXg7XG4gICAgdGhpcy5fX3N0ZXAgPSBwYXJhbXMuc3RlcDtcblxuICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQodGhpcy5fX3N0ZXApKSB7XG5cbiAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSA9PSAwKSB7XG4gICAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IDE7IC8vIFdoYXQgYXJlIHdlLCBwc3ljaGljcz9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhleSBEb3VnLCBjaGVjayB0aGlzIG91dC5cbiAgICAgICAgdGhpcy5fX2ltcGxpZWRTdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2codGhpcy5pbml0aWFsVmFsdWUpL01hdGguTE4xMCkpLzEwO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhpcy5fX2ltcGxpZWRTdGVwID0gdGhpcy5fX3N0ZXA7XG5cbiAgICB9XG5cbiAgICB0aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHModGhpcy5fX2ltcGxpZWRTdGVwKTtcblxuXG4gIH07XG5cbiAgTnVtYmVyQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICAvKiogQGxlbmRzIGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSAqL1xuICAgICAge1xuXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgICBpZiAodGhpcy5fX21pbiAhPT0gdW5kZWZpbmVkICYmIHYgPCB0aGlzLl9fbWluKSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5fX21pbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX19tYXggIT09IHVuZGVmaW5lZCAmJiB2ID4gdGhpcy5fX21heCkge1xuICAgICAgICAgICAgdiA9IHRoaXMuX19tYXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuX19zdGVwICE9PSB1bmRlZmluZWQgJiYgdiAlIHRoaXMuX19zdGVwICE9IDApIHtcbiAgICAgICAgICAgIHYgPSBNYXRoLnJvdW5kKHYgLyB0aGlzLl9fc3RlcCkgKiB0aGlzLl9fc3RlcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gTnVtYmVyQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS5zZXRWYWx1ZS5jYWxsKHRoaXMsIHYpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgYSBtaW5pbXVtIHZhbHVlIGZvciA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pblZhbHVlIFRoZSBtaW5pbXVtIHZhbHVlIGZvclxuICAgICAgICAgKiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG1pbjogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX19taW4gPSB2O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgbWF4aW11bSB2YWx1ZSBmb3IgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhWYWx1ZSBUaGUgbWF4aW11bSB2YWx1ZSBmb3JcbiAgICAgICAgICogPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBtYXg6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9fbWF4ID0gdjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSBhIHN0ZXAgdmFsdWUgdGhhdCBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuICAgICAgICAgKiBpbmNyZW1lbnRzIGJ5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFZhbHVlIFRoZSBzdGVwIHZhbHVlIGZvclxuICAgICAgICAgKiBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuICAgICAgICAgKiBAZGVmYXVsdCBpZiBtaW5pbXVtIGFuZCBtYXhpbXVtIHNwZWNpZmllZCBpbmNyZW1lbnQgaXMgMSUgb2YgdGhlXG4gICAgICAgICAqIGRpZmZlcmVuY2Ugb3RoZXJ3aXNlIHN0ZXBWYWx1ZSBpcyAxXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RlcDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX19zdGVwID0gdjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICBmdW5jdGlvbiBudW1EZWNpbWFscyh4KSB7XG4gICAgeCA9IHgudG9TdHJpbmcoKTtcbiAgICBpZiAoeC5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcmV0dXJuIHgubGVuZ3RoIC0geC5pbmRleE9mKCcuJykgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlckJveCA9IChmdW5jdGlvbiAoTnVtYmVyQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFJlcHJlc2VudHMgYSBnaXZlbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdGhhdCBpcyBhIG51bWJlciBhbmRcbiAgICogcHJvdmlkZXMgYW4gaW5wdXQgZWxlbWVudCB3aXRoIHdoaWNoIHRvIG1hbmlwdWxhdGUgaXQuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1pbl0gTWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1heF0gTWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLnN0ZXBdIEluY3JlbWVudCBieSB3aGljaCB0byBjaGFuZ2UgdmFsdWVcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBOdW1iZXJDb250cm9sbGVyQm94ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG5cbiAgICB0aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IGZhbHNlO1xuXG4gICAgTnVtYmVyQ29udHJvbGxlckJveC5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiB7TnVtYmVyfSBQcmV2aW91cyBtb3VzZSB5IHBvc2l0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHZhciBwcmV2X3k7XG5cbiAgICB0aGlzLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuXG4gICAgLy8gTWFrZXMgaXQgc28gbWFudWFsbHkgc3BlY2lmaWVkIHZhbHVlcyBhcmUgbm90IHRydW5jYXRlZC5cblxuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgLy8gV2hlbiBwcmVzc2luZyBlbnRpcmUsIHlvdSBjYW4gYmUgYXMgcHJlY2lzZSBhcyB5b3Ugd2FudC5cbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICB2YXIgYXR0ZW1wdGVkID0gcGFyc2VGbG9hdChfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICAgIGlmICghY29tbW9uLmlzTmFOKGF0dGVtcHRlZCkpIF90aGlzLnNldFZhbHVlKGF0dGVtcHRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBwcmV2X3kgPSBlLmNsaWVudFk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuXG4gICAgICB2YXIgZGlmZiA9IHByZXZfeSAtIGUuY2xpZW50WTtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLmdldFZhbHVlKCkgKyBkaWZmICogX3RoaXMuX19pbXBsaWVkU3RlcCk7XG5cbiAgICAgIHByZXZfeSA9IGUuY2xpZW50WTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9faW5wdXQpO1xuXG4gIH07XG5cbiAgTnVtYmVyQ29udHJvbGxlckJveC5zdXBlcmNsYXNzID0gTnVtYmVyQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBOdW1iZXJDb250cm9sbGVyQm94LnByb3RvdHlwZSxcbiAgICAgIE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA/IHRoaXMuZ2V0VmFsdWUoKSA6IHJvdW5kVG9EZWNpbWFsKHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5fX3ByZWNpc2lvbik7XG4gICAgICAgICAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJCb3guc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIGZ1bmN0aW9uIHJvdW5kVG9EZWNpbWFsKHZhbHVlLCBkZWNpbWFscykge1xuICAgIHZhciB0ZW5UbyA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiB0ZW5UbykgLyB0ZW5UbztcbiAgfVxuXG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyQm94O1xuXG59KShkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJTbGlkZXIgPSAoZnVuY3Rpb24gKE51bWJlckNvbnRyb2xsZXIsIGRvbSwgY3NzLCBjb21tb24sIHN0eWxlU2hlZXQpIHtcblxuICAvKipcbiAgICogQGNsYXNzIFJlcHJlc2VudHMgYSBnaXZlbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdGhhdCBpcyBhIG51bWJlciwgY29udGFpbnNcbiAgICogYSBtaW5pbXVtIGFuZCBtYXhpbXVtLCBhbmQgcHJvdmlkZXMgYSBzbGlkZXIgZWxlbWVudCB3aXRoIHdoaWNoIHRvXG4gICAqIG1hbmlwdWxhdGUgaXQuIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IHRoZSBzbGlkZXIgZWxlbWVudCBpcyBtYWRlIHVwIG9mXG4gICAqIDxjb2RlPiZsdDtkaXYmZ3Q7PC9jb2RlPiB0YWdzLCA8c3Ryb25nPm5vdDwvc3Ryb25nPiB0aGUgaHRtbDVcbiAgICogPGNvZGU+Jmx0O3NsaWRlciZndDs8L2NvZGU+IGVsZW1lbnQuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gbWluVmFsdWUgTWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhWYWx1ZSBNYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBWYWx1ZSBJbmNyZW1lbnQgYnkgd2hpY2ggdG8gY2hhbmdlIHZhbHVlXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgTnVtYmVyQ29udHJvbGxlclNsaWRlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIG1pbiwgbWF4LCBzdGVwKSB7XG5cbiAgICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogc3RlcCB9KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9fYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19mb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgXG5cblxuICAgIGRvbS5iaW5kKHRoaXMuX19iYWNrZ3JvdW5kLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIFxuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fYmFja2dyb3VuZCwgJ3NsaWRlcicpO1xuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fZm9yZWdyb3VuZCwgJ3NsaWRlci1mZycpO1xuXG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuXG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcblxuICAgICAgb25Nb3VzZURyYWcoZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBvZmZzZXQgPSBkb20uZ2V0T2Zmc2V0KF90aGlzLl9fYmFja2dyb3VuZCk7XG4gICAgICB2YXIgd2lkdGggPSBkb20uZ2V0V2lkdGgoX3RoaXMuX19iYWNrZ3JvdW5kKTtcbiAgICAgIFxuICAgICAgX3RoaXMuc2V0VmFsdWUoXG4gICAgICAgIG1hcChlLmNsaWVudFgsIG9mZnNldC5sZWZ0LCBvZmZzZXQubGVmdCArIHdpZHRoLCBfdGhpcy5fX21pbiwgX3RoaXMuX19tYXgpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgdGhpcy5fX2JhY2tncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5fX2ZvcmVncm91bmQpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fYmFja2dyb3VuZCk7XG5cbiAgfTtcblxuICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnN1cGVyY2xhc3MgPSBOdW1iZXJDb250cm9sbGVyO1xuXG4gIC8qKlxuICAgKiBJbmplY3RzIGRlZmF1bHQgc3R5bGVzaGVldCBmb3Igc2xpZGVyIGVsZW1lbnRzLlxuICAgKi9cbiAgTnVtYmVyQ29udHJvbGxlclNsaWRlci51c2VEZWZhdWx0U3R5bGVzID0gZnVuY3Rpb24oKSB7XG4gICAgY3NzLmluamVjdChzdHlsZVNoZWV0KTtcbiAgfTtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnByb3RvdHlwZSxcbiAgICAgIE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHBjdCA9ICh0aGlzLmdldFZhbHVlKCkgLSB0aGlzLl9fbWluKS8odGhpcy5fX21heCAtIHRoaXMuX19taW4pO1xuICAgICAgICAgIHRoaXMuX19mb3JlZ3JvdW5kLnN0eWxlLndpZHRoID0gcGN0KjEwMCsnJSc7XG4gICAgICAgICAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJTbGlkZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuXG5cbiAgKTtcblxuICBmdW5jdGlvbiBtYXAodiwgaTEsIGkyLCBvMSwgbzIpIHtcbiAgICByZXR1cm4gbzEgKyAobzIgLSBvMSkgKiAoKHYgLSBpMSkgLyAoaTIgLSBpMSkpO1xuICB9XG5cbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJTbGlkZXI7XG4gIFxufSkoZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jc3MsXG5kYXQudXRpbHMuY29tbW9uLFxuXCIuc2xpZGVyIHtcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAgMnB4IDRweCByZ2JhKDAsMCwwLDAuMTUpO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBib3JkZXItcmFkaXVzOiAxZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbiAgcGFkZGluZzogMCAwLjVlbTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbi5zbGlkZXItZmcge1xcbiAgcGFkZGluZzogMXB4IDAgMnB4IDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYWFhO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBtYXJnaW4tbGVmdDogLTAuNWVtO1xcbiAgcGFkZGluZy1yaWdodDogMC41ZW07XFxuICBib3JkZXItcmFkaXVzOiAxZW0gMCAwIDFlbTtcXG59XFxuXFxuLnNsaWRlci1mZzphZnRlciB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBib3JkZXItcmFkaXVzOiAxZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgYm9yZGVyOiAgMXB4IHNvbGlkICNhYWE7XFxuICBjb250ZW50OiAnJztcXG4gIGZsb2F0OiByaWdodDtcXG4gIG1hcmdpbi1yaWdodDogLTFlbTtcXG4gIG1hcmdpbi10b3A6IC0xcHg7XFxuICBoZWlnaHQ6IDAuOWVtO1xcbiAgd2lkdGg6IDAuOWVtO1xcbn1cIik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLkZ1bmN0aW9uQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFByb3ZpZGVzIGEgR1VJIGludGVyZmFjZSB0byBmaXJlIGEgc3BlY2lmaWVkIG1ldGhvZCwgYSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgRnVuY3Rpb25Db250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgdGV4dCkge1xuXG4gICAgRnVuY3Rpb25Db250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9fYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2J1dHRvbi5pbm5lckhUTUwgPSB0ZXh0ID09PSB1bmRlZmluZWQgPyAnRmlyZScgOiB0ZXh0O1xuICAgIGRvbS5iaW5kKHRoaXMuX19idXR0b24sICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIF90aGlzLmZpcmUoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fYnV0dG9uLCAnYnV0dG9uJyk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2J1dHRvbik7XG5cblxuICB9O1xuXG4gIEZ1bmN0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBGdW5jdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICB7XG4gICAgICAgIFxuICAgICAgICBmaXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5nZXRWYWx1ZSgpLmNhbGwodGhpcy5vYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gRnVuY3Rpb25Db250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLkJvb2xlYW5Db250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUHJvdmlkZXMgYSBjaGVja2JveCBpbnB1dCB0byBhbHRlciB0aGUgYm9vbGVhbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgQm9vbGVhbkNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICBCb29sZWFuQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX19wcmV2ID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gICAgdGhpcy5fX2NoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94Jyk7XG5cblxuICAgIGRvbS5iaW5kKHRoaXMuX19jaGVja2JveCwgJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2NoZWNrYm94KTtcblxuICAgIC8vIE1hdGNoIG9yaWdpbmFsIHZhbHVlXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIF90aGlzLnNldFZhbHVlKCFfdGhpcy5fX3ByZXYpO1xuICAgIH1cblxuICB9O1xuXG4gIEJvb2xlYW5Db250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YXIgdG9SZXR1cm4gPSBCb29sZWFuQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS5zZXRWYWx1ZS5jYWxsKHRoaXMsIHYpO1xuICAgICAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19wcmV2ID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodGhpcy5nZXRWYWx1ZSgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gdHJ1ZTsgICAgXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gQm9vbGVhbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIH1cblxuXG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gQm9vbGVhbkNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29sb3IudG9TdHJpbmcgPSAoZnVuY3Rpb24gKGNvbW1vbikge1xuXG4gIHJldHVybiBmdW5jdGlvbihjb2xvcikge1xuXG4gICAgaWYgKGNvbG9yLmEgPT0gMSB8fCBjb21tb24uaXNVbmRlZmluZWQoY29sb3IuYSkpIHtcblxuICAgICAgdmFyIHMgPSBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICAgICAgd2hpbGUgKHMubGVuZ3RoIDwgNikge1xuICAgICAgICBzID0gJzAnICsgcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcjJyArIHM7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZXR1cm4gJ3JnYmEoJyArIE1hdGgucm91bmQoY29sb3IucikgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmcpICsgJywnICsgTWF0aC5yb3VuZChjb2xvci5iKSArICcsJyArIGNvbG9yLmEgKyAnKSc7XG5cbiAgICB9XG5cbiAgfVxuXG59KShkYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29sb3IuaW50ZXJwcmV0ID0gKGZ1bmN0aW9uICh0b1N0cmluZywgY29tbW9uKSB7XG5cbiAgdmFyIHJlc3VsdCwgdG9SZXR1cm47XG5cbiAgdmFyIGludGVycHJldCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdG9SZXR1cm4gPSBmYWxzZTtcblxuICAgIHZhciBvcmlnaW5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gY29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXTtcblxuICAgIGNvbW1vbi5lYWNoKElOVEVSUFJFVEFUSU9OUywgZnVuY3Rpb24oZmFtaWx5KSB7XG5cbiAgICAgIGlmIChmYW1pbHkubGl0bXVzKG9yaWdpbmFsKSkge1xuXG4gICAgICAgIGNvbW1vbi5lYWNoKGZhbWlseS5jb252ZXJzaW9ucywgZnVuY3Rpb24oY29udmVyc2lvbiwgY29udmVyc2lvbk5hbWUpIHtcblxuICAgICAgICAgIHJlc3VsdCA9IGNvbnZlcnNpb24ucmVhZChvcmlnaW5hbCk7XG5cbiAgICAgICAgICBpZiAodG9SZXR1cm4gPT09IGZhbHNlICYmIHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRvUmV0dXJuID0gcmVzdWx0O1xuICAgICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb25OYW1lID0gY29udmVyc2lvbk5hbWU7XG4gICAgICAgICAgICByZXN1bHQuY29udmVyc2lvbiA9IGNvbnZlcnNpb247XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uLkJSRUFLO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjb21tb24uQlJFQUs7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvUmV0dXJuO1xuXG4gIH07XG5cbiAgdmFyIElOVEVSUFJFVEFUSU9OUyA9IFtcblxuICAgIC8vIFN0cmluZ3NcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzU3RyaW5nLFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFRIUkVFX0NIQVJfSEVYOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XSkoW0EtRjAtOV0pKFtBLUYwLTldKSQvaSk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogcGFyc2VJbnQoXG4gICAgICAgICAgICAgICAgICAnMHgnICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzFdLnRvU3RyaW5nKCkgKyB0ZXN0WzFdLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFszXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIFNJWF9DSEFSX0hFWDoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIENTU19SR0I6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgQ1NTX1JHQkE6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JhXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCxcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKSxcbiAgICAgICAgICAgICAgYTogcGFyc2VGbG9hdCh0ZXN0WzRdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBOdW1iZXJzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc051bWJlcixcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBIRVg6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IG9yaWdpbmFsLFxuICAgICAgICAgICAgICBjb252ZXJzaW9uTmFtZTogJ0hFWCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sb3IuaGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gQXJyYXlzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc0FycmF5LFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFJHQl9BUlJBWToge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9IDMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgICAgICBiOiBvcmlnaW5hbFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIFJHQkFfQVJSQVk6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPSA0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICAgICAgYjogb3JpZ2luYWxbMl0sXG4gICAgICAgICAgICAgIGE6IG9yaWdpbmFsWzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYV07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIE9iamVjdHNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzT2JqZWN0LFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFJHQkFfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgICAgIGI6IG9yaWdpbmFsLmIsXG4gICAgICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYixcbiAgICAgICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBSR0JfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgICAgIGI6IG9yaWdpbmFsLmJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSFNWQV9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICAgICAgdjogb3JpZ2luYWwudixcbiAgICAgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgICAgICB2OiBjb2xvci52LFxuICAgICAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIEhTVl9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICAgICAgdjogb3JpZ2luYWwudlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICAgICAgdjogY29sb3IudlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuXG4gIF07XG5cbiAgcmV0dXJuIGludGVycHJldDtcblxuXG59KShkYXQuY29sb3IudG9TdHJpbmcsXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuR1VJID0gZGF0Lmd1aS5HVUkgPSAoZnVuY3Rpb24gKGNzcywgc2F2ZURpYWxvZ3VlQ29udGVudHMsIHN0eWxlU2hlZXQsIGNvbnRyb2xsZXJGYWN0b3J5LCBDb250cm9sbGVyLCBCb29sZWFuQ29udHJvbGxlciwgRnVuY3Rpb25Db250cm9sbGVyLCBOdW1iZXJDb250cm9sbGVyQm94LCBOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBPcHRpb25Db250cm9sbGVyLCBDb2xvckNvbnRyb2xsZXIsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgQ2VudGVyZWREaXYsIGRvbSwgY29tbW9uKSB7XG5cbiAgY3NzLmluamVjdChzdHlsZVNoZWV0KTtcblxuICAvKiogT3V0ZXItbW9zdCBjbGFzc05hbWUgZm9yIEdVSSdzICovXG4gIHZhciBDU1NfTkFNRVNQQUNFID0gJ2RnJztcblxuICB2YXIgSElERV9LRVlfQ09ERSA9IDcyO1xuXG4gIC8qKiBUaGUgb25seSB2YWx1ZSBzaGFyZWQgYmV0d2VlbiB0aGUgSlMgYW5kIFNDU1MuIFVzZSBjYXV0aW9uLiAqL1xuICB2YXIgQ0xPU0VfQlVUVE9OX0hFSUdIVCA9IDIwO1xuXG4gIHZhciBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUgPSAnRGVmYXVsdCc7XG5cbiAgdmFyIFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3cgJiYgd2luZG93Wydsb2NhbFN0b3JhZ2UnXSAhPT0gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSgpO1xuXG4gIHZhciBTQVZFX0RJQUxPR1VFO1xuXG4gIC8qKiBIYXZlIHdlIHlldCB0byBjcmVhdGUgYW4gYXV0b1BsYWNlIEdVST8gKi9cbiAgdmFyIGF1dG9fcGxhY2VfdmlyZ2luID0gdHJ1ZTtcblxuICAvKiogRml4ZWQgcG9zaXRpb24gZGl2IHRoYXQgYXV0byBwbGFjZSBHVUkncyBnbyBpbnNpZGUgKi9cbiAgdmFyIGF1dG9fcGxhY2VfY29udGFpbmVyO1xuXG4gIC8qKiBBcmUgd2UgaGlkaW5nIHRoZSBHVUkncyA/ICovXG4gIHZhciBoaWRlID0gZmFsc2U7XG5cbiAgLyoqIEdVSSdzIHdoaWNoIHNob3VsZCBiZSBoaWRkZW4gKi9cbiAgdmFyIGhpZGVhYmxlX2d1aXMgPSBbXTtcblxuICAvKipcbiAgICogQSBsaWdodHdlaWdodCBjb250cm9sbGVyIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuIEl0IGFsbG93cyB5b3UgdG8gZWFzaWx5XG4gICAqIG1hbmlwdWxhdGUgdmFyaWFibGVzIGFuZCBmaXJlIGZ1bmN0aW9ucyBvbiB0aGUgZmx5LlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICogQG1lbWJlciBkYXQuZ3VpXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5uYW1lXSBUaGUgbmFtZSBvZiB0aGlzIEdVSS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXMubG9hZF0gSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzYXZlZCBzdGF0ZSBvZlxuICAgKiB0aGlzIEdVSS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmF1dG89dHJ1ZV1cbiAgICogQHBhcmFtIHtkYXQuZ3VpLkdVSX0gW3BhcmFtcy5wYXJlbnRdIFRoZSBHVUkgSSdtIG5lc3RlZCBpbi5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmNsb3NlZF0gSWYgdHJ1ZSwgc3RhcnRzIGNsb3NlZFxuICAgKi9cbiAgdmFyIEdVSSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIE91dGVybW9zdCBET00gRWxlbWVudFxuICAgICAqIEB0eXBlIERPTUVsZW1lbnRcbiAgICAgKi9cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fdWwpO1xuXG4gICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgQ1NTX05BTUVTUEFDRSk7XG5cbiAgICAvKipcbiAgICAgKiBOZXN0ZWQgR1VJJ3MgYnkgbmFtZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fZm9sZGVycyA9IHt9O1xuXG4gICAgdGhpcy5fX2NvbnRyb2xsZXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIG9iamVjdHMgSSdtIHJlbWVtYmVyaW5nIGZvciBzYXZlLCBvbmx5IHVzZWQgaW4gdG9wIGxldmVsIEdVSVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIE1hcHMgdGhlIGluZGV4IG9mIHJlbWVtYmVyZWQgb2JqZWN0cyB0byBhIG1hcCBvZiBjb250cm9sbGVycywgb25seSB1c2VkXG4gICAgICogaW4gdG9wIGxldmVsIEdVSS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBbXG4gICAgICogIHtcbiAgICAgKiAgICBwcm9wZXJ0eU5hbWU6IENvbnRyb2xsZXIsXG4gICAgICogICAgYW5vdGhlclByb3BlcnR5TmFtZTogQ29udHJvbGxlclxuICAgICAqICB9LFxuICAgICAqICB7XG4gICAgICogICAgcHJvcGVydHlOYW1lOiBDb250cm9sbGVyXG4gICAgICogIH1cbiAgICAgKiBdXG4gICAgICovXG4gICAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVycyA9IFtdO1xuXG4gICAgdGhpcy5fX2xpc3RlbmluZyA9IFtdO1xuXG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgLy8gRGVmYXVsdCBwYXJhbWV0ZXJzXG4gICAgcGFyYW1zID0gY29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgYXV0b1BsYWNlOiB0cnVlLFxuICAgICAgd2lkdGg6IEdVSS5ERUZBVUxUX1dJRFRIXG4gICAgfSk7XG5cbiAgICBwYXJhbXMgPSBjb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgICByZXNpemFibGU6IHBhcmFtcy5hdXRvUGxhY2UsXG4gICAgICBoaWRlYWJsZTogcGFyYW1zLmF1dG9QbGFjZVxuICAgIH0pO1xuXG5cbiAgICBpZiAoIWNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMubG9hZCkpIHtcblxuICAgICAgLy8gRXhwbGljaXQgcHJlc2V0XG4gICAgICBpZiAocGFyYW1zLnByZXNldCkgcGFyYW1zLmxvYWQucHJlc2V0ID0gcGFyYW1zLnByZXNldDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHBhcmFtcy5sb2FkID0geyBwcmVzZXQ6IERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSB9O1xuXG4gICAgfVxuXG4gICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMuaGlkZWFibGUpIHtcbiAgICAgIGhpZGVhYmxlX2d1aXMucHVzaCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IHJvb3QgbGV2ZWwgR1VJJ3MgYXJlIHJlc2l6YWJsZS5cbiAgICBwYXJhbXMucmVzaXphYmxlID0gY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5yZXNpemFibGU7XG5cblxuICAgIGlmIChwYXJhbXMuYXV0b1BsYWNlICYmIGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMuc2Nyb2xsYWJsZSkpIHtcbiAgICAgIHBhcmFtcy5zY3JvbGxhYmxlID0gdHJ1ZTtcbiAgICB9XG4vLyAgICBwYXJhbXMuc2Nyb2xsYWJsZSA9IGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMuc2Nyb2xsYWJsZSA9PT0gdHJ1ZTtcblxuICAgIC8vIE5vdCBwYXJ0IG9mIHBhcmFtcyBiZWNhdXNlIEkgZG9uJ3Qgd2FudCBwZW9wbGUgcGFzc2luZyB0aGlzIGluIHZpYVxuICAgIC8vIGNvbnN0cnVjdG9yLiBTaG91bGQgYmUgYSAncmVtZW1iZXJlZCcgdmFsdWUuXG4gICAgdmFyIHVzZV9sb2NhbF9zdG9yYWdlID1cbiAgICAgICAgU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSAmJlxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyxcblxuICAgICAgICAvKiogQGxlbmRzIGRhdC5ndWkuR1VJLnByb3RvdHlwZSAqL1xuICAgICAgICB7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgcGFyZW50IDxjb2RlPkdVSTwvY29kZT5cbiAgICAgICAgICAgKiBAdHlwZSBkYXQuZ3VpLkdVSVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHBhcmVudDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNjcm9sbGFibGU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMuc2Nyb2xsYWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSGFuZGxlcyA8Y29kZT5HVUk8L2NvZGU+J3MgZWxlbWVudCBwbGFjZW1lbnQgZm9yIHlvdVxuICAgICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBhdXRvUGxhY2U6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMuYXV0b1BsYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgaWRlbnRpZmllciBmb3IgYSBzZXQgb2Ygc2F2ZWQgdmFsdWVzXG4gICAgICAgICAgICogQHR5cGUgU3RyaW5nXG4gICAgICAgICAgICovXG4gICAgICAgICAgcHJlc2V0OiB7XG5cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0Um9vdCgpLnByZXNldDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmxvYWQucHJlc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmdldFJvb3QoKS5wcmVzZXQgPSB2O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2V0UHJlc2V0U2VsZWN0SW5kZXgodGhpcyk7XG4gICAgICAgICAgICAgIF90aGlzLnJldmVydCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSB3aWR0aCBvZiA8Y29kZT5HVUk8L2NvZGU+IGVsZW1lbnRcbiAgICAgICAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB3aWR0aDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy53aWR0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcGFyYW1zLndpZHRoID0gdjtcbiAgICAgICAgICAgICAgc2V0V2lkdGgoX3RoaXMsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgbmFtZSBvZiA8Y29kZT5HVUk8L2NvZGU+LiBVc2VkIGZvciBmb2xkZXJzLiBpLmVcbiAgICAgICAgICAgKiBhIGZvbGRlcidzIG5hbWVcbiAgICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLm5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIC8vIFRPRE8gQ2hlY2sgZm9yIGNvbGxpc2lvbnMgYW1vbmcgc2libGluZyBmb2xkZXJzXG4gICAgICAgICAgICAgIHBhcmFtcy5uYW1lID0gdjtcbiAgICAgICAgICAgICAgaWYgKHRpdGxlX3Jvd19uYW1lKSB7XG4gICAgICAgICAgICAgICAgdGl0bGVfcm93X25hbWUuaW5uZXJIVE1MID0gcGFyYW1zLm5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hldGhlciB0aGUgPGNvZGU+R1VJPC9jb2RlPiBpcyBjb2xsYXBzZWQgb3Igbm90XG4gICAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNsb3NlZDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHBhcmFtcy5jbG9zZWQgPSB2O1xuICAgICAgICAgICAgICBpZiAocGFyYW1zLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhfdGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRm9yIGJyb3dzZXJzIHRoYXQgYXJlbid0IGdvaW5nIHRvIHJlc3BlY3QgdGhlIENTUyB0cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAvLyBMZXRzIGp1c3QgY2hlY2sgb3VyIGhlaWdodCBhZ2FpbnN0IHRoZSB3aW5kb3cgaGVpZ2h0IHJpZ2h0IG9mZlxuICAgICAgICAgICAgICAvLyB0aGUgYmF0LlxuICAgICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG5cbiAgICAgICAgICAgICAgaWYgKF90aGlzLl9fY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IHYgPyBHVUkuVEVYVF9PUEVOIDogR1VJLlRFWFRfQ0xPU0VEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENvbnRhaW5zIGFsbCBwcmVzZXRzXG4gICAgICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgICAgICovXG4gICAgICAgICAgbG9hZDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIHVzZSA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL1N0b3JhZ2UjbG9jYWxTdG9yYWdlXCI+bG9jYWxTdG9yYWdlPC9hPiBhcyB0aGUgbWVhbnMgZm9yXG4gICAgICAgICAgICogPGNvZGU+cmVtZW1iZXI8L2NvZGU+aW5nXG4gICAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgICAqL1xuICAgICAgICAgIHVzZUxvY2FsU3RvcmFnZToge1xuXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXNlX2xvY2FsX3N0b3JhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihib29sKSB7XG4gICAgICAgICAgICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG4gICAgICAgICAgICAgICAgdXNlX2xvY2FsX3N0b3JhZ2UgPSBib29sO1xuICAgICAgICAgICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICAgICAgICBkb20uYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdpc0xvY2FsJyksIGJvb2wpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAvLyBBcmUgd2UgYSByb290IGxldmVsIEdVST9cbiAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG5cbiAgICAgIHBhcmFtcy5jbG9zZWQgPSBmYWxzZTtcblxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX01BSU4pO1xuICAgICAgZG9tLm1ha2VTZWxlY3RhYmxlKHRoaXMuZG9tRWxlbWVudCwgZmFsc2UpO1xuXG4gICAgICAvLyBBcmUgd2Ugc3VwcG9zZWQgdG8gYmUgbG9hZGluZyBsb2NhbGx5P1xuICAgICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcblxuICAgICAgICBpZiAodXNlX2xvY2FsX3N0b3JhZ2UpIHtcblxuICAgICAgICAgIF90aGlzLnVzZUxvY2FsU3RvcmFnZSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc2F2ZWRfZ3VpID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnZ3VpJykpO1xuXG4gICAgICAgICAgaWYgKHNhdmVkX2d1aSkge1xuICAgICAgICAgICAgcGFyYW1zLmxvYWQgPSBKU09OLnBhcnNlKHNhdmVkX2d1aSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9fY2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSBHVUkuVEVYVF9DTE9TRUQ7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fY2xvc2VCdXR0b24pO1xuXG4gICAgICBkb20uYmluZCh0aGlzLl9fY2xvc2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG5cblxuICAgICAgfSk7XG5cblxuICAgICAgLy8gT2gsIHlvdSdyZSBhIG5lc3RlZCBHVUkhXG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKHBhcmFtcy5jbG9zZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpdGxlX3Jvd19uYW1lID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGFyYW1zLm5hbWUpO1xuICAgICAgZG9tLmFkZENsYXNzKHRpdGxlX3Jvd19uYW1lLCAnY29udHJvbGxlci1uYW1lJyk7XG5cbiAgICAgIHZhciB0aXRsZV9yb3cgPSBhZGRSb3coX3RoaXMsIHRpdGxlX3Jvd19uYW1lKTtcblxuICAgICAgdmFyIG9uX2NsaWNrX3RpdGxlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuXG4gICAgICBkb20uYWRkQ2xhc3ModGl0bGVfcm93LCAndGl0bGUnKTtcbiAgICAgIGRvbS5iaW5kKHRpdGxlX3JvdywgJ2NsaWNrJywgb25fY2xpY2tfdGl0bGUpO1xuXG4gICAgICBpZiAoIXBhcmFtcy5jbG9zZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYXV0b1BsYWNlKSB7XG5cbiAgICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcblxuICAgICAgICBpZiAoYXV0b19wbGFjZV92aXJnaW4pIHtcbiAgICAgICAgICBhdXRvX3BsYWNlX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhhdXRvX3BsYWNlX2NvbnRhaW5lciwgQ1NTX05BTUVTUEFDRSk7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9fcGxhY2VfY29udGFpbmVyLCBHVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYXV0b19wbGFjZV9jb250YWluZXIpO1xuICAgICAgICAgIGF1dG9fcGxhY2VfdmlyZ2luID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXQgaXQgaW4gdGhlIGRvbSBmb3IgeW91LlxuICAgICAgICBhdXRvX3BsYWNlX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgICAgIC8vIEFwcGx5IHRoZSBhdXRvIHN0eWxlc1xuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfQVVUT19QTEFDRSk7XG5cbiAgICAgIH1cblxuXG4gICAgICAvLyBNYWtlIGl0IG5vdCBlbGFzdGljLlxuICAgICAgaWYgKCF0aGlzLnBhcmVudCkgc2V0V2lkdGgoX3RoaXMsIHBhcmFtcy53aWR0aCk7XG5cbiAgICB9XG5cbiAgICBkb20uYmluZCh3aW5kb3csICdyZXNpemUnLCBmdW5jdGlvbigpIHsgX3RoaXMub25SZXNpemUoKSB9KTtcbiAgICBkb20uYmluZCh0aGlzLl9fdWwsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24oKSB7IF90aGlzLm9uUmVzaXplKCk7IH0pO1xuICAgIGRvbS5iaW5kKHRoaXMuX191bCwgJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbigpIHsgX3RoaXMub25SZXNpemUoKSB9KTtcbiAgICBkb20uYmluZCh0aGlzLl9fdWwsICdvVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uKCkgeyBfdGhpcy5vblJlc2l6ZSgpIH0pO1xuICAgIHRoaXMub25SZXNpemUoKTtcblxuXG4gICAgaWYgKHBhcmFtcy5yZXNpemFibGUpIHtcbiAgICAgIGFkZFJlc2l6ZUhhbmRsZSh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYXZlVG9Mb2NhbFN0b3JhZ2UoKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnZ3VpJyksIEpTT04uc3RyaW5naWZ5KF90aGlzLmdldFNhdmVPYmplY3QoKSkpO1xuICAgIH1cblxuICAgIHZhciByb290ID0gX3RoaXMuZ2V0Um9vdCgpO1xuICAgIGZ1bmN0aW9uIHJlc2V0V2lkdGgoKSB7XG4gICAgICAgIHZhciByb290ID0gX3RoaXMuZ2V0Um9vdCgpO1xuICAgICAgICByb290LndpZHRoICs9IDE7XG4gICAgICAgIGNvbW1vbi5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICByb290LndpZHRoIC09IDE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmFtcy5wYXJlbnQpIHtcbiAgICAgICAgcmVzZXRXaWR0aCgpO1xuICAgICAgfVxuXG4gIH07XG5cbiAgR1VJLnRvZ2dsZUhpZGUgPSBmdW5jdGlvbigpIHtcblxuICAgIGhpZGUgPSAhaGlkZTtcbiAgICBjb21tb24uZWFjaChoaWRlYWJsZV9ndWlzLCBmdW5jdGlvbihndWkpIHtcbiAgICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLnpJbmRleCA9IGhpZGUgPyAtOTk5IDogOTk5O1xuICAgICAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IGhpZGUgPyAwIDogMTtcbiAgICB9KTtcbiAgfTtcblxuICBHVUkuQ0xBU1NfQVVUT19QTEFDRSA9ICdhJztcbiAgR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSID0gJ2FjJztcbiAgR1VJLkNMQVNTX01BSU4gPSAnbWFpbic7XG4gIEdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyA9ICdjcic7XG4gIEdVSS5DTEFTU19UT09fVEFMTCA9ICd0YWxsZXItdGhhbi13aW5kb3cnO1xuICBHVUkuQ0xBU1NfQ0xPU0VEID0gJ2Nsb3NlZCc7XG4gIEdVSS5DTEFTU19DTE9TRV9CVVRUT04gPSAnY2xvc2UtYnV0dG9uJztcbiAgR1VJLkNMQVNTX0RSQUcgPSAnZHJhZyc7XG5cbiAgR1VJLkRFRkFVTFRfV0lEVEggPSAyNDU7XG4gIEdVSS5URVhUX0NMT1NFRCA9ICdDbG9zZSBDb250cm9scyc7XG4gIEdVSS5URVhUX09QRU4gPSAnT3BlbiBDb250cm9scyc7XG5cbiAgZG9tLmJpbmQod2luZG93LCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcblxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50LnR5cGUgIT09ICd0ZXh0JyAmJlxuICAgICAgICAoZS53aGljaCA9PT0gSElERV9LRVlfQ09ERSB8fCBlLmtleUNvZGUgPT0gSElERV9LRVlfQ09ERSkpIHtcbiAgICAgIEdVSS50b2dnbGVIaWRlKCk7XG4gICAgfVxuXG4gIH0sIGZhbHNlKTtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBHVUkucHJvdG90eXBlLFxuXG4gICAgICAvKiogQGxlbmRzIGRhdC5ndWkuR1VJICovXG4gICAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5XG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcn0gVGhlIG5ldyBjb250cm9sbGVyIHRoYXQgd2FzIGFkZGVkLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZhY3RvcnlBcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5XG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29sb3JDb250cm9sbGVyfSBUaGUgbmV3IGNvbnRyb2xsZXIgdGhhdCB3YXMgYWRkZWQuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ29sb3I6IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gY29udHJvbGxlclxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oY29udHJvbGxlcikge1xuXG4gICAgICAgICAgLy8gVE9ETyBsaXN0ZW5pbmc/XG4gICAgICAgICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGNvbnRyb2xsZXIuX19saSk7XG4gICAgICAgICAgdGhpcy5fX2NvbnRyb2xsZXJzLnNsaWNlKHRoaXMuX19jb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpLCAxKTtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGNvbW1vbi5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLm9uUmVzaXplKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgICAgICAgYXV0b19wbGFjZV9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG5hbWVcbiAgICAgICAgICogQHJldHVybnMge2RhdC5ndWkuR1VJfSBUaGUgbmV3IGZvbGRlci5cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoaXMgR1VJIGFscmVhZHkgaGFzIGEgZm9sZGVyIGJ5IHRoZSBzcGVjaWZpZWRcbiAgICAgICAgICogbmFtZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGFkZEZvbGRlcjogZnVuY3Rpb24obmFtZSkge1xuXG4gICAgICAgICAgLy8gV2UgaGF2ZSB0byBwcmV2ZW50IGNvbGxpc2lvbnMgb24gbmFtZXMgaW4gb3JkZXIgdG8gaGF2ZSBhIGtleVxuICAgICAgICAgIC8vIGJ5IHdoaWNoIHRvIHJlbWVtYmVyIHNhdmVkIHZhbHVlc1xuICAgICAgICAgIGlmICh0aGlzLl9fZm9sZGVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhbHJlYWR5IGhhdmUgYSBmb2xkZXIgaW4gdGhpcyBHVUkgYnkgdGhlJyArXG4gICAgICAgICAgICAgICAgJyBuYW1lIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV3X2d1aV9wYXJhbXMgPSB7IG5hbWU6IG5hbWUsIHBhcmVudDogdGhpcyB9O1xuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBwYXNzIGRvd24gdGhlIGF1dG9QbGFjZSB0cmFpdCBzbyB0aGF0IHdlIGNhblxuICAgICAgICAgIC8vIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG8gb3Blbi9jbG9zZSBmb2xkZXIgYWN0aW9ucyB0b1xuICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IGEgc2Nyb2xsYmFyIGFwcGVhcnMgaWYgdGhlIHdpbmRvdyBpcyB0b28gc2hvcnQuXG4gICAgICAgICAgbmV3X2d1aV9wYXJhbXMuYXV0b1BsYWNlID0gdGhpcy5hdXRvUGxhY2U7XG5cbiAgICAgICAgICAvLyBEbyB3ZSBoYXZlIHNhdmVkIGFwcGVhcmFuY2UgZGF0YSBmb3IgdGhpcyBmb2xkZXI/XG5cbiAgICAgICAgICBpZiAodGhpcy5sb2FkICYmIC8vIEFueXRoaW5nIGxvYWRlZD9cbiAgICAgICAgICAgICAgdGhpcy5sb2FkLmZvbGRlcnMgJiYgLy8gV2FzIG15IHBhcmVudCBhIGRlYWQtZW5kP1xuICAgICAgICAgICAgICB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXSkgeyAvLyBEaWQgZGFkZHkgcmVtZW1iZXIgbWU/XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG1lIGNsb3NlZCBpZiBJIHdhcyBjbG9zZWRcbiAgICAgICAgICAgIG5ld19ndWlfcGFyYW1zLmNsb3NlZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdLmNsb3NlZDtcblxuICAgICAgICAgICAgLy8gUGFzcyBkb3duIHRoZSBsb2FkZWQgZGF0YVxuICAgICAgICAgICAgbmV3X2d1aV9wYXJhbXMubG9hZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGd1aSA9IG5ldyBHVUkobmV3X2d1aV9wYXJhbXMpO1xuICAgICAgICAgIHRoaXMuX19mb2xkZXJzW25hbWVdID0gZ3VpO1xuXG4gICAgICAgICAgdmFyIGxpID0gYWRkUm93KHRoaXMsIGd1aS5kb21FbGVtZW50KTtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MobGksICdmb2xkZXInKTtcbiAgICAgICAgICByZXR1cm4gZ3VpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVzaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHZhciByb290ID0gdGhpcy5nZXRSb290KCk7XG5cbiAgICAgICAgICBpZiAocm9vdC5zY3JvbGxhYmxlKSB7XG5cbiAgICAgICAgICAgIHZhciB0b3AgPSBkb20uZ2V0T2Zmc2V0KHJvb3QuX191bCkudG9wO1xuICAgICAgICAgICAgdmFyIGggPSAwO1xuXG4gICAgICAgICAgICBjb21tb24uZWFjaChyb290Ll9fdWwuY2hpbGROb2RlcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICBpZiAoISAocm9vdC5hdXRvUGxhY2UgJiYgbm9kZSA9PT0gcm9vdC5fX3NhdmVfcm93KSlcbiAgICAgICAgICAgICAgICBoICs9IGRvbS5nZXRIZWlnaHQobm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgPCBoKSB7XG4gICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocm9vdC5fX3Jlc2l6ZV9oYW5kbGUpIHtcbiAgICAgICAgICAgIGNvbW1vbi5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcm9vdC5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUuaGVpZ2h0ID0gcm9vdC5fX3VsLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocm9vdC5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgICByb290Ll9fY2xvc2VCdXR0b24uc3R5bGUud2lkdGggPSByb290LndpZHRoICsgJ3B4JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFyayBvYmplY3RzIGZvciBzYXZpbmcuIFRoZSBvcmRlciBvZiB0aGVzZSBvYmplY3RzIGNhbm5vdCBjaGFuZ2UgYXNcbiAgICAgICAgICogdGhlIEdVSSBncm93cy4gV2hlbiByZW1lbWJlcmluZyBuZXcgb2JqZWN0cywgYXBwZW5kIHRoZW0gdG8gdGhlIGVuZFxuICAgICAgICAgKiBvZiB0aGUgbGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuLi59IG9iamVjdHNcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IGlmIG5vdCBjYWxsZWQgb24gYSB0b3AgbGV2ZWwgR1VJLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHJlbWVtYmVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQoU0FWRV9ESUFMT0dVRSkpIHtcbiAgICAgICAgICAgIFNBVkVfRElBTE9HVUUgPSBuZXcgQ2VudGVyZWREaXYoKTtcbiAgICAgICAgICAgIFNBVkVfRElBTE9HVUUuZG9tRWxlbWVudC5pbm5lckhUTUwgPSBzYXZlRGlhbG9ndWVDb250ZW50cztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4gb25seSBjYWxsIHJlbWVtYmVyIG9uIGEgdG9wIGxldmVsIEdVSS5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgIGNvbW1vbi5lYWNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgYWRkU2F2ZU1lbnUoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihvYmplY3QpID09IC0xKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICAgICAgICAvLyBTZXQgc2F2ZSByb3cgd2lkdGhcbiAgICAgICAgICAgIHNldFdpZHRoKHRoaXMsIHRoaXMud2lkdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0Lmd1aS5HVUl9IHRoZSB0b3Btb3N0IHBhcmVudCBHVUkgb2YgYSBuZXN0ZWQgR1VJLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGdldFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBndWkgPSB0aGlzO1xuICAgICAgICAgIHdoaWxlIChndWkucGFyZW50KSB7XG4gICAgICAgICAgICBndWkgPSBndWkucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ3VpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZSBvZlxuICAgICAgICAgKiB0aGlzIEdVSSBhcyB3ZWxsIGFzIGl0cyByZW1lbWJlcmVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2F2ZU9iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB2YXIgdG9SZXR1cm4gPSB0aGlzLmxvYWQ7XG5cbiAgICAgICAgICB0b1JldHVybi5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcblxuICAgICAgICAgIC8vIEFtIEkgcmVtZW1iZXJpbmcgYW55IHZhbHVlcz9cbiAgICAgICAgICBpZiAodGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgdG9SZXR1cm4ucHJlc2V0ID0gdGhpcy5wcmVzZXQ7XG5cbiAgICAgICAgICAgIGlmICghdG9SZXR1cm4ucmVtZW1iZXJlZCkge1xuICAgICAgICAgICAgICB0b1JldHVybi5yZW1lbWJlcmVkID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvUmV0dXJuLmZvbGRlcnMgPSB7fTtcbiAgICAgICAgICBjb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24oZWxlbWVudCwga2V5KSB7XG4gICAgICAgICAgICB0b1JldHVybi5mb2xkZXJzW2tleV0gPSBlbGVtZW50LmdldFNhdmVPYmplY3QoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiB0b1JldHVybjtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgICAgICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzYXZlQXM6IGZ1bmN0aW9uKHByZXNldE5hbWUpIHtcblxuICAgICAgICAgIGlmICghdGhpcy5sb2FkLnJlbWVtYmVyZWQpIHtcblxuICAgICAgICAgICAgLy8gUmV0YWluIGRlZmF1bHQgdmFsdWVzIHVwb24gZmlyc3Qgc2F2ZVxuICAgICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMsIHRydWUpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbcHJlc2V0TmFtZV0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgICAgICAgIHRoaXMucHJlc2V0ID0gcHJlc2V0TmFtZTtcbiAgICAgICAgICBhZGRQcmVzZXRPcHRpb24odGhpcywgcHJlc2V0TmFtZSwgdHJ1ZSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICByZXZlcnQ6IGZ1bmN0aW9uKGd1aSkge1xuXG4gICAgICAgICAgY29tbW9uLmVhY2godGhpcy5fX2NvbnRyb2xsZXJzLCBmdW5jdGlvbihjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHJldmVydCB3b3JrIG9uIERlZmF1bHQuXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Um9vdCgpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpIHx8IHRoaXMuZ2V0Um9vdCgpLCBjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIGNvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbihmb2xkZXIpIHtcbiAgICAgICAgICAgIGZvbGRlci5yZXZlcnQoZm9sZGVyKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghZ3VpKSB7XG4gICAgICAgICAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcy5nZXRSb290KCksIGZhbHNlKTtcbiAgICAgICAgICB9XG5cblxuICAgICAgICB9LFxuXG4gICAgICAgIGxpc3RlbjogZnVuY3Rpb24oY29udHJvbGxlcikge1xuXG4gICAgICAgICAgdmFyIGluaXQgPSB0aGlzLl9fbGlzdGVuaW5nLmxlbmd0aCA9PSAwO1xuICAgICAgICAgIHRoaXMuX19saXN0ZW5pbmcucHVzaChjb250cm9sbGVyKTtcbiAgICAgICAgICBpZiAoaW5pdCkgdXBkYXRlRGlzcGxheXModGhpcy5fX2xpc3RlbmluZyk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICBmdW5jdGlvbiBhZGQoZ3VpLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcblxuICAgIGlmIChvYmplY3RbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBcIiArIG9iamVjdCArIFwiIGhhcyBubyBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eSArIFwiXFxcIlwiKTtcbiAgICB9XG5cbiAgICB2YXIgY29udHJvbGxlcjtcblxuICAgIGlmIChwYXJhbXMuY29sb3IpIHtcblxuICAgICAgY29udHJvbGxlciA9IG5ldyBDb2xvckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB2YXIgZmFjdG9yeUFyZ3MgPSBbb2JqZWN0LHByb3BlcnR5XS5jb25jYXQocGFyYW1zLmZhY3RvcnlBcmdzKTtcbiAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyRmFjdG9yeS5hcHBseShndWksIGZhY3RvcnlBcmdzKTtcblxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYmVmb3JlIGluc3RhbmNlb2YgQ29udHJvbGxlcikge1xuICAgICAgcGFyYW1zLmJlZm9yZSA9IHBhcmFtcy5iZWZvcmUuX19saTtcbiAgICB9XG5cbiAgICByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcik7XG5cbiAgICBkb20uYWRkQ2xhc3MoY29udHJvbGxlci5kb21FbGVtZW50LCAnYycpO1xuXG4gICAgdmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgZG9tLmFkZENsYXNzKG5hbWUsICdwcm9wZXJ0eS1uYW1lJyk7XG4gICAgbmFtZS5pbm5lckhUTUwgPSBjb250cm9sbGVyLnByb3BlcnR5O1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuYW1lKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udHJvbGxlci5kb21FbGVtZW50KTtcblxuICAgIHZhciBsaSA9IGFkZFJvdyhndWksIGNvbnRhaW5lciwgcGFyYW1zLmJlZm9yZSk7XG5cbiAgICBkb20uYWRkQ2xhc3MobGksIEdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyk7XG4gICAgZG9tLmFkZENsYXNzKGxpLCB0eXBlb2YgY29udHJvbGxlci5nZXRWYWx1ZSgpKTtcblxuICAgIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpO1xuXG4gICAgZ3VpLl9fY29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcblxuICAgIHJldHVybiBjb250cm9sbGVyO1xuXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcm93IHRvIHRoZSBlbmQgb2YgdGhlIEdVSSBvciBiZWZvcmUgYW5vdGhlciByb3cuXG4gICAqXG4gICAqIEBwYXJhbSBndWlcbiAgICogQHBhcmFtIFtkb21dIElmIHNwZWNpZmllZCwgaW5zZXJ0cyB0aGUgZG9tIGNvbnRlbnQgaW4gdGhlIG5ldyByb3dcbiAgICogQHBhcmFtIFtsaUJlZm9yZV0gSWYgc3BlY2lmaWVkLCBwbGFjZXMgdGhlIG5ldyByb3cgYmVmb3JlIGFub3RoZXIgcm93XG4gICAqL1xuICBmdW5jdGlvbiBhZGRSb3coZ3VpLCBkb20sIGxpQmVmb3JlKSB7XG4gICAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICBpZiAoZG9tKSBsaS5hcHBlbmRDaGlsZChkb20pO1xuICAgIGlmIChsaUJlZm9yZSkge1xuICAgICAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGxpLCBwYXJhbXMuYmVmb3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3VpLl9fdWwuYXBwZW5kQ2hpbGQobGkpO1xuICAgIH1cbiAgICBndWkub25SZXNpemUoKTtcbiAgICByZXR1cm4gbGk7XG4gIH1cblxuICBmdW5jdGlvbiBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKSB7XG5cbiAgICBjb250cm9sbGVyLl9fbGkgPSBsaTtcbiAgICBjb250cm9sbGVyLl9fZ3VpID0gZ3VpO1xuXG4gICAgY29tbW9uLmV4dGVuZChjb250cm9sbGVyLCB7XG5cbiAgICAgIG9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgZ3VpLFxuICAgICAgICAgICAgICBjb250cm9sbGVyLm9iamVjdCxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgICAgICBmYWN0b3J5QXJnczogW2NvbW1vbi50b0FycmF5KGFyZ3VtZW50cyldXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbW9uLmlzQXJyYXkob3B0aW9ucykgfHwgY29tbW9uLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcblxuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIGd1aSxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5vYmplY3QsXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIucHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3M6IFtvcHRpb25zXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0sXG5cbiAgICAgIG5hbWU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgY29udHJvbGxlci5fX2xpLmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkLmlubmVySFRNTCA9IHY7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgfSxcblxuICAgICAgbGlzdGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udHJvbGxlci5fX2d1aS5saXN0ZW4oY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udHJvbGxlci5fX2d1aS5yZW1vdmUoY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyBBbGwgc2xpZGVycyBzaG91bGQgYmUgYWNjb21wYW5pZWQgYnkgYSBib3guXG4gICAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyU2xpZGVyKSB7XG5cbiAgICAgIHZhciBib3ggPSBuZXcgTnVtYmVyQ29udHJvbGxlckJveChjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSxcbiAgICAgICAgICB7IG1pbjogY29udHJvbGxlci5fX21pbiwgbWF4OiBjb250cm9sbGVyLl9fbWF4LCBzdGVwOiBjb250cm9sbGVyLl9fc3RlcCB9KTtcblxuICAgICAgY29tbW9uLmVhY2goWyd1cGRhdGVEaXNwbGF5JywgJ29uQ2hhbmdlJywgJ29uRmluaXNoQ2hhbmdlJ10sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICB2YXIgcGMgPSBjb250cm9sbGVyW21ldGhvZF07XG4gICAgICAgIHZhciBwYiA9IGJveFttZXRob2RdO1xuICAgICAgICBjb250cm9sbGVyW21ldGhvZF0gPSBib3hbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICBwYy5hcHBseShjb250cm9sbGVyLCBhcmdzKTtcbiAgICAgICAgICByZXR1cm4gcGIuYXBwbHkoYm94LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2hhcy1zbGlkZXInKTtcbiAgICAgIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoYm94LmRvbUVsZW1lbnQsIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJCb3gpIHtcblxuICAgICAgdmFyIHIgPSBmdW5jdGlvbihyZXR1cm5lZCkge1xuXG4gICAgICAgIC8vIEhhdmUgd2UgZGVmaW5lZCBib3RoIGJvdW5kYXJpZXM/XG4gICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIoY29udHJvbGxlci5fX21pbikgJiYgY29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19tYXgpKSB7XG5cbiAgICAgICAgICAvLyBXZWxsLCB0aGVuIGxldHMganVzdCByZXBsYWNlIHRoaXMgd2l0aCBhIHNsaWRlci5cbiAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIGd1aSxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5vYmplY3QsXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIucHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3M6IFtjb250cm9sbGVyLl9fbWluLCBjb250cm9sbGVyLl9fbWF4LCBjb250cm9sbGVyLl9fc3RlcF1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXR1cm5lZDtcblxuICAgICAgfTtcblxuICAgICAgY29udHJvbGxlci5taW4gPSBjb21tb24uY29tcG9zZShyLCBjb250cm9sbGVyLm1pbik7XG4gICAgICBjb250cm9sbGVyLm1heCA9IGNvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWF4KTtcblxuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQm9vbGVhbkNvbnRyb2xsZXIpIHtcblxuICAgICAgZG9tLmJpbmQobGksICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJyk7XG4gICAgICB9KTtcblxuICAgICAgZG9tLmJpbmQoY29udHJvbGxlci5fX2NoZWNrYm94LCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIFByZXZlbnRzIGRvdWJsZS10b2dnbGVcbiAgICAgIH0pXG5cbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uQ29udHJvbGxlcikge1xuXG4gICAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5mYWtlRXZlbnQoY29udHJvbGxlci5fX2J1dHRvbiwgJ2NsaWNrJyk7XG4gICAgICB9KTtcblxuICAgICAgZG9tLmJpbmQobGksICdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgICAgfSk7XG5cbiAgICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgICAgfSk7XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIENvbG9yQ29udHJvbGxlcikge1xuXG4gICAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xuICAgICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5ID0gY29tbW9uLmNvbXBvc2UoZnVuY3Rpb24ocikge1xuICAgICAgICBsaS5zdHlsZS5ib3JkZXJMZWZ0Q29sb3IgPSBjb250cm9sbGVyLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9LCBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkpO1xuXG4gICAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIH1cblxuICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUgPSBjb21tb24uY29tcG9zZShmdW5jdGlvbihyKSB7XG4gICAgICBpZiAoZ3VpLmdldFJvb3QoKS5fX3ByZXNldF9zZWxlY3QgJiYgY29udHJvbGxlci5pc01vZGlmaWVkKCkpIHtcbiAgICAgICAgbWFya1ByZXNldE1vZGlmaWVkKGd1aS5nZXRSb290KCksIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgY29udHJvbGxlci5zZXRWYWx1ZSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKSB7XG5cbiAgICAvLyBGaW5kIHRoZSB0b3Btb3N0IEdVSSwgdGhhdCdzIHdoZXJlIHJlbWVtYmVyZWQgb2JqZWN0cyBsaXZlLlxuICAgIHZhciByb290ID0gZ3VpLmdldFJvb3QoKTtcblxuICAgIC8vIERvZXMgdGhlIG9iamVjdCB3ZSdyZSBjb250cm9sbGluZyBtYXRjaCBhbnl0aGluZyB3ZSd2ZSBiZWVuIHRvbGQgdG9cbiAgICAvLyByZW1lbWJlcj9cbiAgICB2YXIgbWF0Y2hlZF9pbmRleCA9IHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0cy5pbmRleE9mKGNvbnRyb2xsZXIub2JqZWN0KTtcblxuICAgIC8vIFdoeSB5ZXMsIGl0IGRvZXMhXG4gICAgaWYgKG1hdGNoZWRfaW5kZXggIT0gLTEpIHtcblxuICAgICAgLy8gTGV0IG1lIGZldGNoIGEgbWFwIG9mIGNvbnRyb2xsZXJzIGZvciB0aGNvbW1vbi5pc09iamVjdC5cbiAgICAgIHZhciBjb250cm9sbGVyX21hcCA9XG4gICAgICAgICAgcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkX2luZGV4XTtcblxuICAgICAgLy8gT2hwLCBJIGJlbGlldmUgdGhpcyBpcyB0aGUgZmlyc3QgY29udHJvbGxlciB3ZSd2ZSBjcmVhdGVkIGZvciB0aGlzXG4gICAgICAvLyBvYmplY3QuIExldHMgbWFrZSB0aGUgbWFwIGZyZXNoLlxuICAgICAgaWYgKGNvbnRyb2xsZXJfbWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udHJvbGxlcl9tYXAgPSB7fTtcbiAgICAgICAgcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkX2luZGV4XSA9XG4gICAgICAgICAgICBjb250cm9sbGVyX21hcDtcbiAgICAgIH1cblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgIGNvbnRyb2xsZXJfbWFwW2NvbnRyb2xsZXIucHJvcGVydHldID0gY29udHJvbGxlcjtcblxuICAgICAgLy8gT2theSwgbm93IGhhdmUgd2Ugc2F2ZWQgYW55IHZhbHVlcyBmb3IgdGhpcyBjb250cm9sbGVyP1xuICAgICAgaWYgKHJvb3QubG9hZCAmJiByb290LmxvYWQucmVtZW1iZXJlZCkge1xuXG4gICAgICAgIHZhciBwcmVzZXRfbWFwID0gcm9vdC5sb2FkLnJlbWVtYmVyZWQ7XG5cbiAgICAgICAgLy8gV2hpY2ggcHJlc2V0IGFyZSB3ZSB0cnlpbmcgdG8gbG9hZD9cbiAgICAgICAgdmFyIHByZXNldDtcblxuICAgICAgICBpZiAocHJlc2V0X21hcFtndWkucHJlc2V0XSkge1xuXG4gICAgICAgICAgcHJlc2V0ID0gcHJlc2V0X21hcFtndWkucHJlc2V0XTtcblxuICAgICAgICB9IGVsc2UgaWYgKHByZXNldF9tYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSkge1xuXG4gICAgICAgICAgLy8gVWhoLCB5b3UgY2FuIGhhdmUgdGhlIGRlZmF1bHQgaW5zdGVhZD9cbiAgICAgICAgICBwcmVzZXQgPSBwcmVzZXRfbWFwW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV07XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIE5hZGEuXG5cbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gRGlkIHRoZSBsb2FkZWQgb2JqZWN0IHJlbWVtYmVyIHRoY29tbW9uLmlzT2JqZWN0P1xuICAgICAgICBpZiAocHJlc2V0W21hdGNoZWRfaW5kZXhdICYmXG5cbiAgICAgICAgICAvLyBEaWQgd2UgcmVtZW1iZXIgdGhpcyBwYXJ0aWN1bGFyIHByb3BlcnR5P1xuICAgICAgICAgICAgcHJlc2V0W21hdGNoZWRfaW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgIC8vIFdlIGRpZCByZW1lbWJlciBzb21ldGhpbmcgZm9yIHRoaXMgZ3V5IC4uLlxuICAgICAgICAgIHZhciB2YWx1ZSA9IHByZXNldFttYXRjaGVkX2luZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XTtcblxuICAgICAgICAgIC8vIEFuZCB0aGF0J3Mgd2hhdCBpdCBpcy5cbiAgICAgICAgICBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUodmFsdWUpO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwga2V5KSB7XG4gICAgLy8gVE9ETyBob3cgZG9lcyB0aGlzIGRlYWwgd2l0aCBtdWx0aXBsZSBHVUkncz9cbiAgICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiArICcuJyArIGtleTtcblxuICB9XG5cbiAgZnVuY3Rpb24gYWRkU2F2ZU1lbnUoZ3VpKSB7XG5cbiAgICB2YXIgZGl2ID0gZ3VpLl9fc2F2ZV9yb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXG4gICAgZG9tLmFkZENsYXNzKGd1aS5kb21FbGVtZW50LCAnaGFzLXNhdmUnKTtcblxuICAgIGd1aS5fX3VsLmluc2VydEJlZm9yZShkaXYsIGd1aS5fX3VsLmZpcnN0Q2hpbGQpO1xuXG4gICAgZG9tLmFkZENsYXNzKGRpdiwgJ3NhdmUtcm93Jyk7XG5cbiAgICB2YXIgZ2VhcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgZ2VhcnMuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG4gICAgZG9tLmFkZENsYXNzKGdlYXJzLCAnYnV0dG9uIGdlYXJzJyk7XG5cbiAgICAvLyBUT0RPIHJlcGxhY2Ugd2l0aCBGdW5jdGlvbkNvbnRyb2xsZXJcbiAgICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ1dHRvbi5pbm5lckhUTUwgPSAnU2F2ZSc7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ2J1dHRvbicpO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24sICdzYXZlJyk7XG5cbiAgICB2YXIgYnV0dG9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidXR0b24yLmlubmVySFRNTCA9ICdOZXcnO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24yLCAnYnV0dG9uJyk7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdzYXZlLWFzJyk7XG5cbiAgICB2YXIgYnV0dG9uMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidXR0b24zLmlubmVySFRNTCA9ICdSZXZlcnQnO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24zLCAnYnV0dG9uJyk7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbjMsICdyZXZlcnQnKTtcblxuICAgIHZhciBzZWxlY3QgPSBndWkuX19wcmVzZXRfc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG5cbiAgICBpZiAoZ3VpLmxvYWQgJiYgZ3VpLmxvYWQucmVtZW1iZXJlZCkge1xuXG4gICAgICBjb21tb24uZWFjaChndWkubG9hZC5yZW1lbWJlcmVkLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIGFkZFByZXNldE9wdGlvbihndWksIGtleSwga2V5ID09IGd1aS5wcmVzZXQpO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZG9tLmJpbmQoc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG5cblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLmlubmVySFRNTCA9IGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBndWkucHJlc2V0ID0gdGhpcy52YWx1ZTtcblxuICAgIH0pO1xuXG4gICAgZGl2LmFwcGVuZENoaWxkKHNlbGVjdCk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGdlYXJzKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG4gICAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjMpO1xuXG4gICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcblxuICAgICAgdmFyIHNhdmVMb2NhbGx5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLXNhdmUtbG9jYWxseScpO1xuICAgICAgdmFyIGV4cGxhaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtZXhwbGFpbicpO1xuXG4gICAgICBzYXZlTG9jYWxseS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgdmFyIGxvY2FsU3RvcmFnZUNoZWNrQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLXN0b3JhZ2UnKTtcblxuICAgICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZUNoZWNrQm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNob3dIaWRlRXhwbGFpbigpIHtcbiAgICAgICAgZXhwbGFpbi5zdHlsZS5kaXNwbGF5ID0gZ3VpLnVzZUxvY2FsU3RvcmFnZSA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIHNob3dIaWRlRXhwbGFpbigpO1xuXG4gICAgICAvLyBUT0RPOiBVc2UgYSBib29sZWFuIGNvbnRyb2xsZXIsIGZvb2whXG4gICAgICBkb20uYmluZChsb2NhbFN0b3JhZ2VDaGVja0JveCwgJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBndWkudXNlTG9jYWxTdG9yYWdlID0gIWd1aS51c2VMb2NhbFN0b3JhZ2U7XG4gICAgICAgIHNob3dIaWRlRXhwbGFpbigpO1xuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICB2YXIgbmV3Q29uc3RydWN0b3JUZXh0QXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1uZXctY29uc3RydWN0b3InKTtcblxuICAgIGRvbS5iaW5kKG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEsICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUubWV0YUtleSAmJiAoZS53aGljaCA9PT0gNjcgfHwgZS5rZXlDb2RlID09IDY3KSkge1xuICAgICAgICBTQVZFX0RJQUxPR1VFLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKGdlYXJzLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuaW5uZXJIVE1MID0gSlNPTi5zdHJpbmdpZnkoZ3VpLmdldFNhdmVPYmplY3QoKSwgdW5kZWZpbmVkLCAyKTtcbiAgICAgIFNBVkVfRElBTE9HVUUuc2hvdygpO1xuICAgICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5mb2N1cygpO1xuICAgICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5zZWxlY3QoKTtcbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKGJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBndWkuc2F2ZSgpO1xuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQoYnV0dG9uMiwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJlc2V0TmFtZSA9IHByb21wdCgnRW50ZXIgYSBuZXcgcHJlc2V0IG5hbWUuJyk7XG4gICAgICBpZiAocHJlc2V0TmFtZSkgZ3VpLnNhdmVBcyhwcmVzZXROYW1lKTtcbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKGJ1dHRvbjMsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgZ3VpLnJldmVydCgpO1xuICAgIH0pO1xuXG4vLyAgICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJlc2l6ZUhhbmRsZShndWkpIHtcblxuICAgIGd1aS5fX3Jlc2l6ZV9oYW5kbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGNvbW1vbi5leHRlbmQoZ3VpLl9fcmVzaXplX2hhbmRsZS5zdHlsZSwge1xuXG4gICAgICB3aWR0aDogJzZweCcsXG4gICAgICBtYXJnaW5MZWZ0OiAnLTNweCcsXG4gICAgICBoZWlnaHQ6ICcyMDBweCcsXG4gICAgICBjdXJzb3I6ICdldy1yZXNpemUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbi8vICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkIGJsdWUnXG5cbiAgICB9KTtcblxuICAgIHZhciBwbW91c2VYO1xuXG4gICAgZG9tLmJpbmQoZ3VpLl9fcmVzaXplX2hhbmRsZSwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG4gICAgZG9tLmJpbmQoZ3VpLl9fY2xvc2VCdXR0b24sICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuXG4gICAgZ3VpLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsIGd1aS5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKTtcblxuICAgIGZ1bmN0aW9uIGRyYWdTdGFydChlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgcG1vdXNlWCA9IGUuY2xpZW50WDtcblxuICAgICAgZG9tLmFkZENsYXNzKGd1aS5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfRFJBRyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYWcoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGd1aS53aWR0aCArPSBwbW91c2VYIC0gZS5jbGllbnRYO1xuICAgICAgZ3VpLm9uUmVzaXplKCk7XG4gICAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmFnU3RvcCgpIHtcblxuICAgICAgZG9tLnJlbW92ZUNsYXNzKGd1aS5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfRFJBRyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZHJhZ1N0b3ApO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRXaWR0aChndWksIHcpIHtcbiAgICBndWkuZG9tRWxlbWVudC5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgIC8vIEF1dG8gcGxhY2VkIHNhdmUtcm93cyBhcmUgcG9zaXRpb24gZml4ZWQsIHNvIHdlIGhhdmUgdG9cbiAgICAvLyBzZXQgdGhlIHdpZHRoIG1hbnVhbGx5IGlmIHdlIHdhbnQgaXQgdG8gYmxlZWQgdG8gdGhlIGVkZ2VcbiAgICBpZiAoZ3VpLl9fc2F2ZV9yb3cgJiYgZ3VpLmF1dG9QbGFjZSkge1xuICAgICAgZ3VpLl9fc2F2ZV9yb3cuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICB9aWYgKGd1aS5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICBndWkuX19jbG9zZUJ1dHRvbi5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRQcmVzZXQoZ3VpLCB1c2VJbml0aWFsVmFsdWVzKSB7XG5cbiAgICB2YXIgdG9SZXR1cm4gPSB7fTtcblxuICAgIC8vIEZvciBlYWNoIG9iamVjdCBJJ20gcmVtZW1iZXJpbmdcbiAgICBjb21tb24uZWFjaChndWkuX19yZW1lbWJlcmVkT2JqZWN0cywgZnVuY3Rpb24odmFsLCBpbmRleCkge1xuXG4gICAgICB2YXIgc2F2ZWRfdmFsdWVzID0ge307XG5cbiAgICAgIC8vIFRoZSBjb250cm9sbGVycyBJJ3ZlIG1hZGUgZm9yIHRoY29tbW9uLmlzT2JqZWN0IGJ5IHByb3BlcnR5XG4gICAgICB2YXIgY29udHJvbGxlcl9tYXAgPVxuICAgICAgICAgIGd1aS5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1tpbmRleF07XG5cbiAgICAgIC8vIFJlbWVtYmVyIGVhY2ggdmFsdWUgZm9yIGVhY2ggcHJvcGVydHlcbiAgICAgIGNvbW1vbi5lYWNoKGNvbnRyb2xsZXJfbWFwLCBmdW5jdGlvbihjb250cm9sbGVyLCBwcm9wZXJ0eSkge1xuICAgICAgICBzYXZlZF92YWx1ZXNbcHJvcGVydHldID0gdXNlSW5pdGlhbFZhbHVlcyA/IGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlIDogY29udHJvbGxlci5nZXRWYWx1ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNhdmUgdGhlIHZhbHVlcyBmb3IgdGhjb21tb24uaXNPYmplY3RcbiAgICAgIHRvUmV0dXJuW2luZGV4XSA9IHNhdmVkX3ZhbHVlcztcblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvUmV0dXJuO1xuXG4gIH1cblxuICBmdW5jdGlvbiBhZGRQcmVzZXRPcHRpb24oZ3VpLCBuYW1lLCBzZXRTZWxlY3RlZCkge1xuICAgIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBvcHQuaW5uZXJIVE1MID0gbmFtZTtcbiAgICBvcHQudmFsdWUgPSBuYW1lO1xuICAgIGd1aS5fX3ByZXNldF9zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcbiAgICBpZiAoc2V0U2VsZWN0ZWQpIHtcbiAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcmVzZXRTZWxlY3RJbmRleChndWkpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS52YWx1ZSA9PSBndWkucHJlc2V0KSB7XG4gICAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtQcmVzZXRNb2RpZmllZChndWksIG1vZGlmaWVkKSB7XG4gICAgdmFyIG9wdCA9IGd1aS5fX3ByZXNldF9zZWxlY3RbZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4XTtcbi8vICAgIGNvbnNvbGUubG9nKCdtYXJrJywgbW9kaWZpZWQsIG9wdCk7XG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlICsgXCIqXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KSB7XG5cblxuICAgIGlmIChjb250cm9sbGVyQXJyYXkubGVuZ3RoICE9IDApIHtcblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpO1xuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBjb21tb24uZWFjaChjb250cm9sbGVyQXJyYXksIGZ1bmN0aW9uKGMpIHtcbiAgICAgIGMudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuXG4gIH1cblxuICByZXR1cm4gR1VJO1xuXG59KShkYXQudXRpbHMuY3NzLFxuXCI8ZGl2IGlkPVxcXCJkZy1zYXZlXFxcIiBjbGFzcz1cXFwiZGcgZGlhbG9ndWVcXFwiPlxcblxcbiAgSGVyZSdzIHRoZSBuZXcgbG9hZCBwYXJhbWV0ZXIgZm9yIHlvdXIgPGNvZGU+R1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yOlxcblxcbiAgPHRleHRhcmVhIGlkPVxcXCJkZy1uZXctY29uc3RydWN0b3JcXFwiPjwvdGV4dGFyZWE+XFxuXFxuICA8ZGl2IGlkPVxcXCJkZy1zYXZlLWxvY2FsbHlcXFwiPlxcblxcbiAgICA8aW5wdXQgaWQ9XFxcImRnLWxvY2FsLXN0b3JhZ2VcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIi8+IEF1dG9tYXRpY2FsbHkgc2F2ZVxcbiAgICB2YWx1ZXMgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBvbiBleGl0LlxcblxcbiAgICA8ZGl2IGlkPVxcXCJkZy1sb2NhbC1leHBsYWluXFxcIj5UaGUgdmFsdWVzIHNhdmVkIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gd2lsbFxcbiAgICAgIG92ZXJyaWRlIHRob3NlIHBhc3NlZCB0byA8Y29kZT5kYXQuR1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yLiBUaGlzIG1ha2VzIGl0XFxuICAgICAgZWFzaWVyIHRvIHdvcmsgaW5jcmVtZW50YWxseSwgYnV0IDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gaXMgZnJhZ2lsZSxcXG4gICAgICBhbmQgeW91ciBmcmllbmRzIG1heSBub3Qgc2VlIHRoZSBzYW1lIHZhbHVlcyB5b3UgZG8uXFxuICAgICAgXFxuICAgIDwvZGl2PlxcbiAgICBcXG4gIDwvZGl2PlxcblxcbjwvZGl2PlwiLFxuXCIuZGcgdWx7bGlzdC1zdHlsZTpub25lO21hcmdpbjowO3BhZGRpbmc6MDt3aWR0aDoxMDAlO2NsZWFyOmJvdGh9LmRnLmFje3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2hlaWdodDowO3otaW5kZXg6MH0uZGc6bm90KC5hYykgLm1haW57b3ZlcmZsb3c6aGlkZGVufS5kZy5tYWluey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXJ9LmRnLm1haW4udGFsbGVyLXRoYW4td2luZG93e292ZXJmbG93LXk6YXV0b30uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3cgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjE7bWFyZ2luLXRvcDotMXB4O2JvcmRlci10b3A6MXB4IHNvbGlkICMyYzJjMmN9LmRnLm1haW4gdWwuY2xvc2VkIC5jbG9zZS1idXR0b257b3BhY2l0eToxICFpbXBvcnRhbnR9LmRnLm1haW46aG92ZXIgLmNsb3NlLWJ1dHRvbiwuZGcubWFpbiAuY2xvc2UtYnV0dG9uLmRyYWd7b3BhY2l0eToxfS5kZy5tYWluIC5jbG9zZS1idXR0b257LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyO3RyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjtib3JkZXI6MDtwb3NpdGlvbjphYnNvbHV0ZTtsaW5lLWhlaWdodDoxOXB4O2hlaWdodDoyMHB4O2N1cnNvcjpwb2ludGVyO3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6IzAwMH0uZGcubWFpbiAuY2xvc2UtYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzExMX0uZGcuYXtmbG9hdDpyaWdodDttYXJnaW4tcmlnaHQ6MTVweDtvdmVyZmxvdy14OmhpZGRlbn0uZGcuYS5oYXMtc2F2ZSB1bHttYXJnaW4tdG9wOjI3cHh9LmRnLmEuaGFzLXNhdmUgdWwuY2xvc2Vke21hcmdpbi10b3A6MH0uZGcuYSAuc2F2ZS1yb3d7cG9zaXRpb246Zml4ZWQ7dG9wOjA7ei1pbmRleDoxMDAyfS5kZyBsaXstd2Via2l0LXRyYW5zaXRpb246aGVpZ2h0IDAuMXMgZWFzZS1vdXQ7LW8tdHJhbnNpdGlvbjpoZWlnaHQgMC4xcyBlYXNlLW91dDstbW96LXRyYW5zaXRpb246aGVpZ2h0IDAuMXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpoZWlnaHQgMC4xcyBlYXNlLW91dH0uZGcgbGk6bm90KC5mb2xkZXIpe2N1cnNvcjphdXRvO2hlaWdodDoyN3B4O2xpbmUtaGVpZ2h0OjI3cHg7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MCA0cHggMCA1cHh9LmRnIGxpLmZvbGRlcntwYWRkaW5nOjA7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHJnYmEoMCwwLDAsMCl9LmRnIGxpLnRpdGxle2N1cnNvcjpwb2ludGVyO21hcmdpbi1sZWZ0Oi00cHh9LmRnIC5jbG9zZWQgbGk6bm90KC50aXRsZSksLmRnIC5jbG9zZWQgdWwgbGksLmRnIC5jbG9zZWQgdWwgbGkgPiAqe2hlaWdodDowO292ZXJmbG93OmhpZGRlbjtib3JkZXI6MH0uZGcgLmNye2NsZWFyOmJvdGg7cGFkZGluZy1sZWZ0OjNweDtoZWlnaHQ6MjdweH0uZGcgLnByb3BlcnR5LW5hbWV7Y3Vyc29yOmRlZmF1bHQ7ZmxvYXQ6bGVmdDtjbGVhcjpsZWZ0O3dpZHRoOjQwJTtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpc30uZGcgLmN7ZmxvYXQ6bGVmdDt3aWR0aDo2MCV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17Ym9yZGVyOjA7bWFyZ2luLXRvcDo0cHg7cGFkZGluZzozcHg7d2lkdGg6MTAwJTtmbG9hdDpyaWdodH0uZGcgLmhhcy1zbGlkZXIgaW5wdXRbdHlwZT10ZXh0XXt3aWR0aDozMCU7bWFyZ2luLWxlZnQ6MH0uZGcgLnNsaWRlcntmbG9hdDpsZWZ0O3dpZHRoOjY2JTttYXJnaW4tbGVmdDotNXB4O21hcmdpbi1yaWdodDowO2hlaWdodDoxOXB4O21hcmdpbi10b3A6NHB4fS5kZyAuc2xpZGVyLWZne2hlaWdodDoxMDAlfS5kZyAuYyBpbnB1dFt0eXBlPWNoZWNrYm94XXttYXJnaW4tdG9wOjlweH0uZGcgLmMgc2VsZWN0e21hcmdpbi10b3A6NXB4fS5kZyAuY3IuZnVuY3Rpb24sLmRnIC5jci5mdW5jdGlvbiAucHJvcGVydHktbmFtZSwuZGcgLmNyLmZ1bmN0aW9uICosLmRnIC5jci5ib29sZWFuLC5kZyAuY3IuYm9vbGVhbiAqe2N1cnNvcjpwb2ludGVyfS5kZyAuc2VsZWN0b3J7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO21hcmdpbi1sZWZ0Oi05cHg7bWFyZ2luLXRvcDoyM3B4O3otaW5kZXg6MTB9LmRnIC5jOmhvdmVyIC5zZWxlY3RvciwuZGcgLnNlbGVjdG9yLmRyYWd7ZGlzcGxheTpibG9ja30uZGcgbGkuc2F2ZS1yb3d7cGFkZGluZzowfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MHB4IDZweH0uZGcuZGlhbG9ndWV7YmFja2dyb3VuZC1jb2xvcjojMjIyO3dpZHRoOjQ2MHB4O3BhZGRpbmc6MTVweDtmb250LXNpemU6MTNweDtsaW5lLWhlaWdodDoxNXB4fSNkZy1uZXctY29uc3RydWN0b3J7cGFkZGluZzoxMHB4O2NvbG9yOiMyMjI7Zm9udC1mYW1pbHk6TW9uYWNvLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHg7Ym9yZGVyOjA7cmVzaXplOm5vbmU7Ym94LXNoYWRvdzppbnNldCAxcHggMXB4IDFweCAjODg4O3dvcmQtd3JhcDpicmVhay13b3JkO21hcmdpbjoxMnB4IDA7ZGlzcGxheTpibG9jazt3aWR0aDo0NDBweDtvdmVyZmxvdy15OnNjcm9sbDtoZWlnaHQ6MTAwcHg7cG9zaXRpb246cmVsYXRpdmV9I2RnLWxvY2FsLWV4cGxhaW57ZGlzcGxheTpub25lO2ZvbnQtc2l6ZToxMXB4O2xpbmUtaGVpZ2h0OjE3cHg7Ym9yZGVyLXJhZGl1czozcHg7YmFja2dyb3VuZC1jb2xvcjojMzMzO3BhZGRpbmc6OHB4O21hcmdpbi10b3A6MTBweH0jZGctbG9jYWwtZXhwbGFpbiBjb2Rle2ZvbnQtc2l6ZToxMHB4fSNkYXQtZ3VpLXNhdmUtbG9jYWxseXtkaXNwbGF5Om5vbmV9LmRne2NvbG9yOiNlZWU7Zm9udDoxMXB4ICdMdWNpZGEgR3JhbmRlJywgc2Fucy1zZXJpZjt0ZXh0LXNoYWRvdzowIC0xcHggMCAjMTExfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhcnt3aWR0aDo1cHg7YmFja2dyb3VuZDojMWExYTFhfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhci1jb3JuZXJ7aGVpZ2h0OjA7ZGlzcGxheTpub25lfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhci10aHVtYntib3JkZXItcmFkaXVzOjVweDtiYWNrZ3JvdW5kOiM2NzY3Njd9LmRnIGxpOm5vdCguZm9sZGVyKXtiYWNrZ3JvdW5kOiMxYTFhMWE7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgIzJjMmMyY30uZGcgbGkuc2F2ZS1yb3d7bGluZS1oZWlnaHQ6MjVweDtiYWNrZ3JvdW5kOiNkYWQ1Y2I7Ym9yZGVyOjB9LmRnIGxpLnNhdmUtcm93IHNlbGVjdHttYXJnaW4tbGVmdDo1cHg7d2lkdGg6MTA4cHh9LmRnIGxpLnNhdmUtcm93IC5idXR0b257bWFyZ2luLWxlZnQ6NXB4O21hcmdpbi10b3A6MXB4O2JvcmRlci1yYWRpdXM6MnB4O2ZvbnQtc2l6ZTo5cHg7bGluZS1oZWlnaHQ6N3B4O3BhZGRpbmc6NHB4IDRweCA1cHggNHB4O2JhY2tncm91bmQ6I2M1YmRhZDtjb2xvcjojZmZmO3RleHQtc2hhZG93OjAgMXB4IDAgI2IwYTU4Zjtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGY7Y3Vyc29yOnBvaW50ZXJ9LmRnIGxpLnNhdmUtcm93IC5idXR0b24uZ2VhcnN7YmFja2dyb3VuZDojYzViZGFkIHVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFzQUFBQU5DQVlBQUFCLzlaUTdBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQVFKSlJFRlVlTnBpWUtBVS9QLy9Qd0dJQy9BcENBQmlCU0FXK0k4QUNsQWNnS3hRNFQ5aG9NQUVVcnh4MlFTR042K2VnRFgrL3ZXVDRlN044MkFNWW9QQXgvZXZ3V29Zb1NZYkFDWDJzN0t4Q3h6Y3NlekRoM2V2Rm9ERUJZVEVFcXljZ2dXQXpBOUF1VVNRUWdlWVBhOWZQdjYvWVdtL0FjeDVJUGI3dHkvZncrUVpibHc2N3ZEczhSMFlIeVFoZ09ieCt5QUprQnFtRzVkUFBEaDFhUE9HUi9ldWdXMEc0dmxJb1RJZnlGY0ErUWVraGhISmhQZFF4YmlBSWd1TUJUUVpyUEQ3MTA4TTZyb1dZREZRaUlBQXY2QW93LzFiRndYZ2lzK2YyTFVBeW53b0lhTmN6OFhOeDNEbDdNRUpVREdRcHg5Z3RROFlDdWVCK0QyNk9FQ0FBUURhZHQ3ZTQ2RDQyUUFBQUFCSlJVNUVya0pnZ2c9PSkgMnB4IDFweCBuby1yZXBlYXQ7aGVpZ2h0OjdweDt3aWR0aDo4cHh9LmRnIGxpLnNhdmUtcm93IC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojYmFiMTllO2JveC1zaGFkb3c6MCAtMXB4IDAgI2IwYTU4Zn0uZGcgbGkuZm9sZGVye2JvcmRlci1ib3R0b206MH0uZGcgbGkudGl0bGV7cGFkZGluZy1sZWZ0OjE2cHg7YmFja2dyb3VuZDojMDAwIHVybChkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhCUUFGQUpFQUFQLy8vL1B6OC8vLy8vLy8veUg1QkFFQUFBSUFMQUFBQUFBRkFBVUFBQUlJbEkraEtnRnhvQ2dBT3c9PSkgNnB4IDEwcHggbm8tcmVwZWF0O2N1cnNvcjpwb2ludGVyO2JvcmRlci1ib3R0b206MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yKX0uZGcgLmNsb3NlZCBsaS50aXRsZXtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhCUUFGQUpFQUFQLy8vL1B6OC8vLy8vLy8veUg1QkFFQUFBSUFMQUFBQUFBRkFBVUFBQUlJbEdJV3FNQ2JXQUVBT3c9PSl9LmRnIC5jci5ib29sZWFue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjODA2Nzg3fS5kZyAuY3IuZnVuY3Rpb257Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICNlNjFkNWZ9LmRnIC5jci5udW1iZXJ7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICMyZmExZDZ9LmRnIC5jci5udW1iZXIgaW5wdXRbdHlwZT10ZXh0XXtjb2xvcjojMmZhMWQ2fS5kZyAuY3Iuc3RyaW5ne2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMWVkMzZmfS5kZyAuY3Iuc3RyaW5nIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzFlZDM2Zn0uZGcgLmNyLmZ1bmN0aW9uOmhvdmVyLC5kZyAuY3IuYm9vbGVhbjpob3ZlcntiYWNrZ3JvdW5kOiMxMTF9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17YmFja2dyb3VuZDojMzAzMDMwO291dGxpbmU6bm9uZX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XTpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06Zm9jdXN7YmFja2dyb3VuZDojNDk0OTQ5O2NvbG9yOiNmZmZ9LmRnIC5jIC5zbGlkZXJ7YmFja2dyb3VuZDojMzAzMDMwO2N1cnNvcjpldy1yZXNpemV9LmRnIC5jIC5zbGlkZXItZmd7YmFja2dyb3VuZDojMmZhMWQ2fS5kZyAuYyAuc2xpZGVyOmhvdmVye2JhY2tncm91bmQ6IzNjM2MzY30uZGcgLmMgLnNsaWRlcjpob3ZlciAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzQ0YWJkYX1cXG5cIixcbmRhdC5jb250cm9sbGVycy5mYWN0b3J5ID0gKGZ1bmN0aW9uIChPcHRpb25Db250cm9sbGVyLCBOdW1iZXJDb250cm9sbGVyQm94LCBOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBTdHJpbmdDb250cm9sbGVyLCBGdW5jdGlvbkNvbnRyb2xsZXIsIEJvb2xlYW5Db250cm9sbGVyLCBjb21tb24pIHtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgICAgICB2YXIgaW5pdGlhbFZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgICAgICAvLyBQcm92aWRpbmcgb3B0aW9ucz9cbiAgICAgICAgaWYgKGNvbW1vbi5pc0FycmF5KGFyZ3VtZW50c1syXSkgfHwgY29tbW9uLmlzT2JqZWN0KGFyZ3VtZW50c1syXSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IE9wdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb3ZpZGluZyBhIG1hcD9cblxuICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKGluaXRpYWxWYWx1ZSkpIHtcblxuICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzJdKSAmJiBjb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzNdKSkge1xuXG4gICAgICAgICAgICAvLyBIYXMgbWluIGFuZCBtYXguXG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBhcmd1bWVudHNbMl0sIG1heDogYXJndW1lbnRzWzNdIH0pO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbW9uLmlzU3RyaW5nKGluaXRpYWxWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0NvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbW9uLmlzRnVuY3Rpb24oaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tb24uaXNCb29sZWFuKGluaXRpYWxWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0pKGRhdC5jb250cm9sbGVycy5PcHRpb25Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJCb3gsXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclNsaWRlcixcbmRhdC5jb250cm9sbGVycy5TdHJpbmdDb250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUHJvdmlkZXMgYSB0ZXh0IGlucHV0IHRvIGFsdGVyIHRoZSBzdHJpbmcgcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIFN0cmluZ0NvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICBTdHJpbmdDb250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAna2V5dXAnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19pbnB1dC52YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9faW5wdXQpO1xuXG4gIH07XG5cbiAgU3RyaW5nQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBTdHJpbmdDb250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gU3RvcHMgdGhlIGNhcmV0IGZyb20gbW92aW5nIG9uIGFjY291bnQgb2Y6XG4gICAgICAgICAgLy8ga2V5dXAgLT4gc2V0VmFsdWUgLT4gdXBkYXRlRGlzcGxheVxuICAgICAgICAgIGlmICghZG9tLmlzQWN0aXZlKHRoaXMuX19pbnB1dCkpIHtcbiAgICAgICAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFN0cmluZ0NvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBTdHJpbmdDb250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuY29udHJvbGxlcnMuRnVuY3Rpb25Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLkJvb2xlYW5Db250cm9sbGVyLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5Cb29sZWFuQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5GdW5jdGlvbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlckJveCxcbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyU2xpZGVyLFxuZGF0LmNvbnRyb2xsZXJzLk9wdGlvbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuQ29sb3JDb250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIENvbG9yLCBpbnRlcnByZXQsIGNvbW1vbikge1xuXG4gIHZhciBDb2xvckNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICBDb2xvckNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdGhpcy5fX2NvbG9yID0gbmV3IENvbG9yKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgdGhpcy5fX3RlbXAgPSBuZXcgQ29sb3IoMCk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBkb20ubWFrZVNlbGVjdGFibGUodGhpcy5kb21FbGVtZW50LCBmYWxzZSk7XG5cbiAgICB0aGlzLl9fc2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fc2VsZWN0b3IuY2xhc3NOYW1lID0gJ3NlbGVjdG9yJztcblxuICAgIHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX3NhdHVyYXRpb25fZmllbGQuY2xhc3NOYW1lID0gJ3NhdHVyYXRpb24tZmllbGQnO1xuXG4gICAgdGhpcy5fX2ZpZWxkX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fZmllbGRfa25vYi5jbGFzc05hbWUgPSAnZmllbGQta25vYic7XG4gICAgdGhpcy5fX2ZpZWxkX2tub2JfYm9yZGVyID0gJzJweCBzb2xpZCAnO1xuXG4gICAgdGhpcy5fX2h1ZV9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2h1ZV9rbm9iLmNsYXNzTmFtZSA9ICdodWUta25vYic7XG5cbiAgICB0aGlzLl9faHVlX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2h1ZV9maWVsZC5jbGFzc05hbWUgPSAnaHVlLWZpZWxkJztcblxuICAgIHRoaXMuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5fX2lucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgdGhpcy5fX2lucHV0X3RleHRTaGFkb3cgPSAnMCAxcHggMXB4ICc7XG5cbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHsgLy8gb24gZW50ZXJcbiAgICAgICAgb25CbHVyLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19zZWxlY3RvciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgZG9tXG4gICAgICAgIC5hZGRDbGFzcyh0aGlzLCAnZHJhZycpXG4gICAgICAgIC5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fc2VsZWN0b3IsICdkcmFnJyk7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICB2YXIgdmFsdWVfZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX3NlbGVjdG9yLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEyMnB4JyxcbiAgICAgIGhlaWdodDogJzEwMnB4JyxcbiAgICAgIHBhZGRpbmc6ICczcHgnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzIyMicsXG4gICAgICBib3hTaGFkb3c6ICcwcHggMXB4IDNweCByZ2JhKDAsMCwwLDAuMyknXG4gICAgfSk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19maWVsZF9rbm9iLnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpZHRoOiAnMTJweCcsXG4gICAgICBoZWlnaHQ6ICcxMnB4JyxcbiAgICAgIGJvcmRlcjogdGhpcy5fX2ZpZWxkX2tub2JfYm9yZGVyICsgKHRoaXMuX19jb2xvci52IDwgLjUgPyAnI2ZmZicgOiAnIzAwMCcpLFxuICAgICAgYm94U2hhZG93OiAnMHB4IDFweCAzcHggcmdiYSgwLDAsMCwwLjUpJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzEycHgnLFxuICAgICAgekluZGV4OiAxXG4gICAgfSk7XG4gICAgXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9faHVlX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzJweCcsXG4gICAgICBib3JkZXJSaWdodDogJzRweCBzb2xpZCAjZmZmJyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDBweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBtYXJnaW5SaWdodDogJzNweCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgfSk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHZhbHVlX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBiYWNrZ3JvdW5kOiAnbm9uZSdcbiAgICB9KTtcbiAgICBcbiAgICBsaW5lYXJHcmFkaWVudCh2YWx1ZV9maWVsZCwgJ3RvcCcsICdyZ2JhKDAsMCwwLDApJywgJyMwMDAnKTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2h1ZV9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzEwMHB4JyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgY3Vyc29yOiAnbnMtcmVzaXplJ1xuICAgIH0pO1xuXG4gICAgaHVlR3JhZGllbnQodGhpcy5fX2h1ZV9maWVsZCk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuICAgICAgb3V0bGluZTogJ25vbmUnLFxuLy8gICAgICB3aWR0aDogJzEyMHB4JyxcbiAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4vLyAgICAgIHBhZGRpbmc6ICc0cHgnLFxuLy8gICAgICBtYXJnaW5Cb3R0b206ICc2cHgnLFxuICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgIGJvcmRlcjogMCxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIHRleHRTaGFkb3c6IHRoaXMuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoMCwwLDAsMC43KSdcbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcbiAgICBkb20uYmluZCh0aGlzLl9fZmllbGRfa25vYiwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG5cbiAgICBkb20uYmluZCh0aGlzLl9faHVlX2ZpZWxkLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgc2V0SChlKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldEgpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIHVuYmluZEgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZmllbGREb3duKGUpIHtcbiAgICAgIHNldFNWKGUpO1xuICAgICAgLy8gZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnbm9uZSc7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgdW5iaW5kU1YpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuYmluZFNWKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCB1bmJpbmRTVik7XG4gICAgICAvLyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLnZhbHVlKTtcbiAgICAgIGlmIChpICE9PSBmYWxzZSkge1xuICAgICAgICBfdGhpcy5fX2NvbG9yLl9fc3RhdGUgPSBpO1xuICAgICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlID0gX3RoaXMuX19jb2xvci50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuYmluZEgoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldEgpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgdW5iaW5kSCk7XG4gICAgfVxuXG4gICAgdGhpcy5fX3NhdHVyYXRpb25fZmllbGQuYXBwZW5kQ2hpbGQodmFsdWVfZmllbGQpO1xuICAgIHRoaXMuX19zZWxlY3Rvci5hcHBlbmRDaGlsZCh0aGlzLl9fZmllbGRfa25vYik7XG4gICAgdGhpcy5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICB0aGlzLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQodGhpcy5fX2h1ZV9maWVsZCk7XG4gICAgdGhpcy5fX2h1ZV9maWVsZC5hcHBlbmRDaGlsZCh0aGlzLl9faHVlX2tub2IpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19pbnB1dCk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19zZWxlY3Rvcik7XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIGZ1bmN0aW9uIHNldFNWKGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgdyA9IGRvbS5nZXRXaWR0aChfdGhpcy5fX3NhdHVyYXRpb25fZmllbGQpO1xuICAgICAgdmFyIG8gPSBkb20uZ2V0T2Zmc2V0KF90aGlzLl9fc2F0dXJhdGlvbl9maWVsZCk7XG4gICAgICB2YXIgcyA9IChlLmNsaWVudFggLSBvLmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpIC8gdztcbiAgICAgIHZhciB2ID0gMSAtIChlLmNsaWVudFkgLSBvLnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSAvIHc7XG5cbiAgICAgIGlmICh2ID4gMSkgdiA9IDE7XG4gICAgICBlbHNlIGlmICh2IDwgMCkgdiA9IDA7XG5cbiAgICAgIGlmIChzID4gMSkgcyA9IDE7XG4gICAgICBlbHNlIGlmIChzIDwgMCkgcyA9IDA7XG5cbiAgICAgIF90aGlzLl9fY29sb3IudiA9IHY7XG4gICAgICBfdGhpcy5fX2NvbG9yLnMgPSBzO1xuXG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG5cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SChlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIHMgPSBkb20uZ2V0SGVpZ2h0KF90aGlzLl9faHVlX2ZpZWxkKTtcbiAgICAgIHZhciBvID0gZG9tLmdldE9mZnNldChfdGhpcy5fX2h1ZV9maWVsZCk7XG4gICAgICB2YXIgaCA9IDEgLSAoZS5jbGllbnRZIC0gby50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCkgLyBzO1xuXG4gICAgICBpZiAoaCA+IDEpIGggPSAxO1xuICAgICAgZWxzZSBpZiAoaCA8IDApIGggPSAwO1xuXG4gICAgICBfdGhpcy5fX2NvbG9yLmggPSBoICogMzYwO1xuXG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICB9O1xuXG4gIENvbG9yQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBDb2xvckNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHZhciBpID0gaW50ZXJwcmV0KHRoaXMuZ2V0VmFsdWUoKSk7XG5cbiAgICAgICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgdmFyIG1pc21hdGNoID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBtaXNtYXRjaCBvbiB0aGUgaW50ZXJwcmV0ZWQgdmFsdWUuXG5cbiAgICAgICAgICAgIGNvbW1vbi5lYWNoKENvbG9yLkNPTVBPTkVOVFMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICBpZiAoIWNvbW1vbi5pc1VuZGVmaW5lZChpW2NvbXBvbmVudF0pICYmXG4gICAgICAgICAgICAgICAgICAhY29tbW9uLmlzVW5kZWZpbmVkKHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pICYmXG4gICAgICAgICAgICAgICAgICBpW2NvbXBvbmVudF0gIT09IHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pIHtcbiAgICAgICAgICAgICAgICBtaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9OyAvLyBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gSWYgbm90aGluZyBkaXZlcmdlcywgd2Uga2VlcCBvdXIgcHJldmlvdXMgdmFsdWVzXG4gICAgICAgICAgICAvLyBmb3Igc3RhdGVmdWxuZXNzLCBvdGhlcndpc2Ugd2UgcmVjYWxjdWxhdGUgZnJlc2hcbiAgICAgICAgICAgIGlmIChtaXNtYXRjaCkge1xuICAgICAgICAgICAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19jb2xvci5fX3N0YXRlLCBpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX3RlbXAuX19zdGF0ZSwgdGhpcy5fX2NvbG9yLl9fc3RhdGUpO1xuXG4gICAgICAgICAgdGhpcy5fX3RlbXAuYSA9IDE7XG5cbiAgICAgICAgICB2YXIgZmxpcCA9ICh0aGlzLl9fY29sb3IudiA8IC41IHx8IHRoaXMuX19jb2xvci5zID4gLjUpID8gMjU1IDogMDtcbiAgICAgICAgICB2YXIgX2ZsaXAgPSAyNTUgLSBmbGlwO1xuXG4gICAgICAgICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgICAgICAgbWFyZ2luTGVmdDogMTAwICogdGhpcy5fX2NvbG9yLnMgLSA3ICsgJ3B4JyxcbiAgICAgICAgICAgIG1hcmdpblRvcDogMTAwICogKDEgLSB0aGlzLl9fY29sb3IudikgLSA3ICsgJ3B4JyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX3RlbXAudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGJvcmRlcjogdGhpcy5fX2ZpZWxkX2tub2JfYm9yZGVyICsgJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsnKSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuX19odWVfa25vYi5zdHlsZS5tYXJnaW5Ub3AgPSAoMSAtIHRoaXMuX19jb2xvci5oIC8gMzYwKSAqIDEwMCArICdweCdcblxuICAgICAgICAgIHRoaXMuX190ZW1wLnMgPSAxO1xuICAgICAgICAgIHRoaXMuX190ZW1wLnYgPSAxO1xuXG4gICAgICAgICAgbGluZWFyR3JhZGllbnQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQsICdsZWZ0JywgJyNmZmYnLCB0aGlzLl9fdGVtcC50b1N0cmluZygpKTtcblxuICAgICAgICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2lucHV0LnN0eWxlLCB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuX19jb2xvci50b1N0cmluZygpLFxuICAgICAgICAgICAgY29sb3I6ICdyZ2IoJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJywnICsgZmxpcCArJyknLFxuICAgICAgICAgICAgdGV4dFNoYWRvdzogdGhpcy5fX2lucHV0X3RleHRTaGFkb3cgKyAncmdiYSgnICsgX2ZsaXAgKyAnLCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsnLC43KSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuICBcbiAgdmFyIHZlbmRvcnMgPSBbJy1tb3otJywnLW8tJywnLXdlYmtpdC0nLCctbXMtJywnJ107XG4gIFxuICBmdW5jdGlvbiBsaW5lYXJHcmFkaWVudChlbGVtLCB4LCBhLCBiKSB7XG4gICAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gICAgY29tbW9uLmVhY2godmVuZG9ycywgZnVuY3Rpb24odmVuZG9yKSB7XG4gICAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6ICcgKyB2ZW5kb3IgKyAnbGluZWFyLWdyYWRpZW50KCcreCsnLCAnK2ErJyAwJSwgJyArIGIgKyAnIDEwMCUpOyAnO1xuICAgIH0pO1xuICB9XG4gIFxuICBmdW5jdGlvbiBodWVHcmFkaWVudChlbGVtKSB7XG4gICAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCAjZmYwMGZmIDE3JSwgIzAwMDBmZiAzNCUsICMwMGZmZmYgNTAlLCAjMDBmZjAwIDY3JSwgI2ZmZmYwMCA4NCUsICNmZjAwMDAgMTAwJSk7J1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOydcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1vLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7J1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7J1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnXG4gIH1cblxuXG4gIHJldHVybiBDb2xvckNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQuY29sb3IuQ29sb3IgPSAoZnVuY3Rpb24gKGludGVycHJldCwgbWF0aCwgdG9TdHJpbmcsIGNvbW1vbikge1xuXG4gIHZhciBDb2xvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5fX3N0YXRlID0gaW50ZXJwcmV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGhpcy5fX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgJ0ZhaWxlZCB0byBpbnRlcnByZXQgY29sb3IgYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICB0aGlzLl9fc3RhdGUuYSA9IHRoaXMuX19zdGF0ZS5hIHx8IDE7XG5cblxuICB9O1xuXG4gIENvbG9yLkNPTVBPTkVOVFMgPSBbJ3InLCdnJywnYicsJ2gnLCdzJywndicsJ2hleCcsJ2EnXTtcblxuICBjb21tb24uZXh0ZW5kKENvbG9yLnByb3RvdHlwZSwge1xuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b09yaWdpbmFsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuY29udmVyc2lvbi53cml0ZSh0aGlzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3InLCAyKTtcbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2cnLCAxKTtcbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2InLCAwKTtcblxuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnaCcpO1xuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncycpO1xuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAndicpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdhJywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuYTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLl9fc3RhdGUuYSA9IHY7XG4gICAgfVxuXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdoZXgnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoIXRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hFWCcpIHtcbiAgICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IG1hdGgucmdiX3RvX2hleCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5oZXg7XG5cbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIRVgnO1xuICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IHY7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVmaW5lUkdCQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ1JHQicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICAgIH1cblxuICAgICAgICByZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgIH0sXG5cbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdSR0InKSB7XG4gICAgICAgICAgcmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG4gICAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ1JHQic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVIU1ZDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgICByZWNhbGN1bGF0ZUhTVih0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgIH0sXG5cbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIU1YnKSB7XG4gICAgICAgICAgcmVjYWxjdWxhdGVIU1YodGhpcyk7XG4gICAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hTVic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZVJHQihjb2xvciwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuXG4gICAgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIRVgnKSB7XG5cbiAgICAgIGNvbG9yLl9fc3RhdGVbY29tcG9uZW50XSA9IG1hdGguY29tcG9uZW50X2Zyb21faGV4KGNvbG9yLl9fc3RhdGUuaGV4LCBjb21wb25lbnRIZXhJbmRleCk7XG5cbiAgICB9IGVsc2UgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKSB7XG5cbiAgICAgIGNvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSwgbWF0aC5oc3ZfdG9fcmdiKGNvbG9yLl9fc3RhdGUuaCwgY29sb3IuX19zdGF0ZS5zLCBjb2xvci5fX3N0YXRlLnYpKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRocm93ICdDb3JydXB0ZWQgY29sb3Igc3RhdGUnO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZUhTVihjb2xvcikge1xuXG4gICAgdmFyIHJlc3VsdCA9IG1hdGgucmdiX3RvX2hzdihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcblxuICAgIGNvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSxcbiAgICAgICAge1xuICAgICAgICAgIHM6IHJlc3VsdC5zLFxuICAgICAgICAgIHY6IHJlc3VsdC52XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFjb21tb24uaXNOYU4ocmVzdWx0LmgpKSB7XG4gICAgICBjb2xvci5fX3N0YXRlLmggPSByZXN1bHQuaDtcbiAgICB9IGVsc2UgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5fX3N0YXRlLmgpKSB7XG4gICAgICBjb2xvci5fX3N0YXRlLmggPSAwO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIENvbG9yO1xuXG59KShkYXQuY29sb3IuaW50ZXJwcmV0LFxuZGF0LmNvbG9yLm1hdGggPSAoZnVuY3Rpb24gKCkge1xuXG4gIHZhciB0bXBDb21wb25lbnQ7XG5cbiAgcmV0dXJuIHtcblxuICAgIGhzdl90b19yZ2I6IGZ1bmN0aW9uKGgsIHMsIHYpIHtcblxuICAgICAgdmFyIGhpID0gTWF0aC5mbG9vcihoIC8gNjApICUgNjtcblxuICAgICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG4gICAgICB2YXIgcCA9IHYgKiAoMS4wIC0gcyk7XG4gICAgICB2YXIgcSA9IHYgKiAoMS4wIC0gKGYgKiBzKSk7XG4gICAgICB2YXIgdCA9IHYgKiAoMS4wIC0gKCgxLjAgLSBmKSAqIHMpKTtcbiAgICAgIHZhciBjID0gW1xuICAgICAgICBbdiwgdCwgcF0sXG4gICAgICAgIFtxLCB2LCBwXSxcbiAgICAgICAgW3AsIHYsIHRdLFxuICAgICAgICBbcCwgcSwgdl0sXG4gICAgICAgIFt0LCBwLCB2XSxcbiAgICAgICAgW3YsIHAsIHFdXG4gICAgICBdW2hpXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcjogY1swXSAqIDI1NSxcbiAgICAgICAgZzogY1sxXSAqIDI1NSxcbiAgICAgICAgYjogY1syXSAqIDI1NVxuICAgICAgfTtcblxuICAgIH0sXG5cbiAgICByZ2JfdG9faHN2OiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgICAgICBoLCBzO1xuXG4gICAgICBpZiAobWF4ICE9IDApIHtcbiAgICAgICAgcyA9IGRlbHRhIC8gbWF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBOYU4sXG4gICAgICAgICAgczogMCxcbiAgICAgICAgICB2OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChyID09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChnID09IG1heCkge1xuICAgICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuICAgICAgaCAvPSA2O1xuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaDogaCAqIDM2MCxcbiAgICAgICAgczogcyxcbiAgICAgICAgdjogbWF4IC8gMjU1XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICByZ2JfdG9faGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICB2YXIgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoMCwgMiwgcik7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDEsIGcpO1xuICAgICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAwLCBiKTtcbiAgICAgIHJldHVybiBoZXg7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24oaGV4LCBjb21wb25lbnRJbmRleCkge1xuICAgICAgcmV0dXJuIChoZXggPj4gKGNvbXBvbmVudEluZGV4ICogOCkpICYgMHhGRjtcbiAgICB9LFxuXG4gICAgaGV4X3dpdGhfY29tcG9uZW50OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIDw8ICh0bXBDb21wb25lbnQgPSBjb21wb25lbnRJbmRleCAqIDgpIHwgKGhleCAmIH4gKDB4RkYgPDwgdG1wQ29tcG9uZW50KSk7XG4gICAgfVxuXG4gIH1cblxufSkoKSxcbmRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbG9yLmludGVycHJldCxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIHJlcXVpcmVqcyB2ZXJzaW9uIG9mIFBhdWwgSXJpc2gncyBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICogaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbiAgICovXG5cbiAgcmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG5cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG5cbiAgICAgIH07XG59KSgpLFxuZGF0LmRvbS5DZW50ZXJlZERpdiA9IChmdW5jdGlvbiAoZG9tLCBjb21tb24pIHtcblxuXG4gIHZhciBDZW50ZXJlZERpdiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbW1vbi5leHRlbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZSwge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAwJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcblxuICAgIGRvbS5tYWtlRnVsbHNjcmVlbih0aGlzLmJhY2tncm91bmRFbGVtZW50KTtcbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcblxuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbW1vbi5leHRlbmQodGhpcy5kb21FbGVtZW50LnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIHpJbmRleDogJzEwMDEnLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICctd2Via2l0LXRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuXG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZG9tLmJpbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5oaWRlKCk7XG4gICAgfSk7XG5cblxuICB9O1xuXG4gIENlbnRlcmVkRGl2LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIFxuXG5cbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbi8vICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSAnNTIlJztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuXG4gICAgdGhpcy5sYXlvdXQoKTtcblxuICAgIGNvbW1vbi5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICB9KTtcblxuICB9O1xuXG4gIENlbnRlcmVkRGl2LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGhpZGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcblxuICAgIH07XG5cbiAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuLy8gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9ICc0OCUnO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuXG4gIH07XG5cbiAgQ2VudGVyZWREaXYucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5sZWZ0ID0gd2luZG93LmlubmVyV2lkdGgvMiAtIGRvbS5nZXRXaWR0aCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9IHdpbmRvdy5pbm5lckhlaWdodC8yIC0gZG9tLmdldEhlaWdodCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gIH07XG4gIFxuICBmdW5jdGlvbiBsb2NrU2Nyb2xsKGUpIHtcbiAgICBjb25zb2xlLmxvZyhlKTtcbiAgfVxuXG4gIHJldHVybiBDZW50ZXJlZERpdjtcblxufSkoZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7IiwiLypcblx0UmFjdGl2ZS5qcyB2MC43LjNcblx0U2F0IEFwciAyNSAyMDE1IDEzOjUyOjM4IEdNVC0wNDAwIChFRFQpIC0gY29tbWl0IGRhNDBmODFjNjYwYmEyZjA5YzQ1YTA5YTljMjBmZGQzNGVlMzZkODBcblxuXHRodHRwOi8vcmFjdGl2ZWpzLm9yZ1xuXHRodHRwOi8vdHdpdHRlci5jb20vUmFjdGl2ZUpTXG5cblx0UmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICBnbG9iYWwuUmFjdGl2ZSA9IGZhY3RvcnkoKVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgVEVNUExBVEVfVkVSU0lPTiA9IDM7XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXG4gIFx0Ly8gcmVuZGVyIHBsYWNlbWVudDpcbiAgXHRlbDogdm9pZCAwLFxuICBcdGFwcGVuZDogZmFsc2UsXG5cbiAgXHQvLyB0ZW1wbGF0ZTpcbiAgXHR0ZW1wbGF0ZTogeyB2OiBURU1QTEFURV9WRVJTSU9OLCB0OiBbXSB9LFxuXG4gIFx0Ly8gcGFyc2U6ICAgICAvLyBUT0RPIHN0YXRpYyBkZWxpbWl0ZXJzP1xuICBcdHByZXNlcnZlV2hpdGVzcGFjZTogZmFsc2UsXG4gIFx0c2FuaXRpemU6IGZhbHNlLFxuICBcdHN0cmlwQ29tbWVudHM6IHRydWUsXG4gIFx0ZGVsaW1pdGVyczogW1wie3tcIiwgXCJ9fVwiXSxcbiAgXHR0cmlwbGVEZWxpbWl0ZXJzOiBbXCJ7e3tcIiwgXCJ9fX1cIl0sXG4gIFx0aW50ZXJwb2xhdGU6IGZhbHNlLFxuXG4gIFx0Ly8gZGF0YSAmIGJpbmRpbmc6XG4gIFx0ZGF0YToge30sXG4gIFx0Y29tcHV0ZWQ6IHt9LFxuICBcdG1hZ2ljOiBmYWxzZSxcbiAgXHRtb2RpZnlBcnJheXM6IHRydWUsXG4gIFx0YWRhcHQ6IFtdLFxuICBcdGlzb2xhdGVkOiBmYWxzZSxcbiAgXHR0d293YXk6IHRydWUsXG4gIFx0bGF6eTogZmFsc2UsXG5cbiAgXHQvLyB0cmFuc2l0aW9uczpcbiAgXHRub0ludHJvOiBmYWxzZSxcbiAgXHR0cmFuc2l0aW9uc0VuYWJsZWQ6IHRydWUsXG4gIFx0Y29tcGxldGU6IHZvaWQgMCxcblxuICBcdC8vIGNzczpcbiAgXHRjc3M6IG51bGwsXG4gIFx0bm9Dc3NUcmFuc2Zvcm06IGZhbHNlXG4gIH07XG5cbiAgdmFyIGNvbmZpZ19kZWZhdWx0cyA9IGRlZmF1bHRPcHRpb25zO1xuXG4gIC8vIFRoZXNlIGFyZSBhIHN1YnNldCBvZiB0aGUgZWFzaW5nIGVxdWF0aW9ucyBmb3VuZCBhdFxuICAvLyBodHRwczovL3Jhdy5naXRodWIuY29tL2RhbnJvL2Vhc2luZy1qcyAtIGxpY2Vuc2UgaW5mb1xuICAvLyBmb2xsb3dzOlxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGVhc2luZy5qcyB2MC41LjRcbiAgLy8gR2VuZXJpYyBzZXQgb2YgZWFzaW5nIGZ1bmN0aW9ucyB3aXRoIEFNRCBzdXBwb3J0XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5yby9lYXNpbmctanNcbiAgLy8gVGhpcyBjb2RlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gIC8vIGh0dHA6Ly9kYW5yby5taXQtbGljZW5zZS5vcmcvXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEFsbCBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFRob21hcyBGdWNocyAmIEplcmVteSBLYWhuXG4gIC8vIEVhc2luZyBFcXVhdGlvbnMgKGMpIDIwMDMgUm9iZXJ0IFBlbm5lciwgQlNEIGxpY2Vuc2VcbiAgLy8gaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9kYW5yby9lYXNpbmctanMvbWFzdGVyL0xJQ0VOU0VcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBJbiB0aGF0IGxpYnJhcnksIHRoZSBmdW5jdGlvbnMgbmFtZWQgZWFzZUluLCBlYXNlT3V0LCBhbmRcbiAgLy8gZWFzZUluT3V0IGJlbG93IGFyZSBuYW1lZCBlYXNlSW5DdWJpYywgZWFzZU91dEN1YmljLCBhbmRcbiAgLy8gKHlvdSBndWVzc2VkIGl0KSBlYXNlSW5PdXRDdWJpYy5cbiAgLy9cbiAgLy8gWW91IGNhbiBhZGQgYWRkaXRpb25hbCBlYXNpbmcgZnVuY3Rpb25zIHRvIHRoaXMgbGlzdCwgYW5kIHRoZXlcbiAgLy8gd2lsbCBiZSBnbG9iYWxseSBhdmFpbGFibGUuXG5cbiAgdmFyIHN0YXRpY19lYXNpbmcgPSB7XG4gIFx0bGluZWFyOiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRyZXR1cm4gcG9zO1xuICBcdH0sXG4gIFx0ZWFzZUluOiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRyZXR1cm4gTWF0aC5wb3cocG9zLCAzKTtcbiAgXHR9LFxuICBcdGVhc2VPdXQ6IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdHJldHVybiBNYXRoLnBvdyhwb3MgLSAxLCAzKSArIDE7XG4gIFx0fSxcbiAgXHRlYXNlSW5PdXQ6IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdGlmICgocG9zIC89IDAuNSkgPCAxKSB7XG4gIFx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdyhwb3MsIDMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIDAuNSAqIChNYXRoLnBvdyhwb3MgLSAyLCAzKSArIDIpO1xuICBcdH1cbiAgfTtcblxuICAvKmdsb2JhbCBjb25zb2xlLCBuYXZpZ2F0b3IgKi9cbiAgdmFyIGlzQ2xpZW50LCBpc0pzZG9tLCBoYXNDb25zb2xlLCBlbnZpcm9ubWVudF9fbWFnaWMsIG5hbWVzcGFjZXMsIHN2ZywgdmVuZG9ycztcblxuICBpc0NsaWVudCA9IHR5cGVvZiBkb2N1bWVudCA9PT0gXCJvYmplY3RcIjtcblxuICBpc0pzZG9tID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvanNEb20vLnRlc3QobmF2aWdhdG9yLmFwcE5hbWUpO1xuXG4gIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGNvbnNvbGUud2Fybi5hcHBseSA9PT0gXCJmdW5jdGlvblwiO1xuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInRlc3RcIiwgeyB2YWx1ZTogMCB9KTtcbiAgXHRlbnZpcm9ubWVudF9fbWFnaWMgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gIFx0ZW52aXJvbm1lbnRfX21hZ2ljID0gZmFsc2U7XG4gIH1cblxuICBuYW1lc3BhY2VzID0ge1xuICBcdGh0bWw6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFxuICBcdG1hdGhtbDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsXG4gIFx0c3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIFx0eGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICBcdHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgXHR4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBcdHN2ZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICBcdHN2ZyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlXCIsIFwiMS4xXCIpO1xuICB9XG5cbiAgdmVuZG9ycyA9IFtcIm9cIiwgXCJtc1wiLCBcIm1velwiLCBcIndlYmtpdFwiXTtcblxuICB2YXIgY3JlYXRlRWxlbWVudCwgbWF0Y2hlcywgZG9tX19kaXYsIG1ldGhvZE5hbWVzLCB1bnByZWZpeGVkLCBwcmVmaXhlZCwgZG9tX19pLCBqLCBtYWtlRnVuY3Rpb247XG5cbiAgLy8gVGVzdCBmb3IgU1ZHIHN1cHBvcnRcbiAgaWYgKCFzdmcpIHtcbiAgXHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIG5zKSB7XG4gIFx0XHRpZiAobnMgJiYgbnMgIT09IG5hbWVzcGFjZXMuaHRtbCkge1xuICBcdFx0XHR0aHJvdyBcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG5hbWVzcGFjZXMgb3RoZXIgdGhhbiBodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sLiBUaGUgbW9zdCBsaWtlbHkgY2F1c2Ugb2YgdGhpcyBlcnJvciBpcyB0aGF0IHlvdSdyZSB0cnlpbmcgdG8gcmVuZGVyIFNWRyBpbiBhbiBvbGRlciBicm93c2VyLiBTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3Qvc3ZnLWFuZC1vbGRlci1icm93c2VycyBmb3IgbW9yZSBpbmZvcm1hdGlvblwiO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgXHR9O1xuICB9IGVsc2Uge1xuICBcdGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgbnMpIHtcbiAgXHRcdGlmICghbnMgfHwgbnMgPT09IG5hbWVzcGFjZXMuaHRtbCkge1xuICBcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgdHlwZSk7XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnQoaW5wdXQpIHtcbiAgXHR2YXIgb3V0cHV0O1xuXG4gIFx0aWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgPT09IFwiYm9vbGVhblwiKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgIWRvY3VtZW50IHx8ICFpbnB1dCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gV2UgYWxyZWFkeSBoYXZlIGEgRE9NIG5vZGUgLSBubyB3b3JrIHRvIGRvLiAoRHVjayB0eXBpbmcgYWxlcnQhKVxuICBcdGlmIChpbnB1dC5ub2RlVHlwZSkge1xuICBcdFx0cmV0dXJuIGlucHV0O1xuICBcdH1cblxuICBcdC8vIEdldCBub2RlIGZyb20gc3RyaW5nXG4gIFx0aWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0Ly8gdHJ5IElEIGZpcnN0XG4gIFx0XHRvdXRwdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpbnB1dCk7XG5cbiAgXHRcdC8vIHRoZW4gYXMgc2VsZWN0b3IsIGlmIHBvc3NpYmxlXG4gIFx0XHRpZiAoIW91dHB1dCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XG4gIFx0XHRcdG91dHB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaW5wdXQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBkaWQgaXQgd29yaz9cbiAgXHRcdGlmIChvdXRwdXQgJiYgb3V0cHV0Lm5vZGVUeXBlKSB7XG4gIFx0XHRcdHJldHVybiBvdXRwdXQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSWYgd2UndmUgYmVlbiBnaXZlbiBhIGNvbGxlY3Rpb24gKGpRdWVyeSwgWmVwdG8gZXRjKSwgZXh0cmFjdCB0aGUgZmlyc3QgaXRlbVxuICBcdGlmIChpbnB1dFswXSAmJiBpbnB1dFswXS5ub2RlVHlwZSkge1xuICBcdFx0cmV0dXJuIGlucHV0WzBdO1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdG1hdGNoZXMgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdGRvbV9fZGl2ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgXHRtZXRob2ROYW1lcyA9IFtcIm1hdGNoZXNcIiwgXCJtYXRjaGVzU2VsZWN0b3JcIl07XG5cbiAgXHRtYWtlRnVuY3Rpb24gPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICBcdFx0cmV0dXJuIGZ1bmN0aW9uIChub2RlLCBzZWxlY3Rvcikge1xuICBcdFx0XHRyZXR1cm4gbm9kZVttZXRob2ROYW1lXShzZWxlY3Rvcik7XG4gIFx0XHR9O1xuICBcdH07XG5cbiAgXHRkb21fX2kgPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoZG9tX19pLS0gJiYgIW1hdGNoZXMpIHtcbiAgXHRcdHVucHJlZml4ZWQgPSBtZXRob2ROYW1lc1tkb21fX2ldO1xuXG4gIFx0XHRpZiAoZG9tX19kaXZbdW5wcmVmaXhlZF0pIHtcbiAgXHRcdFx0bWF0Y2hlcyA9IG1ha2VGdW5jdGlvbih1bnByZWZpeGVkKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGogPSB2ZW5kb3JzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGotLSkge1xuICBcdFx0XHRcdHByZWZpeGVkID0gdmVuZG9yc1tkb21fX2ldICsgdW5wcmVmaXhlZC5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIHVucHJlZml4ZWQuc3Vic3RyaW5nKDEpO1xuXG4gIFx0XHRcdFx0aWYgKGRvbV9fZGl2W3ByZWZpeGVkXSkge1xuICBcdFx0XHRcdFx0bWF0Y2hlcyA9IG1ha2VGdW5jdGlvbihwcmVmaXhlZCk7XG4gIFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJRTguLi5cbiAgXHRpZiAoIW1hdGNoZXMpIHtcbiAgXHRcdG1hdGNoZXMgPSBmdW5jdGlvbiAobm9kZSwgc2VsZWN0b3IpIHtcbiAgXHRcdFx0dmFyIG5vZGVzLCBwYXJlbnROb2RlLCBpO1xuXG4gIFx0XHRcdHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cbiAgXHRcdFx0aWYgKCFwYXJlbnROb2RlKSB7XG4gIFx0XHRcdFx0Ly8gZW1wdHkgZHVtbXkgPGRpdj5cbiAgXHRcdFx0XHRkb21fX2Rpdi5pbm5lckhUTUwgPSBcIlwiO1xuXG4gIFx0XHRcdFx0cGFyZW50Tm9kZSA9IGRvbV9fZGl2O1xuICBcdFx0XHRcdG5vZGUgPSBub2RlLmNsb25lTm9kZSgpO1xuXG4gIFx0XHRcdFx0ZG9tX19kaXYuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRub2RlcyA9IHBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cbiAgXHRcdFx0aSA9IG5vZGVzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGlmIChub2Rlc1tpXSA9PT0gbm9kZSkge1xuICBcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hOb2RlKG5vZGUpIHtcbiAgXHRpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZS5wYXJlbnROb2RlICE9PSBcInVua25vd25cIiAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgXHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVUb1N0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gIFx0cmV0dXJuIHZhbHVlID09IG51bGwgfHwgIXZhbHVlLnRvU3RyaW5nID8gXCJcIiA6IHZhbHVlO1xuICB9XG5cbiAgdmFyIGxlZ2FjeSA9IG51bGw7XG5cbiAgdmFyIGNyZWF0ZSwgZGVmaW5lUHJvcGVydHksIGRlZmluZVByb3BlcnRpZXM7XG5cbiAgdHJ5IHtcbiAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwidGVzdFwiLCB7IHZhbHVlOiAwIH0pO1xuXG4gIFx0aWYgKGlzQ2xpZW50KSB7XG4gIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgXCJ0ZXN0XCIsIHsgdmFsdWU6IDAgfSk7XG4gIFx0fVxuXG4gIFx0ZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBkb2Vzbid0IGV4aXN0LCBvciB3ZSdyZSBpbiBJRTggd2hlcmUgeW91IGNhblxuICBcdC8vIG9ubHkgdXNlIGl0IHdpdGggRE9NIG9iamVjdHMgKHdoYXQgd2VyZSB5b3Ugc21va2luZywgTVNGVD8pXG4gIFx0ZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBkZXNjKSB7XG4gIFx0XHRvYmpbcHJvcF0gPSBkZXNjLnZhbHVlO1xuICBcdH07XG4gIH1cblxuICB0cnkge1xuICBcdHRyeSB7XG4gIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwgeyB0ZXN0OiB7IHZhbHVlOiAwIH0gfSk7XG4gIFx0fSBjYXRjaCAoZXJyKSB7XG4gIFx0XHQvLyBUT0RPIGhvdyBkbyB3ZSBhY2NvdW50IGZvciB0aGlzPyBub01hZ2ljID0gdHJ1ZTtcbiAgXHRcdHRocm93IGVycjtcbiAgXHR9XG5cbiAgXHRpZiAoaXNDbGllbnQpIHtcbiAgXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHsgdGVzdDogeyB2YWx1ZTogMCB9IH0pO1xuICBcdH1cblxuICBcdGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIFx0ZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIHByb3BzKSB7XG4gIFx0XHR2YXIgcHJvcDtcblxuICBcdFx0Zm9yIChwcm9wIGluIHByb3BzKSB7XG4gIFx0XHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICBcdFx0XHRcdGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgcHJvcHNbcHJvcF0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBcdGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdC8vIHNpZ2hcbiAgXHRjcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bywgcHJvcHMpIHtcbiAgXHRcdFx0dmFyIG9iajtcblxuICBcdFx0XHRpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgXHRcdFx0XHRyZXR1cm4ge307XG4gIFx0XHRcdH1cblxuICBcdFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xuICBcdFx0XHRvYmogPSBuZXcgRigpO1xuXG4gIFx0XHRcdGlmIChwcm9wcykge1xuICBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwgcHJvcHMpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIG9iajtcbiAgXHRcdH07XG4gIFx0fSkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0aWxzX29iamVjdF9fZXh0ZW5kKHRhcmdldCkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0c291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0dmFyIHByb3AsIHNvdXJjZTtcblxuICBcdHdoaWxlIChzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCkpIHtcbiAgXHRcdGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgXHRcdFx0aWYgKGhhc093bi5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgXHRcdFx0XHR0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsbEdhcHModGFyZ2V0KSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgXHRcdGZvciAodmFyIGtleSBpbiBzKSB7XG4gIFx0XHRcdGlmIChzLmhhc093blByb3BlcnR5KGtleSkgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICBcdFx0XHRcdHRhcmdldFtrZXldID0gc1trZXldO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gdGhhbmtzLCBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9pbnN0YW5jZW9mLWNvbnNpZGVyZWQtaGFybWZ1bC1vci1ob3ctdG8td3JpdGUtYS1yb2J1c3QtaXNhcnJheS9cbiAgdmFyIGlzX190b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICBhcnJheUxpa2VQYXR0ZXJuID0gL15cXFtvYmplY3QgKD86QXJyYXl8RmlsZUxpc3QpXFxdJC87XG4gIGZ1bmN0aW9uIGlzQXJyYXkodGhpbmcpIHtcbiAgXHRyZXR1cm4gaXNfX3RvU3RyaW5nLmNhbGwodGhpbmcpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcbiAgXHRyZXR1cm4gYXJyYXlMaWtlUGF0dGVybi50ZXN0KGlzX190b1N0cmluZy5jYWxsKG9iaikpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIFx0aWYgKGEgPT09IG51bGwgJiYgYiA9PT0gbnVsbCkge1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBiID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGEgPT09IGI7XG4gIH1cblxuICBmdW5jdGlvbiBpc19faXNOdW1lcmljKHRoaW5nKSB7XG4gIFx0cmV0dXJuICFpc05hTihwYXJzZUZsb2F0KHRoaW5nKSkgJiYgaXNGaW5pdGUodGhpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcbiAgXHRyZXR1cm4gdGhpbmcgJiYgaXNfX3RvU3RyaW5nLmNhbGwodGhpbmcpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuICB9XG5cbiAgdmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAvKiBnbG9iYWwgY29uc29sZSAqL1xuICB2YXIgYWxyZWFkeVdhcm5lZCA9IHt9LFxuICAgICAgbG9nLFxuICAgICAgcHJpbnRXYXJuaW5nLFxuICAgICAgd2VsY29tZTtcblxuICBpZiAoaGFzQ29uc29sZSkge1xuICBcdChmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgd2VsY29tZUludHJvID0gW1wiJWNSYWN0aXZlLmpzICVjMC43LjMgJWNpbiBkZWJ1ZyBtb2RlLCAlY21vcmUuLi5cIiwgXCJjb2xvcjogcmdiKDExNCwgMTU3LCA1Mik7IGZvbnQtd2VpZ2h0OiBub3JtYWw7XCIsIFwiY29sb3I6IHJnYig4NSwgODUsIDg1KTsgZm9udC13ZWlnaHQ6IG5vcm1hbDtcIiwgXCJjb2xvcjogcmdiKDg1LCA4NSwgODUpOyBmb250LXdlaWdodDogbm9ybWFsO1wiLCBcImNvbG9yOiByZ2IoODIsIDE0MCwgMjI0KTsgZm9udC13ZWlnaHQ6IG5vcm1hbDsgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XCJdO1xuICBcdFx0dmFyIHdlbGNvbWVNZXNzYWdlID0gXCJZb3UncmUgcnVubmluZyBSYWN0aXZlIDAuNy4zIGluIGRlYnVnIG1vZGUgLSBtZXNzYWdlcyB3aWxsIGJlIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUgdG8gaGVscCB5b3UgZml4IHByb2JsZW1zIGFuZCBvcHRpbWlzZSB5b3VyIGFwcGxpY2F0aW9uLlxcblxcblRvIGRpc2FibGUgZGVidWcgbW9kZSwgYWRkIHRoaXMgbGluZSBhdCB0aGUgc3RhcnQgb2YgeW91ciBhcHA6XFxuICBSYWN0aXZlLkRFQlVHID0gZmFsc2U7XFxuXFxuVG8gZGlzYWJsZSBkZWJ1ZyBtb2RlIHdoZW4geW91ciBhcHAgaXMgbWluaWZpZWQsIGFkZCB0aGlzIHNuaXBwZXQ6XFxuICBSYWN0aXZlLkRFQlVHID0gL3VubWluaWZpZWQvLnRlc3QoZnVuY3Rpb24oKXsvKnVubWluaWZpZWQqL30pO1xcblxcbkdldCBoZWxwIGFuZCBzdXBwb3J0OlxcbiAgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZ1xcbiAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy90YWdnZWQvcmFjdGl2ZWpzXFxuICBodHRwOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyFmb3J1bS9yYWN0aXZlLWpzXFxuICBodHRwOi8vdHdpdHRlci5jb20vcmFjdGl2ZWpzXFxuXFxuRm91bmQgYSBidWc/IFJhaXNlIGFuIGlzc3VlOlxcbiAgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlc1xcblxcblwiO1xuXG4gIFx0XHR3ZWxjb21lID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgaGFzR3JvdXAgPSAhIWNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gIFx0XHRcdGNvbnNvbGVbaGFzR3JvdXAgPyBcImdyb3VwQ29sbGFwc2VkXCIgOiBcImxvZ1wiXS5hcHBseShjb25zb2xlLCB3ZWxjb21lSW50cm8pO1xuICBcdFx0XHRjb25zb2xlLmxvZyh3ZWxjb21lTWVzc2FnZSk7XG4gIFx0XHRcdGlmIChoYXNHcm91cCkge1xuICBcdFx0XHRcdGNvbnNvbGUuZ3JvdXBFbmQod2VsY29tZUludHJvKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHdlbGNvbWUgPSBub29wO1xuICBcdFx0fTtcblxuICBcdFx0cHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgXHRcdFx0d2VsY29tZSgpO1xuXG4gIFx0XHRcdC8vIGV4dHJhY3QgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGluc3RhbmNlIHRoaXMgbWVzc2FnZSBwZXJ0YWlucyB0bywgaWYgYXBwbGljYWJsZVxuICBcdFx0XHRpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0XHRcdHZhciBvcHRpb25zID0gYXJncy5wb3AoKTtcbiAgXHRcdFx0XHR2YXIgcmFjdGl2ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnJhY3RpdmUgOiBudWxsO1xuXG4gIFx0XHRcdFx0aWYgKHJhY3RpdmUpIHtcbiAgXHRcdFx0XHRcdC8vIGlmIHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgdGhhdCB3ZSBrbm93IHRoZSBuYW1lIG9mLCBhZGRcbiAgXHRcdFx0XHRcdC8vIGl0IHRvIHRoZSBtZXNzYWdlXG4gIFx0XHRcdFx0XHR2YXIgX25hbWUgPSB1bmRlZmluZWQ7XG4gIFx0XHRcdFx0XHRpZiAocmFjdGl2ZS5jb21wb25lbnQgJiYgKF9uYW1lID0gcmFjdGl2ZS5jb21wb25lbnQubmFtZSkpIHtcbiAgXHRcdFx0XHRcdFx0bWVzc2FnZSA9IFwiPFwiICsgX25hbWUgKyBcIj4gXCIgKyBtZXNzYWdlO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHR2YXIgbm9kZSA9IHVuZGVmaW5lZDtcbiAgXHRcdFx0XHRcdGlmIChub2RlID0gb3B0aW9ucy5ub2RlIHx8IHJhY3RpdmUuZnJhZ21lbnQgJiYgcmFjdGl2ZS5mcmFnbWVudC5yZW5kZXJlZCAmJiByYWN0aXZlLmZpbmQoXCIqXCIpKSB7XG4gIFx0XHRcdFx0XHRcdGFyZ3MucHVzaChub2RlKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgW1wiJWNSYWN0aXZlLmpzOiAlY1wiICsgbWVzc2FnZSwgXCJjb2xvcjogcmdiKDExNCwgMTU3LCA1Mik7XCIsIFwiY29sb3I6IHJnYig4NSwgODUsIDg1KTtcIl0uY29uY2F0KGFyZ3MpKTtcbiAgXHRcdH07XG5cbiAgXHRcdGxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0Y29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgXHRcdH07XG4gIFx0fSkoKTtcbiAgfSBlbHNlIHtcbiAgXHRwcmludFdhcm5pbmcgPSBsb2cgPSB3ZWxjb21lID0gbm9vcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdChtZXNzYWdlLCBhcmdzKSB7XG4gIFx0cmV0dXJuIG1lc3NhZ2UucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGFyZ3Muc2hpZnQoKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhdGFsKG1lc3NhZ2UpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdG1lc3NhZ2UgPSBmb3JtYXQobWVzc2FnZSwgYXJncyk7XG4gIFx0dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9nSWZEZWJ1ZygpIHtcbiAgXHRpZiAoX1JhY3RpdmUuREVCVUcpIHtcbiAgXHRcdGxvZy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4obWVzc2FnZSkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0YXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0bWVzc2FnZSA9IGZvcm1hdChtZXNzYWdlLCBhcmdzKTtcbiAgXHRwcmludFdhcm5pbmcobWVzc2FnZSwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuT25jZShtZXNzYWdlKSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRtZXNzYWdlID0gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpO1xuXG4gIFx0aWYgKGFscmVhZHlXYXJuZWRbbWVzc2FnZV0pIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRhbHJlYWR5V2FybmVkW21lc3NhZ2VdID0gdHJ1ZTtcbiAgXHRwcmludFdhcm5pbmcobWVzc2FnZSwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuSWZEZWJ1ZygpIHtcbiAgXHRpZiAoX1JhY3RpdmUuREVCVUcpIHtcbiAgXHRcdHdhcm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuT25jZUlmRGVidWcoKSB7XG4gIFx0aWYgKF9SYWN0aXZlLkRFQlVHKSB7XG4gIFx0XHR3YXJuT25jZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICBcdH1cbiAgfVxuXG4gIC8vIEVycm9yIG1lc3NhZ2VzIHRoYXQgYXJlIHVzZWQgKG9yIGNvdWxkIGJlKSBpbiBtdWx0aXBsZSBwbGFjZXNcbiAgdmFyIGJhZEFyZ3VtZW50cyA9IFwiQmFkIGFyZ3VtZW50c1wiO1xuICB2YXIgbm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuID0gXCJBIGZ1bmN0aW9uIHdhcyBzcGVjaWZpZWQgZm9yIFxcXCIlc1xcXCIgJXMsIGJ1dCBubyAlcyB3YXMgcmV0dXJuZWRcIjtcbiAgdmFyIG1pc3NpbmdQbHVnaW4gPSBmdW5jdGlvbiAobmFtZSwgdHlwZSkge1xuICAgIHJldHVybiBcIk1pc3NpbmcgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBcIiArIHR5cGUgKyBcIiBwbHVnaW4uIFlvdSBtYXkgbmVlZCB0byBkb3dubG9hZCBhIHBsdWdpbiB2aWEgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvcGx1Z2lucyNcIiArIHR5cGUgKyBcInNcIjtcbiAgfTtcblxuICBmdW5jdGlvbiBmaW5kSW5WaWV3SGllcmFyY2h5KHJlZ2lzdHJ5TmFtZSwgcmFjdGl2ZSwgbmFtZSkge1xuICBcdHZhciBpbnN0YW5jZSA9IGZpbmRJbnN0YW5jZShyZWdpc3RyeU5hbWUsIHJhY3RpdmUsIG5hbWUpO1xuICBcdHJldHVybiBpbnN0YW5jZSA/IGluc3RhbmNlW3JlZ2lzdHJ5TmFtZV1bbmFtZV0gOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEluc3RhbmNlKHJlZ2lzdHJ5TmFtZSwgcmFjdGl2ZSwgbmFtZSkge1xuICBcdHdoaWxlIChyYWN0aXZlKSB7XG4gIFx0XHRpZiAobmFtZSBpbiByYWN0aXZlW3JlZ2lzdHJ5TmFtZV0pIHtcbiAgXHRcdFx0cmV0dXJuIHJhY3RpdmU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChyYWN0aXZlLmlzb2xhdGVkKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyYWN0aXZlID0gcmFjdGl2ZS5wYXJlbnQ7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCByYWN0aXZlLCB0eXBlKSB7XG4gIFx0aWYgKGZyb20gPT09IHRvKSB7XG4gIFx0XHRyZXR1cm4gc25hcCh0byk7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGUpIHtcblxuICBcdFx0dmFyIGludGVycG9sID0gZmluZEluVmlld0hpZXJhcmNoeShcImludGVycG9sYXRvcnNcIiwgcmFjdGl2ZSwgdHlwZSk7XG4gIFx0XHRpZiAoaW50ZXJwb2wpIHtcbiAgXHRcdFx0cmV0dXJuIGludGVycG9sKGZyb20sIHRvKSB8fCBzbmFwKHRvKTtcbiAgXHRcdH1cblxuICBcdFx0ZmF0YWwobWlzc2luZ1BsdWdpbih0eXBlLCBcImludGVycG9sYXRvclwiKSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0YXRpY19pbnRlcnBvbGF0b3JzLm51bWJlcihmcm9tLCB0bykgfHwgc3RhdGljX2ludGVycG9sYXRvcnMuYXJyYXkoZnJvbSwgdG8pIHx8IHN0YXRpY19pbnRlcnBvbGF0b3JzLm9iamVjdChmcm9tLCB0bykgfHwgc25hcCh0byk7XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xuXG4gIGZ1bmN0aW9uIHNuYXAodG8pIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRvO1xuICBcdH07XG4gIH1cblxuICB2YXIgaW50ZXJwb2xhdG9ycyA9IHtcbiAgXHRudW1iZXI6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICBcdFx0dmFyIGRlbHRhO1xuXG4gIFx0XHRpZiAoIWlzX19pc051bWVyaWMoZnJvbSkgfHwgIWlzX19pc051bWVyaWModG8pKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRmcm9tID0gK2Zyb207XG4gIFx0XHR0byA9ICt0bztcblxuICBcdFx0ZGVsdGEgPSB0byAtIGZyb207XG5cbiAgXHRcdGlmICghZGVsdGEpIHtcbiAgXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZnJvbTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHJldHVybiBmcm9tICsgdCAqIGRlbHRhO1xuICBcdFx0fTtcbiAgXHR9LFxuXG4gIFx0YXJyYXk6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICBcdFx0dmFyIGludGVybWVkaWF0ZSwgaW50ZXJwb2xhdG9ycywgbGVuLCBpO1xuXG4gIFx0XHRpZiAoIWlzQXJyYXkoZnJvbSkgfHwgIWlzQXJyYXkodG8pKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpbnRlcm1lZGlhdGUgPSBbXTtcbiAgXHRcdGludGVycG9sYXRvcnMgPSBbXTtcblxuICBcdFx0aSA9IGxlbiA9IE1hdGgubWluKGZyb20ubGVuZ3RoLCB0by5sZW5ndGgpO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpbnRlcnBvbGF0b3JzW2ldID0gc2hhcmVkX2ludGVycG9sYXRlKGZyb21baV0sIHRvW2ldKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3VycGx1cyB2YWx1ZXMgLSBkb24ndCBpbnRlcnBvbGF0ZSwgYnV0IGRvbid0IGV4Y2x1ZGUgdGhlbSBlaXRoZXJcbiAgXHRcdGZvciAoaSA9IGxlbjsgaSA8IGZyb20ubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0aW50ZXJtZWRpYXRlW2ldID0gZnJvbVtpXTtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChpID0gbGVuOyBpIDwgdG8ubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0aW50ZXJtZWRpYXRlW2ldID0gdG9baV07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAodCkge1xuICBcdFx0XHR2YXIgaSA9IGxlbjtcblxuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0aW50ZXJtZWRpYXRlW2ldID0gaW50ZXJwb2xhdG9yc1tpXSh0KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG4gIFx0XHR9O1xuICBcdH0sXG5cbiAgXHRvYmplY3Q6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICBcdFx0dmFyIHByb3BlcnRpZXMsIGxlbiwgaW50ZXJwb2xhdG9ycywgaW50ZXJtZWRpYXRlLCBwcm9wO1xuXG4gIFx0XHRpZiAoIWlzT2JqZWN0KGZyb20pIHx8ICFpc09iamVjdCh0bykpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHByb3BlcnRpZXMgPSBbXTtcbiAgXHRcdGludGVybWVkaWF0ZSA9IHt9O1xuICBcdFx0aW50ZXJwb2xhdG9ycyA9IHt9O1xuXG4gIFx0XHRmb3IgKHByb3AgaW4gZnJvbSkge1xuICBcdFx0XHRpZiAoaGFzT3duLmNhbGwoZnJvbSwgcHJvcCkpIHtcbiAgXHRcdFx0XHRpZiAoaGFzT3duLmNhbGwodG8sIHByb3ApKSB7XG4gIFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gIFx0XHRcdFx0XHRpbnRlcnBvbGF0b3JzW3Byb3BdID0gc2hhcmVkX2ludGVycG9sYXRlKGZyb21bcHJvcF0sIHRvW3Byb3BdKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0aW50ZXJtZWRpYXRlW3Byb3BdID0gZnJvbVtwcm9wXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Zm9yIChwcm9wIGluIHRvKSB7XG4gIFx0XHRcdGlmIChoYXNPd24uY2FsbCh0bywgcHJvcCkgJiYgIWhhc093bi5jYWxsKGZyb20sIHByb3ApKSB7XG4gIFx0XHRcdFx0aW50ZXJtZWRpYXRlW3Byb3BdID0gdG9bcHJvcF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bGVuID0gcHJvcGVydGllcy5sZW5ndGg7XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAodCkge1xuICBcdFx0XHR2YXIgaSA9IGxlbixcbiAgXHRcdFx0ICAgIHByb3A7XG5cbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xuXG4gIFx0XHRcdFx0aW50ZXJtZWRpYXRlW3Byb3BdID0gaW50ZXJwb2xhdG9yc1twcm9wXSh0KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG4gIFx0XHR9O1xuICBcdH1cbiAgfTtcblxuICB2YXIgc3RhdGljX2ludGVycG9sYXRvcnMgPSBpbnRlcnBvbGF0b3JzO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBrZXlwYXRoIHN1Y2ggYXMgJ2Zvby5iYXIuYmF6JywgYW5kIHJldHVybnNcbiAgLy8gYWxsIHRoZSB2YXJpYW50cyBvZiB0aGF0IGtleXBhdGggdGhhdCBpbmNsdWRlIGEgd2lsZGNhcmQgaW4gcGxhY2VcbiAgLy8gb2YgYSBrZXksIHN1Y2ggYXMgJ2Zvby5iYXIuKicsICdmb28uKi5iYXonLCAnZm9vLiouKicgYW5kIHNvIG9uLlxuICAvLyBUaGVzZSBhcmUgdGhlbiBjaGVja2VkIGFnYWluc3QgdGhlIGRlcGVuZGFudHMgbWFwIChyYWN0aXZlLnZpZXdtb2RlbC5kZXBzTWFwKVxuICAvLyB0byBzZWUgaWYgYW55IHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSBkb3duc3RyZWFtIG9mIG9uZSBvciBtb3JlIG9mXG4gIC8vIHRoZXNlIHdpbGRjYXJkIGtleXBhdGhzIChlLmcuICdmb28uYmFyLiouc3RhdHVzJylcbiAgdmFyIHV0aWxzX2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcztcblxuICB2YXIgc3Rhck1hcHMgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKGtleXBhdGgpIHtcbiAgXHR2YXIga2V5cywgc3Rhck1hcCwgbWFwcGVyLCBpLCByZXN1bHQsIHdpbGRjYXJkS2V5cGF0aDtcblxuICBcdGtleXMgPSBrZXlwYXRoLnNwbGl0KFwiLlwiKTtcbiAgXHRpZiAoIShzdGFyTWFwID0gc3Rhck1hcHNba2V5cy5sZW5ndGhdKSkge1xuICBcdFx0c3Rhck1hcCA9IGdldFN0YXJNYXAoa2V5cy5sZW5ndGgpO1xuICBcdH1cblxuICBcdHJlc3VsdCA9IFtdO1xuXG4gIFx0bWFwcGVyID0gZnVuY3Rpb24gKHN0YXIsIGkpIHtcbiAgXHRcdHJldHVybiBzdGFyID8gXCIqXCIgOiBrZXlzW2ldO1xuICBcdH07XG5cbiAgXHRpID0gc3Rhck1hcC5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0d2lsZGNhcmRLZXlwYXRoID0gc3Rhck1hcFtpXS5tYXAobWFwcGVyKS5qb2luKFwiLlwiKTtcblxuICBcdFx0aWYgKCFyZXN1bHQuaGFzT3duUHJvcGVydHkod2lsZGNhcmRLZXlwYXRoKSkge1xuICBcdFx0XHRyZXN1bHQucHVzaCh3aWxkY2FyZEtleXBhdGgpO1xuICBcdFx0XHRyZXN1bHRbd2lsZGNhcmRLZXlwYXRoXSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbGwgdGhlIHBvc3NpYmxlIHRydWUvZmFsc2UgY29tYmluYXRpb25zIGZvclxuICAvLyBhIGdpdmVuIG51bWJlciAtIGUuZy4gZm9yIHR3bywgdGhlIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBhcmVcbiAgLy8gWyB0cnVlLCB0cnVlIF0sIFsgdHJ1ZSwgZmFsc2UgXSwgWyBmYWxzZSwgdHJ1ZSBdLCBbIGZhbHNlLCBmYWxzZSBdLlxuICAvLyBJdCBkb2VzIHNvIGJ5IGdldHRpbmcgYWxsIHRoZSBiaW5hcnkgdmFsdWVzIGJldHdlZW4gMCBhbmQgZS5nLiAxMVxuICBmdW5jdGlvbiBnZXRTdGFyTWFwKG51bSkge1xuICBcdHZhciBvbmVzID0gXCJcIixcbiAgXHQgICAgbWF4LFxuICBcdCAgICBiaW5hcnksXG4gIFx0ICAgIHN0YXJNYXAsXG4gIFx0ICAgIG1hcHBlcixcbiAgXHQgICAgaSxcbiAgXHQgICAgaixcbiAgXHQgICAgbCxcbiAgXHQgICAgbWFwO1xuXG4gIFx0aWYgKCFzdGFyTWFwc1tudW1dKSB7XG4gIFx0XHRzdGFyTWFwID0gW107XG5cbiAgXHRcdHdoaWxlIChvbmVzLmxlbmd0aCA8IG51bSkge1xuICBcdFx0XHRvbmVzICs9IDE7XG4gIFx0XHR9XG5cbiAgXHRcdG1heCA9IHBhcnNlSW50KG9uZXMsIDIpO1xuXG4gIFx0XHRtYXBwZXIgPSBmdW5jdGlvbiAoZGlnaXQpIHtcbiAgXHRcdFx0cmV0dXJuIGRpZ2l0ID09PSBcIjFcIjtcbiAgXHRcdH07XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPD0gbWF4OyBpICs9IDEpIHtcbiAgXHRcdFx0YmluYXJ5ID0gaS50b1N0cmluZygyKTtcbiAgXHRcdFx0d2hpbGUgKGJpbmFyeS5sZW5ndGggPCBudW0pIHtcbiAgXHRcdFx0XHRiaW5hcnkgPSBcIjBcIiArIGJpbmFyeTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdG1hcCA9IFtdO1xuICBcdFx0XHRsID0gYmluYXJ5Lmxlbmd0aDtcbiAgXHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICBcdFx0XHRcdG1hcC5wdXNoKG1hcHBlcihiaW5hcnlbal0pKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRzdGFyTWFwW2ldID0gbWFwO1xuICBcdFx0fVxuXG4gIFx0XHRzdGFyTWFwc1tudW1dID0gc3Rhck1hcDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3Rhck1hcHNbbnVtXTtcbiAgfVxuXG4gIHZhciByZWZQYXR0ZXJuID0gL1xcW1xccyooXFwqfFswLTldfFsxLTldWzAtOV0rKVxccypcXF0vZztcbiAgdmFyIHBhdHRlcm5QYXR0ZXJuID0gL1xcKi87XG4gIHZhciBrZXlwYXRoQ2FjaGUgPSB7fTtcblxuICB2YXIgS2V5cGF0aCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgXHR2YXIga2V5cyA9IHN0ci5zcGxpdChcIi5cIik7XG5cbiAgXHR0aGlzLnN0ciA9IHN0cjtcblxuICBcdGlmIChzdHJbMF0gPT09IFwiQFwiKSB7XG4gIFx0XHR0aGlzLmlzU3BlY2lhbCA9IHRydWU7XG4gIFx0XHR0aGlzLnZhbHVlID0gZGVjb2RlS2V5cGF0aChzdHIpO1xuICBcdH1cblxuICBcdHRoaXMuZmlyc3RLZXkgPSBrZXlzWzBdO1xuICBcdHRoaXMubGFzdEtleSA9IGtleXMucG9wKCk7XG5cbiAgXHR0aGlzLmlzUGF0dGVybiA9IHBhdHRlcm5QYXR0ZXJuLnRlc3Qoc3RyKTtcblxuICBcdHRoaXMucGFyZW50ID0gc3RyID09PSBcIlwiID8gbnVsbCA6IGdldEtleXBhdGgoa2V5cy5qb2luKFwiLlwiKSk7XG4gIFx0dGhpcy5pc1Jvb3QgPSAhc3RyO1xuICB9O1xuXG4gIEtleXBhdGgucHJvdG90eXBlID0ge1xuICBcdGVxdWFsc09yU3RhcnRzV2l0aDogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBrZXlwYXRoID09PSB0aGlzIHx8IHRoaXMuc3RhcnRzV2l0aChrZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0am9pbjogZnVuY3Rpb24gKHN0cikge1xuICBcdFx0cmV0dXJuIGdldEtleXBhdGgodGhpcy5pc1Jvb3QgPyBTdHJpbmcoc3RyKSA6IHRoaXMuc3RyICsgXCIuXCIgKyBzdHIpO1xuICBcdH0sXG5cbiAgXHRyZXBsYWNlOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMgPT09IG9sZEtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5ld0tleXBhdGg7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnN0YXJ0c1dpdGgob2xkS2V5cGF0aCkpIHtcbiAgXHRcdFx0cmV0dXJuIG5ld0tleXBhdGggPT09IG51bGwgPyBuZXdLZXlwYXRoIDogZ2V0S2V5cGF0aCh0aGlzLnN0ci5yZXBsYWNlKG9sZEtleXBhdGguc3RyICsgXCIuXCIsIG5ld0tleXBhdGguc3RyICsgXCIuXCIpKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c3RhcnRzV2l0aDogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICgha2V5cGF0aCkge1xuICBcdFx0XHQvLyBUT0RPIHVuZGVyIHdoYXQgY2lyY3Vtc3RhbmNlcyBkb2VzIHRoaXMgaGFwcGVuP1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBrZXlwYXRoICYmIHRoaXMuc3RyLnN1YnN0cigwLCBrZXlwYXRoLnN0ci5sZW5ndGggKyAxKSA9PT0ga2V5cGF0aC5zdHIgKyBcIi5cIjtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkJhZCBjb2VyY2lvblwiKTtcbiAgXHR9LFxuXG4gIFx0dmFsdWVPZjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQmFkIGNvZXJjaW9uXCIpO1xuICBcdH0sXG5cbiAgXHR3aWxkY2FyZE1hdGNoZXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl93aWxkY2FyZE1hdGNoZXMgfHwgKHRoaXMuX3dpbGRjYXJkTWF0Y2hlcyA9IHV0aWxzX2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyh0aGlzLnN0cikpO1xuICBcdH1cbiAgfTtcbiAgZnVuY3Rpb24gYXNzaWduTmV3S2V5cGF0aCh0YXJnZXQsIHByb3BlcnR5LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0dmFyIGV4aXN0aW5nS2V5cGF0aCA9IHRhcmdldFtwcm9wZXJ0eV07XG5cbiAgXHRpZiAoZXhpc3RpbmdLZXlwYXRoICYmIChleGlzdGluZ0tleXBhdGguZXF1YWxzT3JTdGFydHNXaXRoKG5ld0tleXBhdGgpIHx8ICFleGlzdGluZ0tleXBhdGguZXF1YWxzT3JTdGFydHNXaXRoKG9sZEtleXBhdGgpKSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRhcmdldFtwcm9wZXJ0eV0gPSBleGlzdGluZ0tleXBhdGggPyBleGlzdGluZ0tleXBhdGgucmVwbGFjZShvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSA6IG5ld0tleXBhdGg7XG4gIFx0cmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGVLZXlwYXRoKGtleXBhdGgpIHtcbiAgXHR2YXIgdmFsdWUgPSBrZXlwYXRoLnNsaWNlKDIpO1xuXG4gIFx0aWYgKGtleXBhdGhbMV0gPT09IFwiaVwiKSB7XG4gIFx0XHRyZXR1cm4gaXNfX2lzTnVtZXJpYyh2YWx1ZSkgPyArdmFsdWUgOiB2YWx1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIHZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEtleXBhdGgoc3RyKSB7XG4gIFx0aWYgKHN0ciA9PSBudWxsKSB7XG4gIFx0XHRyZXR1cm4gc3RyO1xuICBcdH1cblxuICBcdC8vIFRPRE8gaXQgKm1heSogYmUgd29ydGggaGF2aW5nIHR3byB2ZXJzaW9ucyBvZiB0aGlzIGZ1bmN0aW9uIC0gb25lIHdoZXJlXG4gIFx0Ly8ga2V5cGF0aENhY2hlIGluaGVyaXRzIGZyb20gbnVsbCwgYW5kIG9uZSBmb3IgSUU4LiBEZXBlbmRzIG9uIGhvd1xuICBcdC8vIG11Y2ggb2YgYW4gb3ZlcmhlYWQgaGFzT3duUHJvcGVydHkgaXMgLSBwcm9iYWJseSBuZWdsaWdpYmxlXG4gIFx0aWYgKCFrZXlwYXRoQ2FjaGUuaGFzT3duUHJvcGVydHkoc3RyKSkge1xuICBcdFx0a2V5cGF0aENhY2hlW3N0cl0gPSBuZXcgS2V5cGF0aChzdHIpO1xuICBcdH1cblxuICBcdHJldHVybiBrZXlwYXRoQ2FjaGVbc3RyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1hdGNoaW5nS2V5cGF0aHMocmFjdGl2ZSwga2V5cGF0aCkge1xuICBcdHZhciBrZXlzLCBrZXksIG1hdGNoaW5nS2V5cGF0aHM7XG5cbiAgXHRrZXlzID0ga2V5cGF0aC5zdHIuc3BsaXQoXCIuXCIpO1xuICBcdG1hdGNoaW5nS2V5cGF0aHMgPSBbcm9vdEtleXBhdGhdO1xuXG4gIFx0d2hpbGUgKGtleSA9IGtleXMuc2hpZnQoKSkge1xuICBcdFx0aWYgKGtleSA9PT0gXCIqXCIpIHtcbiAgXHRcdFx0Ly8gZXhwYW5kIHRvIGZpbmQgYWxsIHZhbGlkIGNoaWxkIGtleXBhdGhzXG4gIFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBtYXRjaGluZ0tleXBhdGhzLnJlZHVjZShleHBhbmQsIFtdKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGlmIChtYXRjaGluZ0tleXBhdGhzWzBdID09PSByb290S2V5cGF0aCkge1xuICBcdFx0XHRcdC8vIGZpcnN0IGtleVxuICBcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHNbMF0gPSBnZXRLZXlwYXRoKGtleSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IG1hdGNoaW5nS2V5cGF0aHMubWFwKGNvbmNhdGVuYXRlKGtleSkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG1hdGNoaW5nS2V5cGF0aHM7XG5cbiAgXHRmdW5jdGlvbiBleHBhbmQobWF0Y2hpbmdLZXlwYXRocywga2V5cGF0aCkge1xuICBcdFx0dmFyIHdyYXBwZXIsIHZhbHVlLCBrZXlzO1xuXG4gIFx0XHRpZiAoa2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdFx0a2V5cyA9IFtdLmNvbmNhdChPYmplY3Qua2V5cyhyYWN0aXZlLnZpZXdtb2RlbC5kYXRhKSwgT2JqZWN0LmtleXMocmFjdGl2ZS52aWV3bW9kZWwubWFwcGluZ3MpLCBPYmplY3Qua2V5cyhyYWN0aXZlLnZpZXdtb2RlbC5jb21wdXRhdGlvbnMpKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdyYXBwZXIgPSByYWN0aXZlLnZpZXdtb2RlbC53cmFwcGVkW2tleXBhdGguc3RyXTtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVyID8gd3JhcHBlci5nZXQoKSA6IHJhY3RpdmUudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0XHRrZXlzID0gdmFsdWUgPyBPYmplY3Qua2V5cyh2YWx1ZSkgOiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoa2V5cykge1xuICBcdFx0XHRrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0XHRcdGlmIChrZXkgIT09IFwiX3JhY3RpdmVcIiB8fCAhaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMucHVzaChrZXlwYXRoLmpvaW4oa2V5KSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG1hdGNoaW5nS2V5cGF0aHM7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gY29uY2F0ZW5hdGUoa2V5KSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRyZXR1cm4ga2V5cGF0aC5qb2luKGtleSk7XG4gIFx0fTtcbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpc2UocmVmKSB7XG4gIFx0cmV0dXJuIHJlZiA/IHJlZi5yZXBsYWNlKHJlZlBhdHRlcm4sIFwiLiQxXCIpIDogXCJcIjtcbiAgfVxuXG4gIHZhciByb290S2V5cGF0aCA9IGdldEtleXBhdGgoXCJcIik7XG5cbiAgdmFyIHNoYXJlZF9hZGQgPSBhZGQ7XG4gIHZhciBzaGFyZWRfYWRkX19lcnJvck1lc3NhZ2UgPSBcIkNhbm5vdCBhZGQgdG8gYSBub24tbnVtZXJpYyB2YWx1ZVwiO1xuICBmdW5jdGlvbiBhZGQocm9vdCwga2V5cGF0aCwgZCkge1xuICBcdGlmICh0eXBlb2Yga2V5cGF0aCAhPT0gXCJzdHJpbmdcIiB8fCAhaXNfX2lzTnVtZXJpYyhkKSkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQmFkIGFyZ3VtZW50c1wiKTtcbiAgXHR9XG5cbiAgXHR2YXIgdmFsdWUgPSB1bmRlZmluZWQsXG4gIFx0ICAgIGNoYW5nZXMgPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoL1xcKi8udGVzdChrZXlwYXRoKSkge1xuICBcdFx0Y2hhbmdlcyA9IHt9O1xuXG4gIFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKHJvb3QsIGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHR2YXIgdmFsdWUgPSByb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdFx0aWYgKCFpc19faXNOdW1lcmljKHZhbHVlKSkge1xuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcihzaGFyZWRfYWRkX19lcnJvck1lc3NhZ2UpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y2hhbmdlc1trZXlwYXRoLnN0cl0gPSB2YWx1ZSArIGQ7XG4gIFx0XHR9KTtcblxuICBcdFx0cmV0dXJuIHJvb3Quc2V0KGNoYW5nZXMpO1xuICBcdH1cblxuICBcdHZhbHVlID0gcm9vdC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRpZiAoIWlzX19pc051bWVyaWModmFsdWUpKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3Ioc2hhcmVkX2FkZF9fZXJyb3JNZXNzYWdlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcm9vdC5zZXQoa2V5cGF0aCwgK3ZhbHVlICsgZCk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2FkZCA9IFJhY3RpdmUkYWRkO1xuICBmdW5jdGlvbiBSYWN0aXZlJGFkZChrZXlwYXRoLCBkKSB7XG4gIFx0cmV0dXJuIHNoYXJlZF9hZGQodGhpcywga2V5cGF0aCwgZCA9PT0gdW5kZWZpbmVkID8gMSA6ICtkKTtcbiAgfVxuXG4gIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbiAgLy8gSWYgd2luZG93IGRvZXNuJ3QgZXhpc3QsIHdlIGRvbid0IG5lZWQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHQvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MVxuICBcdChmdW5jdGlvbiAodmVuZG9ycywgbGFzdFRpbWUsIHdpbmRvdykge1xuXG4gIFx0XHR2YXIgeCwgc2V0VGltZW91dDtcblxuICBcdFx0aWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICBcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyBcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gIFx0XHRcdHNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcblxuICBcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIFx0XHRcdFx0dmFyIGN1cnJUaW1lLCB0aW1lVG9DYWxsLCBpZDtcblxuICBcdFx0XHRcdGN1cnJUaW1lID0gRGF0ZS5ub3coKTtcbiAgXHRcdFx0XHR0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICBcdFx0XHRcdGlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICBcdFx0XHRcdH0sIHRpbWVUb0NhbGwpO1xuXG4gIFx0XHRcdFx0bGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gIFx0XHRcdFx0cmV0dXJuIGlkO1xuICBcdFx0XHR9O1xuICBcdFx0fVxuICBcdH0pKHZlbmRvcnMsIDAsIHdpbmRvdyk7XG5cbiAgXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICB9XG5cbiAgdmFyIHJBRiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxuICB2YXIgZ2V0VGltZTtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdGdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICBcdH07XG4gIH0gZWxzZSB7XG4gIFx0Z2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBEYXRlLm5vdygpO1xuICBcdH07XG4gIH1cblxuICB2YXIgdXRpbHNfZ2V0VGltZSA9IGdldFRpbWU7XG5cbiAgdmFyIGRlcHJlY2F0aW9ucyA9IHtcbiAgXHRjb25zdHJ1Y3Q6IHtcbiAgXHRcdGRlcHJlY2F0ZWQ6IFwiYmVmb3JlSW5pdFwiLFxuICBcdFx0cmVwbGFjZW1lbnQ6IFwib25jb25zdHJ1Y3RcIlxuICBcdH0sXG4gIFx0cmVuZGVyOiB7XG4gIFx0XHRkZXByZWNhdGVkOiBcImluaXRcIixcbiAgXHRcdG1lc3NhZ2U6IFwiVGhlIFxcXCJpbml0XFxcIiBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCBcIiArIFwiYW5kIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gXCIgKyBcIllvdSBjYW4gZWl0aGVyIHVzZSB0aGUgXFxcIm9uaW5pdFxcXCIgbWV0aG9kIHdoaWNoIHdpbGwgZmlyZSBcIiArIFwib25seSBvbmNlIHByaW9yIHRvLCBhbmQgcmVnYXJkbGVzcyBvZiwgYW55IGV2ZW50dWFsIHJhY3RpdmUgXCIgKyBcImluc3RhbmNlIGJlaW5nIHJlbmRlcmVkLCBvciBpZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIFwiICsgXCJyZW5kZXJlZCBET00sIHVzZSBcXFwib25yZW5kZXJcXFwiIGluc3RlYWQuIFwiICsgXCJTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbWlncmF0aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gIFx0fSxcbiAgXHRjb21wbGV0ZToge1xuICBcdFx0ZGVwcmVjYXRlZDogXCJjb21wbGV0ZVwiLFxuICBcdFx0cmVwbGFjZW1lbnQ6IFwib25jb21wbGV0ZVwiXG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIEhvb2soZXZlbnQpIHtcbiAgXHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gIFx0dGhpcy5tZXRob2QgPSBcIm9uXCIgKyBldmVudDtcbiAgXHR0aGlzLmRlcHJlY2F0ZSA9IGRlcHJlY2F0aW9uc1tldmVudF07XG4gIH1cblxuICBIb29rLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gKHJhY3RpdmUsIGFyZykge1xuICBcdGZ1bmN0aW9uIGNhbGwobWV0aG9kKSB7XG4gIFx0XHRpZiAocmFjdGl2ZVttZXRob2RdKSB7XG4gIFx0XHRcdGFyZyA/IHJhY3RpdmVbbWV0aG9kXShhcmcpIDogcmFjdGl2ZVttZXRob2RdKCk7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGNhbGwodGhpcy5tZXRob2QpO1xuXG4gIFx0aWYgKCFyYWN0aXZlW3RoaXMubWV0aG9kXSAmJiB0aGlzLmRlcHJlY2F0ZSAmJiBjYWxsKHRoaXMuZGVwcmVjYXRlLmRlcHJlY2F0ZWQpKSB7XG4gIFx0XHRpZiAodGhpcy5kZXByZWNhdGUubWVzc2FnZSkge1xuICBcdFx0XHR3YXJuSWZEZWJ1Zyh0aGlzLmRlcHJlY2F0ZS5tZXNzYWdlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKFwiVGhlIG1ldGhvZCBcXFwiJXNcXFwiIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgXFxcIiVzXFxcIiBhbmQgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbWlncmF0aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiLCB0aGlzLmRlcHJlY2F0ZS5kZXByZWNhdGVkLCB0aGlzLmRlcHJlY2F0ZS5yZXBsYWNlbWVudCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0YXJnID8gcmFjdGl2ZS5maXJlKHRoaXMuZXZlbnQsIGFyZykgOiByYWN0aXZlLmZpcmUodGhpcy5ldmVudCk7XG4gIH07XG5cbiAgdmFyIGhvb2tzX0hvb2sgPSBIb29rO1xuXG4gIGZ1bmN0aW9uIGFkZFRvQXJyYXkoYXJyYXksIHZhbHVlKSB7XG4gIFx0dmFyIGluZGV4ID0gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG5cbiAgXHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRhcnJheS5wdXNoKHZhbHVlKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUNvbnRhaW5zKGFycmF5LCB2YWx1ZSkge1xuICBcdGZvciAodmFyIGkgPSAwLCBjID0gYXJyYXkubGVuZ3RoOyBpIDwgYzsgaSsrKSB7XG4gIFx0XHRpZiAoYXJyYXlbaV0gPT0gdmFsdWUpIHtcbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlDb250ZW50c01hdGNoKGEsIGIpIHtcbiAgXHR2YXIgaTtcblxuICBcdGlmICghaXNBcnJheShhKSB8fCAhaXNBcnJheShiKSkge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHRpID0gYS5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlQXJyYXkoeCkge1xuICBcdGlmICh0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0cmV0dXJuIFt4XTtcbiAgXHR9XG5cbiAgXHRpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRyZXR1cm4gW107XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBsYXN0SXRlbShhcnJheSkge1xuICBcdHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUZyb21BcnJheShhcnJheSwgbWVtYmVyKSB7XG4gIFx0dmFyIGluZGV4ID0gYXJyYXkuaW5kZXhPZihtZW1iZXIpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0YXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICBcdHZhciBhcnJheSA9IFtdLFxuICBcdCAgICBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRhcnJheVtpXSA9IGFycmF5TGlrZVtpXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXJyYXk7XG4gIH1cblxuICB2YXIgX1Byb21pc2UsXG4gICAgICBQRU5ESU5HID0ge30sXG4gICAgICBGVUxGSUxMRUQgPSB7fSxcbiAgICAgIFJFSkVDVEVEID0ge307XG5cbiAgaWYgKHR5cGVvZiBQcm9taXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHQvLyB1c2UgbmF0aXZlIFByb21pc2VcbiAgXHRfUHJvbWlzZSA9IFByb21pc2U7XG4gIH0gZWxzZSB7XG4gIFx0X1Byb21pc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgXHRcdHZhciBmdWxmaWxsZWRIYW5kbGVycyA9IFtdLFxuICBcdFx0ICAgIHJlamVjdGVkSGFuZGxlcnMgPSBbXSxcbiAgXHRcdCAgICBzdGF0ZSA9IFBFTkRJTkcsXG4gIFx0XHQgICAgcmVzdWx0LFxuICBcdFx0ICAgIGRpc3BhdGNoSGFuZGxlcnMsXG4gIFx0XHQgICAgbWFrZVJlc29sdmVyLFxuICBcdFx0ICAgIGZ1bGZpbCxcbiAgXHRcdCAgICByZWplY3QsXG4gIFx0XHQgICAgcHJvbWlzZTtcblxuICBcdFx0bWFrZVJlc29sdmVyID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gIFx0XHRcdHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0XHRpZiAoc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRyZXN1bHQgPSB2YWx1ZTtcbiAgXHRcdFx0XHRzdGF0ZSA9IG5ld1N0YXRlO1xuXG4gIFx0XHRcdFx0ZGlzcGF0Y2hIYW5kbGVycyA9IG1ha2VEaXNwYXRjaGVyKHN0YXRlID09PSBGVUxGSUxMRUQgPyBmdWxmaWxsZWRIYW5kbGVycyA6IHJlamVjdGVkSGFuZGxlcnMsIHJlc3VsdCk7XG5cbiAgXHRcdFx0XHQvLyBkaXNwYXRjaCBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBoYW5kbGVycyBhc3luY2hyb25vdXNseVxuICBcdFx0XHRcdHdhaXQoZGlzcGF0Y2hIYW5kbGVycyk7XG4gIFx0XHRcdH07XG4gIFx0XHR9O1xuXG4gIFx0XHRmdWxmaWwgPSBtYWtlUmVzb2x2ZXIoRlVMRklMTEVEKTtcbiAgXHRcdHJlamVjdCA9IG1ha2VSZXNvbHZlcihSRUpFQ1RFRCk7XG5cbiAgXHRcdHRyeSB7XG4gIFx0XHRcdGNhbGxiYWNrKGZ1bGZpbCwgcmVqZWN0KTtcbiAgXHRcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0XHRyZWplY3QoZXJyKTtcbiAgXHRcdH1cblxuICBcdFx0cHJvbWlzZSA9IHtcbiAgXHRcdFx0Ly8gYHRoZW4oKWAgcmV0dXJucyBhIFByb21pc2UgLSAyLjIuN1xuICBcdFx0XHR0aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgXHRcdFx0XHR2YXIgcHJvbWlzZTIgPSBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCwgcmVqZWN0KSB7XG5cbiAgXHRcdFx0XHRcdHZhciBwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlciwgaGFuZGxlcnMsIGZvcndhcmQpIHtcblxuICBcdFx0XHRcdFx0XHQvLyAyLjIuMS4xXG4gIFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0XHRcdFx0aGFuZGxlcnMucHVzaChmdW5jdGlvbiAocDFyZXN1bHQpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdHZhciB4O1xuXG4gIFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuICBcdFx0XHRcdFx0XHRcdFx0XHR4ID0gaGFuZGxlcihwMXJlc3VsdCk7XG4gIFx0XHRcdFx0XHRcdFx0XHRcdHV0aWxzX1Byb21pc2VfX3Jlc29sdmUocHJvbWlzZTIsIHgsIGZ1bGZpbCwgcmVqZWN0KTtcbiAgXHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0XHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyKTtcbiAgXHRcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHQvLyBGb3J3YXJkIHRoZSByZXN1bHQgb2YgcHJvbWlzZTEgdG8gcHJvbWlzZTIsIGlmIHJlc29sdXRpb24gaGFuZGxlcnNcbiAgXHRcdFx0XHRcdFx0XHQvLyBhcmUgbm90IGdpdmVuXG4gIFx0XHRcdFx0XHRcdFx0aGFuZGxlcnMucHVzaChmb3J3YXJkKTtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fTtcblxuICBcdFx0XHRcdFx0Ly8gMi4yXG4gIFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIob25GdWxmaWxsZWQsIGZ1bGZpbGxlZEhhbmRsZXJzLCBmdWxmaWwpO1xuICBcdFx0XHRcdFx0cHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyKG9uUmVqZWN0ZWQsIHJlamVjdGVkSGFuZGxlcnMsIHJlamVjdCk7XG5cbiAgXHRcdFx0XHRcdGlmIChzdGF0ZSAhPT0gUEVORElORykge1xuICBcdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJvbWlzZSBoYXMgcmVzb2x2ZWQgYWxyZWFkeSwgZGlzcGF0Y2ggdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXJzIGFzeW5jaHJvbm91c2x5XG4gIFx0XHRcdFx0XHRcdHdhaXQoZGlzcGF0Y2hIYW5kbGVycyk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fSk7XG5cbiAgXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTI7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG5cbiAgXHRcdHByb21pc2VbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gIFx0XHR9O1xuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9O1xuXG4gIFx0X1Byb21pc2UuYWxsID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gIFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwsIHJlamVjdCkge1xuICBcdFx0XHR2YXIgcmVzdWx0ID0gW10sXG4gIFx0XHRcdCAgICBwZW5kaW5nLFxuICBcdFx0XHQgICAgaSxcbiAgXHRcdFx0ICAgIHByb2Nlc3NQcm9taXNlO1xuXG4gIFx0XHRcdGlmICghcHJvbWlzZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0ZnVsZmlsKHJlc3VsdCk7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cHJvY2Vzc1Byb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZSwgaSkge1xuICBcdFx0XHRcdGlmIChwcm9taXNlICYmIHR5cGVvZiBwcm9taXNlLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdFx0cHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0XHRcdFx0XHRyZXN1bHRbaV0gPSB2YWx1ZTtcbiAgXHRcdFx0XHRcdFx0LS1wZW5kaW5nIHx8IGZ1bGZpbChyZXN1bHQpO1xuICBcdFx0XHRcdFx0fSwgcmVqZWN0KTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0cmVzdWx0W2ldID0gcHJvbWlzZTtcbiAgXHRcdFx0XHRcdC0tcGVuZGluZyB8fCBmdWxmaWwocmVzdWx0KTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0cGVuZGluZyA9IGkgPSBwcm9taXNlcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRwcm9jZXNzUHJvbWlzZShwcm9taXNlc1tpXSwgaSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH07XG5cbiAgXHRfUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwpIHtcbiAgXHRcdFx0ZnVsZmlsKHZhbHVlKTtcbiAgXHRcdH0pO1xuICBcdH07XG5cbiAgXHRfUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gIFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwsIHJlamVjdCkge1xuICBcdFx0XHRyZWplY3QocmVhc29uKTtcbiAgXHRcdH0pO1xuICBcdH07XG4gIH1cblxuICB2YXIgdXRpbHNfUHJvbWlzZSA9IF9Qcm9taXNlO1xuXG4gIC8vIFRPRE8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJzIG9yIHNvbWV0aGluZyB0byBzaW11bGF0ZSBzZXRJbW1lZGlhdGVcbiAgZnVuY3Rpb24gd2FpdChjYWxsYmFjaykge1xuICBcdHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZURpc3BhdGNoZXIoaGFuZGxlcnMsIHJlc3VsdCkge1xuICBcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaGFuZGxlcjtcblxuICBcdFx0d2hpbGUgKGhhbmRsZXIgPSBoYW5kbGVycy5zaGlmdCgpKSB7XG4gIFx0XHRcdGhhbmRsZXIocmVzdWx0KTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXRpbHNfUHJvbWlzZV9fcmVzb2x2ZShwcm9taXNlLCB4LCBmdWxmaWwsIHJlamVjdCkge1xuICBcdC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcbiAgXHR2YXIgdGhlbjtcblxuICBcdC8vIDIuMy4xXG4gIFx0aWYgKHggPT09IHByb21pc2UpIHtcbiAgXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHByb21pc2UncyBmdWxmaWxsbWVudCBoYW5kbGVyIGNhbm5vdCByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZVwiKTtcbiAgXHR9XG5cbiAgXHQvLyAyLjMuMlxuICBcdGlmICh4IGluc3RhbmNlb2YgX1Byb21pc2UpIHtcbiAgXHRcdHgudGhlbihmdWxmaWwsIHJlamVjdCk7XG4gIFx0fVxuXG4gIFx0Ly8gMi4zLjNcbiAgXHRlbHNlIGlmICh4ICYmICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICBcdFx0dHJ5IHtcbiAgXHRcdFx0dGhlbiA9IHgudGhlbjsgLy8gMi4zLjMuMVxuICBcdFx0fSBjYXRjaCAoZSkge1xuICBcdFx0XHRyZWplY3QoZSk7IC8vIDIuMy4zLjJcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyAyLjMuMy4zXG4gIFx0XHRpZiAodHlwZW9mIHRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHR2YXIgY2FsbGVkLCByZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZTtcblxuICBcdFx0XHRyZXNvbHZlUHJvbWlzZSA9IGZ1bmN0aW9uICh5KSB7XG4gIFx0XHRcdFx0aWYgKGNhbGxlZCkge1xuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuICBcdFx0XHRcdHV0aWxzX1Byb21pc2VfX3Jlc29sdmUocHJvbWlzZSwgeSwgZnVsZmlsLCByZWplY3QpO1xuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHJlamVjdFByb21pc2UgPSBmdW5jdGlvbiAocikge1xuICBcdFx0XHRcdGlmIChjYWxsZWQpIHtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRyZWplY3Qocik7XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0dHJ5IHtcbiAgXHRcdFx0XHR0aGVuLmNhbGwoeCwgcmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UpO1xuICBcdFx0XHR9IGNhdGNoIChlKSB7XG4gIFx0XHRcdFx0aWYgKCFjYWxsZWQpIHtcbiAgXHRcdFx0XHRcdC8vIDIuMy4zLjMuNC4xXG4gIFx0XHRcdFx0XHRyZWplY3QoZSk7IC8vIDIuMy4zLjMuNC4yXG4gIFx0XHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZnVsZmlsKHgpO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRmdWxmaWwoeCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGdldElubmVyQ29udGV4dCA9IGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICBcdGRvIHtcbiAgXHRcdGlmIChmcmFnbWVudC5jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIGZyYWdtZW50LmNvbnRleHQ7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQpO1xuXG4gIFx0cmV0dXJuIHJvb3RLZXlwYXRoO1xuICB9O1xuXG4gIHZhciBzaGFyZWRfcmVzb2x2ZVJlZiA9IHJlc29sdmVSZWY7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZihyYWN0aXZlLCByZWYsIGZyYWdtZW50KSB7XG4gIFx0dmFyIGtleXBhdGg7XG5cbiAgXHRyZWYgPSBub3JtYWxpc2UocmVmKTtcblxuICBcdC8vIElmIGEgcmVmZXJlbmNlIGJlZ2lucyAnfi8nLCBpdCdzIGEgdG9wLWxldmVsIHJlZmVyZW5jZVxuICBcdGlmIChyZWYuc3Vic3RyKDAsIDIpID09PSBcIn4vXCIpIHtcbiAgXHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKHJlZi5zdWJzdHJpbmcoMikpO1xuICBcdFx0Y3JlYXRlTWFwcGluZ0lmTmVjZXNzYXJ5KHJhY3RpdmUsIGtleXBhdGguZmlyc3RLZXksIGZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHQvLyBJZiBhIHJlZmVyZW5jZSBiZWdpbnMgd2l0aCAnLicsIGl0J3MgZWl0aGVyIGEgcmVzdHJpY3RlZCByZWZlcmVuY2Ugb3JcbiAgXHQvLyBhbiBhbmNlc3RvciByZWZlcmVuY2UuLi5cbiAgXHRlbHNlIGlmIChyZWZbMF0gPT09IFwiLlwiKSB7XG4gIFx0XHRrZXlwYXRoID0gcmVzb2x2ZUFuY2VzdG9yUmVmKGdldElubmVyQ29udGV4dChmcmFnbWVudCksIHJlZik7XG5cbiAgXHRcdGlmIChrZXlwYXRoKSB7XG4gIFx0XHRcdGNyZWF0ZU1hcHBpbmdJZk5lY2Vzc2FyeShyYWN0aXZlLCBrZXlwYXRoLmZpcnN0S2V5LCBmcmFnbWVudCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gLi4ub3RoZXJ3aXNlIHdlIG5lZWQgdG8gZmlndXJlIG91dCB0aGUga2V5cGF0aCBiYXNlZCBvbiBjb250ZXh0XG4gIFx0ZWxzZSB7XG4gIFx0XHRrZXlwYXRoID0gcmVzb2x2ZUFtYmlndW91c1JlZmVyZW5jZShyYWN0aXZlLCBnZXRLZXlwYXRoKHJlZiksIGZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ga2V5cGF0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVBbmNlc3RvclJlZihiYXNlQ29udGV4dCwgcmVmKSB7XG4gIFx0dmFyIGNvbnRleHRLZXlzO1xuXG4gIFx0Ly8gVE9ETy4uLlxuICBcdGlmIChiYXNlQ29udGV4dCAhPSB1bmRlZmluZWQgJiYgdHlwZW9mIGJhc2VDb250ZXh0ICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRiYXNlQ29udGV4dCA9IGJhc2VDb250ZXh0LnN0cjtcbiAgXHR9XG5cbiAgXHQvLyB7ey59fSBtZWFucyAnY3VycmVudCBjb250ZXh0J1xuICBcdGlmIChyZWYgPT09IFwiLlwiKSByZXR1cm4gZ2V0S2V5cGF0aChiYXNlQ29udGV4dCk7XG5cbiAgXHRjb250ZXh0S2V5cyA9IGJhc2VDb250ZXh0ID8gYmFzZUNvbnRleHQuc3BsaXQoXCIuXCIpIDogW107XG5cbiAgXHQvLyBhbmNlc3RvciByZWZlcmVuY2VzIChzdGFydGluZyBcIi4uL1wiKSBnbyB1cCB0aGUgdHJlZVxuICBcdGlmIChyZWYuc3Vic3RyKDAsIDMpID09PSBcIi4uL1wiKSB7XG4gIFx0XHR3aGlsZSAocmVmLnN1YnN0cigwLCAzKSA9PT0gXCIuLi9cIikge1xuICBcdFx0XHRpZiAoIWNvbnRleHRLZXlzLmxlbmd0aCkge1xuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIHJlZmVyZW5jZSAtIHRvbyBtYW55IFxcXCIuLi9cXFwiIHByZWZpeGVzXCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y29udGV4dEtleXMucG9wKCk7XG4gIFx0XHRcdHJlZiA9IHJlZi5zdWJzdHJpbmcoMyk7XG4gIFx0XHR9XG5cbiAgXHRcdGNvbnRleHRLZXlzLnB1c2gocmVmKTtcbiAgXHRcdHJldHVybiBnZXRLZXlwYXRoKGNvbnRleHRLZXlzLmpvaW4oXCIuXCIpKTtcbiAgXHR9XG5cbiAgXHQvLyBub3QgYW4gYW5jZXN0b3IgcmVmZXJlbmNlIC0gbXVzdCBiZSBhIHJlc3RyaWN0ZWQgcmVmZXJlbmNlIChwcmVwZW5kZWQgd2l0aCBcIi5cIiBvciBcIi4vXCIpXG4gIFx0aWYgKCFiYXNlQ29udGV4dCkge1xuICBcdFx0cmV0dXJuIGdldEtleXBhdGgocmVmLnJlcGxhY2UoL15cXC5cXC8/LywgXCJcIikpO1xuICBcdH1cblxuICBcdHJldHVybiBnZXRLZXlwYXRoKGJhc2VDb250ZXh0ICsgcmVmLnJlcGxhY2UoL15cXC5cXC8vLCBcIi5cIikpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFtYmlndW91c1JlZmVyZW5jZShyYWN0aXZlLCByZWYsIGZyYWdtZW50LCBpc1BhcmVudExvb2t1cCkge1xuICBcdHZhciBjb250ZXh0LCBrZXksIHBhcmVudFZhbHVlLCBoYXNDb250ZXh0Q2hhaW4sIHBhcmVudEtleXBhdGg7XG5cbiAgXHRpZiAocmVmLmlzUm9vdCkge1xuICBcdFx0cmV0dXJuIHJlZjtcbiAgXHR9XG5cbiAgXHRrZXkgPSByZWYuZmlyc3RLZXk7XG5cbiAgXHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdGNvbnRleHQgPSBmcmFnbWVudC5jb250ZXh0O1xuICBcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG5cbiAgXHRcdGlmICghY29udGV4dCkge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aGFzQ29udGV4dENoYWluID0gdHJ1ZTtcbiAgXHRcdHBhcmVudFZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KGNvbnRleHQpO1xuXG4gIFx0XHRpZiAocGFyZW50VmFsdWUgJiYgKHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYga2V5IGluIHBhcmVudFZhbHVlKSB7XG4gIFx0XHRcdHJldHVybiBjb250ZXh0LmpvaW4ocmVmLnN0cik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gUm9vdC9jb21wdXRlZC9tYXBwZWQgcHJvcGVydHk/XG4gIFx0aWYgKGlzUm9vdFByb3BlcnR5KHJhY3RpdmUudmlld21vZGVsLCBrZXkpKSB7XG4gIFx0XHRyZXR1cm4gcmVmO1xuICBcdH1cblxuICBcdC8vIElmIHRoaXMgaXMgYW4gaW5saW5lIGNvbXBvbmVudCwgYW5kIGl0J3Mgbm90IGlzb2xhdGVkLCB3ZVxuICBcdC8vIGNhbiB0cnkgZ29pbmcgdXAgdGhlIHNjb3BlIGNoYWluXG4gIFx0aWYgKHJhY3RpdmUucGFyZW50ICYmICFyYWN0aXZlLmlzb2xhdGVkKSB7XG4gIFx0XHRoYXNDb250ZXh0Q2hhaW4gPSB0cnVlO1xuICBcdFx0ZnJhZ21lbnQgPSByYWN0aXZlLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblxuICBcdFx0a2V5ID0gZ2V0S2V5cGF0aChrZXkpO1xuXG4gIFx0XHRpZiAocGFyZW50S2V5cGF0aCA9IHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UocmFjdGl2ZS5wYXJlbnQsIGtleSwgZnJhZ21lbnQsIHRydWUpKSB7XG4gIFx0XHRcdC8vIFdlIG5lZWQgdG8gY3JlYXRlIGFuIGludGVyLWNvbXBvbmVudCBiaW5kaW5nXG4gIFx0XHRcdHJhY3RpdmUudmlld21vZGVsLm1hcChrZXksIHtcbiAgXHRcdFx0XHRvcmlnaW46IHJhY3RpdmUucGFyZW50LnZpZXdtb2RlbCxcbiAgXHRcdFx0XHRrZXlwYXRoOiBwYXJlbnRLZXlwYXRoXG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHJldHVybiByZWY7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhlcmUncyBubyBjb250ZXh0IGNoYWluLCBhbmQgdGhlIGluc3RhbmNlIGlzIGVpdGhlciBhKSBpc29sYXRlZCBvclxuICBcdC8vIGIpIGFuIG9ycGhhbiwgdGhlbiB3ZSBrbm93IHRoYXQgdGhlIGtleXBhdGggaXMgaWRlbnRpY2FsIHRvIHRoZSByZWZlcmVuY2VcbiAgXHRpZiAoIWlzUGFyZW50TG9va3VwICYmICFoYXNDb250ZXh0Q2hhaW4pIHtcbiAgXHRcdC8vIHRoZSBkYXRhIG9iamVjdCBuZWVkcyB0byBoYXZlIGEgcHJvcGVydHkgYnkgdGhpcyBuYW1lLFxuICBcdFx0Ly8gdG8gcHJldmVudCBmdXR1cmUgZmFpbGVkIGxvb2t1cHNcbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLnNldChyZWYsIHVuZGVmaW5lZCk7XG4gIFx0XHRyZXR1cm4gcmVmO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1hcHBpbmdJZk5lY2Vzc2FyeShyYWN0aXZlLCBrZXkpIHtcbiAgXHR2YXIgcGFyZW50S2V5cGF0aDtcblxuICBcdGlmICghcmFjdGl2ZS5wYXJlbnQgfHwgcmFjdGl2ZS5pc29sYXRlZCB8fCBpc1Jvb3RQcm9wZXJ0eShyYWN0aXZlLnZpZXdtb2RlbCwga2V5KSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGtleSA9IGdldEtleXBhdGgoa2V5KTtcblxuICBcdGlmIChwYXJlbnRLZXlwYXRoID0gcmVzb2x2ZUFtYmlndW91c1JlZmVyZW5jZShyYWN0aXZlLnBhcmVudCwga2V5LCByYWN0aXZlLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCwgdHJ1ZSkpIHtcbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLm1hcChrZXksIHtcbiAgXHRcdFx0b3JpZ2luOiByYWN0aXZlLnBhcmVudC52aWV3bW9kZWwsXG4gIFx0XHRcdGtleXBhdGg6IHBhcmVudEtleXBhdGhcbiAgXHRcdH0pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUm9vdFByb3BlcnR5KHZpZXdtb2RlbCwga2V5KSB7XG4gIFx0Ly8gc3BlY2lhbCBjYXNlIGZvciByZWZlcmVuY2UgdG8gcm9vdFxuICBcdHJldHVybiBrZXkgPT09IFwiXCIgfHwga2V5IGluIHZpZXdtb2RlbC5kYXRhIHx8IGtleSBpbiB2aWV3bW9kZWwuY29tcHV0YXRpb25zIHx8IGtleSBpbiB2aWV3bW9kZWwubWFwcGluZ3M7XG4gIH1cblxuICBmdW5jdGlvbiB0ZWFyZG93bih4KSB7XG4gICAgeC50ZWFyZG93bigpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWV0aG9kQ2FsbGVyc19fdW5iaW5kKHgpIHtcbiAgICB4LnVuYmluZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWV0aG9kQ2FsbGVyc19fdW5yZW5kZXIoeCkge1xuICAgIHgudW5yZW5kZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCh4KSB7XG4gICAgeC5jYW5jZWwoKTtcbiAgfVxuXG4gIHZhciBUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uIChjYWxsYmFjaywgcGFyZW50KSB7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gIFx0dGhpcy5pbnRyb3MgPSBbXTtcbiAgXHR0aGlzLm91dHJvcyA9IFtdO1xuXG4gIFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuICBcdHRoaXMudG90YWxDaGlsZHJlbiA9IHRoaXMub3V0cm9DaGlsZHJlbiA9IDA7XG5cbiAgXHR0aGlzLmRldGFjaFF1ZXVlID0gW107XG4gIFx0dGhpcy5kZWNvcmF0b3JRdWV1ZSA9IFtdO1xuICBcdHRoaXMub3V0cm9zQ29tcGxldGUgPSBmYWxzZTtcblxuICBcdGlmIChwYXJlbnQpIHtcbiAgXHRcdHBhcmVudC5hZGRDaGlsZCh0aGlzKTtcbiAgXHR9XG4gIH07XG5cbiAgVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlID0ge1xuICBcdGFkZENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgXHRcdHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgXHRcdHRoaXMudG90YWxDaGlsZHJlbiArPSAxO1xuICBcdFx0dGhpcy5vdXRyb0NoaWxkcmVuICs9IDE7XG4gIFx0fSxcblxuICBcdGRlY3JlbWVudE91dHJvczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5vdXRyb0NoaWxkcmVuIC09IDE7XG4gIFx0XHRjaGVjayh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0ZGVjcmVtZW50VG90YWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMudG90YWxDaGlsZHJlbiAtPSAxO1xuICBcdFx0Y2hlY2sodGhpcyk7XG4gIFx0fSxcblxuICBcdGFkZDogZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgXHRcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcbiAgXHRcdGxpc3QucHVzaCh0cmFuc2l0aW9uKTtcbiAgXHR9LFxuXG4gIFx0YWRkRGVjb3JhdG9yOiBmdW5jdGlvbiAoZGVjb3JhdG9yKSB7XG4gIFx0XHR0aGlzLmRlY29yYXRvclF1ZXVlLnB1c2goZGVjb3JhdG9yKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlOiBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICBcdFx0dmFyIGxpc3QgPSB0cmFuc2l0aW9uLmlzSW50cm8gPyB0aGlzLmludHJvcyA6IHRoaXMub3V0cm9zO1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KGxpc3QsIHRyYW5zaXRpb24pO1xuICBcdFx0Y2hlY2sodGhpcyk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuICBcdFx0Y2hlY2sodGhpcyk7XG4gIFx0fSxcblxuICBcdGRldGFjaE5vZGVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmRlY29yYXRvclF1ZXVlLmZvckVhY2godGVhcmRvd24pO1xuICBcdFx0dGhpcy5kZXRhY2hRdWV1ZS5mb3JFYWNoKGRldGFjaCk7XG4gIFx0XHR0aGlzLmNoaWxkcmVuLmZvckVhY2goZGV0YWNoTm9kZXMpO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBkZXRhY2goZWxlbWVudCkge1xuICBcdGVsZW1lbnQuZGV0YWNoKCk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hOb2Rlcyh0bSkge1xuICBcdHRtLmRldGFjaE5vZGVzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVjayh0bSkge1xuICBcdGlmICghdG0ucmVhZHkgfHwgdG0ub3V0cm9zLmxlbmd0aCB8fCB0bS5vdXRyb0NoaWxkcmVuKSByZXR1cm47XG5cbiAgXHQvLyBJZiBhbGwgb3V0cm9zIGFyZSBjb21wbGV0ZSwgYW5kIHdlIGhhdmVuJ3QgYWxyZWFkeSBkb25lIHRoaXMsXG4gIFx0Ly8gd2Ugbm90aWZ5IHRoZSBwYXJlbnQgaWYgdGhlcmUgaXMgb25lLCBvdGhlcndpc2VcbiAgXHQvLyBzdGFydCBkZXRhY2hpbmcgbm9kZXNcbiAgXHRpZiAoIXRtLm91dHJvc0NvbXBsZXRlKSB7XG4gIFx0XHRpZiAodG0ucGFyZW50KSB7XG4gIFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRPdXRyb3ModG0pO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dG0uZGV0YWNoTm9kZXMoKTtcbiAgXHRcdH1cblxuICBcdFx0dG0ub3V0cm9zQ29tcGxldGUgPSB0cnVlO1xuICBcdH1cblxuICBcdC8vIE9uY2UgZXZlcnl0aGluZyBpcyBkb25lLCB3ZSBjYW4gbm90aWZ5IHBhcmVudCB0cmFuc2l0aW9uXG4gIFx0Ly8gbWFuYWdlciBhbmQgY2FsbCB0aGUgY2FsbGJhY2tcbiAgXHRpZiAoIXRtLmludHJvcy5sZW5ndGggJiYgIXRtLnRvdGFsQ2hpbGRyZW4pIHtcbiAgXHRcdGlmICh0eXBlb2YgdG0uY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHR0bS5jYWxsYmFjaygpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodG0ucGFyZW50KSB7XG4gIFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRUb3RhbCgpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBnbG9iYWxfVHJhbnNpdGlvbk1hbmFnZXIgPSBUcmFuc2l0aW9uTWFuYWdlcjtcblxuICB2YXIgYmF0Y2gsXG4gICAgICBydW5sb29wLFxuICAgICAgdW5yZXNvbHZlZCA9IFtdLFxuICAgICAgY2hhbmdlSG9vayA9IG5ldyBob29rc19Ib29rKFwiY2hhbmdlXCIpO1xuXG4gIHJ1bmxvb3AgPSB7XG4gIFx0c3RhcnQ6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcmV0dXJuUHJvbWlzZSkge1xuICBcdFx0dmFyIHByb21pc2UsIGZ1bGZpbFByb21pc2U7XG5cbiAgXHRcdGlmIChyZXR1cm5Qcm9taXNlKSB7XG4gIFx0XHRcdHByb21pc2UgPSBuZXcgdXRpbHNfUHJvbWlzZShmdW5jdGlvbiAoZikge1xuICBcdFx0XHRcdHJldHVybiBmdWxmaWxQcm9taXNlID0gZjtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdGJhdGNoID0ge1xuICBcdFx0XHRwcmV2aW91c0JhdGNoOiBiYXRjaCxcbiAgXHRcdFx0dHJhbnNpdGlvbk1hbmFnZXI6IG5ldyBnbG9iYWxfVHJhbnNpdGlvbk1hbmFnZXIoZnVsZmlsUHJvbWlzZSwgYmF0Y2ggJiYgYmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIpLFxuICBcdFx0XHR2aWV3czogW10sXG4gIFx0XHRcdHRhc2tzOiBbXSxcbiAgXHRcdFx0cmFjdGl2ZXM6IFtdLFxuICBcdFx0XHRpbnN0YW5jZTogaW5zdGFuY2VcbiAgXHRcdH07XG5cbiAgXHRcdGlmIChpbnN0YW5jZSkge1xuICBcdFx0XHRiYXRjaC5yYWN0aXZlcy5wdXNoKGluc3RhbmNlKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fSxcblxuICBcdGVuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0Zmx1c2hDaGFuZ2VzKCk7XG5cbiAgXHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmluaXQoKTtcbiAgXHRcdGlmICghYmF0Y2gucHJldmlvdXNCYXRjaCAmJiAhIWJhdGNoLmluc3RhbmNlKSBiYXRjaC5pbnN0YW5jZS52aWV3bW9kZWwuY2hhbmdlcyA9IFtdO1xuICBcdFx0YmF0Y2ggPSBiYXRjaC5wcmV2aW91c0JhdGNoO1xuICBcdH0sXG5cbiAgXHRhZGRSYWN0aXZlOiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0aWYgKGJhdGNoKSB7XG4gIFx0XHRcdGFkZFRvQXJyYXkoYmF0Y2gucmFjdGl2ZXMsIHJhY3RpdmUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZWdpc3RlclRyYW5zaXRpb246IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gIFx0XHR0cmFuc2l0aW9uLl9tYW5hZ2VyID0gYmF0Y2gudHJhbnNpdGlvbk1hbmFnZXI7XG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5hZGQodHJhbnNpdGlvbik7XG4gIFx0fSxcblxuICBcdHJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbiAoZGVjb3JhdG9yKSB7XG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5hZGREZWNvcmF0b3IoZGVjb3JhdG9yKTtcbiAgXHR9LFxuXG4gIFx0YWRkVmlldzogZnVuY3Rpb24gKHZpZXcpIHtcbiAgXHRcdGJhdGNoLnZpZXdzLnB1c2godmlldyk7XG4gIFx0fSxcblxuICBcdGFkZFVucmVzb2x2ZWQ6IGZ1bmN0aW9uICh0aGluZykge1xuICBcdFx0dW5yZXNvbHZlZC5wdXNoKHRoaW5nKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlVW5yZXNvbHZlZDogZnVuY3Rpb24gKHRoaW5nKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodW5yZXNvbHZlZCwgdGhpbmcpO1xuICBcdH0sXG5cbiAgXHQvLyBzeW5jaHJvbmlzZSBub2RlIGRldGFjaG1lbnRzIHdpdGggdHJhbnNpdGlvbiBlbmRzXG4gIFx0ZGV0YWNoV2hlblJlYWR5OiBmdW5jdGlvbiAodGhpbmcpIHtcbiAgXHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmRldGFjaFF1ZXVlLnB1c2godGhpbmcpO1xuICBcdH0sXG5cbiAgXHRzY2hlZHVsZVRhc2s6IGZ1bmN0aW9uICh0YXNrLCBwb3N0UmVuZGVyKSB7XG4gIFx0XHR2YXIgX2JhdGNoO1xuXG4gIFx0XHRpZiAoIWJhdGNoKSB7XG4gIFx0XHRcdHRhc2soKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdF9iYXRjaCA9IGJhdGNoO1xuICBcdFx0XHR3aGlsZSAocG9zdFJlbmRlciAmJiBfYmF0Y2gucHJldmlvdXNCYXRjaCkge1xuICBcdFx0XHRcdC8vIHRoaXMgY2FuJ3QgaGFwcGVuIHVudGlsIHRoZSBET00gaGFzIGJlZW4gZnVsbHkgdXBkYXRlZFxuICBcdFx0XHRcdC8vIG90aGVyd2lzZSBpbiBzb21lIHNpdHVhdGlvbnMgKHdpdGggY29tcG9uZW50cyBpbnNpZGUgZWxlbWVudHMpXG4gIFx0XHRcdFx0Ly8gdHJhbnNpdGlvbnMgYW5kIGRlY29yYXRvcnMgd2lsbCBpbml0aWFsaXNlIHByZW1hdHVyZWx5XG4gIFx0XHRcdFx0X2JhdGNoID0gX2JhdGNoLnByZXZpb3VzQmF0Y2g7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRfYmF0Y2gudGFza3MucHVzaCh0YXNrKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIGdsb2JhbF9ydW5sb29wID0gcnVubG9vcDtcblxuICBmdW5jdGlvbiBmbHVzaENoYW5nZXMoKSB7XG4gIFx0dmFyIGksIHRoaW5nLCBjaGFuZ2VIYXNoO1xuXG4gIFx0d2hpbGUgKGJhdGNoLnJhY3RpdmVzLmxlbmd0aCkge1xuICBcdFx0dGhpbmcgPSBiYXRjaC5yYWN0aXZlcy5wb3AoKTtcbiAgXHRcdGNoYW5nZUhhc2ggPSB0aGluZy52aWV3bW9kZWwuYXBwbHlDaGFuZ2VzKCk7XG5cbiAgXHRcdGlmIChjaGFuZ2VIYXNoKSB7XG4gIFx0XHRcdGNoYW5nZUhvb2suZmlyZSh0aGluZywgY2hhbmdlSGFzaCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0YXR0ZW1wdEtleXBhdGhSZXNvbHV0aW9uKCk7XG5cbiAgXHQvLyBOb3cgdGhhdCBjaGFuZ2VzIGhhdmUgYmVlbiBmdWxseSBwcm9wYWdhdGVkLCB3ZSBjYW4gdXBkYXRlIHRoZSBET01cbiAgXHQvLyBhbmQgY29tcGxldGUgb3RoZXIgdGFza3NcbiAgXHRmb3IgKGkgPSAwOyBpIDwgYmF0Y2gudmlld3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGJhdGNoLnZpZXdzW2ldLnVwZGF0ZSgpO1xuICBcdH1cbiAgXHRiYXRjaC52aWV3cy5sZW5ndGggPSAwO1xuXG4gIFx0Zm9yIChpID0gMDsgaSA8IGJhdGNoLnRhc2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRiYXRjaC50YXNrc1tpXSgpO1xuICBcdH1cbiAgXHRiYXRjaC50YXNrcy5sZW5ndGggPSAwO1xuXG4gIFx0Ly8gSWYgdXBkYXRpbmcgdGhlIHZpZXcgY2F1c2VkIHNvbWUgbW9kZWwgYmxvd2JhY2sgLSBlLmcuIGEgdHJpcGxlXG4gIFx0Ly8gY29udGFpbmluZyA8b3B0aW9uPiBlbGVtZW50cyBjYXVzZWQgdGhlIGJpbmRpbmcgb24gdGhlIDxzZWxlY3Q+XG4gIFx0Ly8gdG8gdXBkYXRlIC0gdGhlbiB3ZSBzdGFydCBvdmVyXG4gIFx0aWYgKGJhdGNoLnJhY3RpdmVzLmxlbmd0aCkgcmV0dXJuIGZsdXNoQ2hhbmdlcygpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0ZW1wdEtleXBhdGhSZXNvbHV0aW9uKCkge1xuICBcdHZhciBpLCBpdGVtLCBrZXlwYXRoLCByZXNvbHZlZDtcblxuICBcdGkgPSB1bnJlc29sdmVkLmxlbmd0aDtcblxuICBcdC8vIHNlZSBpZiB3ZSBjYW4gcmVzb2x2ZSBhbnkgdW5yZXNvbHZlZCByZWZlcmVuY2VzXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aXRlbSA9IHVucmVzb2x2ZWRbaV07XG5cbiAgXHRcdGlmIChpdGVtLmtleXBhdGgpIHtcbiAgXHRcdFx0Ly8gaXQgcmVzb2x2ZWQgc29tZSBvdGhlciB3YXkuIFRPRE8gaG93PyB0d28td2F5IGJpbmRpbmc/IFNlZW1zXG4gIFx0XHRcdC8vIHdlaXJkIHRoYXQgd2UnZCBzdGlsbCBlbmQgdXAgaGVyZVxuICBcdFx0XHR1bnJlc29sdmVkLnNwbGljZShpLCAxKTtcbiAgXHRcdFx0Y29udGludWU7IC8vIGF2b2lkIHJlbW92aW5nIHRoZSB3cm9uZyB0aGluZyBzaG91bGQgdGhlIG5leHQgY29uZGl0aW9uIGJlIHRydWVcbiAgXHRcdH1cblxuICBcdFx0aWYgKGtleXBhdGggPSBzaGFyZWRfcmVzb2x2ZVJlZihpdGVtLnJvb3QsIGl0ZW0ucmVmLCBpdGVtLnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0XHQocmVzb2x2ZWQgfHwgKHJlc29sdmVkID0gW10pKS5wdXNoKHtcbiAgXHRcdFx0XHRpdGVtOiBpdGVtLFxuICBcdFx0XHRcdGtleXBhdGg6IGtleXBhdGhcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0dW5yZXNvbHZlZC5zcGxpY2UoaSwgMSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHJlc29sdmVkKSB7XG4gIFx0XHRyZXNvbHZlZC5mb3JFYWNoKGdsb2JhbF9ydW5sb29wX19yZXNvbHZlKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnbG9iYWxfcnVubG9vcF9fcmVzb2x2ZShyZXNvbHZlZCkge1xuICBcdHJlc29sdmVkLml0ZW0ucmVzb2x2ZShyZXNvbHZlZC5rZXlwYXRoKTtcbiAgfVxuXG4gIHZhciBxdWV1ZSA9IFtdO1xuXG4gIHZhciBhbmltYXRpb25zID0ge1xuICBcdHRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBpLCBhbmltYXRpb24sIG5vdztcblxuICBcdFx0bm93ID0gdXRpbHNfZ2V0VGltZSgpO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCgpO1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0YW5pbWF0aW9uID0gcXVldWVbaV07XG5cbiAgXHRcdFx0aWYgKCFhbmltYXRpb24udGljayhub3cpKSB7XG4gIFx0XHRcdFx0Ly8gYW5pbWF0aW9uIGlzIGNvbXBsZXRlLCByZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIGFuZCBkZWNyZW1lbnQgaSBzbyB3ZSBkb24ndCBtaXNzIG9uZVxuICBcdFx0XHRcdHF1ZXVlLnNwbGljZShpLS0sIDEpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0XHRpZiAocXVldWUubGVuZ3RoKSB7XG4gIFx0XHRcdHJBRihhbmltYXRpb25zLnRpY2spO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0YW5pbWF0aW9ucy5ydW5uaW5nID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGFkZDogZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICBcdFx0cXVldWUucHVzaChhbmltYXRpb24pO1xuXG4gIFx0XHRpZiAoIWFuaW1hdGlvbnMucnVubmluZykge1xuICBcdFx0XHRhbmltYXRpb25zLnJ1bm5pbmcgPSB0cnVlO1xuICBcdFx0XHRyQUYoYW5pbWF0aW9ucy50aWNrKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gVE9ETyBvcHRpbWlzZSB0aGlzXG4gIFx0YWJvcnQ6IGZ1bmN0aW9uIChrZXlwYXRoLCByb290KSB7XG4gIFx0XHR2YXIgaSA9IHF1ZXVlLmxlbmd0aCxcbiAgXHRcdCAgICBhbmltYXRpb247XG5cbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0YW5pbWF0aW9uID0gcXVldWVbaV07XG5cbiAgXHRcdFx0aWYgKGFuaW1hdGlvbi5yb290ID09PSByb290ICYmIGFuaW1hdGlvbi5rZXlwYXRoID09PSBrZXlwYXRoKSB7XG4gIFx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgc2hhcmVkX2FuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXG4gIHZhciBBbmltYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBrZXk7XG5cbiAgXHR0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgXHQvLyBmcm9tIGFuZCB0b1xuICBcdGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgXHRcdGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0dGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMuaW50ZXJwb2xhdG9yID0gc2hhcmVkX2ludGVycG9sYXRlKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5yb290LCB0aGlzLmludGVycG9sYXRvcik7XG4gIFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICBcdHRoaXMudGljaygpO1xuICB9O1xuXG4gIEFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG4gIFx0dGljazogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGVsYXBzZWQsIHQsIHZhbHVlLCB0aW1lTm93LCBpbmRleCwga2V5cGF0aDtcblxuICBcdFx0a2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcblxuICBcdFx0aWYgKHRoaXMucnVubmluZykge1xuICBcdFx0XHR0aW1lTm93ID0gRGF0ZS5ub3coKTtcbiAgXHRcdFx0ZWxhcHNlZCA9IHRpbWVOb3cgLSB0aGlzLnN0YXJ0VGltZTtcblxuICBcdFx0XHRpZiAoZWxhcHNlZCA+PSB0aGlzLmR1cmF0aW9uKSB7XG4gIFx0XHRcdFx0aWYgKGtleXBhdGggIT09IG51bGwpIHtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMucm9vdCk7XG4gIFx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldChrZXlwYXRoLCB0aGlzLnRvKTtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0XHRcdHRoaXMuc3RlcCgxLCB0aGlzLnRvKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHR0aGlzLmNvbXBsZXRlKHRoaXMudG8pO1xuXG4gIFx0XHRcdFx0aW5kZXggPSB0aGlzLnJvb3QuX2FuaW1hdGlvbnMuaW5kZXhPZih0aGlzKTtcblxuICBcdFx0XHRcdC8vIFRPRE8gaW52ZXN0aWdhdGUgd2h5IHRoaXMgaGFwcGVuc1xuICBcdFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0XHRcdHdhcm5JZkRlYnVnKFwiQW5pbWF0aW9uIHdhcyBub3QgZm91bmRcIik7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0dGhpcy5yb290Ll9hbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgXHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIHJlbW92ZSBmcm9tIHRoZSBzdGFja1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dCA9IHRoaXMuZWFzaW5nID8gdGhpcy5lYXNpbmcoZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24pIDogZWxhcHNlZCAvIHRoaXMuZHVyYXRpb247XG5cbiAgXHRcdFx0aWYgKGtleXBhdGggIT09IG51bGwpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IHRoaXMuaW50ZXJwb2xhdG9yKHQpO1xuICBcdFx0XHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMucm9vdCk7XG4gIFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHRoaXMuc3RlcCkge1xuICBcdFx0XHRcdHRoaXMuc3RlcCh0LCB2YWx1ZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8ga2VlcCBpbiB0aGUgc3RhY2tcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGZhbHNlOyAvLyByZW1vdmUgZnJvbSB0aGUgc3RhY2tcbiAgXHR9LFxuXG4gIFx0c3RvcDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGluZGV4O1xuXG4gIFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuICBcdFx0aW5kZXggPSB0aGlzLnJvb3QuX2FuaW1hdGlvbnMuaW5kZXhPZih0aGlzKTtcblxuICBcdFx0Ly8gVE9ETyBpbnZlc3RpZ2F0ZSB3aHkgdGhpcyBoYXBwZW5zXG4gIFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKFwiQW5pbWF0aW9uIHdhcyBub3QgZm91bmRcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucm9vdC5fYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgYW5pbWF0ZV9BbmltYXRpb24gPSBBbmltYXRpb247XG5cbiAgdmFyIHByb3RvdHlwZV9hbmltYXRlID0gUmFjdGl2ZSRhbmltYXRlO1xuXG4gIHZhciBub0FuaW1hdGlvbiA9IHsgc3RvcDogbm9vcCB9O1xuICBmdW5jdGlvbiBSYWN0aXZlJGFuaW1hdGUoa2V5cGF0aCwgdG8sIG9wdGlvbnMpIHtcbiAgXHR2YXIgcHJvbWlzZSwgZnVsZmlsUHJvbWlzZSwgaywgYW5pbWF0aW9uLCBhbmltYXRpb25zLCBlYXNpbmcsIGR1cmF0aW9uLCBzdGVwLCBjb21wbGV0ZSwgbWFrZVZhbHVlQ29sbGVjdG9yLCBjdXJyZW50VmFsdWVzLCBjb2xsZWN0VmFsdWUsIGR1bW15LCBkdW1teU9wdGlvbnM7XG5cbiAgXHRwcm9taXNlID0gbmV3IHV0aWxzX1Byb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCkge1xuICBcdFx0cmV0dXJuIGZ1bGZpbFByb21pc2UgPSBmdWxmaWw7XG4gIFx0fSk7XG5cbiAgXHQvLyBhbmltYXRlIG11bHRpcGxlIGtleXBhdGhzXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRvcHRpb25zID0gdG8gfHwge307XG4gIFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgXHRcdGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcblxuICBcdFx0YW5pbWF0aW9ucyA9IFtdO1xuXG4gIFx0XHQvLyB3ZSBkb24ndCB3YW50IHRvIHBhc3MgdGhlIGBzdGVwYCBhbmQgYGNvbXBsZXRlYCBoYW5kbGVycywgYXMgdGhleSB3aWxsXG4gIFx0XHQvLyBydW4gZm9yIGVhY2ggYW5pbWF0aW9uISBTbyBpbnN0ZWFkIHdlJ2xsIHN0b3JlIHRoZSBoYW5kbGVycyBhbmQgY3JlYXRlXG4gIFx0XHQvLyBvdXIgb3duLi4uXG4gIFx0XHRzdGVwID0gb3B0aW9ucy5zdGVwO1xuICBcdFx0Y29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuXG4gIFx0XHRpZiAoc3RlcCB8fCBjb21wbGV0ZSkge1xuICBcdFx0XHRjdXJyZW50VmFsdWVzID0ge307XG5cbiAgXHRcdFx0b3B0aW9ucy5zdGVwID0gbnVsbDtcbiAgXHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IG51bGw7XG5cbiAgXHRcdFx0bWFrZVZhbHVlQ29sbGVjdG9yID0gZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQsIHZhbHVlKSB7XG4gIFx0XHRcdFx0XHRjdXJyZW50VmFsdWVzW2tleXBhdGhdID0gdmFsdWU7XG4gIFx0XHRcdFx0fTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChrIGluIGtleXBhdGgpIHtcbiAgXHRcdFx0aWYgKGtleXBhdGguaGFzT3duUHJvcGVydHkoaykpIHtcbiAgXHRcdFx0XHRpZiAoc3RlcCB8fCBjb21wbGV0ZSkge1xuICBcdFx0XHRcdFx0Y29sbGVjdFZhbHVlID0gbWFrZVZhbHVlQ29sbGVjdG9yKGspO1xuICBcdFx0XHRcdFx0b3B0aW9ucyA9IHsgZWFzaW5nOiBlYXNpbmcsIGR1cmF0aW9uOiBkdXJhdGlvbiB9O1xuXG4gIFx0XHRcdFx0XHRpZiAoc3RlcCkge1xuICBcdFx0XHRcdFx0XHRvcHRpb25zLnN0ZXAgPSBjb2xsZWN0VmFsdWU7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNvbXBsZXRlID8gY29sbGVjdFZhbHVlIDogbm9vcDtcbiAgXHRcdFx0XHRhbmltYXRpb25zLnB1c2goYW5pbWF0ZSh0aGlzLCBrLCBrZXlwYXRoW2tdLCBvcHRpb25zKSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gQ3JlYXRlIGEgZHVtbXkgYW5pbWF0aW9uLCB0byBmYWNpbGl0YXRlIHN0ZXAvY29tcGxldGVcbiAgXHRcdC8vIGNhbGxiYWNrcywgYW5kIFByb21pc2UgZnVsZmlsbWVudFxuICBcdFx0ZHVtbXlPcHRpb25zID0geyBlYXNpbmc6IGVhc2luZywgZHVyYXRpb246IGR1cmF0aW9uIH07XG5cbiAgXHRcdGlmIChzdGVwKSB7XG4gIFx0XHRcdGR1bW15T3B0aW9ucy5zdGVwID0gZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0XHRyZXR1cm4gc3RlcCh0LCBjdXJyZW50VmFsdWVzKTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGNvbXBsZXRlKSB7XG4gIFx0XHRcdHByb21pc2UudGhlbihmdW5jdGlvbiAodCkge1xuICBcdFx0XHRcdHJldHVybiBjb21wbGV0ZSh0LCBjdXJyZW50VmFsdWVzKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdGR1bW15T3B0aW9ucy5jb21wbGV0ZSA9IGZ1bGZpbFByb21pc2U7XG5cbiAgXHRcdGR1bW15ID0gYW5pbWF0ZSh0aGlzLCBudWxsLCBudWxsLCBkdW1teU9wdGlvbnMpO1xuICBcdFx0YW5pbWF0aW9ucy5wdXNoKGR1bW15KTtcblxuICBcdFx0cHJvbWlzZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgYW5pbWF0aW9uO1xuXG4gIFx0XHRcdHdoaWxlIChhbmltYXRpb24gPSBhbmltYXRpb25zLnBvcCgpKSB7XG4gIFx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChkdW1teSkge1xuICBcdFx0XHRcdGR1bW15LnN0b3AoKTtcbiAgXHRcdFx0fVxuICBcdFx0fTtcblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fVxuXG4gIFx0Ly8gYW5pbWF0ZSBhIHNpbmdsZSBrZXlwYXRoXG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgXHRpZiAob3B0aW9ucy5jb21wbGV0ZSkge1xuICBcdFx0cHJvbWlzZS50aGVuKG9wdGlvbnMuY29tcGxldGUpO1xuICBcdH1cblxuICBcdG9wdGlvbnMuY29tcGxldGUgPSBmdWxmaWxQcm9taXNlO1xuICBcdGFuaW1hdGlvbiA9IGFuaW1hdGUodGhpcywga2V5cGF0aCwgdG8sIG9wdGlvbnMpO1xuXG4gIFx0cHJvbWlzZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGFuaW1hdGlvbi5zdG9wKCk7XG4gIFx0fTtcbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuaW1hdGUocm9vdCwga2V5cGF0aCwgdG8sIG9wdGlvbnMpIHtcbiAgXHR2YXIgZWFzaW5nLCBkdXJhdGlvbiwgYW5pbWF0aW9uLCBmcm9tO1xuXG4gIFx0aWYgKGtleXBhdGgpIHtcbiAgXHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG4gIFx0fVxuXG4gIFx0aWYgKGtleXBhdGggIT09IG51bGwpIHtcbiAgXHRcdGZyb20gPSByb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0fVxuXG4gIFx0Ly8gY2FuY2VsIGFueSBleGlzdGluZyBhbmltYXRpb25cbiAgXHQvLyBUT0RPIHdoYXQgYWJvdXQgdXBzdHJlYW0vZG93bnN0cmVhbSBrZXlwYXRocz9cbiAgXHRzaGFyZWRfYW5pbWF0aW9ucy5hYm9ydChrZXlwYXRoLCByb290KTtcblxuICBcdC8vIGRvbid0IGJvdGhlciBhbmltYXRpbmcgdmFsdWVzIHRoYXQgc3RheSB0aGUgc2FtZVxuICBcdGlmIChpc0VxdWFsKGZyb20sIHRvKSkge1xuICBcdFx0aWYgKG9wdGlvbnMuY29tcGxldGUpIHtcbiAgXHRcdFx0b3B0aW9ucy5jb21wbGV0ZShvcHRpb25zLnRvKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG5vQW5pbWF0aW9uO1xuICBcdH1cblxuICBcdC8vIGVhc2luZyBmdW5jdGlvblxuICBcdGlmIChvcHRpb25zLmVhc2luZykge1xuICBcdFx0aWYgKHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZWFzaW5nID0gcm9vdC5lYXNpbmdbb3B0aW9ucy5lYXNpbmddO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodHlwZW9mIGVhc2luZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdGVhc2luZyA9IG51bGw7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gZHVyYXRpb25cbiAgXHRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IDQwMCA6IG9wdGlvbnMuZHVyYXRpb247XG5cbiAgXHQvLyBUT0RPIHN0b3JlIGtleXMsIHVzZSBhbiBpbnRlcm5hbCBzZXQgbWV0aG9kXG4gIFx0YW5pbWF0aW9uID0gbmV3IGFuaW1hdGVfQW5pbWF0aW9uKHtcbiAgXHRcdGtleXBhdGg6IGtleXBhdGgsXG4gIFx0XHRmcm9tOiBmcm9tLFxuICBcdFx0dG86IHRvLFxuICBcdFx0cm9vdDogcm9vdCxcbiAgXHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgXHRcdGVhc2luZzogZWFzaW5nLFxuICBcdFx0aW50ZXJwb2xhdG9yOiBvcHRpb25zLmludGVycG9sYXRvcixcblxuICBcdFx0Ly8gVE9ETyB3cmFwIGNhbGxiYWNrcyBpZiBuZWNlc3NhcnksIHRvIHVzZSBpbnN0YW5jZSBhcyBjb250ZXh0XG4gIFx0XHRzdGVwOiBvcHRpb25zLnN0ZXAsXG4gIFx0XHRjb21wbGV0ZTogb3B0aW9ucy5jb21wbGV0ZVxuICBcdH0pO1xuXG4gIFx0c2hhcmVkX2FuaW1hdGlvbnMuYWRkKGFuaW1hdGlvbik7XG4gIFx0cm9vdC5fYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG5cbiAgXHRyZXR1cm4gYW5pbWF0aW9uO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9kZXRhY2ggPSBSYWN0aXZlJGRldGFjaDtcbiAgdmFyIHByb3RvdHlwZV9kZXRhY2hfX2RldGFjaEhvb2sgPSBuZXcgaG9va3NfSG9vayhcImRldGFjaFwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRkZXRhY2goKSB7XG4gIFx0aWYgKHRoaXMuZGV0YWNoZWQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmRldGFjaGVkO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmVsKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMpO1xuICBcdH1cbiAgXHR0aGlzLmRldGFjaGVkID0gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHRwcm90b3R5cGVfZGV0YWNoX19kZXRhY2hIb29rLmZpcmUodGhpcyk7XG4gIFx0cmV0dXJuIHRoaXMuZGV0YWNoZWQ7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmQgPSBSYWN0aXZlJGZpbmQ7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0aWYgKCF0aGlzLmVsKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgfVxuXG4gIHZhciB0ZXN0ID0gUXVlcnkkdGVzdDtcbiAgZnVuY3Rpb24gUXVlcnkkdGVzdChpdGVtLCBub0RpcnR5KSB7XG4gIFx0dmFyIGl0ZW1NYXRjaGVzO1xuXG4gIFx0aWYgKHRoaXMuX2lzQ29tcG9uZW50UXVlcnkpIHtcbiAgXHRcdGl0ZW1NYXRjaGVzID0gIXRoaXMuc2VsZWN0b3IgfHwgaXRlbS5uYW1lID09PSB0aGlzLnNlbGVjdG9yO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRpdGVtTWF0Y2hlcyA9IGl0ZW0ubm9kZSA/IG1hdGNoZXMoaXRlbS5ub2RlLCB0aGlzLnNlbGVjdG9yKSA6IG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKGl0ZW1NYXRjaGVzKSB7XG4gIFx0XHR0aGlzLnB1c2goaXRlbS5ub2RlIHx8IGl0ZW0uaW5zdGFuY2UpO1xuXG4gIFx0XHRpZiAoIW5vRGlydHkpIHtcbiAgXHRcdFx0dGhpcy5fbWFrZURpcnR5KCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIHZhciBtYWtlUXVlcnlfY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICBcdHZhciBsaXZlUXVlcmllcywgc2VsZWN0b3IsIGluZGV4O1xuXG4gIFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9yb290W3RoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBcImxpdmVDb21wb25lbnRRdWVyaWVzXCIgOiBcImxpdmVRdWVyaWVzXCJdO1xuICBcdHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcblxuICBcdGluZGV4ID0gbGl2ZVF1ZXJpZXMuaW5kZXhPZihzZWxlY3Rvcik7XG5cbiAgXHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRsaXZlUXVlcmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0bGl2ZVF1ZXJpZXNbc2VsZWN0b3JdID0gbnVsbDtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIHNvcnRCeUl0ZW1Qb3NpdGlvbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIFx0dmFyIGFuY2VzdHJ5QSwgYW5jZXN0cnlCLCBvbGRlc3RBLCBvbGRlc3RCLCBtdXR1YWxBbmNlc3RvciwgaW5kZXhBLCBpbmRleEIsIGZyYWdtZW50cywgZnJhZ21lbnRBLCBmcmFnbWVudEI7XG5cbiAgXHRhbmNlc3RyeUEgPSBnZXRBbmNlc3RyeShhLmNvbXBvbmVudCB8fCBhLl9yYWN0aXZlLnByb3h5KTtcbiAgXHRhbmNlc3RyeUIgPSBnZXRBbmNlc3RyeShiLmNvbXBvbmVudCB8fCBiLl9yYWN0aXZlLnByb3h5KTtcblxuICBcdG9sZGVzdEEgPSBsYXN0SXRlbShhbmNlc3RyeUEpO1xuICBcdG9sZGVzdEIgPSBsYXN0SXRlbShhbmNlc3RyeUIpO1xuXG4gIFx0Ly8gcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIGVuZCBvZiBib3RoIGFuY2VzdHJpZXMgYXMgbG9uZyBhcyB0aGV5IGFyZSBpZGVudGljYWxcbiAgXHQvLyAtIHRoZSBmaW5hbCBvbmUgcmVtb3ZlZCBpcyB0aGUgY2xvc2VzdCBtdXR1YWwgYW5jZXN0b3JcbiAgXHR3aGlsZSAob2xkZXN0QSAmJiBvbGRlc3RBID09PSBvbGRlc3RCKSB7XG4gIFx0XHRhbmNlc3RyeUEucG9wKCk7XG4gIFx0XHRhbmNlc3RyeUIucG9wKCk7XG5cbiAgXHRcdG11dHVhbEFuY2VzdG9yID0gb2xkZXN0QTtcblxuICBcdFx0b2xkZXN0QSA9IGxhc3RJdGVtKGFuY2VzdHJ5QSk7XG4gIFx0XHRvbGRlc3RCID0gbGFzdEl0ZW0oYW5jZXN0cnlCKTtcbiAgXHR9XG5cbiAgXHQvLyBub3cgdGhhdCB3ZSBoYXZlIHRoZSBtdXR1YWwgYW5jZXN0b3IsIHdlIGNhbiBmaW5kIHdoaWNoIGlzIGVhcmxpZXN0XG4gIFx0b2xkZXN0QSA9IG9sZGVzdEEuY29tcG9uZW50IHx8IG9sZGVzdEE7XG4gIFx0b2xkZXN0QiA9IG9sZGVzdEIuY29tcG9uZW50IHx8IG9sZGVzdEI7XG5cbiAgXHRmcmFnbWVudEEgPSBvbGRlc3RBLnBhcmVudEZyYWdtZW50O1xuICBcdGZyYWdtZW50QiA9IG9sZGVzdEIucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHQvLyBpZiBib3RoIGl0ZW1zIHNoYXJlIGEgcGFyZW50IGZyYWdtZW50LCBvdXIgam9iIGlzIGVhc3lcbiAgXHRpZiAoZnJhZ21lbnRBID09PSBmcmFnbWVudEIpIHtcbiAgXHRcdGluZGV4QSA9IGZyYWdtZW50QS5pdGVtcy5pbmRleE9mKG9sZGVzdEEpO1xuICBcdFx0aW5kZXhCID0gZnJhZ21lbnRCLml0ZW1zLmluZGV4T2Yob2xkZXN0Qik7XG5cbiAgXHRcdC8vIGlmIGl0J3MgdGhlIHNhbWUgaW5kZXgsIGl0IG1lYW5zIG9uZSBjb250YWlucyB0aGUgb3RoZXIsXG4gIFx0XHQvLyBzbyB3ZSBzZWUgd2hpY2ggaGFzIHRoZSBsb25nZXN0IGFuY2VzdHJ5XG4gIFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuICBcdH1cblxuICBcdC8vIGlmIG11dHVhbCBhbmNlc3RvciBpcyBhIHNlY3Rpb24sIHdlIGZpcnN0IHRlc3QgdG8gc2VlIHdoaWNoIHNlY3Rpb25cbiAgXHQvLyBmcmFnbWVudCBjb21lcyBmaXJzdFxuICBcdGlmIChmcmFnbWVudHMgPSBtdXR1YWxBbmNlc3Rvci5mcmFnbWVudHMpIHtcbiAgXHRcdGluZGV4QSA9IGZyYWdtZW50cy5pbmRleE9mKGZyYWdtZW50QSk7XG4gIFx0XHRpbmRleEIgPSBmcmFnbWVudHMuaW5kZXhPZihmcmFnbWVudEIpO1xuXG4gIFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuICBcdH1cblxuICBcdHRocm93IG5ldyBFcnJvcihcIkFuIHVuZXhwZWN0ZWQgY29uZGl0aW9uIHdhcyBtZXQgd2hpbGUgY29tcGFyaW5nIHRoZSBwb3NpdGlvbiBvZiB0d28gY29tcG9uZW50cy4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyFcIik7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50KGl0ZW0pIHtcbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQ7XG5cbiAgXHRpZiAocGFyZW50RnJhZ21lbnQgPSBpdGVtLnBhcmVudEZyYWdtZW50KSB7XG4gIFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG4gIFx0fVxuXG4gIFx0aWYgKGl0ZW0uY29tcG9uZW50ICYmIChwYXJlbnRGcmFnbWVudCA9IGl0ZW0uY29tcG9uZW50LnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0cmV0dXJuIHBhcmVudEZyYWdtZW50Lm93bmVyO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuY2VzdHJ5KGl0ZW0pIHtcbiAgXHR2YXIgYW5jZXN0cnksIGFuY2VzdG9yO1xuXG4gIFx0YW5jZXN0cnkgPSBbaXRlbV07XG5cbiAgXHRhbmNlc3RvciA9IGdldFBhcmVudChpdGVtKTtcblxuICBcdHdoaWxlIChhbmNlc3Rvcikge1xuICBcdFx0YW5jZXN0cnkucHVzaChhbmNlc3Rvcik7XG4gIFx0XHRhbmNlc3RvciA9IGdldFBhcmVudChhbmNlc3Rvcik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGFuY2VzdHJ5O1xuICB9XG5cbiAgdmFyIHNvcnRCeURvY3VtZW50UG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSwgb3RoZXJOb2RlKSB7XG4gIFx0dmFyIGJpdG1hc2s7XG5cbiAgXHRpZiAobm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICBcdFx0Yml0bWFzayA9IG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXJOb2RlKTtcbiAgXHRcdHJldHVybiBiaXRtYXNrICYgMiA/IDEgOiAtMTtcbiAgXHR9XG5cbiAgXHQvLyBJbiBvbGQgSUUsIHdlIGNhbiBwaWdneSBiYWNrIG9uIHRoZSBtZWNoYW5pc20gZm9yXG4gIFx0Ly8gY29tcGFyaW5nIGNvbXBvbmVudCBwb3NpdGlvbnNcbiAgXHRyZXR1cm4gc29ydEJ5SXRlbVBvc2l0aW9uKG5vZGUsIG90aGVyTm9kZSk7XG4gIH07XG5cbiAgdmFyIHNvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dGhpcy5zb3J0KHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBzb3J0QnlJdGVtUG9zaXRpb24gOiBzb3J0QnlEb2N1bWVudFBvc2l0aW9uKTtcbiAgXHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBtYWtlUXVlcnlfZGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdGlmICghdGhpcy5fZGlydHkpIHtcbiAgXHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblxuICBcdFx0Ly8gT25jZSB0aGUgRE9NIGhhcyBiZWVuIHVwZGF0ZWQsIGVuc3VyZSB0aGUgcXVlcnlcbiAgXHRcdC8vIGlzIGNvcnJlY3RseSBvcmRlcmVkXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRfdGhpcy5fc29ydCgpO1xuICBcdFx0fSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciByZW1vdmUgPSBmdW5jdGlvbiAobm9kZU9yQ29tcG9uZW50KSB7XG4gIFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBub2RlT3JDb21wb25lbnQuaW5zdGFuY2UgOiBub2RlT3JDb21wb25lbnQpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0dGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgX21ha2VRdWVyeSA9IG1ha2VRdWVyeTtcbiAgZnVuY3Rpb24gbWFrZVF1ZXJ5KHJhY3RpdmUsIHNlbGVjdG9yLCBsaXZlLCBpc0NvbXBvbmVudFF1ZXJ5KSB7XG4gIFx0dmFyIHF1ZXJ5ID0gW107XG5cbiAgXHRkZWZpbmVQcm9wZXJ0aWVzKHF1ZXJ5LCB7XG4gIFx0XHRzZWxlY3RvcjogeyB2YWx1ZTogc2VsZWN0b3IgfSxcbiAgXHRcdGxpdmU6IHsgdmFsdWU6IGxpdmUgfSxcblxuICBcdFx0X2lzQ29tcG9uZW50UXVlcnk6IHsgdmFsdWU6IGlzQ29tcG9uZW50UXVlcnkgfSxcbiAgXHRcdF90ZXN0OiB7IHZhbHVlOiB0ZXN0IH1cbiAgXHR9KTtcblxuICBcdGlmICghbGl2ZSkge1xuICBcdFx0cmV0dXJuIHF1ZXJ5O1xuICBcdH1cblxuICBcdGRlZmluZVByb3BlcnRpZXMocXVlcnksIHtcbiAgXHRcdGNhbmNlbDogeyB2YWx1ZTogbWFrZVF1ZXJ5X2NhbmNlbCB9LFxuXG4gIFx0XHRfcm9vdDogeyB2YWx1ZTogcmFjdGl2ZSB9LFxuICBcdFx0X3NvcnQ6IHsgdmFsdWU6IHNvcnQgfSxcbiAgXHRcdF9tYWtlRGlydHk6IHsgdmFsdWU6IG1ha2VRdWVyeV9kaXJ0eSB9LFxuICBcdFx0X3JlbW92ZTogeyB2YWx1ZTogcmVtb3ZlIH0sXG5cbiAgXHRcdF9kaXJ0eTogeyB2YWx1ZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH1cbiAgXHR9KTtcblxuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmluZEFsbCA9IFJhY3RpdmUkZmluZEFsbDtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQWxsKHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gIFx0dmFyIGxpdmVRdWVyaWVzLCBxdWVyeTtcblxuICBcdGlmICghdGhpcy5lbCkge1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH1cblxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZVF1ZXJpZXM7XG5cbiAgXHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuICBcdC8vIHNlbGVjdG9yLCB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSBwYXJhbGxlbCBET01cbiAgXHRpZiAocXVlcnkgPSBsaXZlUXVlcmllc1tzZWxlY3Rvcl0pIHtcblxuICBcdFx0Ly8gRWl0aGVyIHJldHVybiB0aGUgZXhhY3Qgc2FtZSBxdWVyeSwgb3IgKGlmIG5vdCBsaXZlKSBhIHNuYXBzaG90XG4gIFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmxpdmUgPyBxdWVyeSA6IHF1ZXJ5LnNsaWNlKCk7XG4gIFx0fVxuXG4gIFx0cXVlcnkgPSBfbWFrZVF1ZXJ5KHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgZmFsc2UpO1xuXG4gIFx0Ly8gQWRkIHRoaXMgdG8gdGhlIGxpc3Qgb2YgbGl2ZSBxdWVyaWVzIFJhY3RpdmUgbmVlZHMgdG8gbWFpbnRhaW4sXG4gIFx0Ly8gaWYgYXBwbGljYWJsZVxuICBcdGlmIChxdWVyeS5saXZlKSB7XG4gIFx0XHRsaXZlUXVlcmllcy5wdXNoKHNlbGVjdG9yKTtcbiAgXHRcdGxpdmVRdWVyaWVzW1wiX1wiICsgc2VsZWN0b3JdID0gcXVlcnk7XG4gIFx0fVxuXG4gIFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyA9IFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHM7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgXHR2YXIgbGl2ZVF1ZXJpZXMsIHF1ZXJ5O1xuXG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9saXZlQ29tcG9uZW50UXVlcmllcztcblxuICBcdC8vIFNob3J0Y3V0OiBpZiB3ZSdyZSBtYWludGFpbmluZyBhIGxpdmUgcXVlcnkgd2l0aCB0aGlzXG4gIFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuICBcdGlmIChxdWVyeSA9IGxpdmVRdWVyaWVzW3NlbGVjdG9yXSkge1xuXG4gIFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3RcbiAgXHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMubGl2ZSA/IHF1ZXJ5IDogcXVlcnkuc2xpY2UoKTtcbiAgXHR9XG5cbiAgXHRxdWVyeSA9IF9tYWtlUXVlcnkodGhpcywgc2VsZWN0b3IsICEhb3B0aW9ucy5saXZlLCB0cnVlKTtcblxuICBcdC8vIEFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGxpdmUgcXVlcmllcyBSYWN0aXZlIG5lZWRzIHRvIG1haW50YWluLFxuICBcdC8vIGlmIGFwcGxpY2FibGVcbiAgXHRpZiAocXVlcnkubGl2ZSkge1xuICBcdFx0bGl2ZVF1ZXJpZXMucHVzaChzZWxlY3Rvcik7XG4gIFx0XHRsaXZlUXVlcmllc1tcIl9cIiArIHNlbGVjdG9yXSA9IHF1ZXJ5O1xuICBcdH1cblxuICBcdHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmRDb21wb25lbnQgPSBSYWN0aXZlJGZpbmRDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQ29tcG9uZW50KHNlbGVjdG9yKSB7XG4gIFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudChzZWxlY3Rvcik7XG4gIH1cblxuICB2YXIgZmluZENvbnRhaW5lciA9IFJhY3RpdmUkZmluZENvbnRhaW5lcjtcblxuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRDb250YWluZXIoc2VsZWN0b3IpIHtcbiAgXHRpZiAodGhpcy5jb250YWluZXIpIHtcbiAgXHRcdGlmICh0aGlzLmNvbnRhaW5lci5jb21wb25lbnQgJiYgdGhpcy5jb250YWluZXIuY29tcG9uZW50Lm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmNvbnRhaW5lci5maW5kQ29udGFpbmVyKHNlbGVjdG9yKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmaW5kUGFyZW50ID0gUmFjdGl2ZSRmaW5kUGFyZW50O1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZFBhcmVudChzZWxlY3Rvcikge1xuXG4gIFx0aWYgKHRoaXMucGFyZW50KSB7XG4gIFx0XHRpZiAodGhpcy5wYXJlbnQuY29tcG9uZW50ICYmIHRoaXMucGFyZW50LmNvbXBvbmVudC5uYW1lID09PSBzZWxlY3Rvcikge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQuZmluZFBhcmVudChzZWxlY3Rvcik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnRTdGFjayA9IHtcbiAgXHRlbnF1ZXVlOiBmdW5jdGlvbiAocmFjdGl2ZSwgZXZlbnQpIHtcbiAgXHRcdGlmIChyYWN0aXZlLmV2ZW50KSB7XG4gIFx0XHRcdHJhY3RpdmUuX2V2ZW50UXVldWUgPSByYWN0aXZlLl9ldmVudFF1ZXVlIHx8IFtdO1xuICBcdFx0XHRyYWN0aXZlLl9ldmVudFF1ZXVlLnB1c2gocmFjdGl2ZS5ldmVudCk7XG4gIFx0XHR9XG4gIFx0XHRyYWN0aXZlLmV2ZW50ID0gZXZlbnQ7XG4gIFx0fSxcbiAgXHRkZXF1ZXVlOiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0aWYgKHJhY3RpdmUuX2V2ZW50UXVldWUgJiYgcmFjdGl2ZS5fZXZlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgXHRcdFx0cmFjdGl2ZS5ldmVudCA9IHJhY3RpdmUuX2V2ZW50UXVldWUucG9wKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRkZWxldGUgcmFjdGl2ZS5ldmVudDtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9ldmVudFN0YWNrID0gZXZlbnRTdGFjaztcblxuICB2YXIgc2hhcmVkX2ZpcmVFdmVudCA9IGZpcmVFdmVudDtcblxuICBmdW5jdGlvbiBmaXJlRXZlbnQocmFjdGl2ZSwgZXZlbnROYW1lKSB7XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gIFx0aWYgKCFldmVudE5hbWUpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAoIW9wdGlvbnMuZXZlbnQpIHtcbiAgXHRcdG9wdGlvbnMuZXZlbnQgPSB7XG4gIFx0XHRcdG5hbWU6IGV2ZW50TmFtZSxcbiAgXHRcdFx0Ly8gdW50aWwgZXZlbnQgbm90IGluY2x1ZGVkIGFzIGFyZ3VtZW50IGRlZmF1bHRcbiAgXHRcdFx0X25vQXJnOiB0cnVlXG4gIFx0XHR9O1xuICBcdH0gZWxzZSB7XG4gIFx0XHRvcHRpb25zLmV2ZW50Lm5hbWUgPSBldmVudE5hbWU7XG4gIFx0fVxuXG4gIFx0dmFyIGV2ZW50TmFtZXMgPSBnZXRLZXlwYXRoKGV2ZW50TmFtZSkud2lsZGNhcmRNYXRjaGVzKCk7XG4gIFx0ZmlyZUV2ZW50QXMocmFjdGl2ZSwgZXZlbnROYW1lcywgb3B0aW9ucy5ldmVudCwgb3B0aW9ucy5hcmdzLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudEFzKHJhY3RpdmUsIGV2ZW50TmFtZXMsIGV2ZW50LCBhcmdzKSB7XG4gIFx0dmFyIGluaXRpYWxGaXJlID0gYXJndW1lbnRzWzRdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1s0XTtcblxuICBcdHZhciBzdWJzY3JpYmVycyxcbiAgXHQgICAgaSxcbiAgXHQgICAgYnViYmxlID0gdHJ1ZTtcblxuICBcdHNoYXJlZF9ldmVudFN0YWNrLmVucXVldWUocmFjdGl2ZSwgZXZlbnQpO1xuXG4gIFx0Zm9yIChpID0gZXZlbnROYW1lcy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gIFx0XHRzdWJzY3JpYmVycyA9IHJhY3RpdmUuX3N1YnNbZXZlbnROYW1lc1tpXV07XG5cbiAgXHRcdGlmIChzdWJzY3JpYmVycykge1xuICBcdFx0XHRidWJibGUgPSBub3RpZnlTdWJzY3JpYmVycyhyYWN0aXZlLCBzdWJzY3JpYmVycywgZXZlbnQsIGFyZ3MpICYmIGJ1YmJsZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5kZXF1ZXVlKHJhY3RpdmUpO1xuXG4gIFx0aWYgKHJhY3RpdmUucGFyZW50ICYmIGJ1YmJsZSkge1xuXG4gIFx0XHRpZiAoaW5pdGlhbEZpcmUgJiYgcmFjdGl2ZS5jb21wb25lbnQpIHtcbiAgXHRcdFx0dmFyIGZ1bGxOYW1lID0gcmFjdGl2ZS5jb21wb25lbnQubmFtZSArIFwiLlwiICsgZXZlbnROYW1lc1tldmVudE5hbWVzLmxlbmd0aCAtIDFdO1xuICBcdFx0XHRldmVudE5hbWVzID0gZ2V0S2V5cGF0aChmdWxsTmFtZSkud2lsZGNhcmRNYXRjaGVzKCk7XG5cbiAgXHRcdFx0aWYgKGV2ZW50KSB7XG4gIFx0XHRcdFx0ZXZlbnQuY29tcG9uZW50ID0gcmFjdGl2ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRmaXJlRXZlbnRBcyhyYWN0aXZlLnBhcmVudCwgZXZlbnROYW1lcywgZXZlbnQsIGFyZ3MpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeVN1YnNjcmliZXJzKHJhY3RpdmUsIHN1YnNjcmliZXJzLCBldmVudCwgYXJncykge1xuICBcdHZhciBvcmlnaW5hbEV2ZW50ID0gbnVsbCxcbiAgXHQgICAgc3RvcEV2ZW50ID0gZmFsc2U7XG5cbiAgXHRpZiAoZXZlbnQgJiYgIWV2ZW50Ll9ub0FyZykge1xuICBcdFx0YXJncyA9IFtldmVudF0uY29uY2F0KGFyZ3MpO1xuICBcdH1cblxuICBcdC8vIHN1YnNjcmliZXJzIGNhbiBiZSBtb2RpZmllZCBpbmZsaWdodCwgZS5nLiBcIm9uY2VcIiBmdW5jdGlvbmFsaXR5XG4gIFx0Ly8gc28gd2UgbmVlZCB0byBjb3B5IHRvIG1ha2Ugc3VyZSBldmVyeW9uZSBnZXRzIGNhbGxlZFxuICBcdHN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuc2xpY2UoKTtcblxuICBcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0aWYgKHN1YnNjcmliZXJzW2ldLmFwcGx5KHJhY3RpdmUsIGFyZ3MpID09PSBmYWxzZSkge1xuICBcdFx0XHRzdG9wRXZlbnQgPSB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChldmVudCAmJiAhZXZlbnQuX25vQXJnICYmIHN0b3BFdmVudCAmJiAob3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsKSkge1xuICBcdFx0b3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCAmJiBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIFx0XHRvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbiAmJiBvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICBcdH1cblxuICBcdHJldHVybiAhc3RvcEV2ZW50O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maXJlID0gUmFjdGl2ZSRmaXJlO1xuICBmdW5jdGlvbiBSYWN0aXZlJGZpcmUoZXZlbnROYW1lKSB7XG5cbiAgXHR2YXIgb3B0aW9ucyA9IHtcbiAgXHRcdGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgXHR9O1xuXG4gIFx0c2hhcmVkX2ZpcmVFdmVudCh0aGlzLCBldmVudE5hbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9nZXQgPSBSYWN0aXZlJGdldDtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gIFx0Y2FwdHVyZTogdHJ1ZSwgLy8gdG9wLWxldmVsIGNhbGxzIHNob3VsZCBiZSBpbnRlcmNlcHRlZFxuICBcdG5vVW53cmFwOiB0cnVlLCAvLyB3cmFwcGVkIHZhbHVlcyBzaG91bGQgTk9UIGJlIHVud3JhcHBlZFxuICBcdGZ1bGxSb290R2V0OiB0cnVlIC8vIHJvb3QgZ2V0IHNob3VsZCByZXR1cm4gbWFwcGluZ3NcbiAgfTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRnZXQoa2V5cGF0aCkge1xuICBcdHZhciB2YWx1ZTtcblxuICBcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG4gIFx0dmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCwgb3B0aW9ucyk7XG5cbiAgXHQvLyBDcmVhdGUgaW50ZXItY29tcG9uZW50IGJpbmRpbmcsIGlmIG5lY2Vzc2FyeVxuICBcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMucGFyZW50ICYmICF0aGlzLmlzb2xhdGVkKSB7XG4gIFx0XHRpZiAoc2hhcmVkX3Jlc29sdmVSZWYodGhpcywga2V5cGF0aC5zdHIsIHRoaXMuY29tcG9uZW50LnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0XHQvLyBjcmVhdGVzIGJpbmRpbmcgYXMgc2lkZS1lZmZlY3QsIGlmIGFwcHJvcHJpYXRlXG4gIFx0XHRcdHZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHZhciBpbnNlcnQgPSBSYWN0aXZlJGluc2VydDtcblxuICB2YXIgaW5zZXJ0SG9vayA9IG5ldyBob29rc19Ib29rKFwiaW5zZXJ0XCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJGluc2VydCh0YXJnZXQsIGFuY2hvcikge1xuICBcdGlmICghdGhpcy5mcmFnbWVudC5yZW5kZXJlZCkge1xuICBcdFx0Ly8gVE9ETyBjcmVhdGUsIGFuZCBsaW5rIHRvLCBkb2N1bWVudGF0aW9uIGV4cGxhaW5pbmcgdGhpc1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIEFQSSBoYXMgY2hhbmdlZCAtIHlvdSBtdXN0IGNhbGwgYHJhY3RpdmUucmVuZGVyKHRhcmdldFssIGFuY2hvcl0pYCB0byByZW5kZXIgeW91ciBSYWN0aXZlIGluc3RhbmNlLiBPbmNlIHJlbmRlcmVkIHlvdSBjYW4gdXNlIGByYWN0aXZlLmluc2VydCgpYC5cIik7XG4gIFx0fVxuXG4gIFx0dGFyZ2V0ID0gZ2V0RWxlbWVudCh0YXJnZXQpO1xuICBcdGFuY2hvciA9IGdldEVsZW1lbnQoYW5jaG9yKSB8fCBudWxsO1xuXG4gIFx0aWYgKCF0YXJnZXQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHNwZWNpZnkgYSB2YWxpZCB0YXJnZXQgdG8gaW5zZXJ0IGludG9cIik7XG4gIFx0fVxuXG4gIFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmRldGFjaCgpLCBhbmNob3IpO1xuICBcdHRoaXMuZWwgPSB0YXJnZXQ7XG5cbiAgXHQodGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyB8fCAodGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyA9IFtdKSkucHVzaCh0aGlzKTtcbiAgXHR0aGlzLmRldGFjaGVkID0gbnVsbDtcblxuICBcdGZpcmVJbnNlcnRIb29rKHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUluc2VydEhvb2socmFjdGl2ZSkge1xuICBcdGluc2VydEhvb2suZmlyZShyYWN0aXZlKTtcblxuICBcdHJhY3RpdmUuZmluZEFsbENvbXBvbmVudHMoXCIqXCIpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gIFx0XHRmaXJlSW5zZXJ0SG9vayhjaGlsZC5pbnN0YW5jZSk7XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX21lcmdlID0gUmFjdGl2ZSRtZXJnZTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRtZXJnZShrZXlwYXRoLCBhcnJheSwgb3B0aW9ucykge1xuICBcdHZhciBjdXJyZW50QXJyYXksIHByb21pc2U7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuICBcdGN1cnJlbnRBcnJheSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdC8vIElmIGVpdGhlciB0aGUgZXhpc3RpbmcgdmFsdWUgb3IgdGhlIG5ldyB2YWx1ZSBpc24ndCBhblxuICBcdC8vIGFycmF5LCBqdXN0IGRvIGEgcmVndWxhciBzZXRcbiAgXHRpZiAoIWlzQXJyYXkoY3VycmVudEFycmF5KSB8fCAhaXNBcnJheShhcnJheSkpIHtcbiAgXHRcdHJldHVybiB0aGlzLnNldChrZXlwYXRoLCBhcnJheSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBsZXRlKTtcbiAgXHR9XG5cbiAgXHQvLyBNYW5hZ2UgdHJhbnNpdGlvbnNcbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG4gIFx0dGhpcy52aWV3bW9kZWwubWVyZ2Uoa2V5cGF0aCwgY3VycmVudEFycmF5LCBhcnJheSwgb3B0aW9ucyk7XG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG4gIFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIFx0dGhpcy5kZWZlciA9IG9wdGlvbnMuZGVmZXI7XG5cbiAgXHQvLyBkZWZhdWx0IHRvIHJvb3QgYXMgY29udGV4dCwgYnV0IGFsbG93IGl0IHRvIGJlIG92ZXJyaWRkZW5cbiAgXHR0aGlzLmNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA/IG9wdGlvbnMuY29udGV4dCA6IHJhY3RpdmU7XG4gIH07XG5cbiAgT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IGZ1bmN0aW9uIChpbW1lZGlhdGUpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB0aGlzLnJvb3QuZ2V0KHRoaXMua2V5cGF0aC5zdHIpO1xuXG4gIFx0XHRpZiAoaW1tZWRpYXRlICE9PSBmYWxzZSkge1xuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGlmICghaXNFcXVhbCh2YWx1ZSwgdGhpcy52YWx1ZSkpIHtcbiAgXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHRcdGlmICh0aGlzLmRlZmVyICYmIHRoaXMucmVhZHkpIHtcbiAgXHRcdFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0cmV0dXJuIF90aGlzLnVwZGF0ZSgpO1xuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BzXG4gIFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXG4gIFx0XHR0aGlzLmNhbGxiYWNrLmNhbGwodGhpcy5jb250ZXh0LCB0aGlzLnZhbHVlLCB0aGlzLm9sZFZhbHVlLCB0aGlzLmtleXBhdGguc3RyKTtcbiAgXHRcdHRoaXMub2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gIFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBvYnNlcnZlX09ic2VydmVyID0gT2JzZXJ2ZXI7XG5cbiAgdmFyIG9ic2VydmVfZ2V0UGF0dGVybiA9IGdldFBhdHRlcm47XG4gIGZ1bmN0aW9uIGdldFBhdHRlcm4ocmFjdGl2ZSwgcGF0dGVybikge1xuICBcdHZhciBtYXRjaGluZ0tleXBhdGhzLCB2YWx1ZXM7XG5cbiAgXHRtYXRjaGluZ0tleXBhdGhzID0gZ2V0TWF0Y2hpbmdLZXlwYXRocyhyYWN0aXZlLCBwYXR0ZXJuKTtcblxuICBcdHZhbHVlcyA9IHt9O1xuICBcdG1hdGNoaW5nS2V5cGF0aHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFsdWVzW2tleXBhdGguc3RyXSA9IHJhY3RpdmUuZ2V0KGtleXBhdGguc3RyKTtcbiAgXHR9KTtcblxuICBcdHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICB2YXIgUGF0dGVybk9ic2VydmVyLFxuICAgICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgUGF0dGVybk9ic2VydmVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblxuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgXHR0aGlzLmRlZmVyID0gb3B0aW9ucy5kZWZlcjtcblxuICBcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0dGhpcy5yZWdleCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBrZXlwYXRoLnN0ci5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLlwiKS5yZXBsYWNlKC9cXCovZywgXCIoW15cXFxcLl0rKVwiKSArIFwiJFwiKTtcbiAgXHR0aGlzLnZhbHVlcyA9IHt9O1xuXG4gIFx0aWYgKHRoaXMuZGVmZXIpIHtcbiAgXHRcdHRoaXMucHJveGllcyA9IFtdO1xuICBcdH1cblxuICBcdC8vIGRlZmF1bHQgdG8gcm9vdCBhcyBjb250ZXh0LCBidXQgYWxsb3cgaXQgdG8gYmUgb3ZlcnJpZGRlblxuICBcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID8gb3B0aW9ucy5jb250ZXh0IDogcmFjdGl2ZTtcbiAgfTtcblxuICBQYXR0ZXJuT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IGZ1bmN0aW9uIChpbW1lZGlhdGUpIHtcbiAgXHRcdHZhciB2YWx1ZXMsIGtleXBhdGg7XG5cbiAgXHRcdHZhbHVlcyA9IG9ic2VydmVfZ2V0UGF0dGVybih0aGlzLnJvb3QsIHRoaXMua2V5cGF0aCk7XG5cbiAgXHRcdGlmIChpbW1lZGlhdGUgIT09IGZhbHNlKSB7XG4gIFx0XHRcdGZvciAoa2V5cGF0aCBpbiB2YWx1ZXMpIHtcbiAgXHRcdFx0XHRpZiAodmFsdWVzLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0XHR0aGlzLnVwZGF0ZShnZXRLZXlwYXRoKGtleXBhdGgpKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdmFsdWVzO1xuXG4gIFx0XHRpZiAoa2V5cGF0aC5pc1BhdHRlcm4pIHtcbiAgXHRcdFx0dmFsdWVzID0gb2JzZXJ2ZV9nZXRQYXR0ZXJuKHRoaXMucm9vdCwga2V5cGF0aCk7XG5cbiAgXHRcdFx0Zm9yIChrZXlwYXRoIGluIHZhbHVlcykge1xuICBcdFx0XHRcdGlmICh2YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5cGF0aCkpIHtcbiAgXHRcdFx0XHRcdHRoaXMudXBkYXRlKGdldEtleXBhdGgoa2V5cGF0aCkpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYXJyYXkgbXV0YXRpb24gc2hvdWxkIG5vdCB0cmlnZ2VyIGBhcnJheS4qYFxuICBcdFx0Ly8gcGF0dGVybiBvYnNlcnZlciB3aXRoIGBhcnJheS5sZW5ndGhgXG4gIFx0XHRpZiAodGhpcy5yb290LnZpZXdtb2RlbC5pbXBsaWNpdENoYW5nZXNba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZGVmZXIgJiYgdGhpcy5yZWFkeSkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHJldHVybiBfdGhpcy5nZXRQcm94eShrZXlwYXRoKS51cGRhdGUoKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5yZWFsbHlVcGRhdGUoa2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHJlYWxseVVwZGF0ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhciBrZXlwYXRoU3RyLCB2YWx1ZSwga2V5cywgYXJncztcblxuICBcdFx0a2V5cGF0aFN0ciA9IGtleXBhdGguc3RyO1xuICBcdFx0dmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0Ly8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuICBcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0dGhpcy52YWx1ZXNba2V5cGF0aFN0cl0gPSB2YWx1ZTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblxuICBcdFx0aWYgKCFpc0VxdWFsKHZhbHVlLCB0aGlzLnZhbHVlc1trZXlwYXRoU3RyXSkgfHwgIXRoaXMucmVhZHkpIHtcbiAgXHRcdFx0a2V5cyA9IHNsaWNlLmNhbGwodGhpcy5yZWdleC5leGVjKGtleXBhdGhTdHIpLCAxKTtcbiAgXHRcdFx0YXJncyA9IFt2YWx1ZSwgdGhpcy52YWx1ZXNba2V5cGF0aFN0cl0sIGtleXBhdGhTdHJdLmNvbmNhdChrZXlzKTtcblxuICBcdFx0XHR0aGlzLnZhbHVlc1trZXlwYXRoU3RyXSA9IHZhbHVlO1xuICBcdFx0XHR0aGlzLmNhbGxiYWNrLmFwcGx5KHRoaXMuY29udGV4dCwgYXJncyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgXHR9LFxuXG4gIFx0Z2V0UHJveHk6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIXRoaXMucHJveGllc1trZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0dGhpcy5wcm94aWVzW2tleXBhdGguc3RyXSA9IHtcbiAgXHRcdFx0XHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdHJldHVybiBfdGhpcy5yZWFsbHlVcGRhdGUoa2V5cGF0aCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm94aWVzW2tleXBhdGguc3RyXTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIG9ic2VydmVfUGF0dGVybk9ic2VydmVyID0gUGF0dGVybk9ic2VydmVyO1xuXG4gIHZhciBvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlID0gZ2V0T2JzZXJ2ZXJGYWNhZGU7XG4gIHZhciBlbXB0eU9iamVjdCA9IHt9O1xuICBmdW5jdGlvbiBnZXRPYnNlcnZlckZhY2FkZShyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBcdHZhciBvYnNlcnZlciwgaXNQYXR0ZXJuT2JzZXJ2ZXIsIGNhbmNlbGxlZDtcblxuICBcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgXHQvLyBwYXR0ZXJuIG9ic2VydmVycyBhcmUgdHJlYXRlZCBkaWZmZXJlbnRseVxuICBcdGlmIChrZXlwYXRoLmlzUGF0dGVybikge1xuICBcdFx0b2JzZXJ2ZXIgPSBuZXcgb2JzZXJ2ZV9QYXR0ZXJuT2JzZXJ2ZXIocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgXHRcdGlzUGF0dGVybk9ic2VydmVyID0gdHJ1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0b2JzZXJ2ZXIgPSBuZXcgb2JzZXJ2ZV9PYnNlcnZlcihyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0b2JzZXJ2ZXIuaW5pdChvcHRpb25zLmluaXQpO1xuICBcdHJhY3RpdmUudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIG9ic2VydmVyLCBpc1BhdHRlcm5PYnNlcnZlciA/IFwicGF0dGVybk9ic2VydmVyc1wiIDogXCJvYnNlcnZlcnNcIik7XG5cbiAgXHQvLyBUaGlzIGZsYWcgYWxsb3dzIG9ic2VydmVycyB0byBpbml0aWFsaXNlIGV2ZW4gd2l0aCB1bmRlZmluZWQgdmFsdWVzXG4gIFx0b2JzZXJ2ZXIucmVhZHkgPSB0cnVlO1xuXG4gIFx0dmFyIGZhY2FkZSA9IHtcbiAgXHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgaW5kZXg7XG5cbiAgXHRcdFx0aWYgKGNhbmNlbGxlZCkge1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChpc1BhdHRlcm5PYnNlcnZlcikge1xuICBcdFx0XHRcdGluZGV4ID0gcmFjdGl2ZS52aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcblxuICBcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC51bnJlZ2lzdGVyKGtleXBhdGgsIG9ic2VydmVyLCBcInBhdHRlcm5PYnNlcnZlcnNcIik7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3RlcihrZXlwYXRoLCBvYnNlcnZlciwgXCJvYnNlcnZlcnNcIik7XG4gIFx0XHRcdH1cbiAgXHRcdFx0Y2FuY2VsbGVkID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0cmFjdGl2ZS5fb2JzZXJ2ZXJzLnB1c2goZmFjYWRlKTtcbiAgXHRyZXR1cm4gZmFjYWRlO1xuICB9XG5cbiAgdmFyIG9ic2VydmUgPSBSYWN0aXZlJG9ic2VydmU7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkb2JzZXJ2ZShrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykge1xuXG4gIFx0dmFyIG9ic2VydmVycywgbWFwLCBrZXlwYXRocywgaTtcblxuICBcdC8vIEFsbG93IGEgbWFwIG9mIGtleXBhdGhzIHRvIGhhbmRsZXJzXG4gIFx0aWYgKGlzT2JqZWN0KGtleXBhdGgpKSB7XG4gIFx0XHRvcHRpb25zID0gY2FsbGJhY2s7XG4gIFx0XHRtYXAgPSBrZXlwYXRoO1xuXG4gIFx0XHRvYnNlcnZlcnMgPSBbXTtcblxuICBcdFx0Zm9yIChrZXlwYXRoIGluIG1hcCkge1xuICBcdFx0XHRpZiAobWFwLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0Y2FsbGJhY2sgPSBtYXBba2V5cGF0aF07XG4gIFx0XHRcdFx0b2JzZXJ2ZXJzLnB1c2godGhpcy5vYnNlcnZlKGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0d2hpbGUgKG9ic2VydmVycy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdG9ic2VydmVycy5wb3AoKS5jYW5jZWwoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0Ly8gQWxsb3cgYHJhY3RpdmUub2JzZXJ2ZSggY2FsbGJhY2sgKWAgLSBpLmUuIG9ic2VydmUgZW50aXJlIG1vZGVsXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdG9wdGlvbnMgPSBjYWxsYmFjaztcbiAgXHRcdGNhbGxiYWNrID0ga2V5cGF0aDtcbiAgXHRcdGtleXBhdGggPSBcIlwiO1xuXG4gIFx0XHRyZXR1cm4gb2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSh0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0a2V5cGF0aHMgPSBrZXlwYXRoLnNwbGl0KFwiIFwiKTtcblxuICBcdC8vIFNpbmdsZSBrZXlwYXRoXG4gIFx0aWYgKGtleXBhdGhzLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmV0dXJuIG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUodGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBcdH1cblxuICBcdC8vIE11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBrZXlwYXRoc1xuICBcdG9ic2VydmVycyA9IFtdO1xuXG4gIFx0aSA9IGtleXBhdGhzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRrZXlwYXRoID0ga2V5cGF0aHNbaV07XG5cbiAgXHRcdGlmIChrZXlwYXRoKSB7XG4gIFx0XHRcdG9ic2VydmVycy5wdXNoKG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUodGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHdoaWxlIChvYnNlcnZlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0b2JzZXJ2ZXJzLnBvcCgpLmNhbmNlbCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBvYnNlcnZlT25jZSA9IFJhY3RpdmUkb2JzZXJ2ZU9uY2U7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRvYnNlcnZlT25jZShwcm9wZXJ0eSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcblxuICBcdHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZShwcm9wZXJ0eSwgZnVuY3Rpb24gKCkge1xuICBcdFx0Y2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXHRcdG9ic2VydmVyLmNhbmNlbCgpO1xuICBcdH0sIHsgaW5pdDogZmFsc2UsIGRlZmVyOiBvcHRpb25zICYmIG9wdGlvbnMuZGVmZXIgfSk7XG5cbiAgXHRyZXR1cm4gb2JzZXJ2ZXI7XG4gIH1cblxuICB2YXIgc2hhcmVkX3RyaW0gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCk7XG4gIH07XG5cbiAgdmFyIG5vdEVtcHR5U3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIgIT09IFwiXCI7XG4gIH07XG5cbiAgdmFyIG9mZiA9IFJhY3RpdmUkb2ZmO1xuICBmdW5jdGlvbiBSYWN0aXZlJG9mZihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBldmVudE5hbWVzO1xuXG4gIFx0Ly8gaWYgbm8gYXJndW1lbnRzIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBjYWxsYmFja3NcbiAgXHRpZiAoIWV2ZW50TmFtZSkge1xuICBcdFx0Ly8gVE9ETyB1c2UgdGhpcyBjb2RlIGluc3RlYWQsIG9uY2UgdGhlIGZvbGxvd2luZyBpc3N1ZSBoYXMgYmVlbiByZXNvbHZlZFxuICBcdFx0Ly8gaW4gUGhhbnRvbUpTICh0ZXN0cyBhcmUgdW5wYXNzYWJsZSBvdGhlcndpc2UhKVxuICBcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTE4NTZcbiAgXHRcdC8vIGRlZmluZVByb3BlcnR5KCB0aGlzLCAnX3N1YnMnLCB7IHZhbHVlOiBjcmVhdGUoIG51bGwgKSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICBcdFx0Zm9yIChldmVudE5hbWUgaW4gdGhpcy5fc3Vicykge1xuICBcdFx0XHRkZWxldGUgdGhpcy5fc3Vic1tldmVudE5hbWVdO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGV2ZW50IG5hbWVzXG4gIFx0XHRldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KFwiIFwiKS5tYXAoc2hhcmVkX3RyaW0pLmZpbHRlcihub3RFbXB0eVN0cmluZyk7XG5cbiAgXHRcdGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gIFx0XHRcdHZhciBzdWJzY3JpYmVycywgaW5kZXg7XG5cbiAgXHRcdFx0Ly8gSWYgd2UgaGF2ZSBzdWJzY3JpYmVycyBmb3IgdGhpcyBldmVudC4uLlxuICBcdFx0XHRpZiAoc3Vic2NyaWJlcnMgPSBfdGhpcy5fc3Vic1tldmVudE5hbWVdKSB7XG4gIFx0XHRcdFx0Ly8gLi4uaWYgYSBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBvbmx5IHJlbW92ZSB0aGF0XG4gIFx0XHRcdFx0aWYgKGNhbGxiYWNrKSB7XG4gIFx0XHRcdFx0XHRpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuICBcdFx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0XHRcdFx0XHRzdWJzY3JpYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSByZW1vdmUgYWxsIGNhbGxiYWNrc1xuICBcdFx0XHRcdGVsc2Uge1xuICBcdFx0XHRcdFx0X3RoaXMuX3N1YnNbZXZlbnROYW1lXSA9IFtdO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgb24gPSBSYWN0aXZlJG9uO1xuICBmdW5jdGlvbiBSYWN0aXZlJG9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIGxpc3RlbmVycywgbiwgZXZlbnROYW1lcztcblxuICBcdC8vIGFsbG93IG11dGxpcGxlIGxpc3RlbmVycyB0byBiZSBib3VuZCBpbiBvbmUgZ29cbiAgXHRpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0bGlzdGVuZXJzID0gW107XG5cbiAgXHRcdGZvciAobiBpbiBldmVudE5hbWUpIHtcbiAgXHRcdFx0aWYgKGV2ZW50TmFtZS5oYXNPd25Qcm9wZXJ0eShuKSkge1xuICBcdFx0XHRcdGxpc3RlbmVycy5wdXNoKHRoaXMub24obiwgZXZlbnROYW1lW25dKSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0dmFyIGxpc3RlbmVyO1xuXG4gIFx0XHRcdFx0d2hpbGUgKGxpc3RlbmVyID0gbGlzdGVuZXJzLnBvcCgpKSB7XG4gIFx0XHRcdFx0XHRsaXN0ZW5lci5jYW5jZWwoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuICBcdGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoXCIgXCIpLm1hcChzaGFyZWRfdHJpbSkuZmlsdGVyKG5vdEVtcHR5U3RyaW5nKTtcblxuICBcdGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gIFx0XHQoX3RoaXMuX3N1YnNbZXZlbnROYW1lXSB8fCAoX3RoaXMuX3N1YnNbZXZlbnROYW1lXSA9IFtdKSkucHVzaChjYWxsYmFjayk7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiBfdGhpcy5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBvbmNlID0gUmFjdGl2ZSRvbmNlO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkb25jZShldmVudE5hbWUsIGhhbmRsZXIpIHtcblxuICBcdHZhciBsaXN0ZW5lciA9IHRoaXMub24oZXZlbnROYW1lLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIFx0XHRsaXN0ZW5lci5jYW5jZWwoKTtcbiAgXHR9KTtcblxuICBcdC8vIHNvIHdlIGNhbiBzdGlsbCBkbyBsaXN0ZW5lci5jYW5jZWwoKSBtYW51YWxseVxuICBcdHJldHVybiBsaXN0ZW5lcjtcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gYXJyYXksIHRoZSBuYW1lIG9mIGEgbXV0YXRvciBtZXRob2QsIGFuZCB0aGVcbiAgLy8gYXJndW1lbnRzIHRvIGNhbGwgdGhhdCBtdXRhdG9yIG1ldGhvZCB3aXRoLCBhbmQgcmV0dXJucyBhbiBhcnJheSB0aGF0XG4gIC8vIG1hcHMgdGhlIG9sZCBpbmRpY2VzIHRvIHRoZWlyIG5ldyBpbmRpY2VzLlxuXG4gIC8vIFNvIGlmIHlvdSBoYWQgc29tZXRoaW5nIGxpa2UgdGhpcy4uLlxuICAvL1xuICAvLyAgICAgYXJyYXkgPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuICAvLyAgICAgYXJyYXkucHVzaCggJ2UnICk7XG4gIC8vXG4gIC8vIC4uLnlvdSdkIGdldCBgWyAwLCAxLCAyLCAzIF1gIC0gaW4gb3RoZXIgd29yZHMsIG5vbmUgb2YgdGhlIG9sZCBpbmRpY2VzXG4gIC8vIGhhdmUgY2hhbmdlZC4gSWYgeW91IHRoZW4gZGlkIHRoaXMuLi5cbiAgLy9cbiAgLy8gICAgIGFycmF5LnVuc2hpZnQoICd6JyApO1xuICAvL1xuICAvLyAuLi50aGUgaW5kaWNlcyB3b3VsZCBiZSBgWyAxLCAyLCAzLCA0LCA1IF1gIC0gZXZlcnkgaXRlbSBoYXMgYmVlbiBtb3ZlZFxuICAvLyBvbmUgaGlnaGVyIHRvIG1ha2Ugcm9vbSBmb3IgdGhlICd6Jy4gSWYgeW91IHJlbW92ZWQgYW4gaXRlbSwgdGhlIG5ldyBpbmRleFxuICAvLyB3b3VsZCBiZSAtMS4uLlxuICAvL1xuICAvLyAgICAgYXJyYXkuc3BsaWNlKCAyLCAyICk7XG4gIC8vXG4gIC8vIC4uLnRoaXMgd291bGQgcmVzdWx0IGluIFsgMCwgMSwgLTEsIC0xLCAyLCAzIF0uXG4gIC8vXG4gIC8vIFRoaXMgaW5mb3JtYXRpb24gaXMgdXNlZCB0byBlbmFibGUgZmFzdCwgbm9uLWRlc3RydWN0aXZlIHNodWZmbGluZyBvZiBsaXN0XG4gIC8vIHNlY3Rpb25zIHdoZW4geW91IGRvIGUuZy4gYHJhY3RpdmUuc3BsaWNlKCAnaXRlbXMnLCAyLCAyICk7XG5cbiAgdmFyIHNoYXJlZF9nZXROZXdJbmRpY2VzID0gZ2V0TmV3SW5kaWNlcztcblxuICBmdW5jdGlvbiBnZXROZXdJbmRpY2VzKGFycmF5LCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gIFx0dmFyIHNwbGljZUFyZ3VtZW50cyxcbiAgXHQgICAgbGVuLFxuICBcdCAgICBuZXdJbmRpY2VzID0gW10sXG4gIFx0ICAgIHJlbW92ZVN0YXJ0LFxuICBcdCAgICByZW1vdmVFbmQsXG4gIFx0ICAgIGJhbGFuY2UsXG4gIFx0ICAgIGk7XG5cbiAgXHRzcGxpY2VBcmd1bWVudHMgPSBnZXRTcGxpY2VFcXVpdmFsZW50KGFycmF5LCBtZXRob2ROYW1lLCBhcmdzKTtcblxuICBcdGlmICghc3BsaWNlQXJndW1lbnRzKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDsgLy8gVE9ETyBzdXBwb3J0IHJldmVyc2UgYW5kIHNvcnQ/XG4gIFx0fVxuXG4gIFx0bGVuID0gYXJyYXkubGVuZ3RoO1xuICBcdGJhbGFuY2UgPSBzcGxpY2VBcmd1bWVudHMubGVuZ3RoIC0gMiAtIHNwbGljZUFyZ3VtZW50c1sxXTtcblxuICBcdHJlbW92ZVN0YXJ0ID0gTWF0aC5taW4obGVuLCBzcGxpY2VBcmd1bWVudHNbMF0pO1xuICBcdHJlbW92ZUVuZCA9IHJlbW92ZVN0YXJ0ICsgc3BsaWNlQXJndW1lbnRzWzFdO1xuXG4gIFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZVN0YXJ0OyBpICs9IDEpIHtcbiAgXHRcdG5ld0luZGljZXMucHVzaChpKTtcbiAgXHR9XG5cbiAgXHRmb3IgKDsgaSA8IHJlbW92ZUVuZDsgaSArPSAxKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnB1c2goLTEpO1xuICBcdH1cblxuICBcdGZvciAoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG5ld0luZGljZXMucHVzaChpICsgYmFsYW5jZSk7XG4gIFx0fVxuXG4gIFx0Ly8gdGhlcmUgaXMgYSBuZXQgc2hpZnQgZm9yIHRoZSByZXN0IG9mIHRoZSBhcnJheSBzdGFydGluZyB3aXRoIGluZGV4ICsgYmFsYW5jZVxuICBcdGlmIChiYWxhbmNlICE9PSAwKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnRvdWNoZWRGcm9tID0gc3BsaWNlQXJndW1lbnRzWzBdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRuZXdJbmRpY2VzLnRvdWNoZWRGcm9tID0gYXJyYXkubGVuZ3RoO1xuICBcdH1cblxuICBcdHJldHVybiBuZXdJbmRpY2VzO1xuICB9XG5cbiAgLy8gVGhlIHBvcCwgcHVzaCwgc2hpZnQgYW4gdW5zaGlmdCBtZXRob2RzIGNhbiBhbGwgYmUgcmVwcmVzZW50ZWRcbiAgLy8gYXMgYW4gZXF1aXZhbGVudCBzcGxpY2VcbiAgZnVuY3Rpb24gZ2V0U3BsaWNlRXF1aXZhbGVudChhcnJheSwgbWV0aG9kTmFtZSwgYXJncykge1xuICBcdHN3aXRjaCAobWV0aG9kTmFtZSkge1xuICBcdFx0Y2FzZSBcInNwbGljZVwiOlxuICBcdFx0XHRpZiAoYXJnc1swXSAhPT0gdW5kZWZpbmVkICYmIGFyZ3NbMF0gPCAwKSB7XG4gIFx0XHRcdFx0YXJnc1swXSA9IGFycmF5Lmxlbmd0aCArIE1hdGgubWF4KGFyZ3NbMF0sIC1hcnJheS5sZW5ndGgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0d2hpbGUgKGFyZ3MubGVuZ3RoIDwgMikge1xuICBcdFx0XHRcdGFyZ3MucHVzaCgwKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGVuc3VyZSB3ZSBvbmx5IHJlbW92ZSBlbGVtZW50cyB0aGF0IGV4aXN0XG4gIFx0XHRcdGFyZ3NbMV0gPSBNYXRoLm1pbihhcmdzWzFdLCBhcnJheS5sZW5ndGggLSBhcmdzWzBdKTtcblxuICBcdFx0XHRyZXR1cm4gYXJncztcblxuICBcdFx0Y2FzZSBcInNvcnRcIjpcbiAgXHRcdGNhc2UgXCJyZXZlcnNlXCI6XG4gIFx0XHRcdHJldHVybiBudWxsO1xuXG4gIFx0XHRjYXNlIFwicG9wXCI6XG4gIFx0XHRcdGlmIChhcnJheS5sZW5ndGgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gW2FycmF5Lmxlbmd0aCAtIDEsIDFdO1xuICBcdFx0XHR9XG4gIFx0XHRcdHJldHVybiBbMCwgMF07XG5cbiAgXHRcdGNhc2UgXCJwdXNoXCI6XG4gIFx0XHRcdHJldHVybiBbYXJyYXkubGVuZ3RoLCAwXS5jb25jYXQoYXJncyk7XG5cbiAgXHRcdGNhc2UgXCJzaGlmdFwiOlxuICBcdFx0XHRyZXR1cm4gWzAsIGFycmF5Lmxlbmd0aCA/IDEgOiAwXTtcblxuICBcdFx0Y2FzZSBcInVuc2hpZnRcIjpcbiAgXHRcdFx0cmV0dXJuIFswLCAwXS5jb25jYXQoYXJncyk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIG1ha2VBcnJheU1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdFx0YXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBhcnJheSxcbiAgXHRcdCAgICBuZXdJbmRpY2VzID0gW10sXG4gIFx0XHQgICAgbGVuLFxuICBcdFx0ICAgIHByb21pc2UsXG4gIFx0XHQgICAgcmVzdWx0O1xuXG4gIFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuXG4gIFx0XHRhcnJheSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdGxlbiA9IGFycmF5Lmxlbmd0aDtcblxuICBcdFx0aWYgKCFpc0FycmF5KGFycmF5KSkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgcmFjdGl2ZS5cIiArIG1ldGhvZE5hbWUgKyBcIignXCIgKyBrZXlwYXRoLnN0ciArIFwiJyksIGJ1dCAnXCIgKyBrZXlwYXRoLnN0ciArIFwiJyBkb2VzIG5vdCByZWZlciB0byBhbiBhcnJheVwiKTtcbiAgXHRcdH1cblxuICBcdFx0bmV3SW5kaWNlcyA9IHNoYXJlZF9nZXROZXdJbmRpY2VzKGFycmF5LCBtZXRob2ROYW1lLCBhcmdzKTtcblxuICBcdFx0cmVzdWx0ID0gYXJyYXlQcm90b1ttZXRob2ROYW1lXS5hcHBseShhcnJheSwgYXJncyk7XG4gIFx0XHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSkudGhlbihmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiByZXN1bHQ7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKCEhbmV3SW5kaWNlcykge1xuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC5zbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fTtcbiAgfTtcblxuICB2YXIgcG9wID0gbWFrZUFycmF5TWV0aG9kKFwicG9wXCIpO1xuXG4gIHZhciBwdXNoID0gbWFrZUFycmF5TWV0aG9kKFwicHVzaFwiKTtcblxuICB2YXIgY3NzLFxuICAgICAgdXBkYXRlLFxuICAgICAgc3R5bGVFbGVtZW50LFxuICAgICAgaGVhZCxcbiAgICAgIHN0eWxlU2hlZXQsXG4gICAgICBpbkRvbSxcbiAgICAgIGdsb2JhbF9jc3NfX3ByZWZpeCA9IFwiLyogUmFjdGl2ZS5qcyBjb21wb25lbnQgc3R5bGVzICovXFxuXCIsXG4gICAgICBzdHlsZXMgPSBbXSxcbiAgICAgIGRpcnR5ID0gZmFsc2U7XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdC8vIFRPRE8gaGFuZGxlIGVuY2Fwc3VsYXRlZCBDU1MgaW4gc2VydmVyLXJlbmRlcmVkIEhUTUwhXG4gIFx0Y3NzID0ge1xuICBcdFx0YWRkOiBub29wLFxuICBcdFx0YXBwbHk6IG5vb3BcbiAgXHR9O1xuICB9IGVsc2Uge1xuICBcdHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuICBcdGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5cbiAgXHRpbkRvbSA9IGZhbHNlO1xuXG4gIFx0Ly8gSW50ZXJuZXQgRXhwbG9kZXIgd29uJ3QgbGV0IHlvdSB1c2Ugc3R5bGVTaGVldC5pbm5lckhUTUwgLSB3ZSBoYXZlIHRvXG4gIFx0Ly8gdXNlIHN0eWxlU2hlZXQuY3NzVGV4dCBpbnN0ZWFkXG4gIFx0c3R5bGVTaGVldCA9IHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0O1xuXG4gIFx0dXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGNzcyA9IGdsb2JhbF9jc3NfX3ByZWZpeCArIHN0eWxlcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgXHRcdFx0cmV0dXJuIFwiXFxuLyoge1wiICsgcy5pZCArIFwifSAqL1xcblwiICsgcy5zdHlsZXM7XG4gIFx0XHR9KS5qb2luKFwiXFxuXCIpO1xuXG4gIFx0XHRpZiAoc3R5bGVTaGVldCkge1xuICBcdFx0XHRzdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRzdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gY3NzO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWluRG9tKSB7XG4gIFx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgXHRcdFx0aW5Eb20gPSB0cnVlO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRjc3MgPSB7XG4gIFx0XHRhZGQ6IGZ1bmN0aW9uIChzKSB7XG4gIFx0XHRcdHN0eWxlcy5wdXNoKHMpO1xuICBcdFx0XHRkaXJ0eSA9IHRydWU7XG4gIFx0XHR9LFxuXG4gIFx0XHRhcHBseTogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRpZiAoZGlydHkpIHtcbiAgXHRcdFx0XHR1cGRhdGUoKTtcbiAgXHRcdFx0XHRkaXJ0eSA9IGZhbHNlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBnbG9iYWxfY3NzID0gY3NzO1xuXG4gIHZhciBwcm90b3R5cGVfcmVuZGVyID0gUmFjdGl2ZSRyZW5kZXI7XG5cbiAgdmFyIHJlbmRlckhvb2sgPSBuZXcgaG9va3NfSG9vayhcInJlbmRlclwiKSxcbiAgICAgIGNvbXBsZXRlSG9vayA9IG5ldyBob29rc19Ib29rKFwiY29tcGxldGVcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkcmVuZGVyKHRhcmdldCwgYW5jaG9yKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBwcm9taXNlLCBpbnN0YW5jZXMsIHRyYW5zaXRpb25zRW5hYmxlZDtcblxuICBcdC8vIGlmIGBub0ludHJvYCBpcyBgdHJ1ZWAsIHRlbXBvcmFyaWx5IGRpc2FibGUgdHJhbnNpdGlvbnNcbiAgXHR0cmFuc2l0aW9uc0VuYWJsZWQgPSB0aGlzLnRyYW5zaXRpb25zRW5hYmxlZDtcbiAgXHRpZiAodGhpcy5ub0ludHJvKSB7XG4gIFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IGZhbHNlO1xuICBcdH1cblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcbiAgXHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHJlbmRlckhvb2suZmlyZShfdGhpcyk7XG4gIFx0fSwgdHJ1ZSk7XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudC5yZW5kZXJlZCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBjYWxsIHJhY3RpdmUucmVuZGVyKCkgb24gYW4gYWxyZWFkeSByZW5kZXJlZCBpbnN0YW5jZSEgQ2FsbCByYWN0aXZlLnVucmVuZGVyKCkgZmlyc3RcIik7XG4gIFx0fVxuXG4gIFx0dGFyZ2V0ID0gZ2V0RWxlbWVudCh0YXJnZXQpIHx8IHRoaXMuZWw7XG4gIFx0YW5jaG9yID0gZ2V0RWxlbWVudChhbmNob3IpIHx8IHRoaXMuYW5jaG9yO1xuXG4gIFx0dGhpcy5lbCA9IHRhcmdldDtcbiAgXHR0aGlzLmFuY2hvciA9IGFuY2hvcjtcblxuICBcdGlmICghdGhpcy5hcHBlbmQgJiYgdGFyZ2V0KSB7XG4gIFx0XHQvLyBUZWFyZG93biBhbnkgZXhpc3RpbmcgaW5zdGFuY2VzICpiZWZvcmUqIHRyeWluZyB0byBzZXQgdXAgdGhlIG5ldyBvbmUgLVxuICBcdFx0Ly8gYXZvaWRzIGNlcnRhaW4gd2VpcmQgYnVnc1xuICBcdFx0dmFyIG90aGVycyA9IHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX187XG4gIFx0XHRpZiAob3RoZXJzICYmIG90aGVycy5sZW5ndGgpIHtcbiAgXHRcdFx0cmVtb3ZlT3RoZXJJbnN0YW5jZXMob3RoZXJzKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gbWFrZSBzdXJlIHdlIGFyZSB0aGUgb25seSBvY2N1cGFudHNcbiAgXHRcdHRhcmdldC5pbm5lckhUTUwgPSBcIlwiOyAvLyBUT0RPIGlzIHRoaXMgcXVpY2tlciB0aGFuIHJlbW92ZUNoaWxkPyBJbml0aWFsIHJlc2VhcmNoIGluY29uY2x1c2l2ZVxuICBcdH1cblxuICBcdGlmICh0aGlzLmNzc0lkKSB7XG4gIFx0XHQvLyBlbnN1cmUgZW5jYXBzdWxhdGVkIENTUyBpcyB1cC10by1kYXRlXG4gIFx0XHRnbG9iYWxfY3NzLmFwcGx5KCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRhcmdldCkge1xuICBcdFx0aWYgKCEoaW5zdGFuY2VzID0gdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXykpIHtcbiAgXHRcdFx0dGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyA9IFt0aGlzXTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoYW5jaG9yKSB7XG4gIFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5mcmFnbWVudC5yZW5kZXIoKSwgYW5jaG9yKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmZyYWdtZW50LnJlbmRlcigpKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gdHJhbnNpdGlvbnNFbmFibGVkO1xuXG4gIFx0cmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gY29tcGxldGVIb29rLmZpcmUoX3RoaXMpO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlT3RoZXJJbnN0YW5jZXMob3RoZXJzKSB7XG4gIFx0b3RoZXJzLnNwbGljZSgwLCBvdGhlcnMubGVuZ3RoKS5mb3JFYWNoKHRlYXJkb3duKTtcbiAgfVxuXG4gIHZhciBhZGFwdENvbmZpZ3VyYXRvciA9IHtcbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHRwcm90by5hZGFwdCA9IGN1c3RvbV9hZGFwdF9fY29tYmluZShwcm90by5hZGFwdCwgZW5zdXJlQXJyYXkob3B0aW9ucy5hZGFwdCkpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7fVxuICB9O1xuXG4gIHZhciBjdXN0b21fYWRhcHQgPSBhZGFwdENvbmZpZ3VyYXRvcjtcblxuICBmdW5jdGlvbiBjdXN0b21fYWRhcHRfX2NvbWJpbmUoYSwgYikge1xuICBcdHZhciBjID0gYS5zbGljZSgpLFxuICBcdCAgICBpID0gYi5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoISB+Yy5pbmRleE9mKGJbaV0pKSB7XG4gIFx0XHRcdGMucHVzaChiW2ldKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gYztcbiAgfVxuXG4gIHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1Dc3M7XG5cbiAgdmFyIHNlbGVjdG9yc1BhdHRlcm4gPSAvKD86XnxcXH0pP1xccyooW15cXHtcXH1dKylcXHMqXFx7L2csXG4gICAgICBjb21tZW50c1BhdHRlcm4gPSAvXFwvXFwqLio/XFwqXFwvL2csXG4gICAgICBzZWxlY3RvclVuaXRQYXR0ZXJuID0gLygoPzooPzpcXFtbXlxcXStdXFxdKXwoPzpbXlxcc1xcK1xcPlxcfjpdKSkrKSgoPzo6W15cXHNcXCtcXD5cXH5cXChdKyg/OlxcKFteXFwpXStcXCkpPyk/XFxzKltcXHNcXCtcXD5cXH5dPylcXHMqL2csXG4gICAgICBtZWRpYVF1ZXJ5UGF0dGVybiA9IC9eQG1lZGlhLyxcbiAgICAgIGRhdGFSdmNHdWlkUGF0dGVybiA9IC9cXFtkYXRhLXJhY3RpdmUtY3Nzfj1cIlxce1thLXowLTktXStcXH1cIl0vZztcbiAgZnVuY3Rpb24gdHJhbnNmb3JtQ3NzKGNzcywgaWQpIHtcbiAgXHR2YXIgdHJhbnNmb3JtZWQsIGRhdGFBdHRyLCBhZGRHdWlkO1xuXG4gIFx0ZGF0YUF0dHIgPSBcIltkYXRhLXJhY3RpdmUtY3Nzfj1cXFwie1wiICsgaWQgKyBcIn1cXFwiXVwiO1xuXG4gIFx0YWRkR3VpZCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdFx0dmFyIHNlbGVjdG9yVW5pdHMsXG4gIFx0XHQgICAgbWF0Y2gsXG4gIFx0XHQgICAgdW5pdCxcbiAgXHRcdCAgICBiYXNlLFxuICBcdFx0ICAgIHByZXBlbmRlZCxcbiAgXHRcdCAgICBhcHBlbmRlZCxcbiAgXHRcdCAgICBpLFxuICBcdFx0ICAgIHRyYW5zZm9ybWVkID0gW107XG5cbiAgXHRcdHNlbGVjdG9yVW5pdHMgPSBbXTtcblxuICBcdFx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JVbml0UGF0dGVybi5leGVjKHNlbGVjdG9yKSkge1xuICBcdFx0XHRzZWxlY3RvclVuaXRzLnB1c2goe1xuICBcdFx0XHRcdHN0cjogbWF0Y2hbMF0sXG4gIFx0XHRcdFx0YmFzZTogbWF0Y2hbMV0sXG4gIFx0XHRcdFx0bW9kaWZpZXJzOiBtYXRjaFsyXVxuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gRm9yIGVhY2ggc2ltcGxlIHNlbGVjdG9yIHdpdGhpbiB0aGUgc2VsZWN0b3IsIHdlIG5lZWQgdG8gY3JlYXRlIGEgdmVyc2lvblxuICBcdFx0Ly8gdGhhdCBhKSBjb21iaW5lcyB3aXRoIHRoZSBpZCwgYW5kIGIpIGlzIGluc2lkZSB0aGUgaWRcbiAgXHRcdGJhc2UgPSBzZWxlY3RvclVuaXRzLm1hcChleHRyYWN0U3RyaW5nKTtcblxuICBcdFx0aSA9IHNlbGVjdG9yVW5pdHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRhcHBlbmRlZCA9IGJhc2Uuc2xpY2UoKTtcblxuICBcdFx0XHQvLyBQc2V1ZG8tc2VsZWN0b3JzIHNob3VsZCBnbyBhZnRlciB0aGUgYXR0cmlidXRlIHNlbGVjdG9yXG4gIFx0XHRcdHVuaXQgPSBzZWxlY3RvclVuaXRzW2ldO1xuICBcdFx0XHRhcHBlbmRlZFtpXSA9IHVuaXQuYmFzZSArIGRhdGFBdHRyICsgdW5pdC5tb2RpZmllcnMgfHwgXCJcIjtcblxuICBcdFx0XHRwcmVwZW5kZWQgPSBiYXNlLnNsaWNlKCk7XG4gIFx0XHRcdHByZXBlbmRlZFtpXSA9IGRhdGFBdHRyICsgXCIgXCIgKyBwcmVwZW5kZWRbaV07XG5cbiAgXHRcdFx0dHJhbnNmb3JtZWQucHVzaChhcHBlbmRlZC5qb2luKFwiIFwiKSwgcHJlcGVuZGVkLmpvaW4oXCIgXCIpKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRyYW5zZm9ybWVkLmpvaW4oXCIsIFwiKTtcbiAgXHR9O1xuXG4gIFx0aWYgKGRhdGFSdmNHdWlkUGF0dGVybi50ZXN0KGNzcykpIHtcbiAgXHRcdHRyYW5zZm9ybWVkID0gY3NzLnJlcGxhY2UoZGF0YVJ2Y0d1aWRQYXR0ZXJuLCBkYXRhQXR0cik7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRyYW5zZm9ybWVkID0gY3NzLnJlcGxhY2UoY29tbWVudHNQYXR0ZXJuLCBcIlwiKS5yZXBsYWNlKHNlbGVjdG9yc1BhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCwgJDEpIHtcbiAgXHRcdFx0dmFyIHNlbGVjdG9ycywgdHJhbnNmb3JtZWQ7XG5cbiAgXHRcdFx0Ly8gZG9uJ3QgdHJhbnNmb3JtIG1lZGlhIHF1ZXJpZXMhXG4gIFx0XHRcdGlmIChtZWRpYVF1ZXJ5UGF0dGVybi50ZXN0KCQxKSkgcmV0dXJuIG1hdGNoO1xuXG4gIFx0XHRcdHNlbGVjdG9ycyA9ICQxLnNwbGl0KFwiLFwiKS5tYXAodHJpbSk7XG4gIFx0XHRcdHRyYW5zZm9ybWVkID0gc2VsZWN0b3JzLm1hcChhZGRHdWlkKS5qb2luKFwiLCBcIikgKyBcIiBcIjtcblxuICBcdFx0XHRyZXR1cm4gbWF0Y2gucmVwbGFjZSgkMSwgdHJhbnNmb3JtZWQpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRyYW5zZm9ybWVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgXHRpZiAoc3RyLnRyaW0pIHtcbiAgXHRcdHJldHVybiBzdHIudHJpbSgpO1xuICBcdH1cblxuICBcdHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvLCBcIlwiKS5yZXBsYWNlKC9cXHMrJC8sIFwiXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdFN0cmluZyh1bml0KSB7XG4gIFx0cmV0dXJuIHVuaXQuc3RyO1xuICB9XG5cbiAgdmFyIGNzc19jc3NfX3VpZCA9IDE7XG5cbiAgdmFyIGNzc0NvbmZpZ3VyYXRvciA9IHtcbiAgXHRuYW1lOiBcImNzc1wiLFxuXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0aWYgKG9wdGlvbnMuY3NzKSB7XG4gIFx0XHRcdHZhciBpZCA9IGNzc19jc3NfX3VpZCsrO1xuICBcdFx0XHR2YXIgc3R5bGVzID0gb3B0aW9ucy5ub0Nzc1RyYW5zZm9ybSA/IG9wdGlvbnMuY3NzIDogdHJhbnNmb3JtKG9wdGlvbnMuY3NzLCBpZCk7XG5cbiAgXHRcdFx0cHJvdG8uY3NzSWQgPSBpZDtcbiAgXHRcdFx0Z2xvYmFsX2Nzcy5hZGQoeyBpZDogaWQsIHN0eWxlczogc3R5bGVzIH0pO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7fVxuICB9O1xuXG4gIHZhciBjc3NfY3NzID0gY3NzQ29uZmlndXJhdG9yO1xuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKGRhdGEpIHtcbiAgXHQvLyBXYXJuIGlmIHVzZXJPcHRpb25zLmRhdGEgaXMgYSBub24tUE9KT1xuICBcdGlmIChkYXRhICYmIGRhdGEuY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICBcdFx0aWYgKHR5cGVvZiBkYXRhID09PSBcImZ1bmN0aW9uXCIpIHt9IGVsc2UgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRcdGZhdGFsKFwiZGF0YSBvcHRpb24gbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgYFwiICsgZGF0YSArIFwiYCBpcyBub3QgdmFsaWRcIik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIklmIHN1cHBsaWVkLCBvcHRpb25zLmRhdGEgc2hvdWxkIGJlIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgLSB1c2luZyBhIG5vbi1QT0pPIGFzIHRoZSByb290IG9iamVjdCBtYXkgd29yaywgYnV0IGlzIGRpc2NvdXJhZ2VkXCIpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBkYXRhQ29uZmlndXJhdG9yID0ge1xuICBcdG5hbWU6IFwiZGF0YVwiLFxuXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0dmFyIGtleSA9IHVuZGVmaW5lZCxcbiAgXHRcdCAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcblxuICBcdFx0Ly8gY2hlY2sgZm9yIG5vbi1wcmltaXRpdmVzLCB3aGljaCBjb3VsZCBjYXVzZSBtdXRhdGlvbi1yZWxhdGVkIGJ1Z3NcbiAgXHRcdGlmIChvcHRpb25zLmRhdGEgJiYgaXNPYmplY3Qob3B0aW9ucy5kYXRhKSkge1xuICBcdFx0XHRmb3IgKGtleSBpbiBvcHRpb25zLmRhdGEpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnMuZGF0YVtrZXldO1xuXG4gIFx0XHRcdFx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0XHRcdFx0aWYgKGlzT2JqZWN0KHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSkge1xuICBcdFx0XHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIlBhc3NpbmcgYSBgZGF0YWAgb3B0aW9uIHdpdGggb2JqZWN0IGFuZCBhcnJheSBwcm9wZXJ0aWVzIHRvIFJhY3RpdmUuZXh0ZW5kKCkgaXMgZGlzY291cmFnZWQsIGFzIG11dGF0aW5nIHRoZW0gaXMgbGlrZWx5IHRvIGNhdXNlIGJ1Z3MuIENvbnNpZGVyIHVzaW5nIGEgZGF0YSBmdW5jdGlvbiBpbnN0ZWFkOlxcblxcbiAgLy8gdGhpcy4uLlxcbiAgZGF0YTogZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIG15T2JqZWN0OiB7fVxcbiAgICB9O1xcbiAgfSlcXG5cXG4gIC8vIGluc3RlYWQgb2YgdGhpczpcXG4gIGRhdGE6IHtcXG4gICAgbXlPYmplY3Q6IHt9XFxuICB9XCIpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRwcm90by5kYXRhID0gY3VzdG9tX2RhdGFfX2NvbWJpbmUocHJvdG8uZGF0YSwgb3B0aW9ucy5kYXRhKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucykge1xuICBcdFx0dmFyIHJlc3VsdCA9IGN1c3RvbV9kYXRhX19jb21iaW5lKFBhcmVudC5wcm90b3R5cGUuZGF0YSwgb3B0aW9ucy5kYXRhKTtcblxuICBcdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRyZXN1bHQgPSByZXN1bHQuY2FsbChyYWN0aXZlKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHJlc3VsdCB8fCB7fTtcbiAgXHR9LFxuXG4gIFx0cmVzZXQ6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5pbml0KHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHJhY3RpdmUudmlld21vZGVsKTtcblxuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwucmVzZXQocmVzdWx0KTtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfTtcblxuICB2YXIgY3VzdG9tX2RhdGEgPSBkYXRhQ29uZmlndXJhdG9yO1xuXG4gIGZ1bmN0aW9uIGN1c3RvbV9kYXRhX19jb21iaW5lKHBhcmVudFZhbHVlLCBjaGlsZFZhbHVlKSB7XG4gIFx0dmFsaWRhdGUoY2hpbGRWYWx1ZSk7XG5cbiAgXHR2YXIgcGFyZW50SXNGbiA9IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xuICBcdHZhciBjaGlsZElzRm4gPSB0eXBlb2YgY2hpbGRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xuXG4gIFx0Ly8gVmVyeSBpbXBvcnRhbnQsIG90aGVyd2lzZSBjaGlsZCBpbnN0YW5jZSBjYW4gYmVjb21lXG4gIFx0Ly8gdGhlIGRlZmF1bHQgZGF0YSBvYmplY3Qgb24gUmFjdGl2ZSBvciBhIGNvbXBvbmVudC5cbiAgXHQvLyB0aGVuIHJhY3RpdmUuc2V0KCkgZW5kcyB1cCBzZXR0aW5nIG9uIHRoZSBwcm90b3R5cGUhXG4gIFx0aWYgKCFjaGlsZFZhbHVlICYmICFwYXJlbnRJc0ZuKSB7XG4gIFx0XHRjaGlsZFZhbHVlID0ge307XG4gIFx0fVxuXG4gIFx0Ly8gRmFzdCBwYXRoLCB3aGVyZSB3ZSBqdXN0IG5lZWQgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAgXHQvLyBwYXJlbnQgdG8gY2hpbGRcbiAgXHRpZiAoIXBhcmVudElzRm4gJiYgIWNoaWxkSXNGbikge1xuICBcdFx0cmV0dXJuIGZyb21Qcm9wZXJ0aWVzKGNoaWxkVmFsdWUsIHBhcmVudFZhbHVlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGNoaWxkID0gY2hpbGRJc0ZuID8gY2FsbERhdGFGdW5jdGlvbihjaGlsZFZhbHVlLCB0aGlzKSA6IGNoaWxkVmFsdWU7XG4gIFx0XHR2YXIgcGFyZW50ID0gcGFyZW50SXNGbiA/IGNhbGxEYXRhRnVuY3Rpb24ocGFyZW50VmFsdWUsIHRoaXMpIDogcGFyZW50VmFsdWU7XG5cbiAgXHRcdHJldHVybiBmcm9tUHJvcGVydGllcyhjaGlsZCwgcGFyZW50KTtcbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsbERhdGFGdW5jdGlvbihmbiwgY29udGV4dCkge1xuICBcdHZhciBkYXRhID0gZm4uY2FsbChjb250ZXh0KTtcblxuICBcdGlmICghZGF0YSkgcmV0dXJuO1xuXG4gIFx0aWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRmYXRhbChcIkRhdGEgZnVuY3Rpb24gbXVzdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xuICBcdH1cblxuICBcdGlmIChkYXRhLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgXHRcdHdhcm5PbmNlSWZEZWJ1ZyhcIkRhdGEgZnVuY3Rpb24gcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdC4gVGhpcyBtaWdodCB3b3JrLCBidXQgaXMgc3Ryb25nbHkgZGlzY291cmFnZWRcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGRhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tUHJvcGVydGllcyhwcmltYXJ5LCBzZWNvbmRhcnkpIHtcbiAgXHRpZiAocHJpbWFyeSAmJiBzZWNvbmRhcnkpIHtcbiAgXHRcdGZvciAodmFyIGtleSBpbiBzZWNvbmRhcnkpIHtcbiAgXHRcdFx0aWYgKCEoa2V5IGluIHByaW1hcnkpKSB7XG4gIFx0XHRcdFx0cHJpbWFyeVtrZXldID0gc2Vjb25kYXJ5W2tleV07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHByaW1hcnk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByaW1hcnkgfHwgc2Vjb25kYXJ5O1xuICB9XG5cbiAgLy8gVE9ETyBkbyB3ZSBuZWVkIHRvIHN1cHBvcnQgdGhpcyBpbiB0aGUgbmV3IFJhY3RpdmUoKSBjYXNlP1xuXG4gIHZhciBQYXJzZXIsXG4gICAgICBQYXJzZUVycm9yLFxuICAgICAgcGFyc2VfUGFyc2VyX19sZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy87XG5cbiAgUGFyc2VFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIFx0dGhpcy5uYW1lID0gXCJQYXJzZUVycm9yXCI7XG4gIFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgXHR0cnkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xuICBcdH1cbiAgfTtcblxuICBQYXJzZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBQYXJzZXIgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0dmFyIGl0ZW1zLFxuICBcdCAgICBpdGVtLFxuICBcdCAgICBsaW5lU3RhcnQgPSAwO1xuXG4gIFx0dGhpcy5zdHIgPSBzdHI7XG4gIFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXHR0aGlzLnBvcyA9IDA7XG5cbiAgXHR0aGlzLmxpbmVzID0gdGhpcy5zdHIuc3BsaXQoXCJcXG5cIik7XG4gIFx0dGhpcy5saW5lRW5kcyA9IHRoaXMubGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gIFx0XHR2YXIgbGluZUVuZCA9IGxpbmVTdGFydCArIGxpbmUubGVuZ3RoICsgMTsgLy8gKzEgZm9yIHRoZSBuZXdsaW5lXG5cbiAgXHRcdGxpbmVTdGFydCA9IGxpbmVFbmQ7XG4gIFx0XHRyZXR1cm4gbGluZUVuZDtcbiAgXHR9LCAwKTtcblxuICBcdC8vIEN1c3RvbSBpbml0IGxvZ2ljXG4gIFx0aWYgKHRoaXMuaW5pdCkgdGhpcy5pbml0KHN0ciwgb3B0aW9ucyk7XG5cbiAgXHRpdGVtcyA9IFtdO1xuXG4gIFx0d2hpbGUgKHRoaXMucG9zIDwgdGhpcy5zdHIubGVuZ3RoICYmIChpdGVtID0gdGhpcy5yZWFkKCkpKSB7XG4gIFx0XHRpdGVtcy5wdXNoKGl0ZW0pO1xuICBcdH1cblxuICBcdHRoaXMubGVmdG92ZXIgPSB0aGlzLnJlbWFpbmluZygpO1xuICBcdHRoaXMucmVzdWx0ID0gdGhpcy5wb3N0UHJvY2VzcyA/IHRoaXMucG9zdFByb2Nlc3MoaXRlbXMsIG9wdGlvbnMpIDogaXRlbXM7XG4gIH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgXHRyZWFkOiBmdW5jdGlvbiAoY29udmVydGVycykge1xuICBcdFx0dmFyIHBvcywgaSwgbGVuLCBpdGVtO1xuXG4gIFx0XHRpZiAoIWNvbnZlcnRlcnMpIGNvbnZlcnRlcnMgPSB0aGlzLmNvbnZlcnRlcnM7XG5cbiAgXHRcdHBvcyA9IHRoaXMucG9zO1xuXG4gIFx0XHRsZW4gPSBjb252ZXJ0ZXJzLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHR0aGlzLnBvcyA9IHBvczsgLy8gcmVzZXQgZm9yIGVhY2ggYXR0ZW1wdFxuXG4gIFx0XHRcdGlmIChpdGVtID0gY29udmVydGVyc1tpXSh0aGlzKSkge1xuICBcdFx0XHRcdHJldHVybiBpdGVtO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH0sXG5cbiAgXHRnZXRMaW5lUG9zOiBmdW5jdGlvbiAoY2hhcikge1xuICBcdFx0dmFyIGxpbmVOdW0gPSAwLFxuICBcdFx0ICAgIGxpbmVTdGFydCA9IDAsXG4gIFx0XHQgICAgY29sdW1uTnVtO1xuXG4gIFx0XHR3aGlsZSAoY2hhciA+PSB0aGlzLmxpbmVFbmRzW2xpbmVOdW1dKSB7XG4gIFx0XHRcdGxpbmVTdGFydCA9IHRoaXMubGluZUVuZHNbbGluZU51bV07XG4gIFx0XHRcdGxpbmVOdW0gKz0gMTtcbiAgXHRcdH1cblxuICBcdFx0Y29sdW1uTnVtID0gY2hhciAtIGxpbmVTdGFydDtcbiAgXHRcdHJldHVybiBbbGluZU51bSArIDEsIGNvbHVtbk51bSArIDEsIGNoYXJdOyAvLyBsaW5lL2NvbCBzaG91bGQgYmUgb25lLWJhc2VkLCBub3QgemVyby1iYXNlZCFcbiAgXHR9LFxuXG4gIFx0ZXJyb3I6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIFx0XHR2YXIgcG9zID0gdGhpcy5nZXRMaW5lUG9zKHRoaXMucG9zKTtcbiAgXHRcdHZhciBsaW5lTnVtID0gcG9zWzBdO1xuICBcdFx0dmFyIGNvbHVtbk51bSA9IHBvc1sxXTtcblxuICBcdFx0dmFyIGxpbmUgPSB0aGlzLmxpbmVzW3Bvc1swXSAtIDFdO1xuICBcdFx0dmFyIG51bVRhYnMgPSAwO1xuICBcdFx0dmFyIGFubm90YXRpb24gPSBsaW5lLnJlcGxhY2UoL1xcdC9nLCBmdW5jdGlvbiAobWF0Y2gsIGNoYXIpIHtcbiAgXHRcdFx0aWYgKGNoYXIgPCBwb3NbMV0pIHtcbiAgXHRcdFx0XHRudW1UYWJzICs9IDE7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gXCIgIFwiO1xuICBcdFx0fSkgKyBcIlxcblwiICsgbmV3IEFycmF5KHBvc1sxXSArIG51bVRhYnMpLmpvaW4oXCIgXCIpICsgXCJeLS0tLVwiO1xuXG4gIFx0XHR2YXIgZXJyb3IgPSBuZXcgUGFyc2VFcnJvcihcIlwiICsgbWVzc2FnZSArIFwiIGF0IGxpbmUgXCIgKyBsaW5lTnVtICsgXCIgY2hhcmFjdGVyIFwiICsgY29sdW1uTnVtICsgXCI6XFxuXCIgKyBhbm5vdGF0aW9uKTtcblxuICBcdFx0ZXJyb3IubGluZSA9IHBvc1swXTtcbiAgXHRcdGVycm9yLmNoYXJhY3RlciA9IHBvc1sxXTtcbiAgXHRcdGVycm9yLnNob3J0TWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgXHRcdHRocm93IGVycm9yO1xuICBcdH0sXG5cbiAgXHRtYXRjaFN0cmluZzogZnVuY3Rpb24gKHN0cmluZykge1xuICBcdFx0aWYgKHRoaXMuc3RyLnN1YnN0cih0aGlzLnBvcywgc3RyaW5nLmxlbmd0aCkgPT09IHN0cmluZykge1xuICBcdFx0XHR0aGlzLnBvcyArPSBzdHJpbmcubGVuZ3RoO1xuICBcdFx0XHRyZXR1cm4gc3RyaW5nO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRtYXRjaFBhdHRlcm46IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gIFx0XHR2YXIgbWF0Y2g7XG5cbiAgXHRcdGlmIChtYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLnJlbWFpbmluZygpKSkge1xuICBcdFx0XHR0aGlzLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gIFx0XHRcdHJldHVybiBtYXRjaFsxXSB8fCBtYXRjaFswXTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0YWxsb3dXaGl0ZXNwYWNlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLm1hdGNoUGF0dGVybihwYXJzZV9QYXJzZXJfX2xlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgXHR9LFxuXG4gIFx0cmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zdHIuc3Vic3RyaW5nKHRoaXMucG9zKTtcbiAgXHR9LFxuXG4gIFx0bmV4dENoYXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnN0ci5jaGFyQXQodGhpcy5wb3MpO1xuICBcdH1cbiAgfTtcblxuICBQYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvKSB7XG4gIFx0dmFyIFBhcmVudCA9IHRoaXMsXG4gIFx0ICAgIENoaWxkLFxuICBcdCAgICBrZXk7XG5cbiAgXHRDaGlsZCA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgXHRcdFBhcnNlci5jYWxsKHRoaXMsIHN0ciwgb3B0aW9ucyk7XG4gIFx0fTtcblxuICBcdENoaWxkLnByb3RvdHlwZSA9IGNyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcblxuICBcdGZvciAoa2V5IGluIHByb3RvKSB7XG4gIFx0XHRpZiAoaGFzT3duLmNhbGwocHJvdG8sIGtleSkpIHtcbiAgXHRcdFx0Q2hpbGQucHJvdG90eXBlW2tleV0gPSBwcm90b1trZXldO1xuICBcdFx0fVxuICBcdH1cblxuICBcdENoaWxkLmV4dGVuZCA9IFBhcnNlci5leHRlbmQ7XG4gIFx0cmV0dXJuIENoaWxkO1xuICB9O1xuXG4gIHZhciBwYXJzZV9QYXJzZXIgPSBQYXJzZXI7XG5cbiAgdmFyIFRFWFQgPSAxO1xuICB2YXIgSU5URVJQT0xBVE9SID0gMjtcbiAgdmFyIFRSSVBMRSA9IDM7XG4gIHZhciBTRUNUSU9OID0gNDtcbiAgdmFyIElOVkVSVEVEID0gNTtcbiAgdmFyIENMT1NJTkcgPSA2O1xuICB2YXIgRUxFTUVOVCA9IDc7XG4gIHZhciBQQVJUSUFMID0gODtcbiAgdmFyIENPTU1FTlQgPSA5O1xuICB2YXIgREVMSU1DSEFOR0UgPSAxMDtcbiAgdmFyIEFUVFJJQlVURSA9IDEzO1xuICB2YXIgQ0xPU0lOR19UQUcgPSAxNDtcbiAgdmFyIENPTVBPTkVOVCA9IDE1O1xuICB2YXIgWUlFTERFUiA9IDE2O1xuICB2YXIgSU5MSU5FX1BBUlRJQUwgPSAxNztcbiAgdmFyIERPQ1RZUEUgPSAxODtcblxuICB2YXIgTlVNQkVSX0xJVEVSQUwgPSAyMDtcbiAgdmFyIFNUUklOR19MSVRFUkFMID0gMjE7XG4gIHZhciBBUlJBWV9MSVRFUkFMID0gMjI7XG4gIHZhciBPQkpFQ1RfTElURVJBTCA9IDIzO1xuICB2YXIgQk9PTEVBTl9MSVRFUkFMID0gMjQ7XG4gIHZhciBSRUdFWFBfTElURVJBTCA9IDI1O1xuXG4gIHZhciBHTE9CQUwgPSAyNjtcbiAgdmFyIEtFWV9WQUxVRV9QQUlSID0gMjc7XG5cbiAgdmFyIFJFRkVSRU5DRSA9IDMwO1xuICB2YXIgUkVGSU5FTUVOVCA9IDMxO1xuICB2YXIgTUVNQkVSID0gMzI7XG4gIHZhciBQUkVGSVhfT1BFUkFUT1IgPSAzMztcbiAgdmFyIEJSQUNLRVRFRCA9IDM0O1xuICB2YXIgQ09ORElUSU9OQUwgPSAzNTtcbiAgdmFyIElORklYX09QRVJBVE9SID0gMzY7XG5cbiAgdmFyIElOVk9DQVRJT04gPSA0MDtcblxuICB2YXIgU0VDVElPTl9JRiA9IDUwO1xuICB2YXIgU0VDVElPTl9VTkxFU1MgPSA1MTtcbiAgdmFyIFNFQ1RJT05fRUFDSCA9IDUyO1xuICB2YXIgU0VDVElPTl9XSVRIID0gNTM7XG4gIHZhciBTRUNUSU9OX0lGX1dJVEggPSA1NDtcblxuICB2YXIgRUxTRSA9IDYwO1xuICB2YXIgRUxTRUlGID0gNjE7XG5cbiAgdmFyIG11c3RhY2hlX3JlYWREZWxpbWl0ZXJDaGFuZ2UgPSByZWFkRGVsaW1pdGVyQ2hhbmdlO1xuICB2YXIgZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiA9IC9eW15cXHM9XSsvLFxuICAgICAgd2hpdGVzcGFjZVBhdHRlcm4gPSAvXlxccysvO1xuICBmdW5jdGlvbiByZWFkRGVsaW1pdGVyQ2hhbmdlKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgb3BlbmluZywgY2xvc2luZztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPVwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgbmV3IG9wZW5pbmcgZGVsaW1pdGVyXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0b3BlbmluZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oZGVsaW1pdGVyQ2hhbmdlUGF0dGVybik7XG4gIFx0aWYgKCFvcGVuaW5nKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIChpbiBmYWN0LCBpdCdzIG5lY2Vzc2FyeS4uLilcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4od2hpdGVzcGFjZVBhdHRlcm4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRjbG9zaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybihkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuKTtcbiAgXHRpZiAoIWNsb3NpbmcpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3NpbmcgJz0nXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI9XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gW29wZW5pbmcsIGNsb3NpbmddO1xuICB9XG5cbiAgdmFyIHJlYWRSZWdleHBMaXRlcmFsID0gcmVhZFJlZ2V4cExpdGVyYWxfX3JlYWROdW1iZXJMaXRlcmFsO1xuICB2YXIgcmVnZXhwUGF0dGVybiA9IC9eKFxcLyg/OlteXFxuXFxyXFx1MjAyOFxcdTIwMjkvXFxcXFtdfFxcXFwufFxcWyg/OlteXFxuXFxyXFx1MjAyOFxcdTIwMjlcXF1cXFxcXXxcXFxcLikqXSkrXFwvKD86KFtnaW11eV0pKD8hW2Etel0qXFwyKSkqKD8hW2EtekEtWl8kMC05XSkpLztcbiAgZnVuY3Rpb24gcmVhZFJlZ2V4cExpdGVyYWxfX3JlYWROdW1iZXJMaXRlcmFsKHBhcnNlcikge1xuICBcdHZhciByZXN1bHQ7XG5cbiAgXHRpZiAocmVzdWx0ID0gcGFyc2VyLm1hdGNoUGF0dGVybihyZWdleHBQYXR0ZXJuKSkge1xuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogUkVHRVhQX0xJVEVSQUwsXG4gIFx0XHRcdHY6IHJlc3VsdFxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZSA9IHJlYWRNdXN0YWNoZTtcblxuICB2YXIgZGVsaW1pdGVyQ2hhbmdlVG9rZW4gPSB7IHQ6IERFTElNQ0hBTkdFLCBleGNsdWRlOiB0cnVlIH07XG4gIGZ1bmN0aW9uIHJlYWRNdXN0YWNoZShwYXJzZXIpIHtcbiAgXHR2YXIgbXVzdGFjaGUsIGk7XG5cbiAgXHQvLyBJZiB3ZSdyZSBpbnNpZGUgYSA8c2NyaXB0PiBvciA8c3R5bGU+IHRhZywgYW5kIHdlJ3JlIG5vdFxuICBcdC8vIGludGVycG9sYXRpbmcsIGJ1ZyBvdXRcbiAgXHRpZiAocGFyc2VyLmludGVycG9sYXRlW3BhcnNlci5pbnNpZGVdID09PSBmYWxzZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Zm9yIChpID0gMDsgaSA8IHBhcnNlci50YWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRpZiAobXVzdGFjaGUgPSByZWFkTXVzdGFjaGVPZlR5cGUocGFyc2VyLCBwYXJzZXIudGFnc1tpXSkpIHtcbiAgXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRNdXN0YWNoZU9mVHlwZShwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgbXVzdGFjaGUsIHJlYWRlciwgaTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJcXFxcXCIgKyB0YWcub3BlbikpIHtcbiAgXHRcdGlmIChzdGFydCA9PT0gMCB8fCBwYXJzZXIuc3RyW3N0YXJ0IC0gMV0gIT09IFwiXFxcXFwiKSB7XG4gIFx0XHRcdHJldHVybiB0YWcub3BlbjtcbiAgXHRcdH1cbiAgXHR9IGVsc2UgaWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLm9wZW4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBkZWxpbWl0ZXIgY2hhbmdlP1xuICBcdGlmIChtdXN0YWNoZSA9IG11c3RhY2hlX3JlYWREZWxpbWl0ZXJDaGFuZ2UocGFyc2VyKSkge1xuICBcdFx0Ly8gZmluZCBjbG9zaW5nIGRlbGltaXRlciBvciBhYm9ydC4uLlxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gLi4udGhlbiBtYWtlIHRoZSBzd2l0Y2hcbiAgXHRcdHRhZy5vcGVuID0gbXVzdGFjaGVbMF07XG4gIFx0XHR0YWcuY2xvc2UgPSBtdXN0YWNoZVsxXTtcbiAgXHRcdHBhcnNlci5zb3J0TXVzdGFjaGVUYWdzKCk7XG5cbiAgXHRcdHJldHVybiBkZWxpbWl0ZXJDaGFuZ2VUb2tlbjtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBpbGxlZ2FsIHNlY3Rpb24gY2xvc2VyXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIi9cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgLT0gMTtcbiAgXHRcdHZhciByZXdpbmQgPSBwYXJzZXIucG9zO1xuICBcdFx0aWYgKCFyZWFkUmVnZXhwTGl0ZXJhbChwYXJzZXIpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSByZXdpbmQgLSB0YWcuY2xvc2UubGVuZ3RoO1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJBdHRlbXB0ZWQgdG8gY2xvc2UgYSBzZWN0aW9uIHRoYXQgd2Fzbid0IG9wZW5cIik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXJzZXIucG9zID0gcmV3aW5kO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGZvciAoaSA9IDA7IGkgPCB0YWcucmVhZGVycy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0cmVhZGVyID0gdGFnLnJlYWRlcnNbaV07XG5cbiAgXHRcdGlmIChtdXN0YWNoZSA9IHJlYWRlcihwYXJzZXIsIHRhZykpIHtcbiAgXHRcdFx0aWYgKHRhZy5pc1N0YXRpYykge1xuICBcdFx0XHRcdG11c3RhY2hlLnMgPSB0cnVlOyAvLyBUT0RPIG1ha2UgdGhpcyBgMWAgaW5zdGVhZCAtIG1vcmUgY29tcGFjdFxuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucykge1xuICBcdFx0XHRcdG11c3RhY2hlLnAgPSBwYXJzZXIuZ2V0TGluZVBvcyhzdGFydCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV4cGVjdGVkRXhwcmVzc2lvbiA9IFwiRXhwZWN0ZWQgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb25cIjtcbiAgdmFyIGV4cGVjdGVkUGFyZW4gPSBcIkV4cGVjdGVkIGNsb3NpbmcgcGFyZW5cIjtcblxuICB2YXIgbGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbCA9IGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWxfX3JlYWROdW1iZXJMaXRlcmFsO1xuICB2YXIgbGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbF9fbnVtYmVyUGF0dGVybiA9IC9eKD86WystXT8pMCooPzooPzooPzpbMS05XVxcZCopP1xcLlxcZCspfCg/Oig/OjB8WzEtOV1cXGQqKVxcLil8KD86MHxbMS05XVxcZCopKSg/OltlRV1bKy1dP1xcZCspPy87XG4gIGZ1bmN0aW9uIGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWxfX3JlYWROdW1iZXJMaXRlcmFsKHBhcnNlcikge1xuICBcdHZhciByZXN1bHQ7XG5cbiAgXHRpZiAocmVzdWx0ID0gcGFyc2VyLm1hdGNoUGF0dGVybihsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsX19udW1iZXJQYXR0ZXJuKSkge1xuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogTlVNQkVSX0xJVEVSQUwsXG4gIFx0XHRcdHY6IHJlc3VsdFxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsaXRlcmFsX3JlYWRCb29sZWFuTGl0ZXJhbCA9IHJlYWRCb29sZWFuTGl0ZXJhbDtcbiAgZnVuY3Rpb24gcmVhZEJvb2xlYW5MaXRlcmFsKHBhcnNlcikge1xuICBcdHZhciByZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cbiAgXHRpZiAocmVtYWluaW5nLnN1YnN0cigwLCA0KSA9PT0gXCJ0cnVlXCIpIHtcbiAgXHRcdHBhcnNlci5wb3MgKz0gNDtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IEJPT0xFQU5fTElURVJBTCxcbiAgXHRcdFx0djogXCJ0cnVlXCJcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0aWYgKHJlbWFpbmluZy5zdWJzdHIoMCwgNSkgPT09IFwiZmFsc2VcIikge1xuICBcdFx0cGFyc2VyLnBvcyArPSA1O1xuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogQk9PTEVBTl9MSVRFUkFMLFxuICBcdFx0XHR2OiBcImZhbHNlXCJcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc3RyaW5nTWlkZGxlUGF0dGVybiwgZXNjYXBlU2VxdWVuY2VQYXR0ZXJuLCBsaW5lQ29udGludWF0aW9uUGF0dGVybjtcblxuICAvLyBNYXRjaCBvbmUgb3IgbW9yZSBjaGFyYWN0ZXJzIHVudGlsOiBcIiwgJywgXFwsIG9yIEVPTC9FT0YuXG4gIC8vIEVPTC9FT0YgaXMgd3JpdHRlbiBhcyAoPyEuKSAobWVhbmluZyB0aGVyZSdzIG5vIG5vbi1uZXdsaW5lIGNoYXIgbmV4dCkuXG4gIHN0cmluZ01pZGRsZVBhdHRlcm4gPSAvXig/PS4pW15cIidcXFxcXSs/KD86KD8hLil8KD89W1wiJ1xcXFxdKSkvO1xuXG4gIC8vIE1hdGNoIG9uZSBlc2NhcGUgc2VxdWVuY2UsIGluY2x1ZGluZyB0aGUgYmFja3NsYXNoLlxuICBlc2NhcGVTZXF1ZW5jZVBhdHRlcm4gPSAvXlxcXFwoPzpbJ1wiXFxcXGJmbnJ0XXwwKD8hWzAtOV0pfHhbMC05YS1mQS1GXXsyfXx1WzAtOWEtZkEtRl17NH18KD89LilbXnV4MC05XSkvO1xuXG4gIC8vIE1hdGNoIG9uZSBFUzUgbGluZSBjb250aW51YXRpb24gKGJhY2tzbGFzaCArIGxpbmUgdGVybWluYXRvcikuXG4gIGxpbmVDb250aW51YXRpb25QYXR0ZXJuID0gL15cXFxcKD86XFxyXFxufFtcXHUwMDBBXFx1MDAwRFxcdTIwMjhcXHUyMDI5XSkvO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgZ2V0RG91YmxlUXVvdGVkU3RyaW5nIGFuZCBnZXRTaW5nbGVRdW90ZWRTdHJpbmcuXG4gIHZhciBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciA9IGZ1bmN0aW9uIChva1F1b3RlKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHRcdHZhciBzdGFydCwgbGl0ZXJhbCwgZG9uZSwgbmV4dDtcblxuICBcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdFx0bGl0ZXJhbCA9IFwiXFxcIlwiO1xuICBcdFx0ZG9uZSA9IGZhbHNlO1xuXG4gIFx0XHR3aGlsZSAoIWRvbmUpIHtcbiAgXHRcdFx0bmV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oc3RyaW5nTWlkZGxlUGF0dGVybikgfHwgcGFyc2VyLm1hdGNoUGF0dGVybihlc2NhcGVTZXF1ZW5jZVBhdHRlcm4pIHx8IHBhcnNlci5tYXRjaFN0cmluZyhva1F1b3RlKTtcbiAgXHRcdFx0aWYgKG5leHQpIHtcbiAgXHRcdFx0XHRpZiAobmV4dCA9PT0gXCJcXFwiXCIpIHtcbiAgXHRcdFx0XHRcdGxpdGVyYWwgKz0gXCJcXFxcXFxcIlwiO1xuICBcdFx0XHRcdH0gZWxzZSBpZiAobmV4dCA9PT0gXCJcXFxcJ1wiKSB7XG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IFwiJ1wiO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IG5leHQ7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGxpbmVDb250aW51YXRpb25QYXR0ZXJuKTtcbiAgXHRcdFx0XHRpZiAobmV4dCkge1xuICBcdFx0XHRcdFx0Ly8gY29udmVydCBcXChuZXdsaW5lLWxpa2UpIGludG8gYSBcXHUgZXNjYXBlLCB3aGljaCBpcyBhbGxvd2VkIGluIEpTT05cbiAgXHRcdFx0XHRcdGxpdGVyYWwgKz0gXCJcXFxcdVwiICsgKFwiMDAwXCIgKyBuZXh0LmNoYXJDb2RlQXQoMSkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGRvbmUgPSB0cnVlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRsaXRlcmFsICs9IFwiXFxcIlwiO1xuXG4gIFx0XHQvLyB1c2UgSlNPTi5wYXJzZSB0byBpbnRlcnByZXQgZXNjYXBlc1xuICBcdFx0cmV0dXJuIEpTT04ucGFyc2UobGl0ZXJhbCk7XG4gIFx0fTtcbiAgfTtcblxuICB2YXIgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nID0gbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIoXCJcXFwiXCIpO1xuICB2YXIgZ2V0RG91YmxlUXVvdGVkU3RyaW5nID0gbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIoXCInXCIpO1xuXG4gIHZhciByZWFkU3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHN0cmluZztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJcXFwiXCIpKSB7XG4gIFx0XHRzdHJpbmcgPSBnZXREb3VibGVRdW90ZWRTdHJpbmcocGFyc2VyKTtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJcXFwiXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IFNUUklOR19MSVRFUkFMLFxuICBcdFx0XHR2OiBzdHJpbmdcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIidcIikpIHtcbiAgXHRcdHN0cmluZyA9IGdldFNpbmdsZVF1b3RlZFN0cmluZyhwYXJzZXIpO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIidcIikpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogU1RSSU5HX0xJVEVSQUwsXG4gIFx0XHRcdHY6IHN0cmluZ1xuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgcGF0dGVybnNfX25hbWUgPSAvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKi87XG5cbiAgLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1wcm9wZXJ0aWVzXG4gIC8vIGNhbiBiZSBhbnkgbmFtZSwgc3RyaW5nIGxpdGVyYWwsIG9yIG51bWJlciBsaXRlcmFsXG4gIHZhciBzaGFyZWRfcmVhZEtleSA9IHJlYWRLZXk7XG4gIHZhciBpZGVudGlmaWVyID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSokLztcbiAgZnVuY3Rpb24gcmVhZEtleShwYXJzZXIpIHtcbiAgXHR2YXIgdG9rZW47XG5cbiAgXHRpZiAodG9rZW4gPSByZWFkU3RyaW5nTGl0ZXJhbChwYXJzZXIpKSB7XG4gIFx0XHRyZXR1cm4gaWRlbnRpZmllci50ZXN0KHRva2VuLnYpID8gdG9rZW4udiA6IFwiXFxcIlwiICsgdG9rZW4udi5yZXBsYWNlKC9cIi9nLCBcIlxcXFxcXFwiXCIpICsgXCJcXFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKHRva2VuID0gbGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbChwYXJzZXIpKSB7XG4gIFx0XHRyZXR1cm4gdG9rZW4udjtcbiAgXHR9XG5cbiAgXHRpZiAodG9rZW4gPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhdHRlcm5zX19uYW1lKSkge1xuICBcdFx0cmV0dXJuIHRva2VuO1xuICBcdH1cbiAgfVxuXG4gIHZhciBrZXlWYWx1ZVBhaXIgPSByZWFkS2V5VmFsdWVQYWlyO1xuICBmdW5jdGlvbiByZWFkS2V5VmFsdWVQYWlyKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwga2V5LCB2YWx1ZTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiAneycgYW5kIGtleVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGtleSA9IHNoYXJlZF9yZWFkS2V5KHBhcnNlcik7XG4gIFx0aWYgKGtleSA9PT0gbnVsbCkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGtleSBhbmQgJzonXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSAnOidcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjpcIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiAnOicgYW5kIHZhbHVlXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gbmV4dCBleHByZXNzaW9uIG11c3QgYmUgYSwgd2VsbC4uLiBleHByZXNzaW9uXG4gIFx0dmFsdWUgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogS0VZX1ZBTFVFX1BBSVIsXG4gIFx0XHRrOiBrZXksXG4gIFx0XHR2OiB2YWx1ZVxuICBcdH07XG4gIH1cblxuICB2YXIgb2JqZWN0TGl0ZXJhbF9rZXlWYWx1ZVBhaXJzID0gcmVhZEtleVZhbHVlUGFpcnM7XG4gIGZ1bmN0aW9uIHJlYWRLZXlWYWx1ZVBhaXJzKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgcGFpcnMsIHBhaXIsIGtleVZhbHVlUGFpcnM7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYWlyID0ga2V5VmFsdWVQYWlyKHBhcnNlcik7XG4gIFx0aWYgKHBhaXIgPT09IG51bGwpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhaXJzID0gW3BhaXJdO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIixcIikpIHtcbiAgXHRcdGtleVZhbHVlUGFpcnMgPSByZWFkS2V5VmFsdWVQYWlycyhwYXJzZXIpO1xuXG4gIFx0XHRpZiAoIWtleVZhbHVlUGFpcnMpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHBhaXJzLmNvbmNhdChrZXlWYWx1ZVBhaXJzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcGFpcnM7XG4gIH1cblxuICB2YXIgcmVhZE9iamVjdExpdGVyYWwgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBrZXlWYWx1ZVBhaXJzO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwie1wiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0a2V5VmFsdWVQYWlycyA9IG9iamVjdExpdGVyYWxfa2V5VmFsdWVQYWlycyhwYXJzZXIpO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGZpbmFsIHZhbHVlIGFuZCAnfSdcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIn1cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBPQkpFQ1RfTElURVJBTCxcbiAgXHRcdG06IGtleVZhbHVlUGFpcnNcbiAgXHR9O1xuICB9O1xuXG4gIHZhciBzaGFyZWRfcmVhZEV4cHJlc3Npb25MaXN0ID0gcmVhZEV4cHJlc3Npb25MaXN0O1xuICBmdW5jdGlvbiByZWFkRXhwcmVzc2lvbkxpc3QocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9ucywgZXhwciwgbmV4dDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHIgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoZXhwciA9PT0gbnVsbCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZXhwcmVzc2lvbnMgPSBbZXhwcl07XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gZXhwcmVzc2lvbiBhbmQgJywnXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIixcIikpIHtcbiAgXHRcdG5leHQgPSByZWFkRXhwcmVzc2lvbkxpc3QocGFyc2VyKTtcbiAgXHRcdGlmIChuZXh0ID09PSBudWxsKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdFx0fVxuXG4gIFx0XHRuZXh0LmZvckVhY2goYXBwZW5kKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBhcHBlbmQoZXhwcmVzc2lvbikge1xuICBcdFx0ZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZXhwcmVzc2lvbnM7XG4gIH1cblxuICB2YXIgcmVhZEFycmF5TGl0ZXJhbCA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb25MaXN0O1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgJ1snXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJbXCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRleHByZXNzaW9uTGlzdCA9IHNoYXJlZF9yZWFkRXhwcmVzc2lvbkxpc3QocGFyc2VyKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiXVwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEFSUkFZX0xJVEVSQUwsXG4gIFx0XHRtOiBleHByZXNzaW9uTGlzdFxuICBcdH07XG4gIH07XG5cbiAgdmFyIHByaW1hcnlfcmVhZExpdGVyYWwgPSByZWFkTGl0ZXJhbDtcbiAgZnVuY3Rpb24gcmVhZExpdGVyYWwocGFyc2VyKSB7XG4gIFx0cmV0dXJuIGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWwocGFyc2VyKSB8fCBsaXRlcmFsX3JlYWRCb29sZWFuTGl0ZXJhbChwYXJzZXIpIHx8IHJlYWRTdHJpbmdMaXRlcmFsKHBhcnNlcikgfHwgcmVhZE9iamVjdExpdGVyYWwocGFyc2VyKSB8fCByZWFkQXJyYXlMaXRlcmFsKHBhcnNlcikgfHwgcmVhZFJlZ2V4cExpdGVyYWwocGFyc2VyKTtcbiAgfVxuXG4gIHZhciBwcmltYXJ5X3JlYWRSZWZlcmVuY2UgPSByZWFkUmVmZXJlbmNlO1xuICB2YXIgcHJlZml4UGF0dGVybiA9IC9eKD86flxcL3woPzpcXC5cXC5cXC8pK3xcXC5cXC8oPzpcXC5cXC5cXC8pKnxcXC4pLyxcbiAgICAgIGdsb2JhbHMsXG4gICAgICBrZXl3b3JkcztcblxuICAvLyBpZiBhIHJlZmVyZW5jZSBpcyBhIGJyb3dzZXIgZ2xvYmFsLCB3ZSBkb24ndCBkZWZlcmVuY2UgaXQgbGF0ZXIsIHNvIGl0IG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50XG4gIGdsb2JhbHMgPSAvXig/OkFycmF5fGNvbnNvbGV8RGF0ZXxSZWdFeHB8ZGVjb2RlVVJJQ29tcG9uZW50fGRlY29kZVVSSXxlbmNvZGVVUklDb21wb25lbnR8ZW5jb2RlVVJJfGlzRmluaXRlfGlzTmFOfHBhcnNlRmxvYXR8cGFyc2VJbnR8SlNPTnxNYXRofE5hTnx1bmRlZmluZWR8bnVsbClcXGIvO1xuXG4gIC8vIGtleXdvcmRzIGFyZSBub3QgdmFsaWQgcmVmZXJlbmNlcywgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGB0aGlzYFxuICBrZXl3b3JkcyA9IC9eKD86YnJlYWt8Y2FzZXxjYXRjaHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGlmfGlufGluc3RhbmNlb2Z8bmV3fHJldHVybnxzd2l0Y2h8dGhyb3d8dHJ5fHR5cGVvZnx2YXJ8dm9pZHx3aGlsZXx3aXRoKSQvO1xuXG4gIHZhciBsZWdhbFJlZmVyZW5jZSA9IC9eW2EtekEtWiRfMC05XSsoPzooPzpcXC5bYS16QS1aJF8wLTldKyl8KD86XFxbWzAtOV0rXFxdKSkqLztcbiAgdmFyIHJlbGF4ZWROYW1lID0gL15bYS16QS1aXyRdWy1hLXpBLVpfJDAtOV0qLztcbiAgZnVuY3Rpb24gcmVhZFJlZmVyZW5jZShwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnRQb3MsIHByZWZpeCwgbmFtZSwgZ2xvYmFsLCByZWZlcmVuY2UsIGxhc3REb3RJbmRleDtcblxuICBcdHN0YXJ0UG9zID0gcGFyc2VyLnBvcztcblxuICBcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eQCg/OmtleXBhdGh8aW5kZXh8a2V5KS8pO1xuXG4gIFx0aWYgKCFuYW1lKSB7XG4gIFx0XHRwcmVmaXggPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHByZWZpeFBhdHRlcm4pIHx8IFwiXCI7XG4gIFx0XHRuYW1lID0gIXByZWZpeCAmJiBwYXJzZXIucmVsYXhlZE5hbWVzICYmIHBhcnNlci5tYXRjaFBhdHRlcm4ocmVsYXhlZE5hbWUpIHx8IHBhcnNlci5tYXRjaFBhdHRlcm4obGVnYWxSZWZlcmVuY2UpO1xuXG4gIFx0XHRpZiAoIW5hbWUgJiYgcHJlZml4ID09PSBcIi5cIikge1xuICBcdFx0XHRwcmVmaXggPSBcIlwiO1xuICBcdFx0XHRuYW1lID0gXCIuXCI7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFuYW1lKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBidWcgb3V0IGlmIGl0J3MgYSBrZXl3b3JkIChleGNlcHRpb24gZm9yIGFuY2VzdG9yL3Jlc3RyaWN0ZWQgcmVmcyAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLzE0OTcpXG4gIFx0aWYgKCFwcmVmaXggJiYgIXBhcnNlci5yZWxheGVkTmFtZXMgJiYga2V5d29yZHMudGVzdChuYW1lKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0UG9zO1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhIGJyb3dzZXIgZ2xvYmFsLCBzdG9wIGhlcmVcbiAgXHRpZiAoIXByZWZpeCAmJiBnbG9iYWxzLnRlc3QobmFtZSkpIHtcbiAgXHRcdGdsb2JhbCA9IGdsb2JhbHMuZXhlYyhuYW1lKVswXTtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcyArIGdsb2JhbC5sZW5ndGg7XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IEdMT0JBTCxcbiAgXHRcdFx0djogZ2xvYmFsXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJlZmVyZW5jZSA9IChwcmVmaXggfHwgXCJcIikgKyBub3JtYWxpc2UobmFtZSk7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiKFwiKSkge1xuICBcdFx0Ly8gaWYgdGhpcyBpcyBhIG1ldGhvZCBpbnZvY2F0aW9uIChhcyBvcHBvc2VkIHRvIGEgZnVuY3Rpb24pIHdlIG5lZWRcbiAgXHRcdC8vIHRvIHN0cmlwIHRoZSBtZXRob2QgbmFtZSBmcm9tIHRoZSByZWZlcmVuY2UgY29tYm8sIGVsc2UgdGhlIGNvbnRleHRcbiAgXHRcdC8vIHdpbGwgYmUgd3JvbmdcbiAgXHRcdGxhc3REb3RJbmRleCA9IHJlZmVyZW5jZS5sYXN0SW5kZXhPZihcIi5cIik7XG4gIFx0XHRpZiAobGFzdERvdEluZGV4ICE9PSAtMSkge1xuICBcdFx0XHRyZWZlcmVuY2UgPSByZWZlcmVuY2Uuc3Vic3RyKDAsIGxhc3REb3RJbmRleCk7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcyArIHJlZmVyZW5jZS5sZW5ndGg7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXJzZXIucG9zIC09IDE7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IFJFRkVSRU5DRSxcbiAgXHRcdG46IHJlZmVyZW5jZS5yZXBsYWNlKC9edGhpc1xcLi8sIFwiLi9cIikucmVwbGFjZSgvXnRoaXMkLywgXCIuXCIpXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBwcmltYXJ5X3JlYWRCcmFja2V0ZWRFeHByZXNzaW9uID0gcmVhZEJyYWNrZXRlZEV4cHJlc3Npb247XG4gIGZ1bmN0aW9uIHJlYWRCcmFja2V0ZWRFeHByZXNzaW9uKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZXhwcjtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiKFwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0ZXhwciA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRpZiAoIWV4cHIpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiKVwiKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkUGFyZW4pO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBCUkFDS0VURUQsXG4gIFx0XHR4OiBleHByXG4gIFx0fTtcbiAgfVxuXG4gIHZhciByZWFkUHJpbWFyeSA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHRyZXR1cm4gcHJpbWFyeV9yZWFkTGl0ZXJhbChwYXJzZXIpIHx8IHByaW1hcnlfcmVhZFJlZmVyZW5jZShwYXJzZXIpIHx8IHByaW1hcnlfcmVhZEJyYWNrZXRlZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgfTtcblxuICB2YXIgc2hhcmVkX3JlYWRSZWZpbmVtZW50ID0gcmVhZFJlZmluZW1lbnQ7XG4gIGZ1bmN0aW9uIHJlYWRSZWZpbmVtZW50KHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgbmFtZSwgZXhwcjtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIFwiLlwiIG5hbWVcbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiLlwiKSkge1xuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRpZiAobmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocGF0dGVybnNfX25hbWUpKSB7XG4gIFx0XHRcdHJldHVybiB7XG4gIFx0XHRcdFx0dDogUkVGSU5FTUVOVCxcbiAgXHRcdFx0XHRuOiBuYW1lXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGEgcHJvcGVydHkgbmFtZVwiKTtcbiAgXHR9XG5cbiAgXHQvLyBcIltcIiBleHByZXNzaW9uIFwiXVwiXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIltcIikpIHtcbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0ZXhwciA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRcdGlmICghZXhwcikge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHRcdH1cblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgJ10nXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBSRUZJTkVNRU5ULFxuICBcdFx0XHR4OiBleHByXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHJlYWRNZW1iZXJPckludm9jYXRpb24gPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0dmFyIGN1cnJlbnQsIGV4cHJlc3Npb24sIHJlZmluZW1lbnQsIGV4cHJlc3Npb25MaXN0O1xuXG4gIFx0ZXhwcmVzc2lvbiA9IHJlYWRQcmltYXJ5KHBhcnNlcik7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHdoaWxlIChleHByZXNzaW9uKSB7XG4gIFx0XHRjdXJyZW50ID0gcGFyc2VyLnBvcztcblxuICBcdFx0aWYgKHJlZmluZW1lbnQgPSBzaGFyZWRfcmVhZFJlZmluZW1lbnQocGFyc2VyKSkge1xuICBcdFx0XHRleHByZXNzaW9uID0ge1xuICBcdFx0XHRcdHQ6IE1FTUJFUixcbiAgXHRcdFx0XHR4OiBleHByZXNzaW9uLFxuICBcdFx0XHRcdHI6IHJlZmluZW1lbnRcbiAgXHRcdFx0fTtcbiAgXHRcdH0gZWxzZSBpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiKFwiKSkge1xuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0XHRcdGV4cHJlc3Npb25MaXN0ID0gc2hhcmVkX3JlYWRFeHByZXNzaW9uTGlzdChwYXJzZXIpO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIilcIikpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRQYXJlbik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRleHByZXNzaW9uID0ge1xuICBcdFx0XHRcdHQ6IElOVk9DQVRJT04sXG4gIFx0XHRcdFx0eDogZXhwcmVzc2lvblxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdGlmIChleHByZXNzaW9uTGlzdCkge1xuICBcdFx0XHRcdGV4cHJlc3Npb24ubyA9IGV4cHJlc3Npb25MaXN0O1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRicmVhaztcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gZXhwcmVzc2lvbjtcbiAgfTtcblxuICB2YXIgcmVhZFR5cGVPZiwgbWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlcjtcblxuICBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24gKHN5bWJvbCwgZmFsbHRocm91Z2gpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdFx0dmFyIGV4cHJlc3Npb247XG5cbiAgXHRcdGlmIChleHByZXNzaW9uID0gZmFsbHRocm91Z2gocGFyc2VyKSkge1xuICBcdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoc3ltYm9sKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHRzOiBzeW1ib2wsXG4gIFx0XHRcdG86IGV4cHJlc3Npb24sXG4gIFx0XHRcdHQ6IFBSRUZJWF9PUEVSQVRPUlxuICBcdFx0fTtcbiAgXHR9O1xuICB9O1xuXG4gIC8vIGNyZWF0ZSBhbGwgcHJlZml4IHNlcXVlbmNlIG1hdGNoZXJzLCByZXR1cm4gcmVhZFR5cGVPZlxuICAoZnVuY3Rpb24gKCkge1xuICBcdHZhciBpLCBsZW4sIG1hdGNoZXIsIHByZWZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cbiAgXHRwcmVmaXhPcGVyYXRvcnMgPSBcIiEgfiArIC0gdHlwZW9mXCIuc3BsaXQoXCIgXCIpO1xuXG4gIFx0ZmFsbHRocm91Z2ggPSByZWFkTWVtYmVyT3JJbnZvY2F0aW9uO1xuICBcdGZvciAoaSA9IDAsIGxlbiA9IHByZWZpeE9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0bWF0Y2hlciA9IG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXIocHJlZml4T3BlcmF0b3JzW2ldLCBmYWxsdGhyb3VnaCk7XG4gIFx0XHRmYWxsdGhyb3VnaCA9IG1hdGNoZXI7XG4gIFx0fVxuXG4gIFx0Ly8gdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb24sIHNvIHByb3ZpZGVzIHRoZVxuICBcdC8vIGZhbGx0aHJvdWdoIGZvciB0aGUgbXVsdGlwbGljYXRpb24gc2VxdWVuY2UgbWF0Y2hlciB3ZSdyZSBhYm91dCB0byBjcmVhdGVcbiAgXHQvLyAod2UncmUgc2tpcHBpbmcgdm9pZCBhbmQgZGVsZXRlKVxuICBcdHJlYWRUeXBlT2YgPSBmYWxsdGhyb3VnaDtcbiAgfSkoKTtcblxuICB2YXIgcmVhZFR5cGVvZiA9IHJlYWRUeXBlT2Y7XG5cbiAgdmFyIHJlYWRMb2dpY2FsT3IsIG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlcjtcblxuICBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXIgPSBmdW5jdGlvbiAoc3ltYm9sLCBmYWxsdGhyb3VnaCkge1xuICBcdHJldHVybiBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0XHR2YXIgc3RhcnQsIGxlZnQsIHJpZ2h0O1xuXG4gIFx0XHRsZWZ0ID0gZmFsbHRocm91Z2gocGFyc2VyKTtcbiAgXHRcdGlmICghbGVmdCkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gTG9vcCB0byBoYW5kbGUgbGVmdC1yZWN1cnNpb24gaW4gYSBjYXNlIGxpa2UgYGEgKiBiICogY2AgYW5kIHByb2R1Y2VcbiAgXHRcdC8vIGxlZnQgYXNzb2NpYXRpb24sIGkuZS4gYChhICogYikgKiBjYC4gIFRoZSBtYXRjaGVyIGNhbid0IGNhbGwgaXRzZWxmXG4gIFx0XHQvLyB0byBwYXJzZSBgbGVmdGAgYmVjYXVzZSB0aGF0IHdvdWxkIGJlIGluZmluaXRlIHJlZ3Jlc3MuXG4gIFx0XHR3aGlsZSAodHJ1ZSkge1xuICBcdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHN5bWJvbCkpIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBpbiBvcGVyYXRvciBtdXN0IG5vdCBiZSBmb2xsb3dlZCBieSBbYS16QS1aXyQwLTldXG4gIFx0XHRcdGlmIChzeW1ib2wgPT09IFwiaW5cIiAmJiAvW2EtekEtWl8kMC05XS8udGVzdChwYXJzZXIucmVtYWluaW5nKCkuY2hhckF0KDApKSkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0XHRyZXR1cm4gbGVmdDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHQvLyByaWdodCBvcGVyYW5kIG11c3QgYWxzbyBjb25zaXN0IG9mIG9ubHkgaGlnaGVyLXByZWNlZGVuY2Ugb3BlcmF0b3JzXG4gIFx0XHRcdHJpZ2h0ID0gZmFsbHRocm91Z2gocGFyc2VyKTtcbiAgXHRcdFx0aWYgKCFyaWdodCkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0XHRyZXR1cm4gbGVmdDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGxlZnQgPSB7XG4gIFx0XHRcdFx0dDogSU5GSVhfT1BFUkFUT1IsXG4gIFx0XHRcdFx0czogc3ltYm9sLFxuICBcdFx0XHRcdG86IFtsZWZ0LCByaWdodF1cbiAgXHRcdFx0fTtcblxuICBcdFx0XHQvLyBMb29wIGJhY2sgYXJvdW5kLiAgSWYgd2UgZG9uJ3Qgc2VlIGFub3RoZXIgb2NjdXJyZW5jZSBvZiB0aGUgc3ltYm9sLFxuICBcdFx0XHQvLyB3ZSdsbCByZXR1cm4gbGVmdC5cbiAgXHRcdH1cbiAgXHR9O1xuICB9O1xuXG4gIC8vIGNyZWF0ZSBhbGwgaW5maXggc2VxdWVuY2UgbWF0Y2hlcnMsIGFuZCByZXR1cm4gcmVhZExvZ2ljYWxPclxuICAoZnVuY3Rpb24gKCkge1xuICBcdHZhciBpLCBsZW4sIG1hdGNoZXIsIGluZml4T3BlcmF0b3JzLCBmYWxsdGhyb3VnaDtcblxuICBcdC8vIEFsbCB0aGUgaW5maXggb3BlcmF0b3JzIG9uIG9yZGVyIG9mIHByZWNlZGVuY2UgKHNvdXJjZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvT3BlcmF0b3JfUHJlY2VkZW5jZSlcbiAgXHQvLyBFYWNoIHNlcXVlbmNlIG1hdGNoZXIgd2lsbCBpbml0aWFsbHkgZmFsbCB0aHJvdWdoIHRvIGl0cyBoaWdoZXIgcHJlY2VkZW5jZVxuICBcdC8vIG5laWdoYm91ciwgYW5kIG9ubHkgYXR0ZW1wdCB0byBtYXRjaCBpZiBvbmUgb2YgdGhlIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9yc1xuICBcdC8vIChvciwgdWx0aW1hdGVseSwgYSBsaXRlcmFsLCByZWZlcmVuY2UsIG9yIGJyYWNrZXRlZCBleHByZXNzaW9uKSBhbHJlYWR5IG1hdGNoZWRcbiAgXHRpbmZpeE9wZXJhdG9ycyA9IFwiKiAvICUgKyAtIDw8ID4+ID4+PiA8IDw9ID4gPj0gaW4gaW5zdGFuY2VvZiA9PSAhPSA9PT0gIT09ICYgXiB8ICYmIHx8XCIuc3BsaXQoXCIgXCIpO1xuXG4gIFx0Ly8gQSB0eXBlb2Ygb3BlcmF0b3IgaXMgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiBtdWx0aXBsaWNhdGlvblxuICBcdGZhbGx0aHJvdWdoID0gcmVhZFR5cGVvZjtcbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSBpbmZpeE9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0bWF0Y2hlciA9IG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlcihpbmZpeE9wZXJhdG9yc1tpXSwgZmFsbHRocm91Z2gpO1xuICBcdFx0ZmFsbHRocm91Z2ggPSBtYXRjaGVyO1xuICBcdH1cblxuICBcdC8vIExvZ2ljYWwgT1IgaXMgdGhlIGZhbGx0aHJvdWdoIGZvciB0aGUgY29uZGl0aW9uYWwgbWF0Y2hlclxuICBcdHJlYWRMb2dpY2FsT3IgPSBmYWxsdGhyb3VnaDtcbiAgfSkoKTtcblxuICB2YXIgZXhwcmVzc2lvbnNfcmVhZExvZ2ljYWxPciA9IHJlYWRMb2dpY2FsT3I7XG5cbiAgLy8gVGhlIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIHRoZSBsb3dlc3QgcHJlY2VkZW5jZSBvcGVyYXRvciwgc28gd2Ugc3RhcnQgaGVyZVxuICB2YXIgcmVhZENvbmRpdGlvbmFsID0gZ2V0Q29uZGl0aW9uYWw7XG4gIGZ1bmN0aW9uIGdldENvbmRpdGlvbmFsKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgaWZUcnVlLCBpZkZhbHNlO1xuXG4gIFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25zX3JlYWRMb2dpY2FsT3IocGFyc2VyKTtcbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiP1wiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIGV4cHJlc3Npb247XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWZUcnVlID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdGlmICghaWZUcnVlKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjpcIikpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIFxcXCI6XFxcIlwiKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZkZhbHNlID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdGlmICghaWZGYWxzZSkge1xuICBcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IENPTkRJVElPTkFMLFxuICBcdFx0bzogW2V4cHJlc3Npb24sIGlmVHJ1ZSwgaWZGYWxzZV1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24gPSByZWFkRXhwcmVzc2lvbjtcbiAgZnVuY3Rpb24gcmVhZEV4cHJlc3Npb24ocGFyc2VyKSB7XG4gIFx0Ly8gVGhlIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIHRoZSBsb3dlc3QgcHJlY2VkZW5jZSBvcGVyYXRvciAoZXhjZXB0IHlpZWxkLFxuICBcdC8vIGFzc2lnbm1lbnQgb3BlcmF0b3JzLCBhbmQgY29tbWFzLCBub25lIG9mIHdoaWNoIGFyZSBzdXBwb3J0ZWQpLCBzbyB3ZVxuICBcdC8vIHN0YXJ0IHRoZXJlLiBJZiBpdCBkb2Vzbid0IG1hdGNoLCBpdCAnZmFsbHMgdGhyb3VnaCcgdG8gcHJvZ3Jlc3NpdmVseVxuICBcdC8vIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9ycywgdW50aWwgaXQgZXZlbnR1YWxseSBtYXRjaGVzIChvciBmYWlscyB0b1xuICBcdC8vIG1hdGNoKSBhICdwcmltYXJ5JyAtIGEgbGl0ZXJhbCBvciBhIHJlZmVyZW5jZS4gVGhpcyB3YXksIHRoZSBhYnN0cmFjdCBzeW50YXhcbiAgXHQvLyB0cmVlIGhhcyBldmVyeXRoaW5nIGluIGl0cyBwcm9wZXIgcGxhY2UsIGkuZS4gMiArIDMgKiA0ID09PSAxNCwgbm90IDIwLlxuICBcdHJldHVybiByZWFkQ29uZGl0aW9uYWwocGFyc2VyKTtcbiAgfVxuXG4gIHZhciB1dGlsc19mbGF0dGVuRXhwcmVzc2lvbiA9IGZsYXR0ZW5FeHByZXNzaW9uO1xuXG4gIGZ1bmN0aW9uIGZsYXR0ZW5FeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgXHR2YXIgcmVmcztcblxuICBcdGV4dHJhY3RSZWZzKGV4cHJlc3Npb24sIHJlZnMgPSBbXSk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0cjogcmVmcyxcbiAgXHRcdHM6IHN0cmluZ2lmeShleHByZXNzaW9uKVxuICBcdH07XG5cbiAgXHRmdW5jdGlvbiBzdHJpbmdpZnkobm9kZSkge1xuICBcdFx0c3dpdGNoIChub2RlLnQpIHtcbiAgXHRcdFx0Y2FzZSBCT09MRUFOX0xJVEVSQUw6XG4gIFx0XHRcdGNhc2UgR0xPQkFMOlxuICBcdFx0XHRjYXNlIE5VTUJFUl9MSVRFUkFMOlxuICBcdFx0XHRjYXNlIFJFR0VYUF9MSVRFUkFMOlxuICBcdFx0XHRcdHJldHVybiBub2RlLnY7XG5cbiAgXHRcdFx0Y2FzZSBTVFJJTkdfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoU3RyaW5nKG5vZGUudikpO1xuXG4gIFx0XHRcdGNhc2UgQVJSQVlfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gXCJbXCIgKyAobm9kZS5tID8gbm9kZS5tLm1hcChzdHJpbmdpZnkpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIl1cIjtcblxuICBcdFx0XHRjYXNlIE9CSkVDVF9MSVRFUkFMOlxuICBcdFx0XHRcdHJldHVybiBcIntcIiArIChub2RlLm0gPyBub2RlLm0ubWFwKHN0cmluZ2lmeSkuam9pbihcIixcIikgOiBcIlwiKSArIFwifVwiO1xuXG4gIFx0XHRcdGNhc2UgS0VZX1ZBTFVFX1BBSVI6XG4gIFx0XHRcdFx0cmV0dXJuIG5vZGUuayArIFwiOlwiICsgc3RyaW5naWZ5KG5vZGUudik7XG5cbiAgXHRcdFx0Y2FzZSBQUkVGSVhfT1BFUkFUT1I6XG4gIFx0XHRcdFx0cmV0dXJuIChub2RlLnMgPT09IFwidHlwZW9mXCIgPyBcInR5cGVvZiBcIiA6IG5vZGUucykgKyBzdHJpbmdpZnkobm9kZS5vKTtcblxuICBcdFx0XHRjYXNlIElORklYX09QRVJBVE9SOlxuICBcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkobm9kZS5vWzBdKSArIChub2RlLnMuc3Vic3RyKDAsIDIpID09PSBcImluXCIgPyBcIiBcIiArIG5vZGUucyArIFwiIFwiIDogbm9kZS5zKSArIHN0cmluZ2lmeShub2RlLm9bMV0pO1xuXG4gIFx0XHRcdGNhc2UgSU5WT0NBVElPTjpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KG5vZGUueCkgKyBcIihcIiArIChub2RlLm8gPyBub2RlLm8ubWFwKHN0cmluZ2lmeSkuam9pbihcIixcIikgOiBcIlwiKSArIFwiKVwiO1xuXG4gIFx0XHRcdGNhc2UgQlJBQ0tFVEVEOlxuICBcdFx0XHRcdHJldHVybiBcIihcIiArIHN0cmluZ2lmeShub2RlLngpICsgXCIpXCI7XG5cbiAgXHRcdFx0Y2FzZSBNRU1CRVI6XG4gIFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeShub2RlLngpICsgc3RyaW5naWZ5KG5vZGUucik7XG5cbiAgXHRcdFx0Y2FzZSBSRUZJTkVNRU5UOlxuICBcdFx0XHRcdHJldHVybiBub2RlLm4gPyBcIi5cIiArIG5vZGUubiA6IFwiW1wiICsgc3RyaW5naWZ5KG5vZGUueCkgKyBcIl1cIjtcblxuICBcdFx0XHRjYXNlIENPTkRJVElPTkFMOlxuICBcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkobm9kZS5vWzBdKSArIFwiP1wiICsgc3RyaW5naWZ5KG5vZGUub1sxXSkgKyBcIjpcIiArIHN0cmluZ2lmeShub2RlLm9bMl0pO1xuXG4gIFx0XHRcdGNhc2UgUkVGRVJFTkNFOlxuICBcdFx0XHRcdHJldHVybiBcIl9cIiArIHJlZnMuaW5kZXhPZihub2RlLm4pO1xuXG4gIFx0XHRcdGRlZmF1bHQ6XG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbGVnYWwgSmF2YVNjcmlwdFwiKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICAvLyBUT0RPIG1heWJlIHJlZmFjdG9yIHRoaXM/XG4gIGZ1bmN0aW9uIGV4dHJhY3RSZWZzKG5vZGUsIHJlZnMpIHtcbiAgXHR2YXIgaSwgbGlzdDtcblxuICBcdGlmIChub2RlLnQgPT09IFJFRkVSRU5DRSkge1xuICBcdFx0aWYgKHJlZnMuaW5kZXhPZihub2RlLm4pID09PSAtMSkge1xuICBcdFx0XHRyZWZzLnVuc2hpZnQobm9kZS5uKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRsaXN0ID0gbm9kZS5vIHx8IG5vZGUubTtcbiAgXHRpZiAobGlzdCkge1xuICBcdFx0aWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gIFx0XHRcdGV4dHJhY3RSZWZzKGxpc3QsIHJlZnMpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0ZXh0cmFjdFJlZnMobGlzdFtpXSwgcmVmcyk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAobm9kZS54KSB7XG4gIFx0XHRleHRyYWN0UmVmcyhub2RlLngsIHJlZnMpO1xuICBcdH1cblxuICBcdGlmIChub2RlLnIpIHtcbiAgXHRcdGV4dHJhY3RSZWZzKG5vZGUuciwgcmVmcyk7XG4gIFx0fVxuXG4gIFx0aWYgKG5vZGUudikge1xuICBcdFx0ZXh0cmFjdFJlZnMobm9kZS52LCByZWZzKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXRpbHNfcmVmaW5lRXhwcmVzc2lvbiA9IHJlZmluZUV4cHJlc3Npb247XG5cbiAgdmFyIGFycmF5TWVtYmVyUGF0dGVybiA9IC9eWzAtOV1bMS05XSokLztcbiAgZnVuY3Rpb24gcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCBtdXN0YWNoZSkge1xuICBcdHZhciByZWZlcmVuY2VFeHByZXNzaW9uO1xuXG4gIFx0aWYgKGV4cHJlc3Npb24pIHtcbiAgXHRcdHdoaWxlIChleHByZXNzaW9uLnQgPT09IEJSQUNLRVRFRCAmJiBleHByZXNzaW9uLngpIHtcbiAgXHRcdFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ueDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gaW50ZWdlcnMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYXJyYXkgbWVtYmVycyByZWZlcmVuY2VzLFxuICBcdFx0Ly8gcmF0aGVyIHRoYW4gYXMgZXhwcmVzc2lvbnMgaW4gdGhlaXIgb3duIHJpZ2h0XG4gIFx0XHRpZiAoZXhwcmVzc2lvbi50ID09PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdFx0bXVzdGFjaGUuciA9IGV4cHJlc3Npb24ubjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGlmIChleHByZXNzaW9uLnQgPT09IE5VTUJFUl9MSVRFUkFMICYmIGFycmF5TWVtYmVyUGF0dGVybi50ZXN0KGV4cHJlc3Npb24udikpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5yID0gZXhwcmVzc2lvbi52O1xuICBcdFx0XHR9IGVsc2UgaWYgKHJlZmVyZW5jZUV4cHJlc3Npb24gPSBnZXRSZWZlcmVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb24pKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUucnggPSByZWZlcmVuY2VFeHByZXNzaW9uO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG11c3RhY2hlLnggPSB1dGlsc19mbGF0dGVuRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbXVzdGFjaGU7XG4gIFx0fVxuICB9XG5cbiAgLy8gVE9ETyByZWZhY3RvciB0aGlzISBpdCdzIGJld2lsZGVyaW5nXG4gIGZ1bmN0aW9uIGdldFJlZmVyZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICBcdHZhciBtZW1iZXJzID0gW10sXG4gIFx0ICAgIHJlZmluZW1lbnQ7XG5cbiAgXHR3aGlsZSAoZXhwcmVzc2lvbi50ID09PSBNRU1CRVIgJiYgZXhwcmVzc2lvbi5yLnQgPT09IFJFRklORU1FTlQpIHtcbiAgXHRcdHJlZmluZW1lbnQgPSBleHByZXNzaW9uLnI7XG5cbiAgXHRcdGlmIChyZWZpbmVtZW50LngpIHtcbiAgXHRcdFx0aWYgKHJlZmluZW1lbnQueC50ID09PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQocmVmaW5lbWVudC54KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQodXRpbHNfZmxhdHRlbkV4cHJlc3Npb24ocmVmaW5lbWVudC54KSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1lbWJlcnMudW5zaGlmdChyZWZpbmVtZW50Lm4pO1xuICBcdFx0fVxuXG4gIFx0XHRleHByZXNzaW9uID0gZXhwcmVzc2lvbi54O1xuICBcdH1cblxuICBcdGlmIChleHByZXNzaW9uLnQgIT09IFJFRkVSRU5DRSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHI6IGV4cHJlc3Npb24ubixcbiAgXHRcdG06IG1lbWJlcnNcbiAgXHR9O1xuICB9XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRUcmlwbGUgPSByZWFkVHJpcGxlO1xuICBmdW5jdGlvbiByZWFkVHJpcGxlKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlciksXG4gIFx0ICAgIHRyaXBsZTtcblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHRyaXBsZSA9IHsgdDogVFJJUExFIH07XG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCB0cmlwbGUpOyAvLyBUT0RPIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5IC0gaXQncyBteXN0ZXJpb3VzXG5cbiAgXHRyZXR1cm4gdHJpcGxlO1xuICB9XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRVbmVzY2FwZWQgPSByZWFkVW5lc2NhcGVkO1xuICBmdW5jdGlvbiByZWFkVW5lc2NhcGVkKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIGV4cHJlc3Npb24sIHRyaXBsZTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiJlwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHRyaXBsZSA9IHsgdDogVFJJUExFIH07XG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCB0cmlwbGUpOyAvLyBUT0RPIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5IC0gaXQncyBteXN0ZXJpb3VzXG5cbiAgXHRyZXR1cm4gdHJpcGxlO1xuICB9XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRQYXJ0aWFsID0gcmVhZFBhcnRpYWw7XG4gIGZ1bmN0aW9uIHJlYWRQYXJ0aWFsKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0LCBuYW1lU3RhcnQsIGV4cHJlc3Npb24sIGNvbnRleHQsIHBhcnRpYWw7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj5cIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRuYW1lU3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gUGFydGlhbCBuYW1lcyBjYW4gaW5jbHVkZSBoeXBoZW5zLCBzbyB3ZSBjYW4ndCB1c2UgcmVhZEV4cHJlc3Npb25cbiAgXHQvLyBibGluZGx5LiBJbnN0ZWFkLCB3ZSB1c2UgdGhlIGByZWxheGVkTmFtZXNgIGZsYWcgdG8gaW5kaWNhdGUgdGhhdFxuICBcdC8vIGBmb28tYmFyYCBzaG91bGQgYmUgcmVhZCBhcyBhIHNpbmdsZSBuYW1lLCByYXRoZXIgdGhhbiAnc3VidHJhY3RcbiAgXHQvLyBiYXIgZnJvbSBmb28nXG4gIFx0cGFyc2VyLnJlbGF4ZWROYW1lcyA9IHRydWU7XG4gIFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRwYXJzZXIucmVsYXhlZE5hbWVzID0gZmFsc2U7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0Y29udGV4dCA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnRpYWwgPSB7IHQ6IFBBUlRJQUwgfTtcbiAgXHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHBhcnRpYWwpOyAvLyBUT0RPLi4uXG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBpZiB3ZSBoYXZlIGFub3RoZXIgZXhwcmVzc2lvbiAtIGUuZy4gYHt7PmZvbyBiYXJ9fWAgLSB0aGVuXG4gIFx0Ly8gd2UgdHVybiBpdCBpbnRvIGB7eyN3aXRoIGJhcn19e3s+Zm9vfX17ey93aXRofX1gXG4gIFx0aWYgKGNvbnRleHQpIHtcbiAgXHRcdHBhcnRpYWwgPSB7XG4gIFx0XHRcdHQ6IFNFQ1RJT04sXG4gIFx0XHRcdG46IFNFQ1RJT05fV0lUSCxcbiAgXHRcdFx0ZjogW3BhcnRpYWxdXG4gIFx0XHR9O1xuXG4gIFx0XHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGNvbnRleHQsIHBhcnRpYWwpO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcGFydGlhbDtcbiAgfVxuXG4gIHZhciByZWFkTXVzdGFjaGVDb21tZW50ID0gcmVhZENvbW1lbnQ7XG4gIGZ1bmN0aW9uIHJlYWRDb21tZW50KHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIGluZGV4O1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIhXCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpbmRleCA9IHBhcnNlci5yZW1haW5pbmcoKS5pbmRleE9mKHRhZy5jbG9zZSk7XG5cbiAgXHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRwYXJzZXIucG9zICs9IGluZGV4ICsgdGFnLmNsb3NlLmxlbmd0aDtcbiAgXHRcdHJldHVybiB7IHQ6IENPTU1FTlQgfTtcbiAgXHR9XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkRXhwcmVzc2lvbk9yUmVmZXJlbmNlID0gcmVhZEV4cHJlc3Npb25PclJlZmVyZW5jZTtcbiAgZnVuY3Rpb24gcmVhZEV4cHJlc3Npb25PclJlZmVyZW5jZShwYXJzZXIsIGV4cGVjdGVkRm9sbG93ZXJzKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBpO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGZvciAoaSA9IDA7IGkgPCBleHBlY3RlZEZvbGxvd2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0aWYgKHBhcnNlci5yZW1haW5pbmcoKS5zdWJzdHIoMCwgZXhwZWN0ZWRGb2xsb3dlcnNbaV0ubGVuZ3RoKSA9PT0gZXhwZWN0ZWRGb2xsb3dlcnNbaV0pIHtcbiAgXHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdHJldHVybiBwcmltYXJ5X3JlYWRSZWZlcmVuY2UocGFyc2VyKTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkSW50ZXJwb2xhdG9yID0gcmVhZEludGVycG9sYXRvcjtcbiAgZnVuY3Rpb24gcmVhZEludGVycG9sYXRvcihwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgaW50ZXJwb2xhdG9yLCBlcnI7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBUT0RPIHdvdWxkIGJlIGdvb2QgZm9yIHBlcmYgaWYgd2UgY291bGQgZG8gYXdheSB3aXRoIHRoZSB0cnktY2F0Y2hcbiAgXHR0cnkge1xuICBcdFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb25PclJlZmVyZW5jZShwYXJzZXIsIFt0YWcuY2xvc2VdKTtcbiAgXHR9IGNhdGNoIChlKSB7XG4gIFx0XHRlcnIgPSBlO1xuICBcdH1cblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0aWYgKHBhcnNlci5zdHIuY2hhckF0KHN0YXJ0KSA9PT0gXCIhXCIpIHtcbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY29tbWVudFxuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoZXJyKSB7XG4gIFx0XHRcdHRocm93IGVycjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIicgYWZ0ZXIgcmVmZXJlbmNlXCIpO1xuXG4gIFx0XHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY29tbWVudFxuICBcdFx0XHRpZiAocGFyc2VyLm5leHRDaGFyKCkgPT09IFwiIVwiKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBleHByZXNzaW9uIG9yIGxlZ2FsIHJlZmVyZW5jZVwiKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpbnRlcnBvbGF0b3IgPSB7IHQ6IElOVEVSUE9MQVRPUiB9O1xuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgaW50ZXJwb2xhdG9yKTsgLy8gVE9ETyBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSAtIGl0J3MgbXlzdGVyaW91c1xuXG4gIFx0cmV0dXJuIGludGVycG9sYXRvcjtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkWWllbGRlciA9IHJlYWRZaWVsZGVyO1xuICB2YXIgeWllbGRQYXR0ZXJuID0gL155aWVsZFxccyovO1xuICBmdW5jdGlvbiByZWFkWWllbGRlcihwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgbmFtZSwgeWllbGRlcjtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybih5aWVsZFBhdHRlcm4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG4gIFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oL15bYS16QS1aXyRdW2EtekEtWl8kMC05XFwtXSovKTtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcImV4cGVjdGVkIGxlZ2FsIHBhcnRpYWwgbmFtZVwiKTtcbiAgXHR9XG5cbiAgXHR5aWVsZGVyID0geyB0OiBZSUVMREVSIH07XG5cbiAgXHRpZiAobmFtZSkge1xuICBcdFx0eWllbGRlci5uID0gbmFtZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4geWllbGRlcjtcbiAgfVxuXG4gIHZhciBzZWN0aW9uX3JlYWRDbG9zaW5nID0gcmVhZENsb3Npbmc7XG4gIGZ1bmN0aW9uIHJlYWRDbG9zaW5nKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0LCByZW1haW5pbmcsIGluZGV4LCBjbG9zaW5nO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLm9wZW4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIi9cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcbiAgXHRpbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKHRhZy5jbG9zZSk7XG5cbiAgXHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRjbG9zaW5nID0ge1xuICBcdFx0XHR0OiBDTE9TSU5HLFxuICBcdFx0XHRyOiByZW1haW5pbmcuc3Vic3RyKDAsIGluZGV4KS5zcGxpdChcIiBcIilbMF1cbiAgXHRcdH07XG5cbiAgXHRcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gY2xvc2luZztcbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2VjdGlvbl9yZWFkRWxzZSA9IHNlY3Rpb25fcmVhZEVsc2VfX3JlYWRFbHNlO1xuICB2YXIgc2VjdGlvbl9yZWFkRWxzZV9fZWxzZVBhdHRlcm4gPSAvXlxccyplbHNlXFxzKi87XG4gIGZ1bmN0aW9uIHNlY3Rpb25fcmVhZEVsc2VfX3JlYWRFbHNlKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5vcGVuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHNlY3Rpb25fcmVhZEVsc2VfX2Vsc2VQYXR0ZXJuKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBFTFNFXG4gIFx0fTtcbiAgfVxuXG4gIHZhciByZWFkRWxzZUlmID0gcmVhZEVsc2VJZl9fcmVhZEVsc2U7XG4gIHZhciByZWFkRWxzZUlmX19lbHNlUGF0dGVybiA9IC9eXFxzKmVsc2VpZlxccysvO1xuICBmdW5jdGlvbiByZWFkRWxzZUlmX19yZWFkRWxzZShwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCA9IHBhcnNlci5wb3MsXG4gIFx0ICAgIGV4cHJlc3Npb247XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcub3BlbikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybihyZWFkRWxzZUlmX19lbHNlUGF0dGVybikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEVMU0VJRixcbiAgXHRcdHg6IGV4cHJlc3Npb25cbiAgXHR9O1xuICB9XG5cbiAgdmFyIGhhbmRsZWJhcnNCbG9ja0NvZGVzID0ge1xuICBcdGVhY2g6IFNFQ1RJT05fRUFDSCxcbiAgXHRcImlmXCI6IFNFQ1RJT05fSUYsXG4gIFx0XCJpZi13aXRoXCI6IFNFQ1RJT05fSUZfV0lUSCxcbiAgXHRcIndpdGhcIjogU0VDVElPTl9XSVRILFxuICBcdHVubGVzczogU0VDVElPTl9VTkxFU1NcbiAgfTtcblxuICB2YXIgbXVzdGFjaGVfcmVhZFNlY3Rpb24gPSByZWFkU2VjdGlvbjtcblxuICB2YXIgaW5kZXhSZWZQYXR0ZXJuID0gL15cXHMqOlxccyooW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKS8sXG4gICAgICBrZXlJbmRleFJlZlBhdHRlcm4gPSAvXlxccyosXFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopLyxcbiAgICAgIGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXihcIiArIE9iamVjdC5rZXlzKGhhbmRsZWJhcnNCbG9ja0NvZGVzKS5qb2luKFwifFwiKSArIFwiKVxcXFxiXCIpO1xuICBmdW5jdGlvbiByZWFkU2VjdGlvbihwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgc2VjdGlvbiwgY2hpbGQsIGNoaWxkcmVuLCBoYXNFbHNlLCBibG9jaywgdW5sZXNzQmxvY2ssIGNvbmRpdGlvbnMsIGNsb3NlZCwgaSwgZXhwZWN0ZWRDbG9zZTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJeXCIpKSB7XG4gIFx0XHRzZWN0aW9uID0geyB0OiBTRUNUSU9OLCBmOiBbXSwgbjogU0VDVElPTl9VTkxFU1MgfTtcbiAgXHR9IGVsc2UgaWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIiNcIikpIHtcbiAgXHRcdHNlY3Rpb24gPSB7IHQ6IFNFQ1RJT04sIGY6IFtdIH07XG5cbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJwYXJ0aWFsXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydCAtIHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0ubGVuZ3RoO1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJQYXJ0aWFsIGRlZmluaXRpb25zIGNhbiBvbmx5IGJlIGF0IHRoZSB0b3AgbGV2ZWwgb2YgdGhlIHRlbXBsYXRlLCBvciBpbW1lZGlhdGVseSBpbnNpZGUgY29tcG9uZW50c1wiKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGJsb2NrID0gcGFyc2VyLm1hdGNoUGF0dGVybihoYW5kbGViYXJzQmxvY2tQYXR0ZXJuKSkge1xuICBcdFx0XHRleHBlY3RlZENsb3NlID0gYmxvY2s7XG4gIFx0XHRcdHNlY3Rpb24ubiA9IGhhbmRsZWJhcnNCbG9ja0NvZGVzW2Jsb2NrXTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgZXhwcmVzc2lvblwiKTtcbiAgXHR9XG5cbiAgXHQvLyBvcHRpb25hbCBpbmRleCBhbmQga2V5IHJlZmVyZW5jZXNcbiAgXHRpZiAoaSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oaW5kZXhSZWZQYXR0ZXJuKSkge1xuICBcdFx0dmFyIGV4dHJhID0gdW5kZWZpbmVkO1xuXG4gIFx0XHRpZiAoZXh0cmEgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGtleUluZGV4UmVmUGF0dGVybikpIHtcbiAgXHRcdFx0c2VjdGlvbi5pID0gaSArIFwiLFwiICsgZXh0cmE7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRzZWN0aW9uLmkgPSBpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuc2VjdGlvbkRlcHRoICs9IDE7XG4gIFx0Y2hpbGRyZW4gPSBzZWN0aW9uLmY7XG5cbiAgXHRjb25kaXRpb25zID0gW107XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAoY2hpbGQgPSBzZWN0aW9uX3JlYWRDbG9zaW5nKHBhcnNlciwgdGFnKSkge1xuICBcdFx0XHRpZiAoZXhwZWN0ZWRDbG9zZSAmJiBjaGlsZC5yICE9PSBleHBlY3RlZENsb3NlKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyB0YWcub3BlbiArIFwiL1wiICsgZXhwZWN0ZWRDbG9zZSArIFwiXCIgKyB0YWcuY2xvc2UpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLnNlY3Rpb25EZXB0aCAtPSAxO1xuICBcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIGlmIChjaGlsZCA9IHJlYWRFbHNlSWYocGFyc2VyLCB0YWcpKSB7XG4gIFx0XHRcdGlmIChzZWN0aW9uLm4gPT09IFNFQ1RJT05fVU5MRVNTKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwie3tlbHNlfX0gbm90IGFsbG93ZWQgaW4ge3sjdW5sZXNzfX1cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaGFzRWxzZSkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcImlsbGVnYWwge3tlbHNlaWYuLi59fSBhZnRlciB7e2Vsc2V9fVwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghdW5sZXNzQmxvY2spIHtcbiAgXHRcdFx0XHR1bmxlc3NCbG9jayA9IGNyZWF0ZVVubGVzc0Jsb2NrKGV4cHJlc3Npb24sIHNlY3Rpb24ubik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR1bmxlc3NCbG9jay5mLnB1c2goe1xuICBcdFx0XHRcdHQ6IFNFQ1RJT04sXG4gIFx0XHRcdFx0bjogU0VDVElPTl9JRixcbiAgXHRcdFx0XHR4OiB1dGlsc19mbGF0dGVuRXhwcmVzc2lvbihtdXN0YWNoZV9yZWFkU2VjdGlvbl9fY29tYmluZShjb25kaXRpb25zLmNvbmNhdChjaGlsZC54KSkpLFxuICBcdFx0XHRcdGY6IGNoaWxkcmVuID0gW11cbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0Y29uZGl0aW9ucy5wdXNoKGludmVydChjaGlsZC54KSk7XG4gIFx0XHR9IGVsc2UgaWYgKGNoaWxkID0gc2VjdGlvbl9yZWFkRWxzZShwYXJzZXIsIHRhZykpIHtcbiAgXHRcdFx0aWYgKHNlY3Rpb24ubiA9PT0gU0VDVElPTl9VTkxFU1MpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJ7e2Vsc2V9fSBub3QgYWxsb3dlZCBpbiB7eyN1bmxlc3N9fVwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChoYXNFbHNlKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwidGhlcmUgY2FuIG9ubHkgYmUgb25lIHt7ZWxzZX19IGJsb2NrLCBhdCB0aGUgZW5kIG9mIGEgc2VjdGlvblwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGhhc0Vsc2UgPSB0cnVlO1xuXG4gIFx0XHRcdC8vIHVzZSBhbiB1bmxlc3MgYmxvY2sgaWYgdGhlcmUncyBubyBlbHNlaWZcbiAgXHRcdFx0aWYgKCF1bmxlc3NCbG9jaykge1xuICBcdFx0XHRcdHVubGVzc0Jsb2NrID0gY3JlYXRlVW5sZXNzQmxvY2soZXhwcmVzc2lvbiwgc2VjdGlvbi5uKTtcbiAgXHRcdFx0XHRjaGlsZHJlbiA9IHVubGVzc0Jsb2NrLmY7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dW5sZXNzQmxvY2suZi5wdXNoKHtcbiAgXHRcdFx0XHRcdHQ6IFNFQ1RJT04sXG4gIFx0XHRcdFx0XHRuOiBTRUNUSU9OX0lGLFxuICBcdFx0XHRcdFx0eDogdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24obXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoY29uZGl0aW9ucykpLFxuICBcdFx0XHRcdFx0ZjogY2hpbGRyZW4gPSBbXVxuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjaGlsZCA9IHBhcnNlci5yZWFkKFJFQURFUlMpO1xuXG4gIFx0XHRcdGlmICghY2hpbGQpIHtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0aWYgKHVubGVzc0Jsb2NrKSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBgd2l0aGAgc2hvdWxkIGJlY29tZSBgaWYtd2l0aGAgKFRPRE8gaXMgdGhpcyByaWdodD9cbiAgXHRcdC8vIHNlZW1zIHRvIG1lIHRoYXQgYHdpdGhgIG91Z2h0IHRvIGJlaGF2ZSBjb25zaXN0ZW50bHksIHJlZ2FyZGxlc3NcbiAgXHRcdC8vIG9mIHRoZSBwcmVzZW5jZS9hYnNlbmNlIG9mIGBlbHNlYC4gSW4gb3RoZXIgd29yZHMgc2hvdWxkIGFsd2F5c1xuICBcdFx0Ly8gYmUgYGlmLXdpdGhgXG4gIFx0XHRpZiAoc2VjdGlvbi5uID09PSBTRUNUSU9OX1dJVEgpIHtcbiAgXHRcdFx0c2VjdGlvbi5uID0gU0VDVElPTl9JRl9XSVRIO1xuICBcdFx0fVxuXG4gIFx0XHRzZWN0aW9uLmwgPSB1bmxlc3NCbG9jaztcbiAgXHR9XG5cbiAgXHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHNlY3Rpb24pO1xuXG4gIFx0Ly8gVE9ETyBpZiBhIHNlY3Rpb24gaXMgZW1wdHkgaXQgc2hvdWxkIGJlIGRpc2NhcmRlZC4gRG9uJ3QgZG9cbiAgXHQvLyB0aGF0IGhlcmUgdGhvdWdoIC0gd2UgbmVlZCB0byBjbGVhbiBldmVyeXRoaW5nIHVwIGZpcnN0LCBhc1xuICBcdC8vIGl0IG1heSBjb250YWluIHJlbW92ZWFibGUgd2hpdGVzcGFjZS4gQXMgYSB0ZW1wb3JhcnkgbWVhc3VyZSxcbiAgXHQvLyB0byBwYXNzIHRoZSBleGlzdGluZyB0ZXN0cywgcmVtb3ZlIGVtcHR5IGBmYCBhcnJheXNcbiAgXHRpZiAoIXNlY3Rpb24uZi5sZW5ndGgpIHtcbiAgXHRcdGRlbGV0ZSBzZWN0aW9uLmY7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHNlY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmxlc3NCbG9jayhleHByZXNzaW9uLCBzZWN0aW9uVHlwZSkge1xuICBcdHZhciB1bmxlc3NCbG9jaztcblxuICBcdGlmIChzZWN0aW9uVHlwZSA9PT0gU0VDVElPTl9XSVRIKSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBhIGB7eyN3aXRoIGZvb319YCBzZWN0aW9uIHdpbGwgcmVuZGVyIGlmIGBmb29gIGlzXG4gIFx0XHQvLyB0cnV0aHksIHNvIHRoZSBge3tlbHNlfX1gIHNlY3Rpb24gbmVlZHMgdG8gcmVuZGVyIGlmIGBmb29gIGlzIGZhbHN5LFxuICBcdFx0Ly8gcmF0aGVyIHRoYW4gYWRoZXJpbmcgdG8gdGhlIG5vcm1hbCBge3sjdW5sZXNzIGZvb319YCBsb2dpYyAod2hpY2hcbiAgXHRcdC8vIHRyZWF0cyBlbXB0eSBhcnJheXMvb2JqZWN0cyBhcyBmYWxzeSlcbiAgXHRcdHVubGVzc0Jsb2NrID0ge1xuICBcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRuOiBTRUNUSU9OX0lGLFxuICBcdFx0XHRmOiBbXVxuICBcdFx0fTtcblxuICBcdFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihpbnZlcnQoZXhwcmVzc2lvbiksIHVubGVzc0Jsb2NrKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dW5sZXNzQmxvY2sgPSB7XG4gIFx0XHRcdHQ6IFNFQ1RJT04sXG4gIFx0XHRcdG46IFNFQ1RJT05fVU5MRVNTLFxuICBcdFx0XHRmOiBbXVxuICBcdFx0fTtcblxuICBcdFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCB1bmxlc3NCbG9jayk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHVubGVzc0Jsb2NrO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52ZXJ0KGV4cHJlc3Npb24pIHtcbiAgXHRpZiAoZXhwcmVzc2lvbi50ID09PSBQUkVGSVhfT1BFUkFUT1IgJiYgZXhwcmVzc2lvbi5zID09PSBcIiFcIikge1xuICBcdFx0cmV0dXJuIGV4cHJlc3Npb24ubztcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogUFJFRklYX09QRVJBVE9SLFxuICBcdFx0czogXCIhXCIsXG4gIFx0XHRvOiBwYXJlbnNJZk5lY2Vzc2FyeShleHByZXNzaW9uKVxuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiBtdXN0YWNoZV9yZWFkU2VjdGlvbl9fY29tYmluZShleHByZXNzaW9ucykge1xuICBcdGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJldHVybiBleHByZXNzaW9uc1swXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogSU5GSVhfT1BFUkFUT1IsXG4gIFx0XHRzOiBcIiYmXCIsXG4gIFx0XHRvOiBbcGFyZW5zSWZOZWNlc3NhcnkoZXhwcmVzc2lvbnNbMF0pLCBwYXJlbnNJZk5lY2Vzc2FyeShtdXN0YWNoZV9yZWFkU2VjdGlvbl9fY29tYmluZShleHByZXNzaW9ucy5zbGljZSgxKSkpXVxuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJlbnNJZk5lY2Vzc2FyeShleHByZXNzaW9uKSB7XG4gIFx0Ly8gVE9ETyBvbmx5IHdyYXAgaWYgbmVjZXNzYXJ5XG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEJSQUNLRVRFRCxcbiAgXHRcdHg6IGV4cHJlc3Npb25cbiAgXHR9O1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZEh0bWxDb21tZW50ID0gcmVhZEh0bWxDb21tZW50O1xuICB2YXIgT1BFTl9DT01NRU5UID0gXCI8IS0tXCIsXG4gICAgICBDTE9TRV9DT01NRU5UID0gXCItLT5cIjtcbiAgZnVuY3Rpb24gcmVhZEh0bWxDb21tZW50KHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgY29udGVudCwgcmVtYWluaW5nLCBlbmRJbmRleCwgY29tbWVudDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKE9QRU5fQ09NTUVOVCkpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcbiAgXHRlbmRJbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKENMT1NFX0NPTU1FTlQpO1xuXG4gIFx0aWYgKGVuZEluZGV4ID09PSAtMSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiSWxsZWdhbCBIVE1MIC0gZXhwZWN0ZWQgY2xvc2luZyBjb21tZW50IHNlcXVlbmNlICgnLS0+JylcIik7XG4gIFx0fVxuXG4gIFx0Y29udGVudCA9IHJlbWFpbmluZy5zdWJzdHIoMCwgZW5kSW5kZXgpO1xuICBcdHBhcnNlci5wb3MgKz0gZW5kSW5kZXggKyAzO1xuXG4gIFx0Y29tbWVudCA9IHtcbiAgXHRcdHQ6IENPTU1FTlQsXG4gIFx0XHRjOiBjb250ZW50XG4gIFx0fTtcblxuICBcdGlmIChwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMpIHtcbiAgXHRcdGNvbW1lbnQucCA9IHBhcnNlci5nZXRMaW5lUG9zKHN0YXJ0KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gY29tbWVudDtcbiAgfVxuXG4gIHZhciBib29sZWFuQXR0cmlidXRlcywgdm9pZEVsZW1lbnROYW1lcywgaHRtbEVudGl0aWVzLCBjb250cm9sQ2hhcmFjdGVycywgZW50aXR5UGF0dGVybiwgbGVzc1RoYW4sIGdyZWF0ZXJUaGFuLCBhbXA7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9odG1sLW1pbmlmaWVyL2lzc3Vlcy82MyNpc3N1ZWNvbW1lbnQtMzc3NjMzMTZcbiAgYm9vbGVhbkF0dHJpYnV0ZXMgPSAvXihhbGxvd0Z1bGxzY3JlZW58YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNoZWNrZWR8Y29tcGFjdHxjb250cm9sc3xkZWNsYXJlfGRlZmF1bHR8ZGVmYXVsdENoZWNrZWR8ZGVmYXVsdE11dGVkfGRlZmF1bHRTZWxlY3RlZHxkZWZlcnxkaXNhYmxlZHxlbmFibGVkfGZvcm1Ob1ZhbGlkYXRlfGhpZGRlbnxpbmRldGVybWluYXRlfGluZXJ0fGlzTWFwfGl0ZW1TY29wZXxsb29wfG11bHRpcGxlfG11dGVkfG5vSHJlZnxub1Jlc2l6ZXxub1NoYWRlfG5vVmFsaWRhdGV8bm9XcmFwfG9wZW58cGF1c2VPbkV4aXR8cmVhZE9ubHl8cmVxdWlyZWR8cmV2ZXJzZWR8c2NvcGVkfHNlYW1sZXNzfHNlbGVjdGVkfHNvcnRhYmxlfHRyYW5zbGF0ZXx0cnVlU3BlZWR8dHlwZU11c3RNYXRjaHx2aXNpYmxlKSQvaTtcbiAgdm9pZEVsZW1lbnROYW1lcyA9IC9eKD86YXJlYXxiYXNlfGJyfGNvbHxjb21tYW5kfGRvY3R5cGV8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdicikkL2k7XG5cbiAgaHRtbEVudGl0aWVzID0geyBxdW90OiAzNCwgYW1wOiAzOCwgYXBvczogMzksIGx0OiA2MCwgZ3Q6IDYyLCBuYnNwOiAxNjAsIGlleGNsOiAxNjEsIGNlbnQ6IDE2MiwgcG91bmQ6IDE2MywgY3VycmVuOiAxNjQsIHllbjogMTY1LCBicnZiYXI6IDE2Niwgc2VjdDogMTY3LCB1bWw6IDE2OCwgY29weTogMTY5LCBvcmRmOiAxNzAsIGxhcXVvOiAxNzEsIG5vdDogMTcyLCBzaHk6IDE3MywgcmVnOiAxNzQsIG1hY3I6IDE3NSwgZGVnOiAxNzYsIHBsdXNtbjogMTc3LCBzdXAyOiAxNzgsIHN1cDM6IDE3OSwgYWN1dGU6IDE4MCwgbWljcm86IDE4MSwgcGFyYTogMTgyLCBtaWRkb3Q6IDE4MywgY2VkaWw6IDE4NCwgc3VwMTogMTg1LCBvcmRtOiAxODYsIHJhcXVvOiAxODcsIGZyYWMxNDogMTg4LCBmcmFjMTI6IDE4OSwgZnJhYzM0OiAxOTAsIGlxdWVzdDogMTkxLCBBZ3JhdmU6IDE5MiwgQWFjdXRlOiAxOTMsIEFjaXJjOiAxOTQsIEF0aWxkZTogMTk1LCBBdW1sOiAxOTYsIEFyaW5nOiAxOTcsIEFFbGlnOiAxOTgsIENjZWRpbDogMTk5LCBFZ3JhdmU6IDIwMCwgRWFjdXRlOiAyMDEsIEVjaXJjOiAyMDIsIEV1bWw6IDIwMywgSWdyYXZlOiAyMDQsIElhY3V0ZTogMjA1LCBJY2lyYzogMjA2LCBJdW1sOiAyMDcsIEVUSDogMjA4LCBOdGlsZGU6IDIwOSwgT2dyYXZlOiAyMTAsIE9hY3V0ZTogMjExLCBPY2lyYzogMjEyLCBPdGlsZGU6IDIxMywgT3VtbDogMjE0LCB0aW1lczogMjE1LCBPc2xhc2g6IDIxNiwgVWdyYXZlOiAyMTcsIFVhY3V0ZTogMjE4LCBVY2lyYzogMjE5LCBVdW1sOiAyMjAsIFlhY3V0ZTogMjIxLCBUSE9STjogMjIyLCBzemxpZzogMjIzLCBhZ3JhdmU6IDIyNCwgYWFjdXRlOiAyMjUsIGFjaXJjOiAyMjYsIGF0aWxkZTogMjI3LCBhdW1sOiAyMjgsIGFyaW5nOiAyMjksIGFlbGlnOiAyMzAsIGNjZWRpbDogMjMxLCBlZ3JhdmU6IDIzMiwgZWFjdXRlOiAyMzMsIGVjaXJjOiAyMzQsIGV1bWw6IDIzNSwgaWdyYXZlOiAyMzYsIGlhY3V0ZTogMjM3LCBpY2lyYzogMjM4LCBpdW1sOiAyMzksIGV0aDogMjQwLCBudGlsZGU6IDI0MSwgb2dyYXZlOiAyNDIsIG9hY3V0ZTogMjQzLCBvY2lyYzogMjQ0LCBvdGlsZGU6IDI0NSwgb3VtbDogMjQ2LCBkaXZpZGU6IDI0Nywgb3NsYXNoOiAyNDgsIHVncmF2ZTogMjQ5LCB1YWN1dGU6IDI1MCwgdWNpcmM6IDI1MSwgdXVtbDogMjUyLCB5YWN1dGU6IDI1MywgdGhvcm46IDI1NCwgeXVtbDogMjU1LCBPRWxpZzogMzM4LCBvZWxpZzogMzM5LCBTY2Fyb246IDM1Miwgc2Nhcm9uOiAzNTMsIFl1bWw6IDM3NiwgZm5vZjogNDAyLCBjaXJjOiA3MTAsIHRpbGRlOiA3MzIsIEFscGhhOiA5MTMsIEJldGE6IDkxNCwgR2FtbWE6IDkxNSwgRGVsdGE6IDkxNiwgRXBzaWxvbjogOTE3LCBaZXRhOiA5MTgsIEV0YTogOTE5LCBUaGV0YTogOTIwLCBJb3RhOiA5MjEsIEthcHBhOiA5MjIsIExhbWJkYTogOTIzLCBNdTogOTI0LCBOdTogOTI1LCBYaTogOTI2LCBPbWljcm9uOiA5MjcsIFBpOiA5MjgsIFJobzogOTI5LCBTaWdtYTogOTMxLCBUYXU6IDkzMiwgVXBzaWxvbjogOTMzLCBQaGk6IDkzNCwgQ2hpOiA5MzUsIFBzaTogOTM2LCBPbWVnYTogOTM3LCBhbHBoYTogOTQ1LCBiZXRhOiA5NDYsIGdhbW1hOiA5NDcsIGRlbHRhOiA5NDgsIGVwc2lsb246IDk0OSwgemV0YTogOTUwLCBldGE6IDk1MSwgdGhldGE6IDk1MiwgaW90YTogOTUzLCBrYXBwYTogOTU0LCBsYW1iZGE6IDk1NSwgbXU6IDk1NiwgbnU6IDk1NywgeGk6IDk1OCwgb21pY3JvbjogOTU5LCBwaTogOTYwLCByaG86IDk2MSwgc2lnbWFmOiA5NjIsIHNpZ21hOiA5NjMsIHRhdTogOTY0LCB1cHNpbG9uOiA5NjUsIHBoaTogOTY2LCBjaGk6IDk2NywgcHNpOiA5NjgsIG9tZWdhOiA5NjksIHRoZXRhc3ltOiA5NzcsIHVwc2loOiA5NzgsIHBpdjogOTgyLCBlbnNwOiA4MTk0LCBlbXNwOiA4MTk1LCB0aGluc3A6IDgyMDEsIHp3bmo6IDgyMDQsIHp3ajogODIwNSwgbHJtOiA4MjA2LCBybG06IDgyMDcsIG5kYXNoOiA4MjExLCBtZGFzaDogODIxMiwgbHNxdW86IDgyMTYsIHJzcXVvOiA4MjE3LCBzYnF1bzogODIxOCwgbGRxdW86IDgyMjAsIHJkcXVvOiA4MjIxLCBiZHF1bzogODIyMiwgZGFnZ2VyOiA4MjI0LCBEYWdnZXI6IDgyMjUsIGJ1bGw6IDgyMjYsIGhlbGxpcDogODIzMCwgcGVybWlsOiA4MjQwLCBwcmltZTogODI0MiwgUHJpbWU6IDgyNDMsIGxzYXF1bzogODI0OSwgcnNhcXVvOiA4MjUwLCBvbGluZTogODI1NCwgZnJhc2w6IDgyNjAsIGV1cm86IDgzNjQsIGltYWdlOiA4NDY1LCB3ZWllcnA6IDg0NzIsIHJlYWw6IDg0NzYsIHRyYWRlOiA4NDgyLCBhbGVmc3ltOiA4NTAxLCBsYXJyOiA4NTkyLCB1YXJyOiA4NTkzLCByYXJyOiA4NTk0LCBkYXJyOiA4NTk1LCBoYXJyOiA4NTk2LCBjcmFycjogODYyOSwgbEFycjogODY1NiwgdUFycjogODY1NywgckFycjogODY1OCwgZEFycjogODY1OSwgaEFycjogODY2MCwgZm9yYWxsOiA4NzA0LCBwYXJ0OiA4NzA2LCBleGlzdDogODcwNywgZW1wdHk6IDg3MDksIG5hYmxhOiA4NzExLCBpc2luOiA4NzEyLCBub3RpbjogODcxMywgbmk6IDg3MTUsIHByb2Q6IDg3MTksIHN1bTogODcyMSwgbWludXM6IDg3MjIsIGxvd2FzdDogODcyNywgcmFkaWM6IDg3MzAsIHByb3A6IDg3MzMsIGluZmluOiA4NzM0LCBhbmc6IDg3MzYsIGFuZDogODc0Mywgb3I6IDg3NDQsIGNhcDogODc0NSwgY3VwOiA4NzQ2LCBpbnQ6IDg3NDcsIHRoZXJlNDogODc1Niwgc2ltOiA4NzY0LCBjb25nOiA4NzczLCBhc3ltcDogODc3NiwgbmU6IDg4MDAsIGVxdWl2OiA4ODAxLCBsZTogODgwNCwgZ2U6IDg4MDUsIHN1YjogODgzNCwgc3VwOiA4ODM1LCBuc3ViOiA4ODM2LCBzdWJlOiA4ODM4LCBzdXBlOiA4ODM5LCBvcGx1czogODg1Mywgb3RpbWVzOiA4ODU1LCBwZXJwOiA4ODY5LCBzZG90OiA4OTAxLCBsY2VpbDogODk2OCwgcmNlaWw6IDg5NjksIGxmbG9vcjogODk3MCwgcmZsb29yOiA4OTcxLCBsYW5nOiA5MDAxLCByYW5nOiA5MDAyLCBsb3o6IDk2NzQsIHNwYWRlczogOTgyNCwgY2x1YnM6IDk4MjcsIGhlYXJ0czogOTgyOSwgZGlhbXM6IDk4MzAgfTtcbiAgY29udHJvbENoYXJhY3RlcnMgPSBbODM2NCwgMTI5LCA4MjE4LCA0MDIsIDgyMjIsIDgyMzAsIDgyMjQsIDgyMjUsIDcxMCwgODI0MCwgMzUyLCA4MjQ5LCAzMzgsIDE0MSwgMzgxLCAxNDMsIDE0NCwgODIxNiwgODIxNywgODIyMCwgODIyMSwgODIyNiwgODIxMSwgODIxMiwgNzMyLCA4NDgyLCAzNTMsIDgyNTAsIDMzOSwgMTU3LCAzODIsIDM3Nl07XG4gIGVudGl0eVBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiJigjPyg/OnhbXFxcXHdcXFxcZF0rfFxcXFxkK3xcIiArIE9iamVjdC5rZXlzKGh0bWxFbnRpdGllcykuam9pbihcInxcIikgKyBcIikpOz9cIiwgXCJnXCIpO1xuXG4gIGZ1bmN0aW9uIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoaHRtbCkge1xuICBcdHJldHVybiBodG1sLnJlcGxhY2UoZW50aXR5UGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCBlbnRpdHkpIHtcbiAgXHRcdHZhciBjb2RlO1xuXG4gIFx0XHQvLyBIYW5kbGUgbmFtZWQgZW50aXRpZXNcbiAgXHRcdGlmIChlbnRpdHlbMF0gIT09IFwiI1wiKSB7XG4gIFx0XHRcdGNvZGUgPSBodG1sRW50aXRpZXNbZW50aXR5XTtcbiAgXHRcdH0gZWxzZSBpZiAoZW50aXR5WzFdID09PSBcInhcIikge1xuICBcdFx0XHRjb2RlID0gcGFyc2VJbnQoZW50aXR5LnN1YnN0cmluZygyKSwgMTYpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y29kZSA9IHBhcnNlSW50KGVudGl0eS5zdWJzdHJpbmcoMSksIDEwKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFjb2RlKSB7XG4gIFx0XHRcdHJldHVybiBtYXRjaDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsaWRhdGVDb2RlKGNvZGUpKTtcbiAgXHR9KTtcbiAgfVxuXG4gIC8vIHNvbWUgY29kZSBwb2ludHMgYXJlIHZlcmJvdGVuLiBJZiB3ZSB3ZXJlIGluc2VydGluZyBIVE1MLCB0aGUgYnJvd3NlciB3b3VsZCByZXBsYWNlIHRoZSBpbGxlZ2FsXG4gIC8vIGNvZGUgcG9pbnRzIHdpdGggYWx0ZXJuYXRpdmVzIGluIHNvbWUgY2FzZXMgLSBzaW5jZSB3ZSdyZSBieXBhc3NpbmcgdGhhdCBtZWNoYW5pc20sIHdlIG5lZWRcbiAgLy8gdG8gcmVwbGFjZSB0aGVtIG91cnNlbHZlc1xuICAvL1xuICAvLyBTb3VyY2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hhcmFjdGVyX2VuY29kaW5nc19pbl9IVE1MI0lsbGVnYWxfY2hhcmFjdGVyc1xuICBmdW5jdGlvbiB2YWxpZGF0ZUNvZGUoY29kZSkge1xuICBcdGlmICghY29kZSkge1xuICBcdFx0cmV0dXJuIDY1NTMzO1xuICBcdH1cblxuICBcdC8vIGxpbmUgZmVlZCBiZWNvbWVzIGdlbmVyaWMgd2hpdGVzcGFjZVxuICBcdGlmIChjb2RlID09PSAxMCkge1xuICBcdFx0cmV0dXJuIDMyO1xuICBcdH1cblxuICBcdC8vIEFTQ0lJIHJhbmdlLiAoV2h5IHNvbWVvbmUgd291bGQgdXNlIEhUTUwgZW50aXRpZXMgZm9yIEFTQ0lJIGNoYXJhY3RlcnMgSSBkb24ndCBrbm93LCBidXQuLi4pXG4gIFx0aWYgKGNvZGUgPCAxMjgpIHtcbiAgXHRcdHJldHVybiBjb2RlO1xuICBcdH1cblxuICBcdC8vIGNvZGUgcG9pbnRzIDEyOC0xNTkgYXJlIGRlYWx0IHdpdGggbGVuaWVudGx5IGJ5IGJyb3dzZXJzLCBidXQgdGhleSdyZSBpbmNvcnJlY3QuIFdlIG5lZWRcbiAgXHQvLyB0byBjb3JyZWN0IHRoZSBtaXN0YWtlIG9yIHdlJ2xsIGVuZCB1cCB3aXRoIG1pc3Npbmcg4oKsIHNpZ25zIGFuZCBzbyBvblxuICBcdGlmIChjb2RlIDw9IDE1OSkge1xuICBcdFx0cmV0dXJuIGNvbnRyb2xDaGFyYWN0ZXJzW2NvZGUgLSAxMjhdO1xuICBcdH1cblxuICBcdC8vIGJhc2ljIG11bHRpbGluZ3VhbCBwbGFuZVxuICBcdGlmIChjb2RlIDwgNTUyOTYpIHtcbiAgXHRcdHJldHVybiBjb2RlO1xuICBcdH1cblxuICBcdC8vIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gIFx0aWYgKGNvZGUgPD0gNTczNDMpIHtcbiAgXHRcdHJldHVybiA2NTUzMztcbiAgXHR9XG5cbiAgXHQvLyByZXN0IG9mIHRoZSBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcbiAgXHRpZiAoY29kZSA8PSA2NTUzNSkge1xuICBcdFx0cmV0dXJuIGNvZGU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIDY1NTMzO1xuICB9XG5cbiAgbGVzc1RoYW4gPSAvPC9nO1xuICBncmVhdGVyVGhhbiA9IC8+L2c7XG4gIGFtcCA9IC8mL2c7XG5cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpIHtcbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UoYW1wLCBcIiZhbXA7XCIpLnJlcGxhY2UobGVzc1RoYW4sIFwiJmx0O1wiKS5yZXBsYWNlKGdyZWF0ZXJUaGFuLCBcIiZndDtcIik7XG4gIH1cblxuICB2YXIgbGVhZGluZ0xpbmVicmVhayA9IC9eXFxzKlxccj9cXG4vLFxuICAgICAgdHJhaWxpbmdMaW5lYnJlYWsgPSAvXFxyP1xcblxccyokLztcblxuICB2YXIgc3RyaXBTdGFuZGFsb25lcyA9IGZ1bmN0aW9uIChpdGVtcykge1xuICBcdHZhciBpLCBjdXJyZW50LCBiYWNrT25lLCBiYWNrVHdvLCBsYXN0U2VjdGlvbkl0ZW07XG5cbiAgXHRmb3IgKGkgPSAxOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGN1cnJlbnQgPSBpdGVtc1tpXTtcbiAgXHRcdGJhY2tPbmUgPSBpdGVtc1tpIC0gMV07XG4gIFx0XHRiYWNrVHdvID0gaXRlbXNbaSAtIDJdO1xuXG4gIFx0XHQvLyBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIGEgW3RleHRdW2NvbW1lbnRdW3RleHRdIHNlcXVlbmNlLi4uXG4gIFx0XHRpZiAoaXNTdHJpbmcoY3VycmVudCkgJiYgaXNDb21tZW50KGJhY2tPbmUpICYmIGlzU3RyaW5nKGJhY2tUd28pKSB7XG5cbiAgXHRcdFx0Ly8gLi4uIGFuZCB0aGUgY29tbWVudCBpcyBhIHN0YW5kYWxvbmUgKGkuZS4gbGluZSBicmVha3MgZWl0aGVyIHNpZGUpLi4uXG4gIFx0XHRcdGlmICh0cmFpbGluZ0xpbmVicmVhay50ZXN0KGJhY2tUd28pICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdChjdXJyZW50KSkge1xuXG4gIFx0XHRcdFx0Ly8gLi4uIHRoZW4gd2Ugd2FudCB0byByZW1vdmUgdGhlIHdoaXRlc3BhY2UgYWZ0ZXIgdGhlIGZpcnN0IGxpbmUgYnJlYWtcbiAgXHRcdFx0XHRpdGVtc1tpIC0gMl0gPSBiYWNrVHdvLnJlcGxhY2UodHJhaWxpbmdMaW5lYnJlYWssIFwiXFxuXCIpO1xuXG4gIFx0XHRcdFx0Ly8gYW5kIHRoZSBsZWFkaW5nIGxpbmUgYnJlYWsgb2YgdGhlIHNlY29uZCB0ZXh0IHRva2VuXG4gIFx0XHRcdFx0aXRlbXNbaV0gPSBjdXJyZW50LnJlcGxhY2UobGVhZGluZ0xpbmVicmVhaywgXCJcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gaWYgdGhlIGN1cnJlbnQgaXRlbSBpcyBhIHNlY3Rpb24sIGFuZCBpdCBpcyBwcmVjZWRlZCBieSBhIGxpbmVicmVhaywgYW5kXG4gIFx0XHQvLyBpdHMgZmlyc3QgaXRlbSBpcyBhIGxpbmVicmVhay4uLlxuICBcdFx0aWYgKGlzU2VjdGlvbihjdXJyZW50KSAmJiBpc1N0cmluZyhiYWNrT25lKSkge1xuICBcdFx0XHRpZiAodHJhaWxpbmdMaW5lYnJlYWsudGVzdChiYWNrT25lKSAmJiBpc1N0cmluZyhjdXJyZW50LmZbMF0pICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdChjdXJyZW50LmZbMF0pKSB7XG4gIFx0XHRcdFx0aXRlbXNbaSAtIDFdID0gYmFja09uZS5yZXBsYWNlKHRyYWlsaW5nTGluZWJyZWFrLCBcIlxcblwiKTtcbiAgXHRcdFx0XHRjdXJyZW50LmZbMF0gPSBjdXJyZW50LmZbMF0ucmVwbGFjZShsZWFkaW5nTGluZWJyZWFrLCBcIlwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBpZiB0aGUgbGFzdCBpdGVtIHdhcyBhIHNlY3Rpb24sIGFuZCBpdCBpcyBmb2xsb3dlZCBieSBhIGxpbmVicmVhaywgYW5kXG4gIFx0XHQvLyBpdHMgbGFzdCBpdGVtIGlzIGEgbGluZWJyZWFrLi4uXG4gIFx0XHRpZiAoaXNTdHJpbmcoY3VycmVudCkgJiYgaXNTZWN0aW9uKGJhY2tPbmUpKSB7XG4gIFx0XHRcdGxhc3RTZWN0aW9uSXRlbSA9IGxhc3RJdGVtKGJhY2tPbmUuZik7XG5cbiAgXHRcdFx0aWYgKGlzU3RyaW5nKGxhc3RTZWN0aW9uSXRlbSkgJiYgdHJhaWxpbmdMaW5lYnJlYWsudGVzdChsYXN0U2VjdGlvbkl0ZW0pICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdChjdXJyZW50KSkge1xuICBcdFx0XHRcdGJhY2tPbmUuZltiYWNrT25lLmYubGVuZ3RoIC0gMV0gPSBsYXN0U2VjdGlvbkl0ZW0ucmVwbGFjZSh0cmFpbGluZ0xpbmVicmVhaywgXCJcXG5cIik7XG4gIFx0XHRcdFx0aXRlbXNbaV0gPSBjdXJyZW50LnJlcGxhY2UobGVhZGluZ0xpbmVicmVhaywgXCJcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNTdHJpbmcoaXRlbSkge1xuICBcdHJldHVybiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29tbWVudChpdGVtKSB7XG4gIFx0cmV0dXJuIGl0ZW0udCA9PT0gQ09NTUVOVCB8fCBpdGVtLnQgPT09IERFTElNQ0hBTkdFO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTZWN0aW9uKGl0ZW0pIHtcbiAgXHRyZXR1cm4gKGl0ZW0udCA9PT0gU0VDVElPTiB8fCBpdGVtLnQgPT09IElOVkVSVEVEKSAmJiBpdGVtLmY7XG4gIH1cblxuICB2YXIgdHJpbVdoaXRlc3BhY2UgPSBmdW5jdGlvbiAoaXRlbXMsIGxlYWRpbmdQYXR0ZXJuLCB0cmFpbGluZ1BhdHRlcm4pIHtcbiAgXHR2YXIgaXRlbTtcblxuICBcdGlmIChsZWFkaW5nUGF0dGVybikge1xuICBcdFx0aXRlbSA9IGl0ZW1zWzBdO1xuICBcdFx0aWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGl0ZW0gPSBpdGVtLnJlcGxhY2UobGVhZGluZ1BhdHRlcm4sIFwiXCIpO1xuXG4gIFx0XHRcdGlmICghaXRlbSkge1xuICBcdFx0XHRcdGl0ZW1zLnNoaWZ0KCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aXRlbXNbMF0gPSBpdGVtO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHRyYWlsaW5nUGF0dGVybikge1xuICBcdFx0aXRlbSA9IGxhc3RJdGVtKGl0ZW1zKTtcbiAgXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKHRyYWlsaW5nUGF0dGVybiwgXCJcIik7XG5cbiAgXHRcdFx0aWYgKCFpdGVtKSB7XG4gIFx0XHRcdFx0aXRlbXMucG9wKCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0gPSBpdGVtO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciB1dGlsc19jbGVhbnVwID0gY2xlYW51cDtcbiAgdmFyIGNvbnRpZ3VvdXNXaGl0ZXNwYWNlID0gL1sgXFx0XFxmXFxyXFxuXSsvZztcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnRzID0gL14oPzpwcmV8c2NyaXB0fHN0eWxlfHRleHRhcmVhKSQvaTtcbiAgdmFyIHV0aWxzX2NsZWFudXBfX2xlYWRpbmdXaGl0ZXNwYWNlID0gL15bIFxcdFxcZlxcclxcbl0rLztcbiAgdmFyIHRyYWlsaW5nV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rJC87XG4gIHZhciBsZWFkaW5nTmV3TGluZSA9IC9eKD86XFxyXFxufFxccnxcXG4pLztcbiAgdmFyIHRyYWlsaW5nTmV3TGluZSA9IC8oPzpcXHJcXG58XFxyfFxcbikkLztcbiAgZnVuY3Rpb24gY2xlYW51cChpdGVtcywgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZSwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlKSB7XG4gIFx0dmFyIGksIGl0ZW0sIHByZXZpb3VzSXRlbSwgbmV4dEl0ZW0sIHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwga2V5O1xuXG4gIFx0Ly8gRmlyc3QgcGFzcyAtIHJlbW92ZSBzdGFuZGFsb25lcyBhbmQgY29tbWVudHMgZXRjXG4gIFx0c3RyaXBTdGFuZGFsb25lcyhpdGVtcyk7XG5cbiAgXHRpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGl0ZW0gPSBpdGVtc1tpXTtcblxuICBcdFx0Ly8gUmVtb3ZlIGRlbGltaXRlciBjaGFuZ2VzLCB1bnNhZmUgZWxlbWVudHMgZXRjXG4gIFx0XHRpZiAoaXRlbS5leGNsdWRlKSB7XG4gIFx0XHRcdGl0ZW1zLnNwbGljZShpLCAxKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gUmVtb3ZlIGNvbW1lbnRzLCB1bmxlc3Mgd2Ugd2FudCB0byBrZWVwIHRoZW1cbiAgXHRcdGVsc2UgaWYgKHN0cmlwQ29tbWVudHMgJiYgaXRlbS50ID09PSBDT01NRU5UKSB7XG4gIFx0XHRcdGl0ZW1zLnNwbGljZShpLCAxKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJZiBuZWNlc3NhcnksIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gIFx0dHJpbVdoaXRlc3BhY2UoaXRlbXMsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlID8gdXRpbHNfY2xlYW51cF9fbGVhZGluZ1doaXRlc3BhY2UgOiBudWxsLCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UgPyB0cmFpbGluZ1doaXRlc3BhY2UgOiBudWxsKTtcblxuICBcdGkgPSBpdGVtcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aXRlbSA9IGl0ZW1zW2ldO1xuXG4gIFx0XHQvLyBSZWN1cnNlXG4gIFx0XHRpZiAoaXRlbS5mKSB7XG4gIFx0XHRcdHZhciBpc1ByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnQgPSBpdGVtLnQgPT09IEVMRU1FTlQgJiYgcHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudHMudGVzdChpdGVtLmUpO1xuICBcdFx0XHRwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHByZXNlcnZlV2hpdGVzcGFjZSB8fCBpc1ByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnQ7XG5cbiAgXHRcdFx0aWYgKCFwcmVzZXJ2ZVdoaXRlc3BhY2UgJiYgaXNQcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50KSB7XG4gIFx0XHRcdFx0dHJpbVdoaXRlc3BhY2UoaXRlbS5mLCBsZWFkaW5nTmV3TGluZSwgdHJhaWxpbmdOZXdMaW5lKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRwcmV2aW91c0l0ZW0gPSBpdGVtc1tpIC0gMV07XG4gIFx0XHRcdFx0bmV4dEl0ZW0gPSBpdGVtc1tpICsgMV07XG5cbiAgXHRcdFx0XHQvLyBpZiB0aGUgcHJldmlvdXMgaXRlbSB3YXMgYSB0ZXh0IGl0ZW0gd2l0aCB0cmFpbGluZyB3aGl0ZXNwYWNlLFxuICBcdFx0XHRcdC8vIHJlbW92ZSBsZWFkaW5nIHdoaXRlc3BhY2UgaW5zaWRlIHRoZSBmcmFnbWVudFxuICBcdFx0XHRcdGlmICghcHJldmlvdXNJdGVtIHx8IHR5cGVvZiBwcmV2aW91c0l0ZW0gPT09IFwic3RyaW5nXCIgJiYgdHJhaWxpbmdXaGl0ZXNwYWNlLnRlc3QocHJldmlvdXNJdGVtKSkge1xuICBcdFx0XHRcdFx0cmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHRydWU7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gYW5kIHZpY2UgdmVyc2FcbiAgXHRcdFx0XHRpZiAoIW5leHRJdGVtIHx8IHR5cGVvZiBuZXh0SXRlbSA9PT0gXCJzdHJpbmdcIiAmJiB1dGlsc19jbGVhbnVwX19sZWFkaW5nV2hpdGVzcGFjZS50ZXN0KG5leHRJdGVtKSkge1xuICBcdFx0XHRcdFx0cmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNsZWFudXAoaXRlbS5mLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBTcGxpdCBpZi1lbHNlIGJsb2NrcyBpbnRvIHR3byAoYW4gaWYsIGFuZCBhbiB1bmxlc3MpXG4gIFx0XHRpZiAoaXRlbS5sKSB7XG4gIFx0XHRcdGNsZWFudXAoaXRlbS5sLmYsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuXG4gIFx0XHRcdGl0ZW1zLnNwbGljZShpICsgMSwgMCwgaXRlbS5sKTtcbiAgXHRcdFx0ZGVsZXRlIGl0ZW0ubDsgLy8gVE9ETyB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBhIHdheSBhcm91bmQgdGhpc1xuICBcdFx0fVxuXG4gIFx0XHQvLyBDbGVhbiB1cCBlbGVtZW50IGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChpdGVtLmEpIHtcbiAgXHRcdFx0Zm9yIChrZXkgaW4gaXRlbS5hKSB7XG4gIFx0XHRcdFx0aWYgKGl0ZW0uYS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiBpdGVtLmFba2V5XSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdFx0Y2xlYW51cChpdGVtLmFba2V5XSwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIENsZWFuIHVwIGNvbmRpdGlvbmFsIGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChpdGVtLm0pIHtcbiAgXHRcdFx0Y2xlYW51cChpdGVtLm0sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBDbGVhbiB1cCBldmVudCBoYW5kbGVyc1xuICBcdFx0aWYgKGl0ZW0udikge1xuICBcdFx0XHRmb3IgKGtleSBpbiBpdGVtLnYpIHtcbiAgXHRcdFx0XHRpZiAoaXRlbS52Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0XHRcdC8vIGNsZWFuIHVwIG5hbWVzXG4gIFx0XHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLnZba2V5XS5uKSkge1xuICBcdFx0XHRcdFx0XHRjbGVhbnVwKGl0ZW0udltrZXldLm4sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHQvLyBjbGVhbiB1cCBwYXJhbXNcbiAgXHRcdFx0XHRcdGlmIChpc0FycmF5KGl0ZW0udltrZXldLmQpKSB7XG4gIFx0XHRcdFx0XHRcdGNsZWFudXAoaXRlbS52W2tleV0uZCwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gZmluYWwgcGFzcyAtIGZ1c2UgdGV4dCBub2RlcyB0b2dldGhlclxuICBcdGkgPSBpdGVtcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKHR5cGVvZiBpdGVtc1tpXSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRpZiAodHlwZW9mIGl0ZW1zW2kgKyAxXSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdGl0ZW1zW2ldID0gaXRlbXNbaV0gKyBpdGVtc1tpICsgMV07XG4gIFx0XHRcdFx0aXRlbXMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghcHJlc2VydmVXaGl0ZXNwYWNlKSB7XG4gIFx0XHRcdFx0aXRlbXNbaV0gPSBpdGVtc1tpXS5yZXBsYWNlKGNvbnRpZ3VvdXNXaGl0ZXNwYWNlLCBcIiBcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaXRlbXNbaV0gPT09IFwiXCIpIHtcbiAgXHRcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgZWxlbWVudF9yZWFkQ2xvc2luZ1RhZyA9IHJlYWRDbG9zaW5nVGFnO1xuICB2YXIgY2xvc2luZ1RhZ1BhdHRlcm4gPSAvXihbYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKilcXHMqXFw+LztcbiAgZnVuY3Rpb24gcmVhZENsb3NpbmdUYWcocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCB0YWc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhcmUgd2UgbG9va2luZyBhdCBhIGNsb3NpbmcgdGFnP1xuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPC9cIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICh0YWcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGNsb3NpbmdUYWdQYXR0ZXJuKSkge1xuICBcdFx0aWYgKHBhcnNlci5pbnNpZGUgJiYgdGFnICE9PSBwYXJzZXIuaW5zaWRlKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IENMT1NJTkdfVEFHLFxuICBcdFx0XHRlOiB0YWdcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0Ly8gV2UgaGF2ZSBhbiBpbGxlZ2FsIGNsb3NpbmcgdGFnLCByZXBvcnQgaXRcbiAgXHRwYXJzZXIucG9zIC09IDI7XG4gIFx0cGFyc2VyLmVycm9yKFwiSWxsZWdhbCBjbG9zaW5nIHRhZ1wiKTtcbiAgfVxuXG4gIHZhciBnZXRMb3dlc3RJbmRleCA9IGZ1bmN0aW9uIChoYXlzdGFjaywgbmVlZGxlcykge1xuICBcdHZhciBpLCBpbmRleCwgbG93ZXN0O1xuXG4gIFx0aSA9IG5lZWRsZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGluZGV4ID0gaGF5c3RhY2suaW5kZXhPZihuZWVkbGVzW2ldKTtcblxuICBcdFx0Ly8gc2hvcnQgY2lyY3VpdFxuICBcdFx0aWYgKCFpbmRleCkge1xuICBcdFx0XHRyZXR1cm4gMDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFsb3dlc3QgfHwgaW5kZXggPCBsb3dlc3QpIHtcbiAgXHRcdFx0bG93ZXN0ID0gaW5kZXg7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGxvd2VzdCB8fCAtMTtcbiAgfTtcblxuICB2YXIgZWxlbWVudF9yZWFkQXR0cmlidXRlID0gcmVhZEF0dHJpYnV0ZTtcblxuICB2YXIgYXR0cmlidXRlTmFtZVBhdHRlcm4gPSAvXlteXFxzXCInPlxcLz1dKy8sXG4gICAgICB1bnF1b3RlZEF0dHJpYnV0ZVZhbHVlVGV4dFBhdHRlcm4gPSAvXlteXFxzXCInPTw+YF0rLztcbiAgZnVuY3Rpb24gcmVhZEF0dHJpYnV0ZShwYXJzZXIpIHtcbiAgXHR2YXIgYXR0ciwgbmFtZSwgdmFsdWU7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybihhdHRyaWJ1dGVOYW1lUGF0dGVybik7XG4gIFx0aWYgKCFuYW1lKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRhdHRyID0geyBuYW1lOiBuYW1lIH07XG5cbiAgXHR2YWx1ZSA9IHJlYWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIpO1xuICBcdGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gIFx0XHQvLyBub3QgbnVsbC91bmRlZmluZWRcbiAgXHRcdGF0dHIudmFsdWUgPSB2YWx1ZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXR0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHZhbHVlU3RhcnQsIHN0YXJ0RGVwdGgsIHZhbHVlO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSBgPWAsIGAvYCwgYD5gIG9yIHdoaXRlc3BhY2VcbiAgXHRpZiAoIS9bPVxcLz5cXHNdLy50ZXN0KHBhcnNlci5uZXh0Q2hhcigpKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgYD1gLCBgL2AsIGA+YCBvciB3aGl0ZXNwYWNlXCIpO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPVwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0dmFsdWVTdGFydCA9IHBhcnNlci5wb3M7XG4gIFx0c3RhcnREZXB0aCA9IHBhcnNlci5zZWN0aW9uRGVwdGg7XG5cbiAgXHR2YWx1ZSA9IHJlYWRRdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIsIFwiJ1wiKSB8fCByZWFkUXVvdGVkQXR0cmlidXRlVmFsdWUocGFyc2VyLCBcIlxcXCJcIikgfHwgcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWUocGFyc2VyKTtcblxuICBcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgdmFsaWQgYXR0cmlidXRlIHZhbHVlXCIpO1xuICBcdH1cblxuICBcdGlmIChwYXJzZXIuc2VjdGlvbkRlcHRoICE9PSBzdGFydERlcHRoKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gdmFsdWVTdGFydDtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkFuIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGNvbnRhaW4gYXMgbWFueSBvcGVuaW5nIHNlY3Rpb24gdGFncyBhcyBjbG9zaW5nIHNlY3Rpb24gdGFnc1wiKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXZhbHVlLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKHZhbHVlLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgdmFsdWVbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJldHVybiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKHZhbHVlWzBdKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgdGV4dCwgaGF5c3RhY2ssIG5lZWRsZXMsIGluZGV4O1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0dGV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4odW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuKTtcblxuICBcdGlmICghdGV4dCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aGF5c3RhY2sgPSB0ZXh0O1xuICBcdG5lZWRsZXMgPSBwYXJzZXIudGFncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgXHRcdHJldHVybiB0Lm9wZW47XG4gIFx0fSk7IC8vIFRPRE8gcmVmYWN0b3IuLi4gd2UgZG8gdGhpcyBpbiByZWFkVGV4dC5qcyBhcyB3ZWxsXG5cbiAgXHRpZiAoKGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoaGF5c3RhY2ssIG5lZWRsZXMpKSAhPT0gLTEpIHtcbiAgXHRcdHRleHQgPSB0ZXh0LnN1YnN0cigwLCBpbmRleCk7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQgKyB0ZXh0Lmxlbmd0aDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlcikge1xuICBcdHZhciB0b2tlbnMsIHRva2VuO1xuXG4gIFx0cGFyc2VyLmluQXR0cmlidXRlID0gdHJ1ZTtcblxuICBcdHRva2VucyA9IFtdO1xuXG4gIFx0dG9rZW4gPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4ocGFyc2VyKTtcbiAgXHR3aGlsZSAodG9rZW4gIT09IG51bGwpIHtcbiAgXHRcdHRva2Vucy5wdXNoKHRva2VuKTtcbiAgXHRcdHRva2VuID0gY29udmVydGVyc19yZWFkTXVzdGFjaGUocGFyc2VyKSB8fCByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKHBhcnNlcik7XG4gIFx0fVxuXG4gIFx0aWYgKCF0b2tlbnMubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBmYWxzZTtcbiAgXHRyZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlciwgcXVvdGVNYXJrKSB7XG4gIFx0dmFyIHN0YXJ0LCB0b2tlbnMsIHRva2VuO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcocXVvdGVNYXJrKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluQXR0cmlidXRlID0gcXVvdGVNYXJrO1xuXG4gIFx0dG9rZW5zID0gW107XG5cbiAgXHR0b2tlbiA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgcmVhZFF1b3RlZFN0cmluZ1Rva2VuKHBhcnNlciwgcXVvdGVNYXJrKTtcbiAgXHR3aGlsZSAodG9rZW4gIT09IG51bGwpIHtcbiAgXHRcdHRva2Vucy5wdXNoKHRva2VuKTtcbiAgXHRcdHRva2VuID0gY29udmVydGVyc19yZWFkTXVzdGFjaGUocGFyc2VyKSB8fCByZWFkUXVvdGVkU3RyaW5nVG9rZW4ocGFyc2VyLCBxdW90ZU1hcmspO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHF1b3RlTWFyaykpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IGZhbHNlO1xuXG4gIFx0cmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRRdW90ZWRTdHJpbmdUb2tlbihwYXJzZXIsIHF1b3RlTWFyaykge1xuICBcdHZhciBzdGFydCwgaW5kZXgsIGhheXN0YWNrLCBuZWVkbGVzO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdGhheXN0YWNrID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0bmVlZGxlcyA9IHBhcnNlci50YWdzLm1hcChmdW5jdGlvbiAodCkge1xuICBcdFx0cmV0dXJuIHQub3BlbjtcbiAgXHR9KTsgLy8gVE9ETyByZWZhY3Rvci4uLiB3ZSBkbyB0aGlzIGluIHJlYWRUZXh0LmpzIGFzIHdlbGxcbiAgXHRuZWVkbGVzLnB1c2gocXVvdGVNYXJrKTtcblxuICBcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoaGF5c3RhY2ssIG5lZWRsZXMpO1xuXG4gIFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiUXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGhhdmUgYSBjbG9zaW5nIHF1b3RlXCIpO1xuICBcdH1cblxuICBcdGlmICghaW5kZXgpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG4gIFx0cmV0dXJuIGhheXN0YWNrLnN1YnN0cigwLCBpbmRleCk7XG4gIH1cblxuICB2YXIgSnNvblBhcnNlciwgc3BlY2lhbHMsIHNwZWNpYWxzUGF0dGVybiwgcGFyc2VKU09OX19udW1iZXJQYXR0ZXJuLCBwbGFjZWhvbGRlclBhdHRlcm4sIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4sIG9ubHlXaGl0ZXNwYWNlO1xuXG4gIHNwZWNpYWxzID0ge1xuICBcdFwidHJ1ZVwiOiB0cnVlLFxuICBcdFwiZmFsc2VcIjogZmFsc2UsXG4gIFx0dW5kZWZpbmVkOiB1bmRlZmluZWQsXG4gIFx0XCJudWxsXCI6IG51bGxcbiAgfTtcblxuICBzcGVjaWFsc1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgT2JqZWN0LmtleXMoc3BlY2lhbHMpLmpvaW4oXCJ8XCIpICsgXCIpXCIpO1xuICBwYXJzZUpTT05fX251bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KSg/Oig/Oig/OjB8WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuICBwbGFjZWhvbGRlclBhdHRlcm4gPSAvXFwkXFx7KFteXFx9XSspXFx9L2c7XG4gIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4gPSAvXlxcJFxceyhbXlxcfV0rKVxcfS87XG4gIG9ubHlXaGl0ZXNwYWNlID0gL15cXHMqJC87XG5cbiAgSnNvblBhcnNlciA9IHBhcnNlX1BhcnNlci5leHRlbmQoe1xuICBcdGluaXQ6IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgXHRcdHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gIFx0XHR0aGlzLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdH0sXG5cbiAgXHRwb3N0UHJvY2VzczogZnVuY3Rpb24gKHJlc3VsdCkge1xuICBcdFx0aWYgKHJlc3VsdC5sZW5ndGggIT09IDEgfHwgIW9ubHlXaGl0ZXNwYWNlLnRlc3QodGhpcy5sZWZ0b3ZlcikpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7IHZhbHVlOiByZXN1bHRbMF0udiB9O1xuICBcdH0sXG5cbiAgXHRjb252ZXJ0ZXJzOiBbZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXIocGFyc2VyKSB7XG4gIFx0XHR2YXIgcGxhY2Vob2xkZXI7XG5cbiAgXHRcdGlmICghcGFyc2VyLnZhbHVlcykge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cGxhY2Vob2xkZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4pO1xuXG4gIFx0XHRpZiAocGxhY2Vob2xkZXIgJiYgcGFyc2VyLnZhbHVlcy5oYXNPd25Qcm9wZXJ0eShwbGFjZWhvbGRlcikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogcGFyc2VyLnZhbHVlc1twbGFjZWhvbGRlcl0gfTtcbiAgXHRcdH1cbiAgXHR9LCBmdW5jdGlvbiBnZXRTcGVjaWFsKHBhcnNlcikge1xuICBcdFx0dmFyIHNwZWNpYWw7XG5cbiAgXHRcdGlmIChzcGVjaWFsID0gcGFyc2VyLm1hdGNoUGF0dGVybihzcGVjaWFsc1BhdHRlcm4pKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHNwZWNpYWxzW3NwZWNpYWxdIH07XG4gIFx0XHR9XG4gIFx0fSwgZnVuY3Rpb24gZ2V0TnVtYmVyKHBhcnNlcikge1xuICBcdFx0dmFyIG51bWJlcjtcblxuICBcdFx0aWYgKG51bWJlciA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocGFyc2VKU09OX19udW1iZXJQYXR0ZXJuKSkge1xuICBcdFx0XHRyZXR1cm4geyB2OiArbnVtYmVyIH07XG4gIFx0XHR9XG4gIFx0fSwgZnVuY3Rpb24gZ2V0U3RyaW5nKHBhcnNlcikge1xuICBcdFx0dmFyIHN0cmluZ0xpdGVyYWwgPSByZWFkU3RyaW5nTGl0ZXJhbChwYXJzZXIpLFxuICBcdFx0ICAgIHZhbHVlcztcblxuICBcdFx0aWYgKHN0cmluZ0xpdGVyYWwgJiYgKHZhbHVlcyA9IHBhcnNlci52YWx1ZXMpKSB7XG4gIFx0XHRcdHJldHVybiB7XG4gIFx0XHRcdFx0djogc3RyaW5nTGl0ZXJhbC52LnJlcGxhY2UocGxhY2Vob2xkZXJQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gJDEgaW4gdmFsdWVzID8gdmFsdWVzWyQxXSA6ICQxO1xuICBcdFx0XHRcdH0pXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBzdHJpbmdMaXRlcmFsO1xuICBcdH0sIGZ1bmN0aW9uIGdldE9iamVjdChwYXJzZXIpIHtcbiAgXHRcdHZhciByZXN1bHQsIHBhaXI7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwie1wiKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmVzdWx0ID0ge307XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIn1cIikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogcmVzdWx0IH07XG4gIFx0XHR9XG5cbiAgXHRcdHdoaWxlIChwYWlyID0gZ2V0S2V5VmFsdWVQYWlyKHBhcnNlcikpIHtcbiAgXHRcdFx0cmVzdWx0W3BhaXIua2V5XSA9IHBhaXIudmFsdWU7XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJ9XCIpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHsgdjogcmVzdWx0IH07XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIixcIikpIHtcbiAgXHRcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9LCBmdW5jdGlvbiBnZXRBcnJheShwYXJzZXIpIHtcbiAgXHRcdHZhciByZXN1bHQsIHZhbHVlVG9rZW47XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiW1wiKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmVzdWx0ID0gW107XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogcmVzdWx0IH07XG4gIFx0XHR9XG5cbiAgXHRcdHdoaWxlICh2YWx1ZVRva2VuID0gcGFyc2VyLnJlYWQoKSkge1xuICBcdFx0XHRyZXN1bHQucHVzaCh2YWx1ZVRva2VuLnYpO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXVwiKSkge1xuICBcdFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1dXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGdldEtleVZhbHVlUGFpcihwYXJzZXIpIHtcbiAgXHR2YXIga2V5LCB2YWx1ZVRva2VuLCBwYWlyO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0a2V5ID0gc2hhcmVkX3JlYWRLZXkocGFyc2VyKTtcblxuICBcdGlmICgha2V5KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYWlyID0geyBrZXk6IGtleSB9O1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiOlwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdHZhbHVlVG9rZW4gPSBwYXJzZXIucmVhZCgpO1xuICBcdGlmICghdmFsdWVUb2tlbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFpci52YWx1ZSA9IHZhbHVlVG9rZW4udjtcblxuICBcdHJldHVybiBwYWlyO1xuICB9XG5cbiAgdmFyIHBhcnNlSlNPTiA9IGZ1bmN0aW9uIChzdHIsIHZhbHVlcykge1xuICBcdHZhciBwYXJzZXIgPSBuZXcgSnNvblBhcnNlcihzdHIsIHtcbiAgXHRcdHZhbHVlczogdmFsdWVzXG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gcGFyc2VyLnJlc3VsdDtcbiAgfTtcblxuICAvLyBUT0RPIGNsZWFuIHRoaXMgdXAsIGl0J3Mgc2hvY2tpbmdcbiAgdmFyIGVsZW1lbnRfcHJvY2Vzc0RpcmVjdGl2ZSA9IHByb2Nlc3NEaXJlY3RpdmU7XG4gIHZhciBtZXRob2RDYWxsUGF0dGVybiA9IC9eKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKilcXCgvLFxuICAgICAgbWV0aG9kQ2FsbEV4Y2Vzc1BhdHRlcm4gPSAvXFwpXFxzKiQvLFxuICAgICAgRXhwcmVzc2lvblBhcnNlcjtcblxuICBFeHByZXNzaW9uUGFyc2VyID0gcGFyc2VfUGFyc2VyLmV4dGVuZCh7XG4gIFx0Y29udmVydGVyczogW2NvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb25dXG4gIH0pO1xuICBmdW5jdGlvbiBwcm9jZXNzRGlyZWN0aXZlKHRva2VucywgcGFyZW50UGFyc2VyKSB7XG4gIFx0dmFyIHJlc3VsdCwgbWF0Y2gsIHBhcnNlciwgYXJncywgdG9rZW4sIGNvbG9uSW5kZXgsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MsIHBhcnNlZDtcblxuICBcdGlmICh0eXBlb2YgdG9rZW5zID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRpZiAobWF0Y2ggPSBtZXRob2RDYWxsUGF0dGVybi5leGVjKHRva2VucykpIHtcbiAgXHRcdFx0dmFyIGVuZCA9IHRva2Vucy5sYXN0SW5kZXhPZihcIilcIik7XG5cbiAgXHRcdFx0Ly8gY2hlY2sgZm9yIGludmFsaWQgbWV0aG9kIGNhbGxzXG4gIFx0XHRcdGlmICghbWV0aG9kQ2FsbEV4Y2Vzc1BhdHRlcm4udGVzdCh0b2tlbnMpKSB7XG4gIFx0XHRcdFx0cGFyZW50UGFyc2VyLmVycm9yKFwiSW52YWxpZCBpbnB1dCBhZnRlciBtZXRob2QgY2FsbCBleHByZXNzaW9uICdcIiArIHRva2Vucy5zbGljZShlbmQgKyAxKSArIFwiJ1wiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJlc3VsdCA9IHsgbTogbWF0Y2hbMV0gfTtcbiAgXHRcdFx0YXJncyA9IFwiW1wiICsgdG9rZW5zLnNsaWNlKHJlc3VsdC5tLmxlbmd0aCArIDEsIGVuZCkgKyBcIl1cIjtcblxuICBcdFx0XHRwYXJzZXIgPSBuZXcgRXhwcmVzc2lvblBhcnNlcihhcmdzKTtcbiAgXHRcdFx0cmVzdWx0LmEgPSB1dGlsc19mbGF0dGVuRXhwcmVzc2lvbihwYXJzZXIucmVzdWx0WzBdKTtcblxuICBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodG9rZW5zLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuICBcdFx0XHRyZXR1cm4gdG9rZW5zLnRyaW0oKTtcbiAgXHRcdH1cblxuICBcdFx0dG9rZW5zID0gW3Rva2Vuc107XG4gIFx0fVxuXG4gIFx0cmVzdWx0ID0ge307XG5cbiAgXHRkaXJlY3RpdmVOYW1lID0gW107XG4gIFx0ZGlyZWN0aXZlQXJncyA9IFtdO1xuXG4gIFx0aWYgKHRva2Vucykge1xuICBcdFx0d2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgXHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblxuICBcdFx0XHRpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0Y29sb25JbmRleCA9IHRva2VuLmluZGV4T2YoXCI6XCIpO1xuXG4gIFx0XHRcdFx0aWYgKGNvbG9uSW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2godG9rZW4pO1xuICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgXHRcdFx0XHRcdC8vIGlzIHRoZSBjb2xvbiB0aGUgZmlyc3QgY2hhcmFjdGVyP1xuICBcdFx0XHRcdFx0aWYgKGNvbG9uSW5kZXgpIHtcbiAgXHRcdFx0XHRcdFx0Ly8gbm9cbiAgXHRcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKHRva2VuLnN1YnN0cigwLCBjb2xvbkluZGV4KSk7XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIGFueXRoaW5nIGFmdGVyIHRoZSBjb2xvbiBpbiB0aGlzIHRva2VuLCB0cmVhdFxuICBcdFx0XHRcdFx0Ly8gaXQgYXMgdGhlIGZpcnN0IHRva2VuIG9mIHRoZSBkaXJlY3RpdmVBcmdzIGZyYWdtZW50XG4gIFx0XHRcdFx0XHRpZiAodG9rZW4ubGVuZ3RoID4gY29sb25JbmRleCArIDEpIHtcbiAgXHRcdFx0XHRcdFx0ZGlyZWN0aXZlQXJnc1swXSA9IHRva2VuLnN1YnN0cmluZyhjb2xvbkluZGV4ICsgMSk7XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2godG9rZW4pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGRpcmVjdGl2ZUFyZ3MgPSBkaXJlY3RpdmVBcmdzLmNvbmNhdCh0b2tlbnMpO1xuICBcdH1cblxuICBcdGlmICghZGlyZWN0aXZlTmFtZS5sZW5ndGgpIHtcbiAgXHRcdHJlc3VsdCA9IFwiXCI7XG4gIFx0fSBlbHNlIGlmIChkaXJlY3RpdmVBcmdzLmxlbmd0aCB8fCB0eXBlb2YgZGlyZWN0aXZlTmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0cmVzdWx0ID0ge1xuICBcdFx0XHQvLyBUT0RPIGlzIHRoaXMgcmVhbGx5IG5lY2Vzc2FyeT8ganVzdCB1c2UgdGhlIGFycmF5XG4gIFx0XHRcdG46IGRpcmVjdGl2ZU5hbWUubGVuZ3RoID09PSAxICYmIHR5cGVvZiBkaXJlY3RpdmVOYW1lWzBdID09PSBcInN0cmluZ1wiID8gZGlyZWN0aXZlTmFtZVswXSA6IGRpcmVjdGl2ZU5hbWVcbiAgXHRcdH07XG5cbiAgXHRcdGlmIChkaXJlY3RpdmVBcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlQXJnc1swXSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oXCJbXCIgKyBkaXJlY3RpdmVBcmdzWzBdICsgXCJdXCIpO1xuICBcdFx0XHRyZXN1bHQuYSA9IHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IGRpcmVjdGl2ZUFyZ3NbMF0udHJpbSgpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmVzdWx0LmQgPSBkaXJlY3RpdmVBcmdzO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXN1bHQgPSBkaXJlY3RpdmVOYW1lO1xuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgdGFnTmFtZVBhdHRlcm4gPSAvXlthLXpBLVpdezEsfTo/W2EtekEtWjAtOVxcLV0qLyxcbiAgICAgIHZhbGlkVGFnTmFtZUZvbGxvd2VyID0gL15bXFxzXFxuXFwvPl0vLFxuICAgICAgb25QYXR0ZXJuID0gL15vbi8sXG4gICAgICBwcm94eUV2ZW50UGF0dGVybiA9IC9eb24tKFthLXpBLVpcXFxcKlxcXFwuJF9dW2EtekEtWlxcXFwqXFxcXC4kXzAtOVxcLV0rKSQvLFxuICAgICAgcmVzZXJ2ZWRFdmVudE5hbWVzID0gL14oPzpjaGFuZ2V8cmVzZXR8dGVhcmRvd258dXBkYXRlfGNvbnN0cnVjdHxjb25maWd8aW5pdHxyZW5kZXJ8dW5yZW5kZXJ8ZGV0YWNofGluc2VydCkkLyxcbiAgICAgIGRpcmVjdGl2ZXMgPSB7IFwiaW50cm8tb3V0cm9cIjogXCJ0MFwiLCBpbnRybzogXCJ0MVwiLCBvdXRybzogXCJ0MlwiLCBkZWNvcmF0b3I6IFwib1wiIH0sXG4gICAgICBleGNsdWRlID0geyBleGNsdWRlOiB0cnVlIH0sXG4gICAgICBkaXNhbGxvd2VkQ29udGVudHM7XG5cbiAgLy8gYmFzZWQgb24gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtdGFnLW9taXNzaW9uXG4gIGRpc2FsbG93ZWRDb250ZW50cyA9IHtcbiAgXHRsaTogW1wibGlcIl0sXG4gIFx0ZHQ6IFtcImR0XCIsIFwiZGRcIl0sXG4gIFx0ZGQ6IFtcImR0XCIsIFwiZGRcIl0sXG4gIFx0cDogXCJhZGRyZXNzIGFydGljbGUgYXNpZGUgYmxvY2txdW90ZSBkaXYgZGwgZmllbGRzZXQgZm9vdGVyIGZvcm0gaDEgaDIgaDMgaDQgaDUgaDYgaGVhZGVyIGhncm91cCBociBtYWluIG1lbnUgbmF2IG9sIHAgcHJlIHNlY3Rpb24gdGFibGUgdWxcIi5zcGxpdChcIiBcIiksXG4gIFx0cnQ6IFtcInJ0XCIsIFwicnBcIl0sXG4gIFx0cnA6IFtcInJ0XCIsIFwicnBcIl0sXG4gIFx0b3B0Z3JvdXA6IFtcIm9wdGdyb3VwXCJdLFxuICBcdG9wdGlvbjogW1wib3B0aW9uXCIsIFwib3B0Z3JvdXBcIl0sXG4gIFx0dGhlYWQ6IFtcInRib2R5XCIsIFwidGZvb3RcIl0sXG4gIFx0dGJvZHk6IFtcInRib2R5XCIsIFwidGZvb3RcIl0sXG4gIFx0dGZvb3Q6IFtcInRib2R5XCJdLFxuICBcdHRyOiBbXCJ0clwiLCBcInRib2R5XCJdLFxuICBcdHRkOiBbXCJ0ZFwiLCBcInRoXCIsIFwidHJcIl0sXG4gIFx0dGg6IFtcInRkXCIsIFwidGhcIiwgXCJ0clwiXVxuICB9O1xuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRFbGVtZW50ID0gcmVhZEVsZW1lbnQ7XG5cbiAgZnVuY3Rpb24gcmVhZEVsZW1lbnQocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBlbGVtZW50LCBkaXJlY3RpdmVOYW1lLCBtYXRjaCwgYWRkUHJveHlFdmVudCwgYXR0cmlidXRlLCBkaXJlY3RpdmUsIHNlbGZDbG9zaW5nLCBjaGlsZHJlbiwgcGFydGlhbHMsIGhhc1BhcnRpYWxzLCBjaGlsZCwgY2xvc2VkLCBwb3MsIHJlbWFpbmluZywgY2xvc2luZ1RhZztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmIChwYXJzZXIuaW5zaWRlIHx8IHBhcnNlci5pbkF0dHJpYnV0ZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI8XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGEgY2xvc2luZyB0YWcsIGFib3J0IHN0cmFpZ2h0IGF3YXlcbiAgXHRpZiAocGFyc2VyLm5leHRDaGFyKCkgPT09IFwiL1wiKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRlbGVtZW50ID0ge307XG4gIFx0aWYgKHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucykge1xuICBcdFx0ZWxlbWVudC5wID0gcGFyc2VyLmdldExpbmVQb3Moc3RhcnQpO1xuICBcdH1cblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIhXCIpKSB7XG4gIFx0XHRlbGVtZW50LnQgPSBET0NUWVBFO1xuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eZG9jdHlwZS9pKSkge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBET0NUWVBFIGRlY2xhcmF0aW9uXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRlbGVtZW50LmEgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eKC4rPyk+Lyk7XG4gIFx0XHRyZXR1cm4gZWxlbWVudDtcbiAgXHR9XG5cbiAgXHRlbGVtZW50LnQgPSBFTEVNRU5UO1xuXG4gIFx0Ly8gZWxlbWVudCBuYW1lXG4gIFx0ZWxlbWVudC5lID0gcGFyc2VyLm1hdGNoUGF0dGVybih0YWdOYW1lUGF0dGVybik7XG4gIFx0aWYgKCFlbGVtZW50LmUpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgd2hpdGVzcGFjZSwgY2xvc2luZyBzb2xpZHVzIG9yICc+J1xuICBcdGlmICghdmFsaWRUYWdOYW1lRm9sbG93ZXIudGVzdChwYXJzZXIubmV4dENoYXIoKSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIklsbGVnYWwgdGFnIG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0YWRkUHJveHlFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBkaXJlY3RpdmUpIHtcbiAgXHRcdHZhciBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlLm4gfHwgZGlyZWN0aXZlO1xuXG4gIFx0XHRpZiAocmVzZXJ2ZWRFdmVudE5hbWVzLnRlc3QoZGlyZWN0aXZlTmFtZSkpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyAtPSBkaXJlY3RpdmVOYW1lLmxlbmd0aDtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiQ2Fubm90IHVzZSByZXNlcnZlZCBldmVudCBuYW1lcyAoY2hhbmdlLCByZXNldCwgdGVhcmRvd24sIHVwZGF0ZSwgY29uc3RydWN0LCBjb25maWcsIGluaXQsIHJlbmRlciwgdW5yZW5kZXIsIGRldGFjaCwgaW5zZXJ0KVwiKTtcbiAgXHRcdH1cblxuICBcdFx0ZWxlbWVudC52W25hbWVdID0gZGlyZWN0aXZlO1xuICBcdH07XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBkaXJlY3RpdmVzIGFuZCBhdHRyaWJ1dGVzXG4gIFx0d2hpbGUgKGF0dHJpYnV0ZSA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgZWxlbWVudF9yZWFkQXR0cmlidXRlKHBhcnNlcikpIHtcbiAgXHRcdC8vIHJlZ3VsYXIgYXR0cmlidXRlc1xuICBcdFx0aWYgKGF0dHJpYnV0ZS5uYW1lKSB7XG4gIFx0XHRcdC8vIGludHJvLCBvdXRybywgZGVjb3JhdG9yXG4gIFx0XHRcdGlmIChkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlc1thdHRyaWJ1dGUubmFtZV0pIHtcbiAgXHRcdFx0XHRlbGVtZW50W2RpcmVjdGl2ZU5hbWVdID0gZWxlbWVudF9wcm9jZXNzRGlyZWN0aXZlKGF0dHJpYnV0ZS52YWx1ZSwgcGFyc2VyKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIG9uLWNsaWNrIGV0Y1xuICBcdFx0XHRlbHNlIGlmIChtYXRjaCA9IHByb3h5RXZlbnRQYXR0ZXJuLmV4ZWMoYXR0cmlidXRlLm5hbWUpKSB7XG4gIFx0XHRcdFx0aWYgKCFlbGVtZW50LnYpIGVsZW1lbnQudiA9IHt9O1xuICBcdFx0XHRcdGRpcmVjdGl2ZSA9IGVsZW1lbnRfcHJvY2Vzc0RpcmVjdGl2ZShhdHRyaWJ1dGUudmFsdWUsIHBhcnNlcik7XG4gIFx0XHRcdFx0YWRkUHJveHlFdmVudChtYXRjaFsxXSwgZGlyZWN0aXZlKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpZiAoIXBhcnNlci5zYW5pdGl6ZUV2ZW50QXR0cmlidXRlcyB8fCAhb25QYXR0ZXJuLnRlc3QoYXR0cmlidXRlLm5hbWUpKSB7XG4gIFx0XHRcdFx0XHRpZiAoIWVsZW1lbnQuYSkgZWxlbWVudC5hID0ge307XG4gIFx0XHRcdFx0XHRlbGVtZW50LmFbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlIHx8IChhdHRyaWJ1dGUudmFsdWUgPT09IFwiXCIgPyBcIlwiIDogMCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHt7I2lmIGZvb319Y2xhc3M9J2Zvbyd7ey9pZn19XG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0aWYgKCFlbGVtZW50Lm0pIGVsZW1lbnQubSA9IFtdO1xuICBcdFx0XHRlbGVtZW50Lm0ucHVzaChhdHRyaWJ1dGUpO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyBzb2xpZHVzXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gc2VsZi1jbG9zaW5nIHNvbGlkdXM/XG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIi9cIikpIHtcbiAgXHRcdHNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHQvLyBjbG9zaW5nIGFuZ2xlIGJyYWNrZXRcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj5cIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHZhciBsb3dlckNhc2VOYW1lID0gZWxlbWVudC5lLnRvTG93ZXJDYXNlKCk7XG4gIFx0dmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IHBhcnNlci5wcmVzZXJ2ZVdoaXRlc3BhY2U7XG5cbiAgXHRpZiAoIXNlbGZDbG9zaW5nICYmICF2b2lkRWxlbWVudE5hbWVzLnRlc3QoZWxlbWVudC5lKSkge1xuICBcdFx0cGFyc2VyLmVsZW1lbnRTdGFjay5wdXNoKGxvd2VyQ2FzZU5hbWUpO1xuXG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBpZiB3ZSBvcGVuIGEgc2NyaXB0IGVsZW1lbnQsIGZ1cnRoZXIgdGFncyBzaG91bGRcbiAgXHRcdC8vIGJlIGlnbm9yZWQgdW5sZXNzIHRoZXkncmUgYSBjbG9zaW5nIHNjcmlwdCBlbGVtZW50XG4gIFx0XHRpZiAobG93ZXJDYXNlTmFtZSA9PT0gXCJzY3JpcHRcIiB8fCBsb3dlckNhc2VOYW1lID09PSBcInN0eWxlXCIpIHtcbiAgXHRcdFx0cGFyc2VyLmluc2lkZSA9IGxvd2VyQ2FzZU5hbWU7XG4gIFx0XHR9XG5cbiAgXHRcdGNoaWxkcmVuID0gW107XG4gIFx0XHRwYXJ0aWFscyA9IGNyZWF0ZShudWxsKTtcblxuICBcdFx0ZG8ge1xuICBcdFx0XHRwb3MgPSBwYXJzZXIucG9zO1xuICBcdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cbiAgXHRcdFx0Ly8gaWYgZm9yIGV4YW1wbGUgd2UncmUgaW4gYW4gPGxpPiBlbGVtZW50LCBhbmQgd2Ugc2VlIGFub3RoZXJcbiAgXHRcdFx0Ly8gPGxpPiB0YWcsIGNsb3NlIHRoZSBmaXJzdCBzbyB0aGV5IGJlY29tZSBzaWJsaW5nc1xuICBcdFx0XHRpZiAoIWNhbkNvbnRhaW4obG93ZXJDYXNlTmFtZSwgcmVtYWluaW5nKSkge1xuICBcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBjbG9zaW5nIHRhZ1xuICBcdFx0XHRlbHNlIGlmIChjbG9zaW5nVGFnID0gZWxlbWVudF9yZWFkQ2xvc2luZ1RhZyhwYXJzZXIpKSB7XG4gIFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcblxuICBcdFx0XHRcdHZhciBjbG9zaW5nVGFnTmFtZSA9IGNsb3NpbmdUYWcuZS50b0xvd2VyQ2FzZSgpO1xuXG4gIFx0XHRcdFx0Ly8gaWYgdGhpcyAqaXNuJ3QqIHRoZSBjbG9zaW5nIHRhZyBmb3IgdGhlIGN1cnJlbnQgZWxlbWVudC4uLlxuICBcdFx0XHRcdGlmIChjbG9zaW5nVGFnTmFtZSAhPT0gbG93ZXJDYXNlTmFtZSkge1xuICBcdFx0XHRcdFx0Ly8gcmV3aW5kIHBhcnNlclxuICBcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcblxuICBcdFx0XHRcdFx0Ly8gaWYgaXQgZG9lc24ndCBjbG9zZSBhIHBhcmVudCB0YWcsIGVycm9yXG4gIFx0XHRcdFx0XHRpZiAoISB+cGFyc2VyLmVsZW1lbnRTdGFjay5pbmRleE9mKGNsb3NpbmdUYWdOYW1lKSkge1xuICBcdFx0XHRcdFx0XHR2YXIgZXJyb3JNZXNzYWdlID0gXCJVbmV4cGVjdGVkIGNsb3NpbmcgdGFnXCI7XG5cbiAgXHRcdFx0XHRcdFx0Ly8gYWRkIGFkZGl0aW9uYWwgaGVscCBmb3Igdm9pZCBlbGVtZW50cywgc2luY2UgY29tcG9uZW50IG5hbWVzXG4gIFx0XHRcdFx0XHRcdC8vIG1pZ2h0IGNsYXNoIHdpdGggdGhlbVxuICBcdFx0XHRcdFx0XHRpZiAodm9pZEVsZW1lbnROYW1lcy50ZXN0KGNsb3NpbmdUYWdOYW1lKSkge1xuICBcdFx0XHRcdFx0XHRcdGVycm9yTWVzc2FnZSArPSBcIiAoPFwiICsgY2xvc2luZ1RhZ05hbWUgKyBcIj4gaXMgYSB2b2lkIGVsZW1lbnQgLSBpdCBjYW5ub3QgY29udGFpbiBjaGlsZHJlbilcIjtcbiAgXHRcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvcihlcnJvck1lc3NhZ2UpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGltcGxpY2l0IGNsb3NlIGJ5IGNsb3Npbmcgc2VjdGlvbiB0YWcuIFRPRE8gY2xlYW4gdGhpcyB1cFxuICBcdFx0XHRlbHNlIGlmIChjaGlsZCA9IHNlY3Rpb25fcmVhZENsb3NpbmcocGFyc2VyLCB7IG9wZW46IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0sIGNsb3NlOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzFdIH0pKSB7XG4gIFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gcG9zO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGlmIChjaGlsZCA9IHBhcnNlci5yZWFkKFBBUlRJQUxfUkVBREVSUykpIHtcbiAgXHRcdFx0XHRcdGlmIChwYXJ0aWFsc1tjaGlsZC5uXSkge1xuICBcdFx0XHRcdFx0XHRwYXJzZXIucG9zID0gcG9zO1xuICBcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJEdXBsaWNhdGUgcGFydGlhbCBkZWZpbml0aW9uXCIpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHR1dGlsc19jbGVhbnVwKGNoaWxkLmYsIHBhcnNlci5zdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsICFwcmVzZXJ2ZVdoaXRlc3BhY2UsICFwcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuXG4gIFx0XHRcdFx0XHRwYXJ0aWFsc1tjaGlsZC5uXSA9IGNoaWxkLmY7XG4gIFx0XHRcdFx0XHRoYXNQYXJ0aWFscyA9IHRydWU7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGlmIChjaGlsZCA9IHBhcnNlci5yZWFkKFJFQURFUlMpKSB7XG4gIFx0XHRcdFx0XHRcdGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICBcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gIFx0XHRcdGVsZW1lbnQuZiA9IGNoaWxkcmVuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaGFzUGFydGlhbHMpIHtcbiAgXHRcdFx0ZWxlbWVudC5wID0gcGFydGlhbHM7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5lbGVtZW50U3RhY2sucG9wKCk7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluc2lkZSA9IG51bGw7XG5cbiAgXHRpZiAocGFyc2VyLnNhbml0aXplRWxlbWVudHMgJiYgcGFyc2VyLnNhbml0aXplRWxlbWVudHMuaW5kZXhPZihsb3dlckNhc2VOYW1lKSAhPT0gLTEpIHtcbiAgXHRcdHJldHVybiBleGNsdWRlO1xuICBcdH1cblxuICBcdHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuQ29udGFpbihuYW1lLCByZW1haW5pbmcpIHtcbiAgXHR2YXIgbWF0Y2gsIGRpc2FsbG93ZWQ7XG5cbiAgXHRtYXRjaCA9IC9ePChbYS16QS1aXVthLXpBLVowLTldKikvLmV4ZWMocmVtYWluaW5nKTtcbiAgXHRkaXNhbGxvd2VkID0gZGlzYWxsb3dlZENvbnRlbnRzW25hbWVdO1xuXG4gIFx0aWYgKCFtYXRjaCB8fCAhZGlzYWxsb3dlZCkge1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuICEgfmRpc2FsbG93ZWQuaW5kZXhPZihtYXRjaFsxXS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRUZXh0ID0gcmVhZFRleHQ7XG4gIGZ1bmN0aW9uIHJlYWRUZXh0KHBhcnNlcikge1xuICBcdHZhciBpbmRleCwgcmVtYWluaW5nLCBkaXNhbGxvd2VkLCBiYXJyaWVyO1xuXG4gIFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0YmFycmllciA9IHBhcnNlci5pbnNpZGUgPyBcIjwvXCIgKyBwYXJzZXIuaW5zaWRlIDogXCI8XCI7XG5cbiAgXHRpZiAocGFyc2VyLmluc2lkZSAmJiAhcGFyc2VyLmludGVycG9sYXRlW3BhcnNlci5pbnNpZGVdKSB7XG4gIFx0XHRpbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKGJhcnJpZXIpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRkaXNhbGxvd2VkID0gcGFyc2VyLnRhZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHJldHVybiB0Lm9wZW47XG4gIFx0XHR9KTtcbiAgXHRcdGRpc2FsbG93ZWQgPSBkaXNhbGxvd2VkLmNvbmNhdChwYXJzZXIudGFncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0cmV0dXJuIFwiXFxcXFwiICsgdC5vcGVuO1xuICBcdFx0fSkpO1xuXG4gIFx0XHQvLyBodHRwOi8vZGV2ZWxvcGVycy53aGF0d2cub3JnL3N5bnRheC5odG1sI3N5bnRheC1hdHRyaWJ1dGVzXG4gIFx0XHRpZiAocGFyc2VyLmluQXR0cmlidXRlID09PSB0cnVlKSB7XG4gIFx0XHRcdC8vIHdlJ3JlIGluc2lkZSBhbiB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVcbiAgXHRcdFx0ZGlzYWxsb3dlZC5wdXNoKFwiXFxcIlwiLCBcIidcIiwgXCI9XCIsIFwiPFwiLCBcIj5cIiwgXCJgXCIpO1xuICBcdFx0fSBlbHNlIGlmIChwYXJzZXIuaW5BdHRyaWJ1dGUpIHtcbiAgXHRcdFx0Ly8gcXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZVxuICBcdFx0XHRkaXNhbGxvd2VkLnB1c2gocGFyc2VyLmluQXR0cmlidXRlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRpc2FsbG93ZWQucHVzaChiYXJyaWVyKTtcbiAgXHRcdH1cblxuICBcdFx0aW5kZXggPSBnZXRMb3dlc3RJbmRleChyZW1haW5pbmcsIGRpc2FsbG93ZWQpO1xuICBcdH1cblxuICBcdGlmICghaW5kZXgpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdGluZGV4ID0gcmVtYWluaW5nLmxlbmd0aDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zICs9IGluZGV4O1xuXG4gIFx0cmV0dXJuIHBhcnNlci5pbnNpZGUgPyByZW1haW5pbmcuc3Vic3RyKDAsIGluZGV4KSA6IGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMocmVtYWluaW5nLnN1YnN0cigwLCBpbmRleCkpO1xuICB9XG5cbiAgdmFyIHV0aWxzX2VzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgdmFyIHV0aWxzX2VzY2FwZVJlZ0V4cF9fcGF0dGVybiA9IC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nO1xuICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKHV0aWxzX2VzY2FwZVJlZ0V4cF9fcGF0dGVybiwgXCJcXFxcJCZcIik7XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkUGFydGlhbERlZmluaXRpb25Db21tZW50ID0gcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudDtcblxuICB2YXIgc3RhcnRQYXR0ZXJuID0gL148IS0tXFxzKi8sXG4gICAgICBuYW1lUGF0dGVybiA9IC9zKj5cXHMqKFthLXpBLVpfJF1bLWEtekEtWl8kMC05XSopXFxzKi8sXG4gICAgICBmaW5pc2hQYXR0ZXJuID0gL1xccyotLT4vLFxuICAgICAgY2hpbGQ7XG5cbiAgZnVuY3Rpb24gcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudChwYXJzZXIpIHtcbiAgXHR2YXIgZmlyc3RQb3MgPSBwYXJzZXIucG9zLFxuICBcdCAgICBvcGVuID0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1swXSxcbiAgXHQgICAgY2xvc2UgPSBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzFdLFxuICBcdCAgICBjb250ZW50ID0gdW5kZWZpbmVkLFxuICBcdCAgICBjbG9zZWQgPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4oc3RhcnRQYXR0ZXJuKSB8fCAhcGFyc2VyLm1hdGNoU3RyaW5nKG9wZW4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gZmlyc3RQb3M7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHR2YXIgbmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4obmFtZVBhdHRlcm4pO1xuXG4gIFx0d2Fybk9uY2VJZkRlYnVnKFwiSW5saW5lIHBhcnRpYWwgY29tbWVudHMgYXJlIGRlcHJlY2F0ZWQuXFxuVXNlIHRoaXMuLi5cXG4gIHt7I3BhcnRpYWwgXCIgKyBuYW1lICsgXCJ9fSAuLi4ge3svcGFydGlhbH19XFxuXFxuLi4uaW5zdGVhZCBvZiB0aGlzOlxcbiAgPCEtLSB7ez5cIiArIG5hbWUgKyBcIn19IC0tPiAuLi4gPCEtLSB7ey9cIiArIG5hbWUgKyBcIn19IC0tPidcIik7XG5cbiAgXHQvLyBtYWtlIHN1cmUgdGhlIHJlc3Qgb2YgdGhlIGNvbW1lbnQgaXMgaW4gdGhlIGNvcnJlY3QgcGxhY2VcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhjbG9zZSkgfHwgIXBhcnNlci5tYXRjaFBhdHRlcm4oZmluaXNoUGF0dGVybikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBmaXJzdFBvcztcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGNvbnRlbnQgPSBbXTtcblxuICBcdHZhciBlbmRQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl48IS0tXFxcXHMqXCIgKyB1dGlsc19lc2NhcGVSZWdFeHAob3BlbikgKyBcIlxcXFxzKlxcXFwvXFxcXHMqXCIgKyBuYW1lICsgXCJcXFxccypcIiArIHV0aWxzX2VzY2FwZVJlZ0V4cChjbG9zZSkgKyBcIlxcXFxzKi0tPlwiKTtcblxuICBcdGRvIHtcbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hQYXR0ZXJuKGVuZFBhdHRlcm4pKSB7XG4gIFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjaGlsZCA9IHBhcnNlci5yZWFkKFJFQURFUlMpO1xuICBcdFx0XHRpZiAoIWNoaWxkKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiZXhwZWN0ZWQgY2xvc2luZyBjb21tZW50ICgnPCEtLSBcIiArIG9wZW4gKyBcIi9cIiArIG5hbWUgKyBcIlwiICsgY2xvc2UgKyBcIiAtLT4nKVwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnRlbnQucHVzaChjaGlsZCk7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoIWNsb3NlZCk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogSU5MSU5FX1BBUlRJQUwsXG4gIFx0XHRmOiBjb250ZW50LFxuICBcdFx0bjogbmFtZVxuICBcdH07XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkUGFydGlhbERlZmluaXRpb25TZWN0aW9uID0gcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbjtcbiAgdmFyIHBhcnRpYWxEZWZpbml0aW9uU2VjdGlvblBhdHRlcm4gPSAvXiNcXHMqcGFydGlhbFxccysvO1xuICBmdW5jdGlvbiByZWFkUGFydGlhbERlZmluaXRpb25TZWN0aW9uKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgbmFtZSwgY29udGVudCwgY2hpbGQsIGNsb3NlZDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHZhciBkZWxpbWl0ZXJzID0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVycztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKGRlbGltaXRlcnNbMF0pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4ocGFydGlhbERlZmluaXRpb25TZWN0aW9uUGF0dGVybikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOVxcLV0qLyk7XG5cbiAgXHRpZiAoIW5hbWUpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcImV4cGVjdGVkIGxlZ2FsIHBhcnRpYWwgbmFtZVwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhkZWxpbWl0ZXJzWzFdKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgZGVsaW1pdGVyc1sxXSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRjb250ZW50ID0gW107XG5cbiAgXHRkbyB7XG4gIFx0XHQvLyBUT0RPIGNsZWFuIHRoaXMgdXBcbiAgXHRcdGlmIChjaGlsZCA9IHNlY3Rpb25fcmVhZENsb3NpbmcocGFyc2VyLCB7IG9wZW46IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0sIGNsb3NlOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzFdIH0pKSB7XG4gIFx0XHRcdGlmICghY2hpbGQuciA9PT0gXCJwYXJ0aWFsXCIpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBcIiArIGRlbGltaXRlcnNbMF0gKyBcIi9wYXJ0aWFsXCIgKyBkZWxpbWl0ZXJzWzFdKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjaGlsZCA9IHBhcnNlci5yZWFkKFJFQURFUlMpO1xuXG4gIFx0XHRcdGlmICghY2hpbGQpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBcIiArIGRlbGltaXRlcnNbMF0gKyBcIi9wYXJ0aWFsXCIgKyBkZWxpbWl0ZXJzWzFdKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnRlbnQucHVzaChjaGlsZCk7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoIWNsb3NlZCk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogSU5MSU5FX1BBUlRJQUwsXG4gIFx0XHRuOiBuYW1lLFxuICBcdFx0ZjogY29udGVudFxuICBcdH07XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkVGVtcGxhdGUgPSByZWFkVGVtcGxhdGU7XG4gIGZ1bmN0aW9uIHJlYWRUZW1wbGF0ZShwYXJzZXIpIHtcbiAgXHR2YXIgZnJhZ21lbnQgPSBbXTtcbiAgXHR2YXIgcGFydGlhbHMgPSBjcmVhdGUobnVsbCk7XG4gIFx0dmFyIGhhc1BhcnRpYWxzID0gZmFsc2U7XG5cbiAgXHR2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gcGFyc2VyLnByZXNlcnZlV2hpdGVzcGFjZTtcblxuICBcdHdoaWxlIChwYXJzZXIucG9zIDwgcGFyc2VyLnN0ci5sZW5ndGgpIHtcbiAgXHRcdHZhciBwb3MgPSBwYXJzZXIucG9zLFxuICBcdFx0ICAgIGl0ZW0gPSB1bmRlZmluZWQsXG4gIFx0XHQgICAgcGFydGlhbCA9IHVuZGVmaW5lZDtcblxuICBcdFx0aWYgKHBhcnRpYWwgPSBwYXJzZXIucmVhZChQQVJUSUFMX1JFQURFUlMpKSB7XG4gIFx0XHRcdGlmIChwYXJ0aWFsc1twYXJ0aWFsLm5dKSB7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJEdXBsaWNhdGVkIHBhcnRpYWwgZGVmaW5pdGlvblwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHV0aWxzX2NsZWFudXAocGFydGlhbC5mLCBwYXJzZXIuc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlKTtcblxuICBcdFx0XHRwYXJ0aWFsc1twYXJ0aWFsLm5dID0gcGFydGlhbC5mO1xuICBcdFx0XHRoYXNQYXJ0aWFscyA9IHRydWU7XG4gIFx0XHR9IGVsc2UgaWYgKGl0ZW0gPSBwYXJzZXIucmVhZChSRUFERVJTKSkge1xuICBcdFx0XHRmcmFnbWVudC5wdXNoKGl0ZW0pO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiVW5leHBlY3RlZCB0ZW1wbGF0ZSBjb250ZW50XCIpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHZhciByZXN1bHQgPSB7XG4gIFx0XHR2OiBURU1QTEFURV9WRVJTSU9OLFxuICBcdFx0dDogZnJhZ21lbnRcbiAgXHR9O1xuXG4gIFx0aWYgKGhhc1BhcnRpYWxzKSB7XG4gIFx0XHRyZXN1bHQucCA9IHBhcnRpYWxzO1xuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgX3BhcnNlID0gcGFyc2U7XG5cbiAgdmFyIFNUQU5EQVJEX1JFQURFUlMgPSBbbXVzdGFjaGVfcmVhZFBhcnRpYWwsIG11c3RhY2hlX3JlYWRVbmVzY2FwZWQsIG11c3RhY2hlX3JlYWRTZWN0aW9uLCBtdXN0YWNoZV9yZWFkWWllbGRlciwgbXVzdGFjaGVfcmVhZEludGVycG9sYXRvciwgcmVhZE11c3RhY2hlQ29tbWVudF07XG4gIHZhciBUUklQTEVfUkVBREVSUyA9IFttdXN0YWNoZV9yZWFkVHJpcGxlXTtcbiAgdmFyIFNUQVRJQ19SRUFERVJTID0gW211c3RhY2hlX3JlYWRVbmVzY2FwZWQsIG11c3RhY2hlX3JlYWRTZWN0aW9uLCBtdXN0YWNoZV9yZWFkSW50ZXJwb2xhdG9yXTsgLy8gVE9ETyBkb2VzIGl0IG1ha2Ugc2Vuc2UgdG8gaGF2ZSBhIHN0YXRpYyBzZWN0aW9uP1xuXG4gIHZhciBTdGFuZGFyZFBhcnNlciA9IHVuZGVmaW5lZDtcbiAgZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFN0YW5kYXJkUGFyc2VyKHRlbXBsYXRlLCBvcHRpb25zIHx8IHt9KS5yZXN1bHQ7XG4gIH1cblxuICB2YXIgUkVBREVSUyA9IFtjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZSwgY29udmVydGVyc19yZWFkSHRtbENvbW1lbnQsIGNvbnZlcnRlcnNfcmVhZEVsZW1lbnQsIGNvbnZlcnRlcnNfcmVhZFRleHRdO1xuICB2YXIgUEFSVElBTF9SRUFERVJTID0gW2NvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudCwgY29udmVydGVyc19yZWFkUGFydGlhbERlZmluaXRpb25TZWN0aW9uXTtcblxuICBTdGFuZGFyZFBhcnNlciA9IHBhcnNlX1BhcnNlci5leHRlbmQoe1xuICBcdGluaXQ6IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciB0cmlwbGVEZWxpbWl0ZXJzID0gb3B0aW9ucy50cmlwbGVEZWxpbWl0ZXJzIHx8IFtcInt7e1wiLCBcIn19fVwiXSxcbiAgXHRcdCAgICBzdGF0aWNEZWxpbWl0ZXJzID0gb3B0aW9ucy5zdGF0aWNEZWxpbWl0ZXJzIHx8IFtcIltbXCIsIFwiXV1cIl0sXG4gIFx0XHQgICAgc3RhdGljVHJpcGxlRGVsaW1pdGVycyA9IG9wdGlvbnMuc3RhdGljVHJpcGxlRGVsaW1pdGVycyB8fCBbXCJbW1tcIiwgXCJdXV1cIl07XG5cbiAgXHRcdHRoaXMuc3RhbmRhcmREZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzIHx8IFtcInt7XCIsIFwifX1cIl07XG5cbiAgXHRcdHRoaXMudGFncyA9IFt7IGlzU3RhdGljOiBmYWxzZSwgaXNUcmlwbGU6IGZhbHNlLCBvcGVuOiB0aGlzLnN0YW5kYXJkRGVsaW1pdGVyc1swXSwgY2xvc2U6IHRoaXMuc3RhbmRhcmREZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBTVEFOREFSRF9SRUFERVJTIH0sIHsgaXNTdGF0aWM6IGZhbHNlLCBpc1RyaXBsZTogdHJ1ZSwgb3BlbjogdHJpcGxlRGVsaW1pdGVyc1swXSwgY2xvc2U6IHRyaXBsZURlbGltaXRlcnNbMV0sIHJlYWRlcnM6IFRSSVBMRV9SRUFERVJTIH0sIHsgaXNTdGF0aWM6IHRydWUsIGlzVHJpcGxlOiBmYWxzZSwgb3Blbjogc3RhdGljRGVsaW1pdGVyc1swXSwgY2xvc2U6IHN0YXRpY0RlbGltaXRlcnNbMV0sIHJlYWRlcnM6IFNUQVRJQ19SRUFERVJTIH0sIHsgaXNTdGF0aWM6IHRydWUsIGlzVHJpcGxlOiB0cnVlLCBvcGVuOiBzdGF0aWNUcmlwbGVEZWxpbWl0ZXJzWzBdLCBjbG9zZTogc3RhdGljVHJpcGxlRGVsaW1pdGVyc1sxXSwgcmVhZGVyczogVFJJUExFX1JFQURFUlMgfV07XG5cbiAgXHRcdHRoaXMuc29ydE11c3RhY2hlVGFncygpO1xuXG4gIFx0XHR0aGlzLnNlY3Rpb25EZXB0aCA9IDA7XG4gIFx0XHR0aGlzLmVsZW1lbnRTdGFjayA9IFtdO1xuXG4gIFx0XHR0aGlzLmludGVycG9sYXRlID0ge1xuICBcdFx0XHRzY3JpcHQ6ICFvcHRpb25zLmludGVycG9sYXRlIHx8IG9wdGlvbnMuaW50ZXJwb2xhdGUuc2NyaXB0ICE9PSBmYWxzZSxcbiAgXHRcdFx0c3R5bGU6ICFvcHRpb25zLmludGVycG9sYXRlIHx8IG9wdGlvbnMuaW50ZXJwb2xhdGUuc3R5bGUgIT09IGZhbHNlXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAob3B0aW9ucy5zYW5pdGl6ZSA9PT0gdHJ1ZSkge1xuICBcdFx0XHRvcHRpb25zLnNhbml0aXplID0ge1xuICBcdFx0XHRcdC8vIGJsYWNrbGlzdCBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWNhamEvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9jYWphL2xhbmcvaHRtbC9odG1sNC1lbGVtZW50cy13aGl0ZWxpc3QuanNvblxuICBcdFx0XHRcdGVsZW1lbnRzOiBcImFwcGxldCBiYXNlIGJhc2Vmb250IGJvZHkgZnJhbWUgZnJhbWVzZXQgaGVhZCBodG1sIGlzaW5kZXggbGluayBtZXRhIG5vZnJhbWVzIG5vc2NyaXB0IG9iamVjdCBwYXJhbSBzY3JpcHQgc3R5bGUgdGl0bGVcIi5zcGxpdChcIiBcIiksXG4gIFx0XHRcdFx0ZXZlbnRBdHRyaWJ1dGVzOiB0cnVlXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuc3RyaXBDb21tZW50cyA9IG9wdGlvbnMuc3RyaXBDb21tZW50cyAhPT0gZmFsc2U7XG4gIFx0XHR0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlO1xuICBcdFx0dGhpcy5zYW5pdGl6ZUVsZW1lbnRzID0gb3B0aW9ucy5zYW5pdGl6ZSAmJiBvcHRpb25zLnNhbml0aXplLmVsZW1lbnRzO1xuICBcdFx0dGhpcy5zYW5pdGl6ZUV2ZW50QXR0cmlidXRlcyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5ldmVudEF0dHJpYnV0ZXM7XG4gIFx0XHR0aGlzLmluY2x1ZGVMaW5lUG9zaXRpb25zID0gb3B0aW9ucy5pbmNsdWRlTGluZVBvc2l0aW9ucztcbiAgXHR9LFxuXG4gIFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGVtcHR5IHN0cmluZ1xuICBcdFx0aWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gIFx0XHRcdHJldHVybiB7IHQ6IFtdLCB2OiBURU1QTEFURV9WRVJTSU9OIH07XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnNlY3Rpb25EZXB0aCA+IDApIHtcbiAgXHRcdFx0dGhpcy5lcnJvcihcIkEgc2VjdGlvbiB3YXMgbGVmdCBvcGVuXCIpO1xuICBcdFx0fVxuXG4gIFx0XHR1dGlsc19jbGVhbnVwKHJlc3VsdFswXS50LCB0aGlzLnN0cmlwQ29tbWVudHMsIHRoaXMucHJlc2VydmVXaGl0ZXNwYWNlLCAhdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UsICF0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSk7XG5cbiAgXHRcdHJldHVybiByZXN1bHRbMF07XG4gIFx0fSxcblxuICBcdGNvbnZlcnRlcnM6IFtjb252ZXJ0ZXJzX3JlYWRUZW1wbGF0ZV0sXG5cbiAgXHRzb3J0TXVzdGFjaGVUYWdzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBTb3J0IGluIG9yZGVyIG9mIGRlc2NlbmRpbmcgb3BlbmluZyBkZWxpbWl0ZXIgbGVuZ3RoIChsb25nZXIgZmlyc3QpLFxuICBcdFx0Ly8gdG8gcHJvdGVjdCBhZ2FpbnN0IG9wZW5pbmcgZGVsaW1pdGVycyBiZWluZyBzdWJzdHJpbmdzIG9mIGVhY2ggb3RoZXJcbiAgXHRcdHRoaXMudGFncy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gIFx0XHRcdHJldHVybiBiLm9wZW4ubGVuZ3RoIC0gYS5vcGVuLmxlbmd0aDtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIHBhcnNlT3B0aW9ucyA9IFtcInByZXNlcnZlV2hpdGVzcGFjZVwiLCBcInNhbml0aXplXCIsIFwic3RyaXBDb21tZW50c1wiLCBcImRlbGltaXRlcnNcIiwgXCJ0cmlwbGVEZWxpbWl0ZXJzXCIsIFwiaW50ZXJwb2xhdGVcIl07XG5cbiAgdmFyIHBhcnNlciA9IHtcbiAgXHRmcm9tSWQ6IGZyb21JZCwgaXNIYXNoZWRJZDogaXNIYXNoZWRJZCwgaXNQYXJzZWQ6IGlzUGFyc2VkLCBnZXRQYXJzZU9wdGlvbnM6IGdldFBhcnNlT3B0aW9ucywgY3JlYXRlSGVscGVyOiB0ZW1wbGF0ZV9wYXJzZXJfX2NyZWF0ZUhlbHBlcixcbiAgXHRwYXJzZTogZG9QYXJzZVxuICB9O1xuXG4gIGZ1bmN0aW9uIHRlbXBsYXRlX3BhcnNlcl9fY3JlYXRlSGVscGVyKHBhcnNlT3B0aW9ucykge1xuICBcdHZhciBoZWxwZXIgPSBjcmVhdGUocGFyc2VyKTtcbiAgXHRoZWxwZXIucGFyc2UgPSBmdW5jdGlvbiAodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiBkb1BhcnNlKHRlbXBsYXRlLCBvcHRpb25zIHx8IHBhcnNlT3B0aW9ucyk7XG4gIFx0fTtcbiAgXHRyZXR1cm4gaGVscGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9QYXJzZSh0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zKSB7XG4gIFx0aWYgKCFfcGFyc2UpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgUmFjdGl2ZS5wYXJzZSAtIGNhbm5vdCBwYXJzZSB0ZW1wbGF0ZS4gRWl0aGVyIHByZXBhcnNlIG9yIHVzZSB0aGUgdmVyc2lvbiB0aGF0IGluY2x1ZGVzIHRoZSBwYXJzZXJcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIF9wYXJzZSh0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zIHx8IHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tSWQoaWQsIG9wdGlvbnMpIHtcbiAgXHR2YXIgdGVtcGxhdGU7XG5cbiAgXHRpZiAoIWlzQ2xpZW50KSB7XG4gIFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJldHJpZXZlIHRlbXBsYXRlICNcIiArIGlkICsgXCIgYXMgUmFjdGl2ZSBpcyBub3QgcnVubmluZyBpbiBhIGJyb3dzZXIuXCIpO1xuICBcdH1cblxuICBcdGlmIChpc0hhc2hlZElkKGlkKSkge1xuICBcdFx0aWQgPSBpZC5zdWJzdHJpbmcoMSk7XG4gIFx0fVxuXG4gIFx0aWYgKCEodGVtcGxhdGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpKSB7XG4gIFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICNcIiArIGlkKTtcbiAgXHR9XG5cbiAgXHRpZiAodGVtcGxhdGUudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSBcIlNDUklQVFwiKSB7XG4gIFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICNcIiArIGlkICsgXCIsIG11c3QgYmUgYSA8c2NyaXB0PiBlbGVtZW50XCIpO1xuICBcdH1cblxuICBcdHJldHVybiBcInRleHRDb250ZW50XCIgaW4gdGVtcGxhdGUgPyB0ZW1wbGF0ZS50ZXh0Q29udGVudCA6IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSGFzaGVkSWQoaWQpIHtcbiAgXHRyZXR1cm4gaWQgJiYgaWRbMF0gPT09IFwiI1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXJzZWQodGVtcGxhdGUpIHtcbiAgXHRyZXR1cm4gISh0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpIHtcbiAgXHQvLyBDb3VsZCBiZSBSYWN0aXZlIG9yIGEgQ29tcG9uZW50XG4gIFx0aWYgKHJhY3RpdmUuZGVmYXVsdHMpIHtcbiAgXHRcdHJhY3RpdmUgPSByYWN0aXZlLmRlZmF1bHRzO1xuICBcdH1cblxuICBcdHJldHVybiBwYXJzZU9wdGlvbnMucmVkdWNlKGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICBcdFx0dmFsW2tleV0gPSByYWN0aXZlW2tleV07XG4gIFx0XHRyZXR1cm4gdmFsO1xuICBcdH0sIHt9KTtcbiAgfVxuXG4gIHZhciB0ZW1wbGF0ZV9wYXJzZXIgPSBwYXJzZXI7XG5cbiAgdmFyIHRlbXBsYXRlQ29uZmlndXJhdG9yID0ge1xuICBcdG5hbWU6IFwidGVtcGxhdGVcIixcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHZhciB0ZW1wbGF0ZTtcblxuICBcdFx0Ly8gb25seSBhc3NpZ24gaWYgZXhpc3RzXG4gIFx0XHRpZiAoXCJ0ZW1wbGF0ZVwiIGluIG9wdGlvbnMpIHtcbiAgXHRcdFx0dGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXG4gIFx0XHRcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cHJvdG8udGVtcGxhdGUgPSBwYXJzZUlmU3RyaW5nKHRlbXBsYXRlLCBwcm90byk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gaW5pdChQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciB0ZW1wbGF0ZSwgZm47XG5cbiAgXHRcdC8vIFRPRE8gYmVjYXVzZSBvZiBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB3ZSBtaWdodCBqdXN0IGJlIGFibGUgdG8gdXNlXG4gIFx0XHQvLyByYWN0aXZlLnRlbXBsYXRlLCBhbmQgbm90IGJvdGhlciBwYXNzaW5nIHRocm91Z2ggdGhlIFBhcmVudCBvYmplY3QuXG4gIFx0XHQvLyBBdCBwcmVzZW50IHRoYXQgYnJlYWtzIHRoZSB0ZXN0IG1vY2tzJyBleHBlY3RhdGlvbnNcbiAgXHRcdHRlbXBsYXRlID0gXCJ0ZW1wbGF0ZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnRlbXBsYXRlIDogUGFyZW50LnByb3RvdHlwZS50ZW1wbGF0ZTtcblxuICBcdFx0aWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdGZuID0gdGVtcGxhdGU7XG4gIFx0XHRcdHRlbXBsYXRlID0gZ2V0RHluYW1pY1RlbXBsYXRlKHJhY3RpdmUsIGZuKTtcblxuICBcdFx0XHRyYWN0aXZlLl9jb25maWcudGVtcGxhdGUgPSB7XG4gIFx0XHRcdFx0Zm46IGZuLFxuICBcdFx0XHRcdHJlc3VsdDogdGVtcGxhdGVcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0dGVtcGxhdGUgPSBwYXJzZUlmU3RyaW5nKHRlbXBsYXRlLCByYWN0aXZlKTtcblxuICBcdFx0Ly8gVE9ETyB0aGUgbmFtaW5nIG9mIHRoaXMgaXMgY29uZnVzaW5nIC0gcmFjdGl2ZS50ZW1wbGF0ZSByZWZlcnMgdG8gWy4uLl0sXG4gIFx0XHQvLyBidXQgQ29tcG9uZW50LnByb3RvdHlwZS50ZW1wbGF0ZSByZWZlcnMgdG8ge3Y6MSx0OltdLHA6W119Li4uXG4gIFx0XHQvLyBpdCdzIHVubmVjZXNzYXJ5LCBiZWNhdXNlIHRoZSBkZXZlbG9wZXIgbmV2ZXIgbmVlZHMgdG8gYWNjZXNzXG4gIFx0XHQvLyByYWN0aXZlLnRlbXBsYXRlXG4gIFx0XHRyYWN0aXZlLnRlbXBsYXRlID0gdGVtcGxhdGUudDtcblxuICBcdFx0aWYgKHRlbXBsYXRlLnApIHtcbiAgXHRcdFx0ZXh0ZW5kUGFydGlhbHMocmFjdGl2ZS5wYXJ0aWFscywgdGVtcGxhdGUucCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlc2V0OiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0dmFyIHJlc3VsdCA9IHJlc2V0VmFsdWUocmFjdGl2ZSksXG4gIFx0XHQgICAgcGFyc2VkO1xuXG4gIFx0XHRpZiAocmVzdWx0KSB7XG4gIFx0XHRcdHBhcnNlZCA9IHBhcnNlSWZTdHJpbmcocmVzdWx0LCByYWN0aXZlKTtcblxuICBcdFx0XHRyYWN0aXZlLnRlbXBsYXRlID0gcGFyc2VkLnQ7XG4gIFx0XHRcdGV4dGVuZFBhcnRpYWxzKHJhY3RpdmUucGFydGlhbHMsIHBhcnNlZC5wLCB0cnVlKTtcblxuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVzZXRWYWx1ZShyYWN0aXZlKSB7XG4gIFx0dmFyIGluaXRpYWwgPSByYWN0aXZlLl9jb25maWcudGVtcGxhdGUsXG4gIFx0ICAgIHJlc3VsdDtcblxuICBcdC8vIElmIHRoaXMgaXNuJ3QgYSBkeW5hbWljIHRlbXBsYXRlLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cbiAgXHRpZiAoIWluaXRpYWwgfHwgIWluaXRpYWwuZm4pIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRyZXN1bHQgPSBnZXREeW5hbWljVGVtcGxhdGUocmFjdGl2ZSwgaW5pdGlhbC5mbik7XG5cbiAgXHQvLyBUT0RPIGRlZXAgZXF1YWxpdHkgY2hlY2sgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJpbmdcbiAgXHQvLyBpbiB0aGUgY2FzZSBvZiBhbHJlYWR5LXBhcnNlZCB0ZW1wbGF0ZXNcbiAgXHRpZiAocmVzdWx0ICE9PSBpbml0aWFsLnJlc3VsdCkge1xuICBcdFx0aW5pdGlhbC5yZXN1bHQgPSByZXN1bHQ7XG4gIFx0XHRyZXN1bHQgPSBwYXJzZUlmU3RyaW5nKHJlc3VsdCwgcmFjdGl2ZSk7XG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldER5bmFtaWNUZW1wbGF0ZShyYWN0aXZlLCBmbikge1xuICBcdHZhciBoZWxwZXIgPSB0ZW1wbGF0ZV90ZW1wbGF0ZV9fY3JlYXRlSGVscGVyKHRlbXBsYXRlX3BhcnNlci5nZXRQYXJzZU9wdGlvbnMocmFjdGl2ZSkpO1xuICBcdHJldHVybiBmbi5jYWxsKHJhY3RpdmUsIGhlbHBlcik7XG4gIH1cblxuICBmdW5jdGlvbiB0ZW1wbGF0ZV90ZW1wbGF0ZV9fY3JlYXRlSGVscGVyKHBhcnNlT3B0aW9ucykge1xuICBcdHZhciBoZWxwZXIgPSBjcmVhdGUodGVtcGxhdGVfcGFyc2VyKTtcbiAgXHRoZWxwZXIucGFyc2UgPSBmdW5jdGlvbiAodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiB0ZW1wbGF0ZV9wYXJzZXIucGFyc2UodGVtcGxhdGUsIG9wdGlvbnMgfHwgcGFyc2VPcHRpb25zKTtcbiAgXHR9O1xuICBcdHJldHVybiBoZWxwZXI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUlmU3RyaW5nKHRlbXBsYXRlLCByYWN0aXZlKSB7XG4gIFx0aWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0Ly8gSUQgb2YgYW4gZWxlbWVudCBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZT9cbiAgXHRcdGlmICh0ZW1wbGF0ZVswXSA9PT0gXCIjXCIpIHtcbiAgXHRcdFx0dGVtcGxhdGUgPSB0ZW1wbGF0ZV9wYXJzZXIuZnJvbUlkKHRlbXBsYXRlKTtcbiAgXHRcdH1cblxuICBcdFx0dGVtcGxhdGUgPSBfcGFyc2UodGVtcGxhdGUsIHRlbXBsYXRlX3BhcnNlci5nZXRQYXJzZU9wdGlvbnMocmFjdGl2ZSkpO1xuICBcdH1cblxuICBcdC8vIENoZWNrIHRoYXQgdGhlIHRlbXBsYXRlIGV2ZW4gZXhpc3RzXG4gIFx0ZWxzZSBpZiAodGVtcGxhdGUgPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGVtcGxhdGUgY2Fubm90IGJlIFwiICsgdGVtcGxhdGUgKyBcIi5cIik7XG4gIFx0fVxuXG4gIFx0Ly8gQ2hlY2sgdGhlIHBhcnNlZCB0ZW1wbGF0ZSBoYXMgYSB2ZXJzaW9uIGF0IGFsbFxuICBcdGVsc2UgaWYgKHR5cGVvZiB0ZW1wbGF0ZS52ICE9PSBcIm51bWJlclwiKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGVtcGxhdGUgcGFyc2VyIHdhcyBwYXNzZWQgYSBub24tc3RyaW5nIHRlbXBsYXRlLCBidXQgdGhlIHRlbXBsYXRlIGRvZXNuJ3QgaGF2ZSBhIHZlcnNpb24uICBNYWtlIHN1cmUgeW91J3JlIHBhc3NpbmcgaW4gdGhlIHRlbXBsYXRlIHlvdSB0aGluayB5b3UgYXJlLlwiKTtcbiAgXHR9XG5cbiAgXHQvLyBDaGVjayB3ZSdyZSB1c2luZyB0aGUgY29ycmVjdCB2ZXJzaW9uXG4gIFx0ZWxzZSBpZiAodGVtcGxhdGUudiAhPT0gVEVNUExBVEVfVkVSU0lPTikge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCB0ZW1wbGF0ZSB2ZXJzaW9uIChleHBlY3RlZCBcIiArIFRFTVBMQVRFX1ZFUlNJT04gKyBcIiwgZ290IFwiICsgdGVtcGxhdGUudiArIFwiKSBQbGVhc2UgZW5zdXJlIHlvdSBhcmUgdXNpbmcgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIFJhY3RpdmUuanMgaW4geW91ciBidWlsZCBwcm9jZXNzIGFzIHdlbGwgYXMgaW4geW91ciBhcHBcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kUGFydGlhbHMoZXhpc3RpbmdQYXJ0aWFscywgbmV3UGFydGlhbHMsIG92ZXJ3cml0ZSkge1xuICBcdGlmICghbmV3UGFydGlhbHMpIHJldHVybjtcblxuICBcdC8vIFRPRE8gdGhlcmUncyBhbiBhbWJpZ3VpdHkgaGVyZSAtIHdlIG5lZWQgdG8gb3ZlcndyaXRlIGluIHRoZSBgcmVzZXQoKWBcbiAgXHQvLyBjYXNlLCBidXQgbm90IGluaXRpYWxseS4uLlxuXG4gIFx0Zm9yICh2YXIga2V5IGluIG5ld1BhcnRpYWxzKSB7XG4gIFx0XHRpZiAob3ZlcndyaXRlIHx8ICFleGlzdGluZ1BhcnRpYWxzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0ZXhpc3RpbmdQYXJ0aWFsc1trZXldID0gbmV3UGFydGlhbHNba2V5XTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgdGVtcGxhdGVfdGVtcGxhdGUgPSB0ZW1wbGF0ZUNvbmZpZ3VyYXRvcjtcblxuICB2YXIgY29uZmlnX3JlZ2lzdHJpZXNfX3JlZ2lzdHJ5TmFtZXMsIFJlZ2lzdHJ5LCByZWdpc3RyaWVzO1xuXG4gIGNvbmZpZ19yZWdpc3RyaWVzX19yZWdpc3RyeU5hbWVzID0gW1wiYWRhcHRvcnNcIiwgXCJjb21wb25lbnRzXCIsIFwiY29tcHV0ZWRcIiwgXCJkZWNvcmF0b3JzXCIsIFwiZWFzaW5nXCIsIFwiZXZlbnRzXCIsIFwiaW50ZXJwb2xhdG9yc1wiLCBcInBhcnRpYWxzXCIsIFwidHJhbnNpdGlvbnNcIl07XG5cbiAgUmVnaXN0cnkgPSBmdW5jdGlvbiAobmFtZSwgdXNlRGVmYXVsdHMpIHtcbiAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuICBcdHRoaXMudXNlRGVmYXVsdHMgPSB1c2VEZWZhdWx0cztcbiAgfTtcblxuICBSZWdpc3RyeS5wcm90b3R5cGUgPSB7XG4gIFx0Y29uc3RydWN0b3I6IFJlZ2lzdHJ5LFxuXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0dGhpcy5jb25maWd1cmUodGhpcy51c2VEZWZhdWx0cyA/IFBhcmVudC5kZWZhdWx0cyA6IFBhcmVudCwgdGhpcy51c2VEZWZhdWx0cyA/IHByb3RvIDogcHJvdG8uY29uc3RydWN0b3IsIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7fSxcblxuICBcdGNvbmZpZ3VyZTogZnVuY3Rpb24gKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgbmFtZSA9IHRoaXMubmFtZSxcbiAgXHRcdCAgICBvcHRpb24gPSBvcHRpb25zW25hbWVdLFxuICBcdFx0ICAgIHJlZ2lzdHJ5O1xuXG4gIFx0XHRyZWdpc3RyeSA9IGNyZWF0ZShQYXJlbnRbbmFtZV0pO1xuXG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gb3B0aW9uKSB7XG4gIFx0XHRcdHJlZ2lzdHJ5W2tleV0gPSBvcHRpb25ba2V5XTtcbiAgXHRcdH1cblxuICBcdFx0dGFyZ2V0W25hbWVdID0gcmVnaXN0cnk7XG4gIFx0fSxcblxuICBcdHJlc2V0OiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0dmFyIHJlZ2lzdHJ5ID0gcmFjdGl2ZVt0aGlzLm5hbWVdO1xuICBcdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgXHRcdE9iamVjdC5rZXlzKHJlZ2lzdHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdFx0dmFyIGl0ZW0gPSByZWdpc3RyeVtrZXldO1xuICBcdFx0XHRpZiAoaXRlbS5fZm4pIHtcbiAgXHRcdFx0XHRpZiAoaXRlbS5fZm4uaXNPd25lcikge1xuICBcdFx0XHRcdFx0cmVnaXN0cnlba2V5XSA9IGl0ZW0uX2ZuO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRkZWxldGUgcmVnaXN0cnlba2V5XTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdFx0cmV0dXJuIGNoYW5nZWQ7XG4gIFx0fVxuICB9O1xuXG4gIHJlZ2lzdHJpZXMgPSBjb25maWdfcmVnaXN0cmllc19fcmVnaXN0cnlOYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRyZXR1cm4gbmV3IFJlZ2lzdHJ5KG5hbWUsIG5hbWUgPT09IFwiY29tcHV0ZWRcIik7XG4gIH0pO1xuXG4gIHZhciBjb25maWdfcmVnaXN0cmllcyA9IHJlZ2lzdHJpZXM7XG5cbiAgLyp0aGlzLmNvbmZpZ3VyZShcbiAgXHR0aGlzLnVzZURlZmF1bHRzID8gUGFyZW50LmRlZmF1bHRzIDogUGFyZW50LFxuICBcdHJhY3RpdmUsXG4gIFx0b3B0aW9ucyApOyovXG5cbiAgdmFyIHdyYXBQcm90b3R5cGUgPSB3cmFwO1xuXG4gIGZ1bmN0aW9uIHdyYXAocGFyZW50LCBuYW1lLCBtZXRob2QpIHtcbiAgXHRpZiAoIS9fc3VwZXIvLnRlc3QobWV0aG9kKSkge1xuICBcdFx0cmV0dXJuIG1ldGhvZDtcbiAgXHR9XG5cbiAgXHR2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBTdXBlcigpIHtcbiAgXHRcdHZhciBzdXBlck1ldGhvZCA9IGdldFN1cGVyTWV0aG9kKHdyYXBwZXIuX3BhcmVudCwgbmFtZSksXG4gIFx0XHQgICAgaGFzU3VwZXIgPSAoXCJfc3VwZXJcIiBpbiB0aGlzKSxcbiAgXHRcdCAgICBvbGRTdXBlciA9IHRoaXMuX3N1cGVyLFxuICBcdFx0ICAgIHJlc3VsdDtcblxuICBcdFx0dGhpcy5fc3VwZXIgPSBzdXBlck1ldGhvZDtcblxuICBcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgXHRcdGlmIChoYXNTdXBlcikge1xuICBcdFx0XHR0aGlzLl9zdXBlciA9IG9sZFN1cGVyO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX3N1cGVyO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH07XG5cbiAgXHR3cmFwcGVyLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIFx0d3JhcHBlci5fbWV0aG9kID0gbWV0aG9kO1xuXG4gIFx0cmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdXBlck1ldGhvZChwYXJlbnQsIG5hbWUpIHtcbiAgXHR2YXIgdmFsdWUsIG1ldGhvZDtcblxuICBcdGlmIChuYW1lIGluIHBhcmVudCkge1xuICBcdFx0dmFsdWUgPSBwYXJlbnRbbmFtZV07XG5cbiAgXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRtZXRob2QgPSB2YWx1ZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1ldGhvZCA9IGZ1bmN0aW9uIHJldHVyblZhbHVlKCkge1xuICBcdFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0bWV0aG9kID0gbm9vcDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbWV0aG9kO1xuICB9XG5cbiAgdmFyIGNvbmZpZ19kZXByZWNhdGUgPSBkZXByZWNhdGU7XG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoZGVwcmVjYXRlZCwgY29ycmVjdCwgaXNFcnJvcikge1xuICBcdHJldHVybiBcIm9wdGlvbnMuXCIgKyBkZXByZWNhdGVkICsgXCIgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Ygb3B0aW9ucy5cIiArIGNvcnJlY3QgKyBcIi5cIiArIChpc0Vycm9yID8gXCIgWW91IGNhbm5vdCBzcGVjaWZ5IGJvdGggb3B0aW9ucywgcGxlYXNlIHVzZSBvcHRpb25zLlwiICsgY29ycmVjdCArIFwiLlwiIDogXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgZGVwcmVjYXRlZE9wdGlvbiwgY29ycmVjdCkge1xuICBcdGlmIChkZXByZWNhdGVkT3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgXHRcdGlmICghKGNvcnJlY3QgaW4gb3B0aW9ucykpIHtcbiAgXHRcdFx0d2FybklmRGVidWcoZ2V0TWVzc2FnZShkZXByZWNhdGVkT3B0aW9uLCBjb3JyZWN0KSk7XG4gIFx0XHRcdG9wdGlvbnNbY29ycmVjdF0gPSBvcHRpb25zW2RlcHJlY2F0ZWRPcHRpb25dO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKGdldE1lc3NhZ2UoZGVwcmVjYXRlZE9wdGlvbiwgY29ycmVjdCwgdHJ1ZSkpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuICBmdW5jdGlvbiBkZXByZWNhdGUob3B0aW9ucykge1xuICBcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImJlZm9yZUluaXRcIiwgXCJvbmNvbnN0cnVjdFwiKTtcbiAgXHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJpbml0XCIsIFwib25yZW5kZXJcIik7XG4gIFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiY29tcGxldGVcIiwgXCJvbmNvbXBsZXRlXCIpO1xuICBcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImV2ZW50RGVmaW5pdGlvbnNcIiwgXCJldmVudHNcIik7XG5cbiAgXHQvLyBVc2luZyBleHRlbmQgd2l0aCBDb21wb25lbnQgaW5zdGVhZCBvZiBvcHRpb25zLFxuICBcdC8vIGxpa2UgSHVtYW4uZXh0ZW5kKCBTcGlkZXIgKSBtZWFucyBhZGFwdG9ycyBhcyBhIHJlZ2lzdHJ5XG4gIFx0Ly8gZ2V0cyBjb3BpZWQgdG8gb3B0aW9ucy4gU28gd2UgaGF2ZSB0byBjaGVjayBpZiBhY3R1YWxseSBhbiBhcnJheVxuICBcdGlmIChpc0FycmF5KG9wdGlvbnMuYWRhcHRvcnMpKSB7XG4gIFx0XHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJhZGFwdG9yc1wiLCBcImFkYXB0XCIpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBjb25maWcsIG9yZGVyLCBkZWZhdWx0S2V5cywgY3VzdG9tLCBpc0JsYWNrbGlzdGVkLCBpc1N0YW5kYXJkS2V5O1xuXG4gIGN1c3RvbSA9IHtcbiAgXHRhZGFwdDogY3VzdG9tX2FkYXB0LFxuICBcdGNzczogY3NzX2NzcyxcbiAgXHRkYXRhOiBjdXN0b21fZGF0YSxcbiAgXHR0ZW1wbGF0ZTogdGVtcGxhdGVfdGVtcGxhdGVcbiAgfTtcblxuICBkZWZhdWx0S2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZ19kZWZhdWx0cyk7XG5cbiAgaXNTdGFuZGFyZEtleSA9IG1ha2VPYmooZGVmYXVsdEtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRyZXR1cm4gIWN1c3RvbVtrZXldO1xuICB9KSk7XG5cbiAgLy8gYmxhY2tsaXN0ZWQga2V5cyB0aGF0IHdlIGRvbid0IGRvdWJsZSBleHRlbmRcbiAgaXNCbGFja2xpc3RlZCA9IG1ha2VPYmooZGVmYXVsdEtleXMuY29uY2F0KGNvbmZpZ19yZWdpc3RyaWVzLm1hcChmdW5jdGlvbiAocikge1xuICBcdHJldHVybiByLm5hbWU7XG4gIH0pKSk7XG5cbiAgb3JkZXIgPSBbXS5jb25jYXQoZGVmYXVsdEtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRyZXR1cm4gIWNvbmZpZ19yZWdpc3RyaWVzW2tleV0gJiYgIWN1c3RvbVtrZXldO1xuICB9KSwgY29uZmlnX3JlZ2lzdHJpZXMsIGN1c3RvbS5kYXRhLCBjdXN0b20udGVtcGxhdGUsIGN1c3RvbS5jc3MpO1xuXG4gIGNvbmZpZyA9IHtcbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gY29uZmlndXJlKFwiZXh0ZW5kXCIsIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoUGFyZW50LCByYWN0aXZlLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gY29uZmlndXJlKFwiaW5pdFwiLCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHJldHVybiBvcmRlci5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgXHRcdFx0cmV0dXJuIGMucmVzZXQgJiYgYy5yZXNldChyYWN0aXZlKTtcbiAgXHRcdH0pLm1hcChmdW5jdGlvbiAoYykge1xuICBcdFx0XHRyZXR1cm4gYy5uYW1lO1xuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdC8vIHRoaXMgZGVmaW5lcyB0aGUgb3JkZXIuIFRPRE8gdGhpcyBpc24ndCB1c2VkIGFueXdoZXJlIGluIHRoZSBjb2RlYmFzZSxcbiAgXHQvLyBvbmx5IGluIHRoZSB0ZXN0IHN1aXRlIC0gc2hvdWxkIGdldCByaWQgb2YgaXRcbiAgXHRvcmRlcjogb3JkZXIgfTtcblxuICBmdW5jdGlvbiBjb25maWd1cmUobWV0aG9kLCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICBcdGNvbmZpZ19kZXByZWNhdGUob3B0aW9ucyk7XG5cbiAgXHRmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICBcdFx0aWYgKGlzU3RhbmRhcmRLZXkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHR2YXIgdmFsdWUgPSBvcHRpb25zW2tleV07XG5cbiAgXHRcdFx0Ly8gd2FybiB0aGUgZGV2ZWxvcGVyIGlmIHRoZXkgcGFzc2VkIGEgZnVuY3Rpb24gYW5kIGlnbm9yZSBpdHMgdmFsdWVcblxuICBcdFx0XHQvLyBOT1RFOiB3ZSBhbGxvdyBzb21lIGZ1bmN0aW9ucyBvbiBcImVsXCIgYmVjYXVzZSB3ZSBkdWNrIHR5cGUgZWxlbWVudCBsaXN0c1xuICBcdFx0XHQvLyBhbmQgc29tZSBsaWJyYXJpZXMgb3IgZWYnZWQtdXAgdmlydHVhbCBicm93c2VycyAocGhhbnRvbUpTKSByZXR1cm4gYVxuICBcdFx0XHQvLyBmdW5jdGlvbiBvYmplY3QgYXMgdGhlIHJlc3VsdCBvZiBxdWVyeVNlbGVjdG9yIG1ldGhvZHNcbiAgXHRcdFx0aWYgKGtleSAhPT0gXCJlbFwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0d2FybklmRGVidWcoXCJcIiArIGtleSArIFwiIGlzIGEgUmFjdGl2ZSBvcHRpb24gdGhhdCBkb2VzIG5vdCBleHBlY3QgYSBmdW5jdGlvbiBhbmQgd2lsbCBiZSBpZ25vcmVkXCIsIG1ldGhvZCA9PT0gXCJpbml0XCIgPyB0YXJnZXQgOiBudWxsKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR0YXJnZXRba2V5XSA9IHZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Y29uZmlnX3JlZ2lzdHJpZXMuZm9yRWFjaChmdW5jdGlvbiAocmVnaXN0cnkpIHtcbiAgXHRcdHJlZ2lzdHJ5W21ldGhvZF0oUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuICBcdH0pO1xuXG4gIFx0Y3VzdG9tX2FkYXB0W21ldGhvZF0oUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuICBcdHRlbXBsYXRlX3RlbXBsYXRlW21ldGhvZF0oUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuICBcdGNzc19jc3NbbWV0aG9kXShQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgXHRleHRlbmRPdGhlck1ldGhvZHMoUGFyZW50LnByb3RvdHlwZSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZE90aGVyTWV0aG9kcyhwYXJlbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICBcdGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gIFx0XHRpZiAoIWlzQmxhY2tsaXN0ZWRba2V5XSAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0dmFyIG1lbWJlciA9IG9wdGlvbnNba2V5XTtcblxuICBcdFx0XHQvLyBpZiB0aGlzIGlzIGEgbWV0aG9kIHRoYXQgb3ZlcndyaXRlcyBhIG1ldGhvZCwgd3JhcCBpdDpcbiAgXHRcdFx0aWYgKHR5cGVvZiBtZW1iZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdG1lbWJlciA9IHdyYXBQcm90b3R5cGUocGFyZW50LCBrZXksIG1lbWJlcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0YXJnZXRba2V5XSA9IG1lbWJlcjtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlT2JqKGFycmF5KSB7XG4gIFx0dmFyIG9iaiA9IHt9O1xuICBcdGFycmF5LmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgXHRcdHJldHVybiBvYmpbeF0gPSB0cnVlO1xuICBcdH0pO1xuICBcdHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgY29uZmlnX2NvbmZpZyA9IGNvbmZpZztcblxuICB2YXIgcHJvdG90eXBlX2J1YmJsZSA9IEZyYWdtZW50JGJ1YmJsZTtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRidWJibGUoKSB7XG4gIFx0dGhpcy5kaXJ0eVZhbHVlID0gdGhpcy5kaXJ0eUFyZ3MgPSB0cnVlO1xuXG4gIFx0aWYgKHRoaXMuYm91bmQgJiYgdHlwZW9mIHRoaXMub3duZXIuYnViYmxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdHRoaXMub3duZXIuYnViYmxlKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9kZXRhY2ggPSBGcmFnbWVudCRkZXRhY2g7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZGV0YWNoKCkge1xuICBcdHZhciBkb2NGcmFnO1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pdGVtc1swXS5kZXRhY2goKTtcbiAgXHR9XG5cbiAgXHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHR2YXIgbm9kZSA9IGl0ZW0uZGV0YWNoKCk7XG5cbiAgXHRcdC8vIFRPRE8gVGhlIGlmIHsuLi59IHdhc24ndCBwcmV2aW91c2x5IHJlcXVpcmVkIC0gaXQgaXMgbm93LCBiZWNhdXNlIHdlJ3JlXG4gIFx0XHQvLyBmb3JjaWJseSBkZXRhY2hpbmcgZXZlcnl0aGluZyB0byByZW9yZGVyIHNlY3Rpb25zIGFmdGVyIGFuIHVwZGF0ZS4gVGhhdCdzXG4gIFx0XHQvLyBhIG5vbi1pZGVhbCBicnV0ZSBmb3JjZSBhcHByb2FjaCwgaW1wbGVtZW50ZWQgdG8gZ2V0IGFsbCB0aGUgdGVzdHMgdG8gcGFzc1xuICBcdFx0Ly8gLSBhcyBzb29uIGFzIGl0J3MgcmVwbGFjZWQgd2l0aCBzb21ldGhpbmcgbW9yZSBlbGVnYW50LCB0aGlzIHNob3VsZFxuICBcdFx0Ly8gcmV2ZXJ0IHRvIGBkb2NGcmFnLmFwcGVuZENoaWxkKCBpdGVtLmRldGFjaCgpIClgXG4gIFx0XHRpZiAobm9kZSkge1xuICBcdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKG5vZGUpO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0cmV0dXJuIGRvY0ZyYWc7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmQgPSBGcmFnbWVudCRmaW5kO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpbmQoc2VsZWN0b3IpIHtcbiAgXHR2YXIgaSwgbGVuLCBpdGVtLCBxdWVyeVJlc3VsdDtcblxuICBcdGlmICh0aGlzLml0ZW1zKSB7XG4gIFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1tpXTtcblxuICBcdFx0XHRpZiAoaXRlbS5maW5kICYmIChxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZChzZWxlY3RvcikpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZmluZEFsbCA9IEZyYWdtZW50JGZpbmRBbGw7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZEFsbChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHR2YXIgaSwgbGVuLCBpdGVtO1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMpIHtcbiAgXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXG4gIFx0XHRcdGlmIChpdGVtLmZpbmRBbGwpIHtcbiAgXHRcdFx0XHRpdGVtLmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMgPSBGcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cztcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHR2YXIgaSwgbGVuLCBpdGVtO1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMpIHtcbiAgXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXG4gIFx0XHRcdGlmIChpdGVtLmZpbmRBbGxDb21wb25lbnRzKSB7XG4gIFx0XHRcdFx0aXRlbS5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50ID0gRnJhZ21lbnQkZmluZENvbXBvbmVudDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQ29tcG9uZW50KHNlbGVjdG9yKSB7XG4gIFx0dmFyIGxlbiwgaSwgaXRlbSwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5pdGVtcykge1xuICBcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cbiAgXHRcdFx0aWYgKGl0ZW0uZmluZENvbXBvbmVudCAmJiAocXVlcnlSZXN1bHQgPSBpdGVtLmZpbmRDb21wb25lbnQoc2VsZWN0b3IpKSkge1xuICBcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSA9IEZyYWdtZW50JGZpbmROZXh0Tm9kZTtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kTmV4dE5vZGUoaXRlbSkge1xuICBcdHZhciBpbmRleCA9IGl0ZW0uaW5kZXgsXG4gIFx0ICAgIG5vZGU7XG5cbiAgXHRpZiAodGhpcy5pdGVtc1tpbmRleCArIDFdKSB7XG4gIFx0XHRub2RlID0gdGhpcy5pdGVtc1tpbmRleCArIDFdLmZpcnN0Tm9kZSgpO1xuICBcdH1cblxuICBcdC8vIGlmIHRoaXMgaXMgdGhlIHJvb3QgZnJhZ21lbnQsIGFuZCB0aGVyZSBhcmUgbm8gbW9yZSBpdGVtcyxcbiAgXHQvLyBpdCBtZWFucyB3ZSdyZSBhdCB0aGUgZW5kLi4uXG4gIFx0ZWxzZSBpZiAodGhpcy5vd25lciA9PT0gdGhpcy5yb290KSB7XG4gIFx0XHRpZiAoIXRoaXMub3duZXIuY29tcG9uZW50KSB7XG4gIFx0XHRcdC8vIFRPRE8gYnV0IHNvbWV0aGluZyBlbHNlIGNvdWxkIGhhdmUgYmVlbiBhcHBlbmRlZCB0b1xuICBcdFx0XHQvLyB0aGlzLnJvb3QuZWwsIG5vP1xuICBcdFx0XHRub2RlID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gLi4udW5sZXNzIHRoaXMgaXMgYSBjb21wb25lbnRcbiAgXHRcdGVsc2Uge1xuICBcdFx0XHRub2RlID0gdGhpcy5vd25lci5jb21wb25lbnQuZmluZE5leHROb2RlKCk7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG5vZGUgPSB0aGlzLm93bmVyLmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmlyc3ROb2RlID0gRnJhZ21lbnQkZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpcnN0Tm9kZSgpIHtcbiAgXHRpZiAodGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zWzBdKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pdGVtc1swXS5maXJzdE5vZGUoKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzaGFyZWRfcHJvY2Vzc0l0ZW1zID0gcHJvY2Vzc0l0ZW1zO1xuXG4gIGZ1bmN0aW9uIHByb2Nlc3NJdGVtcyhpdGVtcywgdmFsdWVzLCBndWlkLCBjb3VudGVyKSB7XG4gIFx0Y291bnRlciA9IGNvdW50ZXIgfHwgMDtcblxuICBcdHJldHVybiBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdHZhciBwbGFjZWhvbGRlcklkLCB3cmFwcGVkLCB2YWx1ZTtcblxuICBcdFx0aWYgKGl0ZW0udGV4dCkge1xuICBcdFx0XHRyZXR1cm4gaXRlbS50ZXh0O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaXRlbS5mcmFnbWVudHMpIHtcbiAgXHRcdFx0cmV0dXJuIGl0ZW0uZnJhZ21lbnRzLm1hcChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRyZXR1cm4gcHJvY2Vzc0l0ZW1zKGZyYWdtZW50Lml0ZW1zLCB2YWx1ZXMsIGd1aWQsIGNvdW50ZXIpO1xuICBcdFx0XHR9KS5qb2luKFwiXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRwbGFjZWhvbGRlcklkID0gZ3VpZCArIFwiLVwiICsgY291bnRlcisrO1xuXG4gIFx0XHRpZiAoaXRlbS5rZXlwYXRoICYmICh3cmFwcGVkID0gaXRlbS5yb290LnZpZXdtb2RlbC53cmFwcGVkW2l0ZW0ua2V5cGF0aC5zdHJdKSkge1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZWQudmFsdWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR2YWx1ZSA9IGl0ZW0uZ2V0VmFsdWUoKTtcbiAgXHRcdH1cblxuICBcdFx0dmFsdWVzW3BsYWNlaG9sZGVySWRdID0gdmFsdWU7XG5cbiAgXHRcdHJldHVybiBcIiR7XCIgKyBwbGFjZWhvbGRlcklkICsgXCJ9XCI7XG4gIFx0fSkuam9pbihcIlwiKTtcbiAgfVxuXG4gIHZhciBnZXRBcmdzTGlzdCA9IEZyYWdtZW50JGdldEFyZ3NMaXN0O1xuICBmdW5jdGlvbiBGcmFnbWVudCRnZXRBcmdzTGlzdCgpIHtcbiAgXHR2YXIgdmFsdWVzLCBzb3VyY2UsIHBhcnNlZCwgcmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuZGlydHlBcmdzKSB7XG4gIFx0XHRzb3VyY2UgPSBzaGFyZWRfcHJvY2Vzc0l0ZW1zKHRoaXMuaXRlbXMsIHZhbHVlcyA9IHt9LCB0aGlzLnJvb3QuX2d1aWQpO1xuICBcdFx0cGFyc2VkID0gcGFyc2VKU09OKFwiW1wiICsgc291cmNlICsgXCJdXCIsIHZhbHVlcyk7XG5cbiAgXHRcdGlmICghcGFyc2VkKSB7XG4gIFx0XHRcdHJlc3VsdCA9IFt0aGlzLnRvU3RyaW5nKCldO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmVzdWx0ID0gcGFyc2VkLnZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmFyZ3NMaXN0ID0gcmVzdWx0O1xuICBcdFx0dGhpcy5kaXJ0eUFyZ3MgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5hcmdzTGlzdDtcbiAgfVxuXG4gIHZhciBnZXROb2RlID0gRnJhZ21lbnQkZ2V0Tm9kZTtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRnZXROb2RlKCkge1xuICBcdHZhciBmcmFnbWVudCA9IHRoaXM7XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAoZnJhZ21lbnQucEVsZW1lbnQpIHtcbiAgXHRcdFx0cmV0dXJuIGZyYWdtZW50LnBFbGVtZW50Lm5vZGU7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQpO1xuXG4gIFx0cmV0dXJuIHRoaXMucm9vdC5kZXRhY2hlZCB8fCB0aGlzLnJvb3QuZWw7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2dldFZhbHVlID0gRnJhZ21lbnQkZ2V0VmFsdWU7XG4gIGZ1bmN0aW9uIEZyYWdtZW50JGdldFZhbHVlKCkge1xuICBcdHZhciB2YWx1ZXMsIHNvdXJjZSwgcGFyc2VkLCByZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5kaXJ0eVZhbHVlKSB7XG4gIFx0XHRzb3VyY2UgPSBzaGFyZWRfcHJvY2Vzc0l0ZW1zKHRoaXMuaXRlbXMsIHZhbHVlcyA9IHt9LCB0aGlzLnJvb3QuX2d1aWQpO1xuICBcdFx0cGFyc2VkID0gcGFyc2VKU09OKHNvdXJjZSwgdmFsdWVzKTtcblxuICBcdFx0aWYgKCFwYXJzZWQpIHtcbiAgXHRcdFx0cmVzdWx0ID0gdGhpcy50b1N0cmluZygpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmVzdWx0ID0gcGFyc2VkLnZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnZhbHVlID0gcmVzdWx0O1xuICBcdFx0dGhpcy5kaXJ0eVZhbHVlID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICB2YXIgc2hhcmVkX2RldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRyZXR1cm4gZGV0YWNoTm9kZSh0aGlzLm5vZGUpO1xuICB9O1xuXG4gIHZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBURVhUO1xuICBcdHRoaXMudGV4dCA9IG9wdGlvbnMudGVtcGxhdGU7XG4gIH07XG5cbiAgVGV4dC5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBzaGFyZWRfZGV0YWNoLFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoZXNjYXBlKSB7XG4gIFx0XHRyZXR1cm4gZXNjYXBlID8gZXNjYXBlSHRtbCh0aGlzLnRleHQpIDogdGhpcy50ZXh0O1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGlmIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmRldGFjaCgpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfVGV4dCA9IFRleHQ7XG5cbiAgdmFyIHNoYXJlZF91bmJpbmQgPSBzaGFyZWRfdW5iaW5kX191bmJpbmQ7XG5cbiAgZnVuY3Rpb24gc2hhcmVkX3VuYmluZF9fdW5iaW5kKCkge1xuICBcdGlmICh0aGlzLnJlZ2lzdGVyZWQpIHtcbiAgXHRcdC8vIHRoaXMgd2FzIHJlZ2lzdGVyZWQgYXMgYSBkZXBlbmRhbnRcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLnJlc29sdmVyKSB7XG4gIFx0XHR0aGlzLnJlc29sdmVyLnVuYmluZCgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBNdXN0YWNoZV9nZXRWYWx1ZSA9IE11c3RhY2hlJGdldFZhbHVlO1xuXG4gIGZ1bmN0aW9uIE11c3RhY2hlJGdldFZhbHVlKCkge1xuICBcdHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgdmFyIFJlZmVyZW5jZVJlc29sdmVyID0gZnVuY3Rpb24gKG93bmVyLCByZWYsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIGtleXBhdGg7XG5cbiAgXHR0aGlzLnJlZiA9IHJlZjtcbiAgXHR0aGlzLnJlc29sdmVkID0gZmFsc2U7XG5cbiAgXHR0aGlzLnJvb3QgPSBvd25lci5yb290O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHRrZXlwYXRoID0gc2hhcmVkX3Jlc29sdmVSZWYob3duZXIucm9vdCwgcmVmLCBvd25lci5wYXJlbnRGcmFnbWVudCk7XG4gIFx0aWYgKGtleXBhdGggIT0gdW5kZWZpbmVkKSB7XG4gIFx0XHR0aGlzLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmFkZFVucmVzb2x2ZWQodGhpcyk7XG4gIFx0fVxuICB9O1xuXG4gIFJlZmVyZW5jZVJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCAmJiAha2V5cGF0aCkge1xuICBcdFx0XHQvLyBpdCB3YXMgcmVzb2x2ZWQsIGFuZCBub3cgaXQncyBub3QuIENhbiBoYXBwZW4gaWYgZS5nLiBgYmFyYCBpblxuICBcdFx0XHQvLyBge3tmb29bYmFyXX19YCBiZWNvbWVzIHVuZGVmaW5lZFxuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRVbnJlc29sdmVkKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMuY2FsbGJhY2soa2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5yZXNvbHZlKGdldEtleXBhdGgodGhpcy5yZWYpKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dmFyIGtleXBhdGg7XG5cbiAgXHRcdGlmICh0aGlzLmtleXBhdGggIT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdGtleXBhdGggPSB0aGlzLmtleXBhdGgucmVwbGFjZShvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdFx0Ly8gd2FzIGEgbmV3IGtleXBhdGggY3JlYXRlZD9cbiAgXHRcdFx0aWYgKGtleXBhdGggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdC8vIHJlc29sdmUgaXRcbiAgXHRcdFx0XHR0aGlzLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AucmVtb3ZlVW5yZXNvbHZlZCh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19SZWZlcmVuY2VSZXNvbHZlciA9IFJlZmVyZW5jZVJlc29sdmVyO1xuXG4gIHZhciBTcGVjaWFsUmVzb2x2ZXIgPSBmdW5jdGlvbiAob3duZXIsIHJlZiwgY2FsbGJhY2spIHtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5yZWYgPSByZWY7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIFx0dGhpcy5yZWJpbmQoKTtcbiAgfTtcblxuICB2YXIgcHJvcHMgPSB7XG4gIFx0XCJAa2V5cGF0aFwiOiB7IHByZWZpeDogXCJjXCIsIHByb3A6IFtcImNvbnRleHRcIl0gfSxcbiAgXHRcIkBpbmRleFwiOiB7IHByZWZpeDogXCJpXCIsIHByb3A6IFtcImluZGV4XCJdIH0sXG4gIFx0XCJAa2V5XCI6IHsgcHJlZml4OiBcImtcIiwgcHJvcDogW1wia2V5XCIsIFwiaW5kZXhcIl0gfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFByb3AodGFyZ2V0LCBwcm9wKSB7XG4gIFx0dmFyIHZhbHVlO1xuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcC5wcm9wLmxlbmd0aDsgaSsrKSB7XG4gIFx0XHRpZiAoKHZhbHVlID0gdGFyZ2V0W3Byb3AucHJvcFtpXV0pICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIFNwZWNpYWxSZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0cmViaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcmVmID0gdGhpcy5yZWYsXG4gIFx0XHQgICAgZnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50LFxuICBcdFx0ICAgIHByb3AgPSBwcm9wc1tyZWZdLFxuICBcdFx0ICAgIHZhbHVlO1xuXG4gIFx0XHRpZiAoIXByb3ApIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzcGVjaWFsIHJlZmVyZW5jZSBcXFwiXCIgKyByZWYgKyBcIlxcXCIgLSB2YWxpZCByZWZlcmVuY2VzIGFyZSBAaW5kZXgsIEBrZXkgYW5kIEBrZXlwYXRoXCIpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBoYXZlIHdlIGFscmVhZHkgZm91bmQgdGhlIG5lYXJlc3QgcGFyZW50P1xuICBcdFx0aWYgKHRoaXMuY2FjaGVkKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmNhbGxiYWNrKGdldEtleXBhdGgoXCJAXCIgKyBwcm9wLnByZWZpeCArIGdldFByb3AodGhpcy5jYWNoZWQsIHByb3ApKSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSBmb3IgaW5kaWNlcywgd2hpY2ggbWF5IGNyb3NzIGNvbXBvbmVudCBib3VuZGFyaWVzXG4gIFx0XHRpZiAocHJvcC5wcm9wLmluZGV4T2YoXCJpbmRleFwiKSAhPT0gLTEgfHwgcHJvcC5wcm9wLmluZGV4T2YoXCJrZXlcIikgIT09IC0xKSB7XG4gIFx0XHRcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0XHRcdGlmIChmcmFnbWVudC5vd25lci5jdXJyZW50U3VidHlwZSA9PT0gU0VDVElPTl9FQUNIICYmICh2YWx1ZSA9IGdldFByb3AoZnJhZ21lbnQsIHByb3ApKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHR0aGlzLmNhY2hlZCA9IGZyYWdtZW50O1xuXG4gIFx0XHRcdFx0XHRmcmFnbWVudC5yZWdpc3RlckluZGV4UmVmKHRoaXMpO1xuXG4gIFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jYWxsYmFjayhnZXRLZXlwYXRoKFwiQFwiICsgcHJvcC5wcmVmaXggKyB2YWx1ZSkpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIHdhdGNoIGZvciBjb21wb25lbnQgYm91bmRhcmllc1xuICBcdFx0XHRcdGlmICghZnJhZ21lbnQucGFyZW50ICYmIGZyYWdtZW50Lm93bmVyICYmIGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudCAmJiBmcmFnbWVudC5vd25lci5jb21wb25lbnQucGFyZW50RnJhZ21lbnQgJiYgIWZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5pbnN0YW5jZS5pc29sYXRlZCkge1xuICBcdFx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5vd25lci5jb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRcdFx0aWYgKCh2YWx1ZSA9IGdldFByb3AoZnJhZ21lbnQsIHByb3ApKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jYWxsYmFjayhnZXRLZXlwYXRoKFwiQFwiICsgcHJvcC5wcmVmaXggKyB2YWx1ZS5zdHIpKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmNhY2hlZCkge1xuICBcdFx0XHR0aGlzLmNhY2hlZC51bnJlZ2lzdGVySW5kZXhSZWYodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfU3BlY2lhbFJlc29sdmVyID0gU3BlY2lhbFJlc29sdmVyO1xuXG4gIHZhciBJbmRleFJlc29sdmVyID0gZnVuY3Rpb24gKG93bmVyLCByZWYsIGNhbGxiYWNrKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG93bmVyLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMucmVmID0gcmVmO1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdHJlZi5yZWYuZnJhZ21lbnQucmVnaXN0ZXJJbmRleFJlZih0aGlzKTtcblxuICBcdHRoaXMucmViaW5kKCk7XG4gIH07XG5cbiAgSW5kZXhSZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0cmViaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaW5kZXgsXG4gIFx0XHQgICAgcmVmID0gdGhpcy5yZWYucmVmO1xuXG4gIFx0XHRpZiAocmVmLnJlZi50ID09PSBcImtcIikge1xuICBcdFx0XHRpbmRleCA9IFwia1wiICsgcmVmLmZyYWdtZW50LmtleTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGluZGV4ID0gXCJpXCIgKyByZWYuZnJhZ21lbnQuaW5kZXg7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuY2FsbGJhY2soZ2V0S2V5cGF0aChcIkBcIiArIGluZGV4KSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5yZWYucmVmLmZyYWdtZW50LnVucmVnaXN0ZXJJbmRleFJlZih0aGlzKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19JbmRleFJlc29sdmVyID0gSW5kZXhSZXNvbHZlcjtcblxuICB2YXIgUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMgPSBmaW5kSW5kZXhSZWZzO1xuXG4gIGZ1bmN0aW9uIGZpbmRJbmRleFJlZnMoZnJhZ21lbnQsIHJlZk5hbWUpIHtcbiAgXHR2YXIgcmVzdWx0ID0ge30sXG4gIFx0ICAgIHJlZnMsXG4gIFx0ICAgIGZyYWdSZWZzLFxuICBcdCAgICByZWYsXG4gIFx0ICAgIGksXG4gIFx0ICAgIG93bmVyLFxuICBcdCAgICBoaXQgPSBmYWxzZTtcblxuICBcdGlmICghcmVmTmFtZSkge1xuICBcdFx0cmVzdWx0LnJlZnMgPSByZWZzID0ge307XG4gIFx0fVxuXG4gIFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRpZiAoKG93bmVyID0gZnJhZ21lbnQub3duZXIpICYmIChmcmFnUmVmcyA9IG93bmVyLmluZGV4UmVmcykpIHtcblxuICBcdFx0XHQvLyB3ZSdyZSBsb29raW5nIGZvciBhIHBhcnRpY3VsYXIgcmVmLCBhbmQgaXQncyBoZXJlXG4gIFx0XHRcdGlmIChyZWZOYW1lICYmIChyZWYgPSBvd25lci5nZXRJbmRleFJlZihyZWZOYW1lKSkpIHtcbiAgXHRcdFx0XHRyZXN1bHQucmVmID0ge1xuICBcdFx0XHRcdFx0ZnJhZ21lbnQ6IGZyYWdtZW50LFxuICBcdFx0XHRcdFx0cmVmOiByZWZcbiAgXHRcdFx0XHR9O1xuICBcdFx0XHRcdHJldHVybiByZXN1bHQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyB3ZSdyZSBjb2xsZWN0aW5nIHJlZnMgdXAtdHJlZVxuICBcdFx0XHRlbHNlIGlmICghcmVmTmFtZSkge1xuICBcdFx0XHRcdGZvciAoaSBpbiBmcmFnUmVmcykge1xuICBcdFx0XHRcdFx0cmVmID0gZnJhZ1JlZnNbaV07XG5cbiAgXHRcdFx0XHRcdC8vIGRvbid0IG92ZXJ3cml0ZSBleGlzdGluZyByZWZzIC0gdGhleSBzaG91bGQgc2hhZG93IHBhcmVudHNcbiAgXHRcdFx0XHRcdGlmICghcmVmc1tyZWYubl0pIHtcbiAgXHRcdFx0XHRcdFx0aGl0ID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdFx0cmVmc1tyZWYubl0gPSB7XG4gIFx0XHRcdFx0XHRcdFx0ZnJhZ21lbnQ6IGZyYWdtZW50LFxuICBcdFx0XHRcdFx0XHRcdHJlZjogcmVmXG4gIFx0XHRcdFx0XHRcdH07XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHdhdGNoIGZvciBjb21wb25lbnQgYm91bmRhcmllc1xuICBcdFx0aWYgKCFmcmFnbWVudC5wYXJlbnQgJiYgZnJhZ21lbnQub3duZXIgJiYgZnJhZ21lbnQub3duZXIuY29tcG9uZW50ICYmIGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCAmJiAhZnJhZ21lbnQub3duZXIuY29tcG9uZW50Lmluc3RhbmNlLmlzb2xhdGVkKSB7XG4gIFx0XHRcdHJlc3VsdC5jb21wb25lbnRCb3VuZGFyeSA9IHRydWU7XG4gIFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQub3duZXIuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFoaXQpIHtcbiAgXHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fVxuICB9XG5cbiAgZmluZEluZGV4UmVmcy5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShpbmRpY2VzKSB7XG4gIFx0dmFyIHJlZnMgPSB7fSxcbiAgXHQgICAgayxcbiAgXHQgICAgcmVmO1xuXG4gIFx0Zm9yIChrIGluIGluZGljZXMucmVmcykge1xuICBcdFx0cmVmID0gaW5kaWNlcy5yZWZzW2tdO1xuICBcdFx0cmVmc1tyZWYucmVmLm5dID0gcmVmLnJlZi50ID09PSBcImtcIiA/IHJlZi5mcmFnbWVudC5rZXkgOiByZWYuZnJhZ21lbnQuaW5kZXg7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlZnM7XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlciA9IGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyO1xuICBmdW5jdGlvbiBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihvd25lciwgcmVmLCBjYWxsYmFjaykge1xuICBcdHZhciBpbmRleFJlZjtcblxuICBcdGlmIChyZWYuY2hhckF0KDApID09PSBcIkBcIikge1xuICBcdFx0cmV0dXJuIG5ldyBSZXNvbHZlcnNfU3BlY2lhbFJlc29sdmVyKG93bmVyLCByZWYsIGNhbGxiYWNrKTtcbiAgXHR9XG5cbiAgXHRpZiAoaW5kZXhSZWYgPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcyhvd25lci5wYXJlbnRGcmFnbWVudCwgcmVmKSkge1xuICBcdFx0cmV0dXJuIG5ldyBSZXNvbHZlcnNfSW5kZXhSZXNvbHZlcihvd25lciwgaW5kZXhSZWYsIGNhbGxiYWNrKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbmV3IFJlc29sdmVyc19SZWZlcmVuY2VSZXNvbHZlcihvd25lciwgcmVmLCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgc2hhcmVkX2dldEZ1bmN0aW9uRnJvbVN0cmluZyA9IGdldEZ1bmN0aW9uRnJvbVN0cmluZztcbiAgdmFyIGNhY2hlID0ge307XG4gIGZ1bmN0aW9uIGdldEZ1bmN0aW9uRnJvbVN0cmluZyhzdHIsIGkpIHtcbiAgXHR2YXIgZm4sIGFyZ3M7XG5cbiAgXHRpZiAoY2FjaGVbc3RyXSkge1xuICBcdFx0cmV0dXJuIGNhY2hlW3N0cl07XG4gIFx0fVxuXG4gIFx0YXJncyA9IFtdO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGFyZ3NbaV0gPSBcIl9cIiArIGk7XG4gIFx0fVxuXG4gIFx0Zm4gPSBuZXcgRnVuY3Rpb24oYXJncy5qb2luKFwiLFwiKSwgXCJyZXR1cm4oXCIgKyBzdHIgKyBcIilcIik7XG5cbiAgXHRjYWNoZVtzdHJdID0gZm47XG4gIFx0cmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIEV4cHJlc3Npb25SZXNvbHZlcixcbiAgICAgIFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXJfX2JpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcblxuICBFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiAob3duZXIsIHBhcmVudEZyYWdtZW50LCBleHByZXNzaW9uLCBjYWxsYmFjaykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcmFjdGl2ZTtcblxuICBcdHJhY3RpdmUgPSBvd25lci5yb290O1xuXG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBcdHRoaXMub3duZXIgPSBvd25lcjtcbiAgXHR0aGlzLnN0ciA9IGV4cHJlc3Npb24ucztcbiAgXHR0aGlzLmtleXBhdGhzID0gW107XG5cbiAgXHQvLyBDcmVhdGUgcmVzb2x2ZXJzIGZvciBlYWNoIHJlZmVyZW5jZVxuICBcdHRoaXMucGVuZGluZyA9IGV4cHJlc3Npb24uci5sZW5ndGg7XG4gIFx0dGhpcy5yZWZSZXNvbHZlcnMgPSBleHByZXNzaW9uLnIubWFwKGZ1bmN0aW9uIChyZWYsIGkpIHtcbiAgXHRcdHJldHVybiBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoX3RoaXMsIHJlZiwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0X3RoaXMucmVzb2x2ZShpLCBrZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH0pO1xuXG4gIFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIFx0dGhpcy5idWJibGUoKTtcbiAgfTtcblxuICBFeHByZXNzaW9uUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy51bmlxdWVTdHJpbmcgPSBnZXRVbmlxdWVTdHJpbmcodGhpcy5zdHIsIHRoaXMua2V5cGF0aHMpO1xuICBcdFx0dGhpcy5rZXlwYXRoID0gY3JlYXRlRXhwcmVzc2lvbktleXBhdGgodGhpcy51bmlxdWVTdHJpbmcpO1xuXG4gIFx0XHR0aGlzLmNyZWF0ZUV2YWx1YXRvcigpO1xuICBcdFx0dGhpcy5jYWxsYmFjayh0aGlzLmtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciByZXNvbHZlcjtcblxuICBcdFx0d2hpbGUgKHJlc29sdmVyID0gdGhpcy5yZWZSZXNvbHZlcnMucG9wKCkpIHtcbiAgXHRcdFx0cmVzb2x2ZXIudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChpbmRleCwga2V5cGF0aCkge1xuICBcdFx0dGhpcy5rZXlwYXRoc1tpbmRleF0gPSBrZXlwYXRoO1xuICBcdFx0dGhpcy5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0Y3JlYXRlRXZhbHVhdG9yOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgY29tcHV0YXRpb24sIHZhbHVlR2V0dGVycywgc2lnbmF0dXJlLCBrZXlwYXRoLCBmbjtcblxuICBcdFx0a2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcbiAgXHRcdGNvbXB1dGF0aW9uID0gdGhpcy5yb290LnZpZXdtb2RlbC5jb21wdXRhdGlvbnNba2V5cGF0aC5zdHJdO1xuXG4gIFx0XHQvLyBvbmx5IGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0IVxuICBcdFx0aWYgKCFjb21wdXRhdGlvbikge1xuICBcdFx0XHRmbiA9IHNoYXJlZF9nZXRGdW5jdGlvbkZyb21TdHJpbmcodGhpcy5zdHIsIHRoaXMucmVmUmVzb2x2ZXJzLmxlbmd0aCk7XG5cbiAgXHRcdFx0dmFsdWVHZXR0ZXJzID0gdGhpcy5rZXlwYXRocy5tYXAoZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0XHR2YXIgdmFsdWU7XG5cbiAgXHRcdFx0XHRpZiAoa2V5cGF0aCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHRcdFx0XHRcdH07XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gJ3NwZWNpYWwnIGtleXBhdGhzIGVuY29kZSBhIHZhbHVlXG4gIFx0XHRcdFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRcdFx0XHR2YWx1ZSA9IGtleXBhdGgudmFsdWU7XG4gIFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHRcdFx0XHR9O1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBfdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCwgeyBub1Vud3JhcDogdHJ1ZSwgZnVsbFJvb3RHZXQ6IHRydWUgfSk7XG4gIFx0XHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRcdFx0dmFsdWUgPSB3cmFwRnVuY3Rpb24odmFsdWUsIF90aGlzLnJvb3QpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0XHRcdH07XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHNpZ25hdHVyZSA9IHtcbiAgXHRcdFx0XHRkZXBzOiB0aGlzLmtleXBhdGhzLmZpbHRlcihpc1ZhbGlkRGVwZW5kZW5jeSksXG4gIFx0XHRcdFx0Z2V0dGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHR2YXIgYXJncyA9IHZhbHVlR2V0dGVycy5tYXAoY2FsbCk7XG4gIFx0XHRcdFx0XHRyZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5yb290LnZpZXdtb2RlbC5jb21wdXRlKGtleXBhdGgsIHNpZ25hdHVyZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdC8vIFRPRE8gb25seSBidWJibGUgb25jZSwgbm8gbWF0dGVyIGhvdyBtYW55IHJlZmVyZW5jZXMgYXJlIGFmZmVjdGVkIGJ5IHRoZSByZWJpbmRcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgXHRcdFx0cmV0dXJuIHIucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyID0gRXhwcmVzc2lvblJlc29sdmVyO1xuXG4gIGZ1bmN0aW9uIGNhbGwodmFsdWUpIHtcbiAgXHRyZXR1cm4gdmFsdWUuY2FsbCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VW5pcXVlU3RyaW5nKHN0ciwga2V5cGF0aHMpIHtcbiAgXHQvLyBnZXQgc3RyaW5nIHRoYXQgaXMgdW5pcXVlIHRvIHRoaXMgZXhwcmVzc2lvblxuICBcdHJldHVybiBzdHIucmVwbGFjZSgvXyhbMC05XSspL2csIGZ1bmN0aW9uIChtYXRjaCwgJDEpIHtcbiAgXHRcdHZhciBrZXlwYXRoLCB2YWx1ZTtcblxuICBcdFx0Ly8gbWFrZSBzdXJlIHdlJ3JlIG5vdCByZXBsYWNpbmcgYSBub24ta2V5cGF0aCBfWzAtOV1cbiAgXHRcdGlmICgrJDEgPj0ga2V5cGF0aHMubGVuZ3RoKSB7XG4gIFx0XHRcdHJldHVybiBcIl9cIiArICQxO1xuICBcdFx0fVxuXG4gIFx0XHRrZXlwYXRoID0ga2V5cGF0aHNbJDFdO1xuXG4gIFx0XHRpZiAoa2V5cGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiBcInVuZGVmaW5lZFwiO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdFx0dmFsdWUgPSBrZXlwYXRoLnZhbHVlO1xuICBcdFx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdmFsdWUgOiBcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCI7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBrZXlwYXRoLnN0cjtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUV4cHJlc3Npb25LZXlwYXRoKHVuaXF1ZVN0cmluZykge1xuICBcdC8vIFNhbml0aXplIGJ5IHJlbW92aW5nIGFueSBwZXJpb2RzIG9yIHNxdWFyZSBicmFja2V0cy4gT3RoZXJ3aXNlXG4gIFx0Ly8gd2UgY2FuJ3Qgc3BsaXQgdGhlIGtleXBhdGggaW50byBrZXlzIVxuICBcdC8vIFJlbW92ZSBhc3Rlcmlza3MgdG9vLCBzaW5jZSB0aGV5IG1lc3Mgd2l0aCBwYXR0ZXJuIG9ic2VydmVyc1xuICBcdHJldHVybiBnZXRLZXlwYXRoKFwiJHtcIiArIHVuaXF1ZVN0cmluZy5yZXBsYWNlKC9bXFwuXFxbXFxdXS9nLCBcIi1cIikucmVwbGFjZSgvXFwqLywgXCIjTVVMI1wiKSArIFwifVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWREZXBlbmRlbmN5KGtleXBhdGgpIHtcbiAgXHRyZXR1cm4ga2V5cGF0aCAhPT0gdW5kZWZpbmVkICYmIGtleXBhdGhbMF0gIT09IFwiQFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcEZ1bmN0aW9uKGZuLCByYWN0aXZlKSB7XG4gIFx0dmFyIHdyYXBwZWQsIHByb3AsIGtleTtcblxuICBcdGlmIChmbi5fX3JhY3RpdmVfbm93cmFwKSB7XG4gIFx0XHRyZXR1cm4gZm47XG4gIFx0fVxuXG4gIFx0cHJvcCA9IFwiX19yYWN0aXZlX1wiICsgcmFjdGl2ZS5fZ3VpZDtcbiAgXHR3cmFwcGVkID0gZm5bcHJvcF07XG5cbiAgXHRpZiAod3JhcHBlZCkge1xuICBcdFx0cmV0dXJuIHdyYXBwZWQ7XG4gIFx0fSBlbHNlIGlmICgvdGhpcy8udGVzdChmbi50b1N0cmluZygpKSkge1xuICBcdFx0ZGVmaW5lUHJvcGVydHkoZm4sIHByb3AsIHtcbiAgXHRcdFx0dmFsdWU6IFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXJfX2JpbmQuY2FsbChmbiwgcmFjdGl2ZSksXG4gIFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICBcdFx0fSk7XG5cbiAgXHRcdC8vIEFkZCBwcm9wZXJ0aWVzL21ldGhvZHMgdG8gd3JhcHBlZCBmdW5jdGlvblxuICBcdFx0Zm9yIChrZXkgaW4gZm4pIHtcbiAgXHRcdFx0aWYgKGZuLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0XHRmbltwcm9wXVtrZXldID0gZm5ba2V5XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyYWN0aXZlLl9ib3VuZEZ1bmN0aW9ucy5wdXNoKHtcbiAgXHRcdFx0Zm46IGZuLFxuICBcdFx0XHRwcm9wOiBwcm9wXG4gIFx0XHR9KTtcblxuICBcdFx0cmV0dXJuIGZuW3Byb3BdO1xuICBcdH1cblxuICBcdGRlZmluZVByb3BlcnR5KGZuLCBcIl9fcmFjdGl2ZV9ub3dyYXBcIiwge1xuICBcdFx0dmFsdWU6IGZuXG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gZm4uX19yYWN0aXZlX25vd3JhcDtcbiAgfVxuXG4gIHZhciBNZW1iZXJSZXNvbHZlciA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgcmVzb2x2ZXIsIHBhcmVudEZyYWdtZW50KSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHRoaXMucmVzb2x2ZXIgPSByZXNvbHZlcjtcbiAgXHR0aGlzLnJvb3QgPSByZXNvbHZlci5yb290O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnZpZXdtb2RlbCA9IHJlc29sdmVyLnJvb3Qudmlld21vZGVsO1xuXG4gIFx0aWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0dGhpcy52YWx1ZSA9IHRlbXBsYXRlO1xuICBcdH1cblxuICBcdC8vIFNpbXBsZSByZWZlcmVuY2U/XG4gIFx0ZWxzZSBpZiAodGVtcGxhdGUudCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHR0aGlzLnJlZlJlc29sdmVyID0gUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKHRoaXMsIHRlbXBsYXRlLm4sIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdF90aGlzLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyBPdGhlcndpc2Ugd2UgaGF2ZSBhbiBleHByZXNzaW9uIGluIGl0cyBvd24gcmlnaHRcbiAgXHRlbHNlIHtcbiAgXHRcdG5ldyBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyKHJlc29sdmVyLCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGUsIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdF90aGlzLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH07XG5cbiAgTWVtYmVyUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdHRoaXMuYmluZCgpO1xuXG4gIFx0XHR0aGlzLnJlc29sdmVyLmJ1YmJsZSgpO1xuICBcdH0sXG5cbiAgXHRiaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5yZWZSZXNvbHZlcikge1xuICBcdFx0XHR0aGlzLnJlZlJlc29sdmVyLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdFx0dGhpcy5yZXNvbHZlci5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMucmVmUmVzb2x2ZXIpIHtcbiAgXHRcdFx0dGhpcy5yZWZSZXNvbHZlci51bmJpbmQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5yZWZSZXNvbHZlcikge1xuICBcdFx0XHR0aGlzLnJlZlJlc29sdmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX01lbWJlclJlc29sdmVyID0gTWVtYmVyUmVzb2x2ZXI7XG5cbiAgdmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uIChtdXN0YWNoZSwgdGVtcGxhdGUsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciByYWN0aXZlLCByZWYsIGtleXBhdGgsIHBhcmVudEZyYWdtZW50O1xuXG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50ID0gbXVzdGFjaGUucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IG11c3RhY2hlLnJvb3Q7XG4gIFx0dGhpcy5tdXN0YWNoZSA9IG11c3RhY2hlO1xuXG4gIFx0dGhpcy5yZWYgPSByZWYgPSB0ZW1wbGF0ZS5yO1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdHRoaXMudW5yZXNvbHZlZCA9IFtdO1xuXG4gIFx0Ly8gRmluZCBiYXNlIGtleXBhdGhcbiAgXHRpZiAoa2V5cGF0aCA9IHNoYXJlZF9yZXNvbHZlUmVmKHJhY3RpdmUsIHJlZiwgcGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHR0aGlzLmJhc2UgPSBrZXlwYXRoO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLmJhc2VSZXNvbHZlciA9IG5ldyBSZXNvbHZlcnNfUmVmZXJlbmNlUmVzb2x2ZXIodGhpcywgcmVmLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRfdGhpcy5iYXNlID0ga2V5cGF0aDtcbiAgXHRcdFx0X3RoaXMuYmFzZVJlc29sdmVyID0gbnVsbDtcbiAgXHRcdFx0X3RoaXMuYnViYmxlKCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyBGaW5kIHZhbHVlcyBmb3IgbWVtYmVycywgb3IgbWFyayB0aGVtIGFzIHVucmVzb2x2ZWRcbiAgXHR0aGlzLm1lbWJlcnMgPSB0ZW1wbGF0ZS5tLm1hcChmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgXHRcdHJldHVybiBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX01lbWJlclJlc29sdmVyKHRlbXBsYXRlLCBfdGhpcywgcGFyZW50RnJhZ21lbnQpO1xuICBcdH0pO1xuXG4gIFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIFx0dGhpcy5idWJibGUoKTsgLy8gdHJpZ2dlciBpbml0aWFsIHJlc29sdXRpb24gaWYgcG9zc2libGVcbiAgfTtcblxuICBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdGdldEtleXBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB2YWx1ZXMgPSB0aGlzLm1lbWJlcnMubWFwKFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfX2dldFZhbHVlKTtcblxuICBcdFx0aWYgKCF2YWx1ZXMuZXZlcnkoaXNEZWZpbmVkKSB8fCB0aGlzLmJhc2VSZXNvbHZlcikge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMuYmFzZS5qb2luKHZhbHVlcy5qb2luKFwiLlwiKSk7XG4gIFx0fSxcblxuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLnJlYWR5IHx8IHRoaXMuYmFzZVJlc29sdmVyKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5jYWxsYmFjayh0aGlzLmdldEtleXBhdGgoKSk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dmFyIGNoYW5nZWQ7XG5cbiAgXHRcdGlmICh0aGlzLmJhc2UpIHtcbiAgXHRcdFx0dmFyIG5ld0Jhc2UgPSB0aGlzLmJhc2UucmVwbGFjZShvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdFx0aWYgKG5ld0Jhc2UgJiYgbmV3QmFzZSAhPT0gdGhpcy5iYXNlKSB7XG4gIFx0XHRcdFx0dGhpcy5iYXNlID0gbmV3QmFzZTtcbiAgXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaChmdW5jdGlvbiAobWVtYmVycykge1xuICBcdFx0XHRpZiAobWVtYmVycy5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkpIHtcbiAgXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG5cbiAgXHRcdGlmIChjaGFuZ2VkKSB7XG4gIFx0XHRcdHRoaXMuYnViYmxlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuYmFzZVJlc29sdmVyKSB7XG4gIFx0XHRcdHRoaXMuYmFzZSA9IGdldEtleXBhdGgodGhpcy5yZWYpO1xuXG4gIFx0XHRcdHRoaXMuYmFzZVJlc29sdmVyLnVuYmluZCgpO1xuICBcdFx0XHR0aGlzLmJhc2VSZXNvbHZlciA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKGZvcmNlUmVzb2x1dGlvbik7XG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX19nZXRWYWx1ZShtZW1iZXIpIHtcbiAgXHRyZXR1cm4gbWVtYmVyLnZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIFx0cmV0dXJuIHZhbHVlICE9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcmNlUmVzb2x1dGlvbihtZW1iZXIpIHtcbiAgXHRtZW1iZXIuZm9yY2VSZXNvbHV0aW9uKCk7XG4gIH1cblxuICB2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciA9IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcjtcblxuICB2YXIgTXVzdGFjaGVfaW5pdGlhbGlzZSA9IE11c3RhY2hlJGluaXQ7XG4gIGZ1bmN0aW9uIE11c3RhY2hlJGluaXQobXVzdGFjaGUsIG9wdGlvbnMpIHtcblxuICBcdHZhciByZWYsIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZTtcblxuICBcdHBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcbiAgXHR0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cbiAgXHRtdXN0YWNoZS5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHRtdXN0YWNoZS5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuICBcdG11c3RhY2hlLnBFbGVtZW50ID0gcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cbiAgXHRtdXN0YWNoZS50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gIFx0bXVzdGFjaGUuaW5kZXggPSBvcHRpb25zLmluZGV4IHx8IDA7XG4gIFx0bXVzdGFjaGUuaXNTdGF0aWMgPSBvcHRpb25zLnRlbXBsYXRlLnM7XG5cbiAgXHRtdXN0YWNoZS50eXBlID0gb3B0aW9ucy50ZW1wbGF0ZS50O1xuXG4gIFx0bXVzdGFjaGUucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhIHNpbXBsZSBtdXN0YWNoZSwgd2l0aCBhIHJlZmVyZW5jZSwgd2UganVzdCBuZWVkIHRvIHJlc29sdmVcbiAgXHQvLyB0aGUgcmVmZXJlbmNlIHRvIGEga2V5cGF0aFxuICBcdGlmIChyZWYgPSB0ZW1wbGF0ZS5yKSB7XG4gIFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihtdXN0YWNoZSwgcmVmLCByZXNvbHZlKTtcbiAgXHR9XG5cbiAgXHQvLyBpZiBpdCdzIGFuIGV4cHJlc3Npb24sIHdlIGhhdmUgYSBiaXQgbW9yZSB3b3JrIHRvIGRvXG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUueCkge1xuICBcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlcihtdXN0YWNoZSwgcGFyZW50RnJhZ21lbnQsIG9wdGlvbnMudGVtcGxhdGUueCwgcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuKTtcbiAgXHR9XG5cbiAgXHRpZiAob3B0aW9ucy50ZW1wbGF0ZS5yeCkge1xuICBcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcihtdXN0YWNoZSwgb3B0aW9ucy50ZW1wbGF0ZS5yeCwgcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSBpbnZlcnRlZCBzZWN0aW9uc1xuICBcdGlmIChtdXN0YWNoZS50ZW1wbGF0ZS5uID09PSBTRUNUSU9OX1VOTEVTUyAmJiAhbXVzdGFjaGUuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSkge1xuICBcdFx0bXVzdGFjaGUuc2V0VmFsdWUodW5kZWZpbmVkKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZXNvbHZlKGtleXBhdGgpIHtcbiAgXHRcdG11c3RhY2hlLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuKG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBvbGRLZXlwYXRoID0gbXVzdGFjaGUua2V5cGF0aDtcblxuICBcdFx0aWYgKG5ld0tleXBhdGggIT0gb2xkS2V5cGF0aCkge1xuICBcdFx0XHRtdXN0YWNoZS5yZXNvbHZlKG5ld0tleXBhdGgpO1xuXG4gIFx0XHRcdGlmIChvbGRLZXlwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5mcmFnbWVudHMgJiYgbXVzdGFjaGUuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdFx0XHRcdGYucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIE11c3RhY2hlX3Jlc29sdmUgPSBNdXN0YWNoZSRyZXNvbHZlO1xuXG4gIGZ1bmN0aW9uIE11c3RhY2hlJHJlc29sdmUoa2V5cGF0aCkge1xuICBcdHZhciB3YXNSZXNvbHZlZCwgdmFsdWUsIHR3b3dheUJpbmRpbmc7XG5cbiAgXHQvLyAnU3BlY2lhbCcga2V5cGF0aHMsIGUuZy4gQGZvbyBvciBANywgZW5jb2RlIGEgdmFsdWVcbiAgXHRpZiAoa2V5cGF0aCAmJiBrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMuc2V0VmFsdWUoa2V5cGF0aC52YWx1ZSk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gSWYgd2UgcmVzb2x2ZWQgcHJldmlvdXNseSwgd2UgbmVlZCB0byB1bnJlZ2lzdGVyXG4gIFx0aWYgKHRoaXMucmVnaXN0ZXJlZCkge1xuICBcdFx0Ly8gdW5kZWZpbmVkIG9yIG51bGxcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdFx0dGhpcy5yZWdpc3RlcmVkID0gZmFsc2U7XG5cbiAgXHRcdHdhc1Jlc29sdmVkID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXG4gIFx0Ly8gSWYgdGhlIG5ldyBrZXlwYXRoIGV4aXN0cywgd2UgbmVlZCB0byByZWdpc3RlclxuICBcdC8vIHdpdGggdGhlIHZpZXdtb2RlbFxuICBcdGlmIChrZXlwYXRoICE9IHVuZGVmaW5lZCkge1xuICBcdFx0Ly8gdW5kZWZpbmVkIG9yIG51bGxcbiAgXHRcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMpO1xuXG4gIFx0XHR0aGlzLnJlZ2lzdGVyZWQgPSB0cnVlO1xuICBcdH1cblxuICBcdC8vIEVpdGhlciB3YXkgd2UgbmVlZCB0byBxdWV1ZSB1cCBhIHJlbmRlciAoYHZhbHVlYFxuICBcdC8vIHdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgdGhlcmUncyBubyBrZXlwYXRoKVxuICBcdHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuXG4gIFx0Ly8gVHdvLXdheSBiaW5kaW5ncyBuZWVkIHRvIHBvaW50IHRvIHRoZWlyIG5ldyB0YXJnZXQga2V5cGF0aFxuICBcdGlmICh3YXNSZXNvbHZlZCAmJiAodHdvd2F5QmluZGluZyA9IHRoaXMudHdvd2F5QmluZGluZykpIHtcbiAgXHRcdHR3b3dheUJpbmRpbmcucmVib3VuZCgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBNdXN0YWNoZV9yZWJpbmQgPSBNdXN0YWNoZSRyZWJpbmQ7XG5cbiAgZnVuY3Rpb24gTXVzdGFjaGUkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHQvLyBDaGlsZHJlbiBmaXJzdFxuICBcdGlmICh0aGlzLmZyYWdtZW50cykge1xuICBcdFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0XHRyZXR1cm4gZi5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyBFeHByZXNzaW9uIG11c3RhY2hlP1xuICBcdGlmICh0aGlzLnJlc29sdmVyKSB7XG4gIFx0XHR0aGlzLnJlc29sdmVyLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgTXVzdGFjaGUgPSB7XG4gIFx0Z2V0VmFsdWU6IE11c3RhY2hlX2dldFZhbHVlLFxuICBcdGluaXQ6IE11c3RhY2hlX2luaXRpYWxpc2UsXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGVfcmVzb2x2ZSxcbiAgXHRyZWJpbmQ6IE11c3RhY2hlX3JlYmluZFxuICB9O1xuXG4gIHZhciBJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IElOVEVSUE9MQVRPUjtcbiAgXHRNdXN0YWNoZS5pbml0KHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEludGVycG9sYXRvci5wcm90b3R5cGUgPSB7XG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLm5vZGUuZGF0YSA9IHRoaXMudmFsdWUgPT0gdW5kZWZpbmVkID8gXCJcIiA6IHRoaXMudmFsdWU7XG4gIFx0fSxcbiAgXHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuICBcdHJlYmluZDogTXVzdGFjaGUucmViaW5kLFxuICBcdGRldGFjaDogc2hhcmVkX2RldGFjaCxcblxuICBcdHVuYmluZDogc2hhcmVkX3VuYmluZCxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLm5vZGUpIHtcbiAgXHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2FmZVRvU3RyaW5nVmFsdWUodGhpcy52YWx1ZSkpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGlmIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRcdGRldGFjaE5vZGUodGhpcy5ub2RlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuXG4gIFx0Ly8gVEVNUFxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHZhciB3cmFwcGVyO1xuXG4gIFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBhcHByb2FjaCB0aGlzP1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCAmJiAod3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFt0aGlzLmtleXBhdGguc3RyXSkpIHtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWlzRXF1YWwodmFsdWUsIHRoaXMudmFsdWUpKSB7XG4gIFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblxuICBcdFx0XHRpZiAodGhpcy5ub2RlKSB7XG4gIFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoZXNjYXBlKSB7XG4gIFx0XHR2YXIgc3RyaW5nID0gXCJcIiArIHNhZmVUb1N0cmluZ1ZhbHVlKHRoaXMudmFsdWUpO1xuICBcdFx0cmV0dXJuIGVzY2FwZSA/IGVzY2FwZUh0bWwoc3RyaW5nKSA6IHN0cmluZztcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGl0ZW1zX0ludGVycG9sYXRvciA9IEludGVycG9sYXRvcjtcblxuICB2YXIgU2VjdGlvbl9wcm90b3R5cGVfYnViYmxlID0gU2VjdGlvbiRidWJibGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRidWJibGUoKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcbiAgfVxuXG4gIHZhciBTZWN0aW9uX3Byb3RvdHlwZV9kZXRhY2ggPSBTZWN0aW9uJGRldGFjaDtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGRldGFjaCgpIHtcbiAgXHR2YXIgZG9jRnJhZztcblxuICBcdGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50c1swXS5kZXRhY2goKTtcbiAgXHR9XG5cbiAgXHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZChpdGVtLmRldGFjaCgpKTtcbiAgXHR9KTtcblxuICBcdHJldHVybiBkb2NGcmFnO1xuICB9XG5cbiAgdmFyIGZpbmQgPSBTZWN0aW9uJGZpbmQ7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRpZiAocXVlcnlSZXN1bHQgPSB0aGlzLmZyYWdtZW50c1tpXS5maW5kKHNlbGVjdG9yKSkge1xuICBcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmluZEFsbCA9IFNlY3Rpb24kZmluZEFsbDtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0dmFyIGksIGxlbjtcblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnRzW2ldLmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9XG4gIH1cblxuICB2YXIgZmluZEFsbENvbXBvbmVudHMgPSBTZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0dmFyIGksIGxlbjtcblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnRzW2ldLmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGZpbmRDb21wb25lbnQgPSBTZWN0aW9uJGZpbmRDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kQ29tcG9uZW50KHNlbGVjdG9yKSB7XG4gIFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRpZiAocXVlcnlSZXN1bHQgPSB0aGlzLmZyYWdtZW50c1tpXS5maW5kQ29tcG9uZW50KHNlbGVjdG9yKSkge1xuICBcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmluZE5leHROb2RlID0gU2VjdGlvbiRmaW5kTmV4dE5vZGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kTmV4dE5vZGUoZnJhZ21lbnQpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudHNbZnJhZ21lbnQuaW5kZXggKyAxXSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnRzW2ZyYWdtZW50LmluZGV4ICsgMV0uZmlyc3ROb2RlKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICB9XG5cbiAgdmFyIGZpcnN0Tm9kZSA9IFNlY3Rpb24kZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmlyc3ROb2RlKCkge1xuICBcdHZhciBsZW4sIGksIG5vZGU7XG5cbiAgXHRpZiAobGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aWYgKG5vZGUgPSB0aGlzLmZyYWdtZW50c1tpXS5maXJzdE5vZGUoKSkge1xuICBcdFx0XHRcdHJldHVybiBub2RlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICB9XG5cbiAgdmFyIHNodWZmbGUgPSBTZWN0aW9uJHNodWZmbGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRzaHVmZmxlKG5ld0luZGljZXMpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCBmaXJzdENoYW5nZSwgaSwgbmV3TGVuZ3RoLCByZWJvdW5kRnJhZ21lbnRzLCBmcmFnbWVudE9wdGlvbnMsIGZyYWdtZW50O1xuXG4gIFx0Ly8gc2hvcnQgY2lyY3VpdCBhbnkgZG91YmxlLXVwZGF0ZXMsIGFuZCBlbnN1cmUgdGhhdCB0aGlzIGlzbid0IGFwcGxpZWQgdG9cbiAgXHQvLyBub24tbGlzdCBzZWN0aW9uc1xuICBcdGlmICh0aGlzLnNodWZmbGluZyB8fCB0aGlzLnVuYm91bmQgfHwgdGhpcy5jdXJyZW50U3VidHlwZSAhPT0gU0VDVElPTl9FQUNIKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGhpcy5zaHVmZmxpbmcgPSB0cnVlO1xuICBcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gX3RoaXMuc2h1ZmZsaW5nID0gZmFsc2U7XG4gIFx0fSk7XG5cbiAgXHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHRyZWJvdW5kRnJhZ21lbnRzID0gW107XG5cbiAgXHQvLyBUT0RPOiBuZWVkIHRvIHVwZGF0ZSB0aGlzXG4gIFx0Ly8gZmlyc3QsIHJlYmluZCBleGlzdGluZyBmcmFnbWVudHNcbiAgXHRuZXdJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKG5ld0luZGV4LCBvbGRJbmRleCkge1xuICBcdFx0dmFyIGZyYWdtZW50LCBieSwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCwgZGVwcztcblxuICBcdFx0aWYgKG5ld0luZGV4ID09PSBvbGRJbmRleCkge1xuICBcdFx0XHRyZWJvdW5kRnJhZ21lbnRzW25ld0luZGV4XSA9IF90aGlzLmZyYWdtZW50c1tvbGRJbmRleF07XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0ZnJhZ21lbnQgPSBfdGhpcy5mcmFnbWVudHNbb2xkSW5kZXhdO1xuXG4gIFx0XHRpZiAoZmlyc3RDaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRmaXJzdENoYW5nZSA9IG9sZEluZGV4O1xuICBcdFx0fVxuXG4gIFx0XHQvLyBkb2VzIHRoaXMgZnJhZ21lbnQgbmVlZCB0byBiZSB0b3JuIGRvd24/XG4gIFx0XHRpZiAobmV3SW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdF90aGlzLmZyYWdtZW50c1RvVW5yZW5kZXIucHVzaChmcmFnbWVudCk7XG4gIFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIE90aGVyd2lzZSwgaXQgbmVlZHMgdG8gYmUgcmVib3VuZCB0byBhIG5ldyBpbmRleFxuICBcdFx0YnkgPSBuZXdJbmRleCAtIG9sZEluZGV4O1xuICBcdFx0b2xkS2V5cGF0aCA9IF90aGlzLmtleXBhdGguam9pbihvbGRJbmRleCk7XG4gIFx0XHRuZXdLZXlwYXRoID0gX3RoaXMua2V5cGF0aC5qb2luKG5ld0luZGV4KTtcblxuICBcdFx0ZnJhZ21lbnQuaW5kZXggPSBuZXdJbmRleDtcblxuICBcdFx0Ly8gbm90aWZ5IGFueSByZWdpc3RlcmVkIGluZGV4IHJlZnMgZGlyZWN0bHlcbiAgXHRcdGlmIChkZXBzID0gZnJhZ21lbnQucmVnaXN0ZXJlZEluZGV4UmVmcykge1xuICBcdFx0XHRkZXBzLmZvckVhY2goc2h1ZmZsZV9fYmxpbmRSZWJpbmQpO1xuICBcdFx0fVxuXG4gIFx0XHRmcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHRyZWJvdW5kRnJhZ21lbnRzW25ld0luZGV4XSA9IGZyYWdtZW50O1xuICBcdH0pO1xuXG4gIFx0bmV3TGVuZ3RoID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5rZXlwYXRoKS5sZW5ndGg7XG5cbiAgXHQvLyBJZiBub3RoaW5nIGNoYW5nZWQgd2l0aCB0aGUgZXhpc3RpbmcgZnJhZ21lbnRzLCB0aGVuIHdlIHN0YXJ0IGFkZGluZ1xuICBcdC8vIG5ldyBmcmFnbWVudHMgYXQgdGhlIGVuZC4uLlxuICBcdGlmIChmaXJzdENoYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHQvLyAuLi51bmxlc3MgdGhlcmUgYXJlIG5vIG5ldyBmcmFnbWVudHMgdG8gYWRkXG4gIFx0XHRpZiAodGhpcy5sZW5ndGggPT09IG5ld0xlbmd0aCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZpcnN0Q2hhbmdlID0gdGhpcy5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0dGhpcy5sZW5ndGggPSB0aGlzLmZyYWdtZW50cy5sZW5ndGggPSBuZXdMZW5ndGg7XG5cbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHR9XG5cbiAgXHQvLyBQcmVwYXJlIG5ldyBmcmFnbWVudCBvcHRpb25zXG4gIFx0ZnJhZ21lbnRPcHRpb25zID0ge1xuICBcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZixcbiAgXHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fTtcblxuICBcdC8vIEFkZCBhcyBtYW55IG5ldyBmcmFnbWVudHMgYXMgd2UgbmVlZCB0bywgb3IgYWRkIGJhY2sgZXhpc3RpbmdcbiAgXHQvLyAoZGV0YWNoZWQpIGZyYWdtZW50c1xuICBcdGZvciAoaSA9IGZpcnN0Q2hhbmdlOyBpIDwgbmV3TGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGZyYWdtZW50ID0gcmVib3VuZEZyYWdtZW50c1tpXTtcblxuICBcdFx0aWYgKCFmcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLnB1c2goaSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnRzW2ldID0gZnJhZ21lbnQ7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gc2h1ZmZsZV9fYmxpbmRSZWJpbmQoZGVwKSB7XG4gIFx0Ly8gdGhlIGtleXBhdGggZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgaGVyZSBhcyBpdCB3b24ndCBoYXZlIGNoYW5nZWRcbiAgXHRkZXAucmViaW5kKFwiXCIsIFwiXCIpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9yZWJpbmQgPSBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdE11c3RhY2hlLnJlYmluZC5jYWxsKHRoaXMsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICB9O1xuXG4gIHZhciBTZWN0aW9uX3Byb3RvdHlwZV9yZW5kZXIgPSBTZWN0aW9uJHJlbmRlcjtcblxuICBmdW5jdGlvbiBTZWN0aW9uJHJlbmRlcigpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0cmV0dXJuIF90aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoZi5yZW5kZXIoKSk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHMuc2xpY2UoKTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvUmVuZGVyID0gW107XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICB9XG5cbiAgdmFyIHNldFZhbHVlID0gU2VjdGlvbiRzZXRWYWx1ZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJHNldFZhbHVlKHZhbHVlKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciB3cmFwcGVyLCBmcmFnbWVudE9wdGlvbnM7XG5cbiAgXHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0Ly8gSWYgYSBjaGlsZCBvZiB0aGlzIHNlY3Rpb24gY2F1c2VzIGEgcmUtZXZhbHVhdGlvbiAtIGZvciBleGFtcGxlLCBhblxuICBcdFx0Ly8gZXhwcmVzc2lvbiByZWZlcnMgdG8gYSBmdW5jdGlvbiB0aGF0IG11dGF0ZXMgdGhlIGFycmF5IHRoYXQgdGhpc1xuICBcdFx0Ly8gc2VjdGlvbiBkZXBlbmRzIG9uIC0gd2UnbGwgZW5kIHVwIHdpdGggYSBkb3VibGUgcmVuZGVyaW5nIGJ1ZyAoc2VlXG4gIFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLzc0OCkuIFRoaXMgcHJldmVudHMgaXQuXG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cbiAgXHQvLyB3aXRoIHNlY3Rpb25zLCB3ZSBuZWVkIHRvIGdldCB0aGUgZmFrZSB2YWx1ZSBpZiB3ZSBoYXZlIGEgd3JhcHBlZCBvYmplY3RcbiAgXHRpZiAodGhpcy5rZXlwYXRoICYmICh3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkW3RoaXMua2V5cGF0aC5zdHJdKSkge1xuICBcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdH1cblxuICBcdC8vIElmIGFueSBmcmFnbWVudHMgYXJlIGF3YWl0aW5nIGNyZWF0aW9uIGFmdGVyIGEgc3BsaWNlLFxuICBcdC8vIHRoaXMgaXMgdGhlIHBsYWNlIHRvIGRvIGl0XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUubGVuZ3RoKSB7XG4gIFx0XHRmcmFnbWVudE9wdGlvbnMgPSB7XG4gIFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYgfHwgW10sXG4gIFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0cEVsZW1lbnQ6IHRoaXMucEVsZW1lbnQsXG4gIFx0XHRcdG93bmVyOiB0aGlzXG4gIFx0XHR9O1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gIFx0XHRcdHZhciBmcmFnbWVudDtcblxuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IF90aGlzLmtleXBhdGguam9pbihpbmRleCk7XG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGluZGV4O1xuXG4gIFx0XHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcbiAgXHRcdFx0X3RoaXMuZnJhZ21lbnRzVG9SZW5kZXIucHVzaChfdGhpcy5mcmFnbWVudHNbaW5kZXhdID0gZnJhZ21lbnQpO1xuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUubGVuZ3RoID0gMDtcbiAgXHR9IGVsc2UgaWYgKHJlZXZhbHVhdGVTZWN0aW9uKHRoaXMsIHZhbHVlKSkge1xuICBcdFx0dGhpcy5idWJibGUoKTtcblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgdmFsdWUsIG9iaikge1xuICBcdGlmICh2YWx1ZSA9PT0gU0VDVElPTl9FQUNIKSB7XG4gIFx0XHQvLyBtYWtlIHN1cmUgcmVmIHR5cGUgaXMgdXAgdG8gZGF0ZSBmb3Iga2V5IG9yIHZhbHVlIGluZGljZXNcbiAgXHRcdGlmIChzZWN0aW9uLmluZGV4UmVmcyAmJiBzZWN0aW9uLmluZGV4UmVmc1swXSkge1xuICBcdFx0XHR2YXIgcmVmID0gc2VjdGlvbi5pbmRleFJlZnNbMF07XG5cbiAgXHRcdFx0Ly8gd2hlbiBzd2l0Y2hpbmcgZmxhdm9ycywgbWFrZSBzdXJlIHRoZSBzZWN0aW9uIGdldHMgdXBkYXRlZFxuICBcdFx0XHRpZiAob2JqICYmIHJlZi50ID09PSBcImlcIiB8fCAhb2JqICYmIHJlZi50ID09PSBcImtcIikge1xuICBcdFx0XHRcdC8vIGlmIHN3aXRjaGluZyBmcm9tIG9iamVjdCB0byBsaXN0LCB1bmJpbmQgYWxsIG9mIHRoZSBvbGQgZnJhZ21lbnRzXG4gIFx0XHRcdFx0aWYgKCFvYmopIHtcbiAgXHRcdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMDtcbiAgXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNsaWNlKDApO1xuICBcdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdFx0XHRcdFx0cmV0dXJuIGYudW5iaW5kKCk7XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZWYudCA9IG9iaiA/IFwia1wiIDogXCJpXCI7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0c2VjdGlvbi5jdXJyZW50U3VidHlwZSA9IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZVNlY3Rpb24oc2VjdGlvbiwgdmFsdWUpIHtcbiAgXHR2YXIgZnJhZ21lbnRPcHRpb25zID0ge1xuICBcdFx0dGVtcGxhdGU6IHNlY3Rpb24udGVtcGxhdGUuZiB8fCBbXSxcbiAgXHRcdHJvb3Q6IHNlY3Rpb24ucm9vdCxcbiAgXHRcdHBFbGVtZW50OiBzZWN0aW9uLnBhcmVudEZyYWdtZW50LnBFbGVtZW50LFxuICBcdFx0b3duZXI6IHNlY3Rpb25cbiAgXHR9O1xuXG4gIFx0c2VjdGlvbi5oYXNDb250ZXh0ID0gdHJ1ZTtcblxuICBcdC8vIElmIHdlIGFscmVhZHkga25vdyB0aGUgc2VjdGlvbiB0eXBlLCBncmVhdFxuICBcdC8vIFRPRE8gY2FuIHRoaXMgYmUgb3B0aW1pc2VkPyBpLmUuIHBpY2sgYW4gcmVldmFsdWF0ZVNlY3Rpb24gZnVuY3Rpb24gZHVyaW5nIGluaXRcbiAgXHQvLyBhbmQgYXZvaWQgZG9pbmcgdGhpcyBlYWNoIHRpbWU/XG4gIFx0aWYgKHNlY3Rpb24uc3VidHlwZSkge1xuICBcdFx0c3dpdGNoIChzZWN0aW9uLnN1YnR5cGUpIHtcbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX0lGOlxuICBcdFx0XHRcdHNlY3Rpb24uaGFzQ29udGV4dCA9IGZhbHNlO1xuICBcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmYWxzZSwgZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRjYXNlIFNFQ1RJT05fVU5MRVNTOlxuICBcdFx0XHRcdHNlY3Rpb24uaGFzQ29udGV4dCA9IGZhbHNlO1xuICBcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCB0cnVlLCBmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdGNhc2UgU0VDVElPTl9XSVRIOlxuICBcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRjYXNlIFNFQ1RJT05fSUZfV0lUSDpcbiAgXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX0VBQ0g6XG4gIFx0XHRcdFx0aWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICBcdFx0XHRcdFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgc2VjdGlvbi5zdWJ0eXBlLCB0cnVlKTtcbiAgXHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gRmFsbHRocm91Z2ggLSBpZiBpdCdzIGEgY29uZGl0aW9uYWwgb3IgYW4gYXJyYXkgd2UgbmVlZCB0byBjb250aW51ZVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIHdvcmsgb3V0IHdoYXQgc29ydCBvZiBzZWN0aW9uIHdlJ3JlIGRlYWxpbmcgd2l0aFxuICBcdHNlY3Rpb24ub3JkZXJlZCA9ICEhaXNBcnJheUxpa2UodmFsdWUpO1xuXG4gIFx0Ly8gT3JkZXJlZCBsaXN0IHNlY3Rpb25cbiAgXHRpZiAoc2VjdGlvbi5vcmRlcmVkKSB7XG4gIFx0XHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBTRUNUSU9OX0VBQ0gsIGZhbHNlKTtcbiAgXHRcdHJldHVybiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0Ly8gVW5vcmRlcmVkIGxpc3QsIG9yIGNvbnRleHRcbiAgXHRpZiAoaXNPYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHQvLyBJbmRleCByZWZlcmVuY2UgaW5kaWNhdGVzIHNlY3Rpb24gc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBsaXN0XG4gIFx0XHRpZiAoc2VjdGlvbi50ZW1wbGF0ZS5pKSB7XG4gIFx0XHRcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIFNFQ1RJT05fRUFDSCwgdHJ1ZSk7XG4gIFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIE90aGVyd2lzZSwgb2JqZWN0IHByb3ZpZGVzIGNvbnRleHQgZm9yIGNvbnRlbnRzXG4gIFx0XHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBTRUNUSU9OX1dJVEgsIGZhbHNlKTtcbiAgXHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zKTtcbiAgXHR9XG5cbiAgXHQvLyBDb25kaXRpb25hbCBzZWN0aW9uXG4gIFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgU0VDVElPTl9JRiwgZmFsc2UpO1xuICBcdHNlY3Rpb24uaGFzQ29udGV4dCA9IGZhbHNlO1xuICBcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmYWxzZSwgZnJhZ21lbnRPcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVMaXN0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0dmFyIGksIGxlbmd0aCwgZnJhZ21lbnQ7XG5cbiAgXHRsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgXHRpZiAobGVuZ3RoID09PSBzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0Ly8gTm90aGluZyB0byBkb1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdC8vIGlmIHRoZSBhcnJheSBpcyBzaG9ydGVyIHRoYW4gaXQgd2FzIHByZXZpb3VzbHksIHJlbW92ZSBpdGVtc1xuICBcdGlmIChsZW5ndGggPCBzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKGxlbmd0aCwgc2VjdGlvbi5sZW5ndGggLSBsZW5ndGgpO1xuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHR9XG5cbiAgXHQvLyBvdGhlcndpc2UuLi5cbiAgXHRlbHNlIHtcbiAgXHRcdGlmIChsZW5ndGggPiBzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0XHQvLyBhZGQgYW55IG5ldyBvbmVzXG4gIFx0XHRcdGZvciAoaSA9IHNlY3Rpb24ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0XHQvLyBhcHBlbmQgbGlzdCBpdGVtIHRvIGNvbnRleHQgc3RhY2tcbiAgXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aC5qb2luKGkpO1xuICBcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGk7XG5cbiAgXHRcdFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKHNlY3Rpb24uZnJhZ21lbnRzW2ldID0gZnJhZ21lbnQpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0c2VjdGlvbi5sZW5ndGggPSBsZW5ndGg7XG4gIFx0cmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucykge1xuICBcdHZhciBpZCwgaSwgaGFzS2V5LCBmcmFnbWVudCwgY2hhbmdlZCwgZGVwcztcblxuICBcdGhhc0tleSA9IHNlY3Rpb24uaGFzS2V5IHx8IChzZWN0aW9uLmhhc0tleSA9IHt9KTtcblxuICBcdC8vIHJlbW92ZSBhbnkgZnJhZ21lbnRzIHRoYXQgc2hvdWxkIG5vIGxvbmdlciBleGlzdFxuICBcdGkgPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1tpXTtcblxuICBcdFx0aWYgKCEoZnJhZ21lbnQua2V5IGluIHZhbHVlKSkge1xuICBcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLnB1c2goZnJhZ21lbnQpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoaSwgMSk7XG5cbiAgXHRcdFx0aGFzS2V5W2ZyYWdtZW50LmtleV0gPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBub3RpZnkgYW55IGRlcGVuZGVudHMgYWJvdXQgY2hhbmdlZCBpbmRpY2VzXG4gIFx0aSA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzW2ldO1xuXG4gIFx0XHRpZiAoZnJhZ21lbnQuaW5kZXggIT09IGkpIHtcbiAgXHRcdFx0ZnJhZ21lbnQuaW5kZXggPSBpO1xuICBcdFx0XHRpZiAoZGVwcyA9IGZyYWdtZW50LnJlZ2lzdGVyZWRJbmRleFJlZnMpIHtcbiAgXHRcdFx0XHRkZXBzLmZvckVhY2goc2V0VmFsdWVfX2JsaW5kUmViaW5kKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGFkZCBhbnkgdGhhdCBoYXZlbid0IGJlZW4gY3JlYXRlZCB5ZXRcbiAgXHRpID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaWQgaW4gdmFsdWUpIHtcbiAgXHRcdGlmICghaGFzS2V5W2lkXSkge1xuICBcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aC5qb2luKGlkKTtcbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmtleSA9IGlkO1xuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpKys7XG5cbiAgXHRcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaChmcmFnbWVudCk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnB1c2goZnJhZ21lbnQpO1xuICBcdFx0XHRoYXNLZXlbaWRdID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRzZWN0aW9uLmxlbmd0aCA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRyZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVDb25kaXRpb25hbENvbnRleHRTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHRpZiAodmFsdWUpIHtcbiAgXHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoc2VjdGlvbik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucykge1xuICBcdHZhciBmcmFnbWVudDtcblxuICBcdC8vIC4uLnRoZW4gaWYgaXQgaXNuJ3QgcmVuZGVyZWQsIHJlbmRlciBpdCwgYWRkaW5nIHNlY3Rpb24ua2V5cGF0aCB0byB0aGUgY29udGV4dCBzdGFja1xuICBcdC8vIChpZiBpdCBpcyBhbHJlYWR5IHJlbmRlcmVkLCB0aGVuIGFueSBjaGlsZHJlbiBkZXBlbmRlbnQgb24gdGhlIGNvbnRleHQgc3RhY2tcbiAgXHQvLyB3aWxsIHVwZGF0ZSB0aGVtc2VsdmVzIHdpdGhvdXQgYW55IHByb21wdGluZylcbiAgXHRpZiAoIXNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHQvLyBhcHBlbmQgdGhpcyBzZWN0aW9uIHRvIHRoZSBjb250ZXh0IHN0YWNrXG4gIFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aDtcbiAgXHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IDA7XG5cbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKHNlY3Rpb24uZnJhZ21lbnRzWzBdID0gZnJhZ21lbnQpO1xuICBcdFx0c2VjdGlvbi5sZW5ndGggPSAxO1xuXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBpbnZlcnRlZCwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0dmFyIGRvUmVuZGVyLCBlbXB0eUFycmF5LCBlbXB0eU9iamVjdCwgZnJhZ21lbnQsIG5hbWU7XG5cbiAgXHRlbXB0eUFycmF5ID0gaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgXHRlbXB0eU9iamVjdCA9IGZhbHNlO1xuICBcdGlmICghaXNBcnJheUxpa2UodmFsdWUpICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICBcdFx0ZW1wdHlPYmplY3QgPSB0cnVlO1xuICBcdFx0Zm9yIChuYW1lIGluIHZhbHVlKSB7XG4gIFx0XHRcdGVtcHR5T2JqZWN0ID0gZmFsc2U7XG4gIFx0XHRcdGJyZWFrO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChpbnZlcnRlZCkge1xuICBcdFx0ZG9SZW5kZXIgPSBlbXB0eUFycmF5IHx8IGVtcHR5T2JqZWN0IHx8ICF2YWx1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZG9SZW5kZXIgPSB2YWx1ZSAmJiAhZW1wdHlBcnJheSAmJiAhZW1wdHlPYmplY3Q7XG4gIFx0fVxuXG4gIFx0aWYgKGRvUmVuZGVyKSB7XG4gIFx0XHRpZiAoIXNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHRcdC8vIG5vIGNoYW5nZSB0byBjb250ZXh0IHN0YWNrXG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IDA7XG5cbiAgXHRcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goc2VjdGlvbi5mcmFnbWVudHNbMF0gPSBmcmFnbWVudCk7XG4gIFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMTtcblxuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHNlY3Rpb24ubGVuZ3RoID4gMSkge1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoMSk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKHNlY3Rpb24pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoc2VjdGlvbikge1xuICBcdGlmIChzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKDAsIHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aCkuZmlsdGVyKGlzUmVuZGVyZWQpO1xuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHRcdHNlY3Rpb24ubGVuZ3RoID0gc2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5sZW5ndGggPSAwO1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gaXNSZW5kZXJlZChmcmFnbWVudCkge1xuICBcdHJldHVybiBmcmFnbWVudC5yZW5kZXJlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFZhbHVlX19ibGluZFJlYmluZChkZXApIHtcbiAgXHQvLyB0aGUga2V5cGF0aCBkb2Vzbid0IGFjdHVhbGx5IG1hdHRlciBoZXJlIGFzIGl0IHdvbid0IGhhdmUgY2hhbmdlZFxuICBcdGRlcC5yZWJpbmQoXCJcIiwgXCJcIik7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3RvU3RyaW5nID0gU2VjdGlvbiR0b1N0cmluZztcblxuICBmdW5jdGlvbiBTZWN0aW9uJHRvU3RyaW5nKGVzY2FwZSkge1xuICBcdHZhciBzdHIsIGksIGxlbjtcblxuICBcdHN0ciA9IFwiXCI7XG5cbiAgXHRpID0gMDtcbiAgXHRsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0c3RyICs9IHRoaXMuZnJhZ21lbnRzW2ldLnRvU3RyaW5nKGVzY2FwZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdW5iaW5kID0gU2VjdGlvbiR1bmJpbmQ7XG4gIGZ1bmN0aW9uIFNlY3Rpb24kdW5iaW5kKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRyZXR1cm4gcmVtb3ZlRnJvbUFycmF5KF90aGlzLmZyYWdtZW50cywgZik7XG4gIFx0fSk7XG4gIFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuICBcdHNoYXJlZF91bmJpbmQuY2FsbCh0aGlzKTtcblxuICBcdHRoaXMubGVuZ3RoID0gMDtcbiAgXHR0aGlzLnVuYm91bmQgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV91bnJlbmRlciA9IFNlY3Rpb24kdW5yZW5kZXI7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChzaG91bGREZXN0cm95ID8gdW5yZW5kZXJBbmREZXN0cm95IDogcHJvdG90eXBlX3VucmVuZGVyX191bnJlbmRlcik7XG4gIFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IFtdO1xuICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucmVuZGVyQW5kRGVzdHJveShmcmFnbWVudCkge1xuICBcdGZyYWdtZW50LnVucmVuZGVyKHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvdG90eXBlX3VucmVuZGVyX191bnJlbmRlcihmcmFnbWVudCkge1xuICBcdGZyYWdtZW50LnVucmVuZGVyKGZhbHNlKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdXBkYXRlID0gU2VjdGlvbiR1cGRhdGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiR1cGRhdGUoKSB7XG4gIFx0dmFyIGZyYWdtZW50LCByZW5kZXJJbmRleCwgcmVuZGVyZWRGcmFnbWVudHMsIGFuY2hvciwgdGFyZ2V0LCBpLCBsZW47XG5cbiAgXHQvLyBgdGhpcy5yZW5kZXJlZEZyYWdtZW50c2AgaXMgaW4gdGhlIG9yZGVyIG9mIHRoZSBwcmV2aW91cyByZW5kZXIuXG4gIFx0Ly8gSWYgZnJhZ21lbnRzIGhhdmUgc2h1ZmZsZWQgYWJvdXQsIHRoaXMgYWxsb3dzIHVzIHRvIHF1aWNrbHlcbiAgXHQvLyByZWluc2VydCB0aGVtIGluIHRoZSBjb3JyZWN0IHBsYWNlXG4gIFx0cmVuZGVyZWRGcmFnbWVudHMgPSB0aGlzLnJlbmRlcmVkRnJhZ21lbnRzO1xuXG4gIFx0Ly8gUmVtb3ZlIGZyYWdtZW50cyB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgZm9yIGRlc3RydWN0aW9uXG4gIFx0d2hpbGUgKGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNUb1VucmVuZGVyLnBvcCgpKSB7XG4gIFx0XHRmcmFnbWVudC51bnJlbmRlcih0cnVlKTtcbiAgXHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZShyZW5kZXJlZEZyYWdtZW50cy5pbmRleE9mKGZyYWdtZW50KSwgMSk7XG4gIFx0fVxuXG4gIFx0Ly8gUmVuZGVyIG5ldyBmcmFnbWVudHMgKGJ1dCBkb24ndCBpbnNlcnQgdGhlbSB5ZXQpXG4gIFx0d2hpbGUgKGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNUb1JlbmRlci5zaGlmdCgpKSB7XG4gIFx0XHRmcmFnbWVudC5yZW5kZXIoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG4gIFx0fVxuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0ZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgXHRcdHJlbmRlckluZGV4ID0gcmVuZGVyZWRGcmFnbWVudHMuaW5kZXhPZihmcmFnbWVudCwgaSk7IC8vIHNlYXJjaCBmcm9tIGN1cnJlbnQgaW5kZXggLSBpdCdzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHNhbWUgb3IgaGlnaGVyXG5cbiAgXHRcdGlmIChyZW5kZXJJbmRleCA9PT0gaSkge1xuICBcdFx0XHQvLyBhbHJlYWR5IGluIHRoZSByaWdodCBwbGFjZS4gaW5zZXJ0IGFjY3VtdWxhdGVkIG5vZGVzIChpZiBhbnkpIGFuZCBjYXJyeSBvblxuICBcdFx0XHRpZiAodGhpcy5kb2NGcmFnLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0YW5jaG9yID0gZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG4gIFx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmRvY0ZyYWcsIGFuY2hvcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKGZyYWdtZW50LmRldGFjaCgpKTtcblxuICBcdFx0Ly8gdXBkYXRlIHJlbmRlcmVkRnJhZ21lbnRzXG4gIFx0XHRpZiAocmVuZGVySW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZShyZW5kZXJJbmRleCwgMSk7XG4gIFx0XHR9XG4gIFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UoaSwgMCwgZnJhZ21lbnQpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLnJlbmRlcmVkICYmIHRoaXMuZG9jRnJhZy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICBcdFx0YW5jaG9yID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jRnJhZywgYW5jaG9yKTtcbiAgXHR9XG5cbiAgXHQvLyBTYXZlIHRoZSByZW5kZXJpbmcgb3JkZXIgZm9yIG5leHQgdGltZVxuICBcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cy5zbGljZSgpO1xuICB9XG5cbiAgdmFyIFNlY3Rpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IFNFQ1RJT047XG4gIFx0dGhpcy5zdWJ0eXBlID0gdGhpcy5jdXJyZW50U3VidHlwZSA9IG9wdGlvbnMudGVtcGxhdGUubjtcbiAgXHR0aGlzLmludmVydGVkID0gdGhpcy5zdWJ0eXBlID09PSBTRUNUSU9OX1VOTEVTUztcblxuICBcdHRoaXMucEVsZW1lbnQgPSBvcHRpb25zLnBFbGVtZW50O1xuXG4gIFx0dGhpcy5mcmFnbWVudHMgPSBbXTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlID0gW107XG4gIFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9VbnJlbmRlciA9IFtdO1xuXG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUuaSkge1xuICBcdFx0dGhpcy5pbmRleFJlZnMgPSBvcHRpb25zLnRlbXBsYXRlLmkuc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbiAoaywgaSkge1xuICBcdFx0XHRyZXR1cm4geyBuOiBrLCB0OiBpID09PSAwID8gXCJrXCIgOiBcImlcIiB9O1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IFtdO1xuXG4gIFx0dGhpcy5sZW5ndGggPSAwOyAvLyBudW1iZXIgb2YgdGltZXMgdGhpcyBzZWN0aW9uIGlzIHJlbmRlcmVkXG5cbiAgXHRNdXN0YWNoZS5pbml0KHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIFNlY3Rpb24ucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogU2VjdGlvbl9wcm90b3R5cGVfYnViYmxlLFxuICBcdGRldGFjaDogU2VjdGlvbl9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IGZpbmQsXG4gIFx0ZmluZEFsbDogZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcbiAgXHRmaW5kTmV4dE5vZGU6IGZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcbiAgXHRnZXRJbmRleFJlZjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdGlmICh0aGlzLmluZGV4UmVmcykge1xuICBcdFx0XHR2YXIgaSA9IHRoaXMuaW5kZXhSZWZzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdHZhciByZWYgPSB0aGlzLmluZGV4UmVmc1tpXTtcbiAgXHRcdFx0XHRpZiAocmVmLm4gPT09IG5hbWUpIHtcbiAgXHRcdFx0XHRcdHJldHVybiByZWY7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcbiAgXHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG4gIFx0c2h1ZmZsZTogc2h1ZmZsZSxcbiAgXHRyZWJpbmQ6IHByb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVuZGVyOiBTZWN0aW9uX3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcbiAgXHRzZXRWYWx1ZTogc2V0VmFsdWUsXG4gIFx0dG9TdHJpbmc6IHByb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IHByb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IHByb3RvdHlwZV91bnJlbmRlcixcbiAgXHR1cGRhdGU6IHByb3RvdHlwZV91cGRhdGVcbiAgfTtcblxuICB2YXIgX1NlY3Rpb24gPSBTZWN0aW9uO1xuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX2RldGFjaCA9IFRyaXBsZSRkZXRhY2g7XG5cbiAgZnVuY3Rpb24gVHJpcGxlJGRldGFjaCgpIHtcbiAgXHR2YXIgbGVuLCBpO1xuXG4gIFx0aWYgKHRoaXMuZG9jRnJhZykge1xuICBcdFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKHRoaXMubm9kZXNbaV0pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICBcdH1cbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX2ZpbmQgPSBUcmlwbGUkZmluZDtcbiAgZnVuY3Rpb24gVHJpcGxlJGZpbmQoc2VsZWN0b3IpIHtcbiAgXHR2YXIgaSwgbGVuLCBub2RlLCBxdWVyeVJlc3VsdDtcblxuICBcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0bm9kZSA9IHRoaXMubm9kZXNbaV07XG5cbiAgXHRcdGlmIChub2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWF0Y2hlcyhub2RlLCBzZWxlY3RvcikpIHtcbiAgXHRcdFx0cmV0dXJuIG5vZGU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChxdWVyeVJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgXHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfZmluZEFsbCA9IFRyaXBsZSRmaW5kQWxsO1xuICBmdW5jdGlvbiBUcmlwbGUkZmluZEFsbChzZWxlY3RvciwgcXVlcnlSZXN1bHQpIHtcbiAgXHR2YXIgaSwgbGVuLCBub2RlLCBxdWVyeUFsbFJlc3VsdCwgbnVtTm9kZXMsIGo7XG5cbiAgXHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG5vZGUgPSB0aGlzLm5vZGVzW2ldO1xuXG4gIFx0XHRpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1hdGNoZXMobm9kZSwgc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHF1ZXJ5UmVzdWx0LnB1c2gobm9kZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChxdWVyeUFsbFJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpIHtcbiAgXHRcdFx0bnVtTm9kZXMgPSBxdWVyeUFsbFJlc3VsdC5sZW5ndGg7XG4gIFx0XHRcdGZvciAoaiA9IDA7IGogPCBudW1Ob2RlczsgaiArPSAxKSB7XG4gIFx0XHRcdFx0cXVlcnlSZXN1bHQucHVzaChxdWVyeUFsbFJlc3VsdFtqXSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9maXJzdE5vZGUgPSBUcmlwbGUkZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIFRyaXBsZSRmaXJzdE5vZGUoKSB7XG4gIFx0aWYgKHRoaXMucmVuZGVyZWQgJiYgdGhpcy5ub2Rlc1swXSkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZXNbMF07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICB9XG5cbiAgdmFyIGVsZW1lbnRDYWNoZSA9IHt9LFxuICAgICAgaWVCdWcsXG4gICAgICBpZUJsYWNrbGlzdDtcblxuICB0cnkge1xuICBcdGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKS5pbm5lckhUTUwgPSBcImZvb1wiO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHRpZUJ1ZyA9IHRydWU7XG5cbiAgXHRpZUJsYWNrbGlzdCA9IHtcbiAgXHRcdFRBQkxFOiBbXCI8dGFibGUgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvdGFibGU+XCJdLFxuICBcdFx0VEhFQUQ6IFtcIjx0YWJsZT48dGhlYWQgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvdGhlYWQ+PC90YWJsZT5cIl0sXG4gIFx0XHRUQk9EWTogW1wiPHRhYmxlPjx0Ym9keSBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiXSxcbiAgXHRcdFRSOiBbXCI8dGFibGU+PHRyIGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3RyPjwvdGFibGU+XCJdLFxuICBcdFx0U0VMRUNUOiBbXCI8c2VsZWN0IGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3NlbGVjdD5cIl1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIGluc2VydEh0bWwgPSBmdW5jdGlvbiAoaHRtbCwgbm9kZSwgZG9jRnJhZykge1xuICBcdHZhciBjb250YWluZXIsXG4gIFx0ICAgIG5vZGVzID0gW10sXG4gIFx0ICAgIHdyYXBwZXIsXG4gIFx0ICAgIHNlbGVjdGVkT3B0aW9uLFxuICBcdCAgICBjaGlsZCxcbiAgXHQgICAgaTtcblxuICBcdC8vIHJlbmRlciAwIGFuZCBmYWxzZVxuICBcdGlmIChodG1sICE9IG51bGwgJiYgaHRtbCAhPT0gXCJcIikge1xuICBcdFx0aWYgKGllQnVnICYmICh3cmFwcGVyID0gaWVCbGFja2xpc3Rbbm9kZS50YWdOYW1lXSkpIHtcbiAgXHRcdFx0Y29udGFpbmVyID0gZWxlbWVudChcIkRJVlwiKTtcbiAgXHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IHdyYXBwZXJbMF0gKyBodG1sICsgd3JhcHBlclsxXTtcbiAgXHRcdFx0Y29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIueFwiKTtcblxuICBcdFx0XHRpZiAoY29udGFpbmVyLnRhZ05hbWUgPT09IFwiU0VMRUNUXCIpIHtcbiAgXHRcdFx0XHRzZWxlY3RlZE9wdGlvbiA9IGNvbnRhaW5lci5vcHRpb25zW2NvbnRhaW5lci5zZWxlY3RlZEluZGV4XTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5zdmcpIHtcbiAgXHRcdFx0Y29udGFpbmVyID0gZWxlbWVudChcIkRJVlwiKTtcbiAgXHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2ZyBjbGFzcz1cXFwieFxcXCI+XCIgKyBodG1sICsgXCI8L3N2Zz5cIjtcbiAgXHRcdFx0Y29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIueFwiKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQobm9kZS50YWdOYW1lKTtcbiAgXHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgXHRcdFx0aWYgKGNvbnRhaW5lci50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gIFx0XHRcdFx0c2VsZWN0ZWRPcHRpb24gPSBjb250YWluZXIub3B0aW9uc1tjb250YWluZXIuc2VsZWN0ZWRJbmRleF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0d2hpbGUgKGNoaWxkID0gY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgXHRcdFx0bm9kZXMucHVzaChjaGlsZCk7XG4gIFx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUaGlzIGlzIHJlYWxseSBhbm5veWluZy4gRXh0cmFjdGluZyA8b3B0aW9uPiBub2RlcyBmcm9tIHRoZVxuICBcdFx0Ly8gdGVtcG9yYXJ5IGNvbnRhaW5lciA8c2VsZWN0PiBjYXVzZXMgdGhlIHJlbWFpbmluZyBvbmVzIHRvXG4gIFx0XHQvLyBiZWNvbWUgc2VsZWN0ZWQuIFNvIG5vdyB3ZSBoYXZlIHRvIGRlc2VsZWN0IHRoZW0uIElFOCwgeW91XG4gIFx0XHQvLyBhbWF6ZSBtZS4gWW91IHJlYWxseSBkb1xuICBcdFx0Ly8gLi4uYW5kIG5vdyBDaHJvbWUgdG9vXG4gIFx0XHRpZiAobm9kZS50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gIFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRpZiAobm9kZXNbaV0gIT09IHNlbGVjdGVkT3B0aW9uKSB7XG4gIFx0XHRcdFx0XHRub2Rlc1tpXS5zZWxlY3RlZCA9IGZhbHNlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBub2RlcztcbiAgfTtcblxuICBmdW5jdGlvbiBlbGVtZW50KHRhZ05hbWUpIHtcbiAgXHRyZXR1cm4gZWxlbWVudENhY2hlW3RhZ05hbWVdIHx8IChlbGVtZW50Q2FjaGVbdGFnTmFtZV0gPSBjcmVhdGVFbGVtZW50KHRhZ05hbWUpKTtcbiAgfVxuXG4gIHZhciBoZWxwZXJzX3VwZGF0ZVNlbGVjdCA9IHVwZGF0ZVNlbGVjdDtcblxuICBmdW5jdGlvbiB1cGRhdGVTZWxlY3QocGFyZW50RWxlbWVudCkge1xuICBcdHZhciBzZWxlY3RlZE9wdGlvbnMsIG9wdGlvbiwgdmFsdWU7XG5cbiAgXHRpZiAoIXBhcmVudEVsZW1lbnQgfHwgcGFyZW50RWxlbWVudC5uYW1lICE9PSBcInNlbGVjdFwiIHx8ICFwYXJlbnRFbGVtZW50LmJpbmRpbmcpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRzZWxlY3RlZE9wdGlvbnMgPSB0b0FycmF5KHBhcmVudEVsZW1lbnQubm9kZS5vcHRpb25zKS5maWx0ZXIoaXNTZWxlY3RlZCk7XG5cbiAgXHQvLyBJZiBvbmUgb2YgdGhlbSBoYWQgYSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSwgd2UgbmVlZCB0byBzeW5jXG4gIFx0Ly8gdGhlIG1vZGVsIHRvIHRoZSB2aWV3XG4gIFx0aWYgKHBhcmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikpIHtcbiAgXHRcdHZhbHVlID0gc2VsZWN0ZWRPcHRpb25zLm1hcChmdW5jdGlvbiAobykge1xuICBcdFx0XHRyZXR1cm4gby52YWx1ZTtcbiAgXHRcdH0pO1xuICBcdH0gZWxzZSBpZiAob3B0aW9uID0gc2VsZWN0ZWRPcHRpb25zWzBdKSB7XG4gIFx0XHR2YWx1ZSA9IG9wdGlvbi52YWx1ZTtcbiAgXHR9XG5cbiAgXHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0cGFyZW50RWxlbWVudC5iaW5kaW5nLnNldFZhbHVlKHZhbHVlKTtcbiAgXHR9XG5cbiAgXHRwYXJlbnRFbGVtZW50LmJ1YmJsZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTZWxlY3RlZChvcHRpb24pIHtcbiAgXHRyZXR1cm4gb3B0aW9uLnNlbGVjdGVkO1xuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfcmVuZGVyID0gVHJpcGxlJHJlbmRlcjtcbiAgZnVuY3Rpb24gVHJpcGxlJHJlbmRlcigpIHtcbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHJlbmRlciBhbiBpdGVtIHRoYXQgd2FzIGFscmVhZHkgcmVuZGVyZWRcIik7XG4gIFx0fVxuXG4gIFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBcdHRoaXMubm9kZXMgPSBpbnNlcnRIdG1sKHRoaXMudmFsdWUsIHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpLCB0aGlzLmRvY0ZyYWcpO1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG4gIFx0aGVscGVyc191cGRhdGVTZWxlY3QodGhpcy5wRWxlbWVudCk7XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9zZXRWYWx1ZSA9IFRyaXBsZSRzZXRWYWx1ZTtcbiAgZnVuY3Rpb24gVHJpcGxlJHNldFZhbHVlKHZhbHVlKSB7XG4gIFx0dmFyIHdyYXBwZXI7XG5cbiAgXHQvLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBhcHByb2FjaCB0aGlzP1xuICBcdGlmICh3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkW3RoaXMua2V5cGF0aC5zdHJdKSB7XG4gIFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0fVxuXG4gIFx0aWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX3RvU3RyaW5nID0gVHJpcGxlJHRvU3RyaW5nO1xuICBmdW5jdGlvbiBUcmlwbGUkdG9TdHJpbmcoKSB7XG4gIFx0cmV0dXJuIHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkID8gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyhcIlwiICsgdGhpcy52YWx1ZSkgOiBcIlwiO1xuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfdW5yZW5kZXIgPSBUcmlwbGUkdW5yZW5kZXI7XG4gIGZ1bmN0aW9uIFRyaXBsZSR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0aWYgKHRoaXMucmVuZGVyZWQgJiYgc2hvdWxkRGVzdHJveSkge1xuICBcdFx0dGhpcy5ub2Rlcy5mb3JFYWNoKGRldGFjaE5vZGUpO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICBcdH1cblxuICBcdC8vIFRPRE8gdXBkYXRlIGxpdmUgcXVlcmllc1xuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfdXBkYXRlID0gVHJpcGxlJHVwZGF0ZTtcbiAgZnVuY3Rpb24gVHJpcGxlJHVwZGF0ZSgpIHtcbiAgXHR2YXIgbm9kZSwgcGFyZW50Tm9kZTtcblxuICBcdGlmICghdGhpcy5yZW5kZXJlZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFJlbW92ZSBleGlzdGluZyBub2Rlc1xuICBcdHdoaWxlICh0aGlzLm5vZGVzICYmIHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gIFx0XHRub2RlID0gdGhpcy5ub2Rlcy5wb3AoKTtcbiAgXHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgXHR9XG5cbiAgXHQvLyBJbnNlcnQgbmV3IG5vZGVzXG4gIFx0cGFyZW50Tm9kZSA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuXG4gIFx0dGhpcy5ub2RlcyA9IGluc2VydEh0bWwodGhpcy52YWx1ZSwgcGFyZW50Tm9kZSwgdGhpcy5kb2NGcmFnKTtcbiAgXHRwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmRvY0ZyYWcsIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpKTtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHdlJ3JlIGluc2VydGluZyB0aGUgY29udGVudHMgb2YgYSA8c2VsZWN0PlxuICBcdGhlbHBlcnNfdXBkYXRlU2VsZWN0KHRoaXMucEVsZW1lbnQpO1xuICB9XG5cbiAgdmFyIFRyaXBsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gVFJJUExFO1xuICBcdE11c3RhY2hlLmluaXQodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgVHJpcGxlLnByb3RvdHlwZSA9IHtcbiAgXHRkZXRhY2g6IFRyaXBsZV9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IFRyaXBsZV9wcm90b3R5cGVfZmluZCxcbiAgXHRmaW5kQWxsOiBUcmlwbGVfcHJvdG90eXBlX2ZpbmRBbGwsXG4gIFx0Zmlyc3ROb2RlOiBUcmlwbGVfcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG4gIFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG4gIFx0cmVuZGVyOiBUcmlwbGVfcHJvdG90eXBlX3JlbmRlcixcbiAgXHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuICBcdHNldFZhbHVlOiBwcm90b3R5cGVfc2V0VmFsdWUsXG4gIFx0dG9TdHJpbmc6IFRyaXBsZV9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBzaGFyZWRfdW5iaW5kLFxuICBcdHVucmVuZGVyOiBUcmlwbGVfcHJvdG90eXBlX3VucmVuZGVyLFxuICBcdHVwZGF0ZTogVHJpcGxlX3Byb3RvdHlwZV91cGRhdGVcbiAgfTtcblxuICB2YXIgX1RyaXBsZSA9IFRyaXBsZTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfYnViYmxlID0gZnVuY3Rpb24gKCkge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2RldGFjaCA9IEVsZW1lbnQkZGV0YWNoO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkZGV0YWNoKCkge1xuICBcdHZhciBub2RlID0gdGhpcy5ub2RlLFxuICBcdCAgICBwYXJlbnROb2RlO1xuXG4gIFx0aWYgKG5vZGUpIHtcbiAgXHRcdC8vIG5lZWQgdG8gY2hlY2sgZm9yIHBhcmVudCBub2RlIC0gRE9NIG1heSBoYXZlIGJlZW4gYWx0ZXJlZFxuICBcdFx0Ly8gYnkgc29tZXRoaW5nIG90aGVyIHRoYW4gUmFjdGl2ZSEgZS5nLiBqUXVlcnkgVUkuLi5cbiAgXHRcdGlmIChwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gIFx0XHRcdHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBub2RlO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0aWYgKCF0aGlzLm5vZGUpIHtcbiAgXHRcdC8vIHRoaXMgZWxlbWVudCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXRcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmIChtYXRjaGVzKHRoaXMubm9kZSwgc2VsZWN0b3IpKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuZnJhZ21lbnQuZmluZCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kQWxsID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdC8vIEFkZCB0aGlzIG5vZGUgdG8gdGhlIHF1ZXJ5LCBpZiBhcHBsaWNhYmxlLCBhbmQgcmVnaXN0ZXIgdGhlXG4gIFx0Ly8gcXVlcnkgb24gdGhpcyBlbGVtZW50XG4gIFx0aWYgKHF1ZXJ5Ll90ZXN0KHRoaXMsIHRydWUpICYmIHF1ZXJ5LmxpdmUpIHtcbiAgXHRcdCh0aGlzLmxpdmVRdWVyaWVzIHx8ICh0aGlzLmxpdmVRdWVyaWVzID0gW10pKS5wdXNoKHF1ZXJ5KTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSA9IEVsZW1lbnQkZmluZE5leHROb2RlO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkZmluZE5leHROb2RlKCkge1xuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSA9IEVsZW1lbnQkZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkZmlyc3ROb2RlKCkge1xuICBcdHJldHVybiB0aGlzLm5vZGU7XG4gIH1cblxuICB2YXIgZ2V0QXR0cmlidXRlID0gRWxlbWVudCRnZXRBdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gRWxlbWVudCRnZXRBdHRyaWJ1dGUobmFtZSkge1xuICBcdGlmICghdGhpcy5hdHRyaWJ1dGVzIHx8ICF0aGlzLmF0dHJpYnV0ZXNbbmFtZV0pIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW25hbWVdLnZhbHVlO1xuICB9XG5cbiAgdmFyIHRydXRoeSA9IC9edHJ1ZXxvbnx5ZXN8MSQvaTtcbiAgdmFyIHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlc19faXNOdW1lcmljID0gL15bMC05XSskLztcblxuICB2YXIgcHJvY2Vzc0JpbmRpbmdBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRlbXBsYXRlKSB7XG4gIFx0dmFyIHZhbCwgYXR0cnMsIGF0dHJpYnV0ZXM7XG5cbiAgXHRhdHRyaWJ1dGVzID0gdGVtcGxhdGUuYSB8fCB7fTtcbiAgXHRhdHRycyA9IHt9O1xuXG4gIFx0Ly8gYXR0cmlidXRlcyB0aGF0IGFyZSBwcmVzZW50IGJ1dCBkb24ndCBoYXZlIGEgdmFsdWUgKD0pXG4gIFx0Ly8gd2lsbCBiZSBzZXQgdG8gdGhlIG51bWJlciAwLCB3aGljaCB3ZSBjb25kaWRlciB0byBiZSB0cnVlXG4gIFx0Ly8gdGhlIHN0cmluZyAnMCcsIGhvd2V2ZXIgaXMgZmFsc2VcblxuICBcdHZhbCA9IGF0dHJpYnV0ZXMudHdvd2F5O1xuICBcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0YXR0cnMudHdvd2F5ID0gdmFsID09PSAwIHx8IHRydXRoeS50ZXN0KHZhbCk7XG4gIFx0fVxuXG4gIFx0dmFsID0gYXR0cmlidXRlcy5sYXp5O1xuICBcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0Ly8gY2hlY2sgZm9yIHRpbWVvdXQgdmFsdWVcbiAgXHRcdGlmICh2YWwgIT09IDAgJiYgcHJvY2Vzc0JpbmRpbmdBdHRyaWJ1dGVzX19pc051bWVyaWMudGVzdCh2YWwpKSB7XG4gIFx0XHRcdGF0dHJzLmxhenkgPSBwYXJzZUludCh2YWwpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0YXR0cnMubGF6eSA9IHZhbCA9PT0gMCB8fCB0cnV0aHkudGVzdCh2YWwpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBhdHRycztcbiAgfTtcblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV9idWJibGUgPSBBdHRyaWJ1dGUkYnViYmxlO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkYnViYmxlKCkge1xuICBcdHZhciB2YWx1ZSA9IHRoaXMudXNlUHJvcGVydHkgfHwgIXRoaXMucmVuZGVyZWQgPyB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCkgOiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG5cbiAgXHQvLyBUT0RPIHRoaXMgY2FuIHJlZ2lzdGVyIHRoZSBhdHRyaWJ1dGUgbXVsdGlwbGUgdGltZXMgKHNlZSByZW5kZXIgdGVzdFxuICBcdC8vICdBdHRyaWJ1dGUgd2l0aCBuZXN0ZWQgbXVzdGFjaGVzJylcbiAgXHRpZiAoIWlzRXF1YWwodmFsdWUsIHRoaXMudmFsdWUpKSB7XG5cbiAgXHRcdC8vIE5lZWQgdG8gY2xlYXIgb2xkIGlkIGZyb20gcmFjdGl2ZS5ub2Rlc1xuICBcdFx0aWYgKHRoaXMubmFtZSA9PT0gXCJpZFwiICYmIHRoaXMudmFsdWUpIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMucm9vdC5ub2Rlc1t0aGlzLnZhbHVlXTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHRpZiAodGhpcy5uYW1lID09PSBcInZhbHVlXCIgJiYgdGhpcy5ub2RlKSB7XG4gIFx0XHRcdC8vIFdlIG5lZWQgdG8gc3RvcmUgdGhlIHZhbHVlIG9uIHRoZSBET00gbGlrZSB0aGlzIHNvIHdlXG4gIFx0XHRcdC8vIGNhbiByZXRyaWV2ZSBpdCBsYXRlciB3aXRob3V0IGl0IGJlaW5nIGNvZXJjZWQgdG8gYSBzdHJpbmdcbiAgXHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHN2Z0NhbWVsQ2FzZUVsZW1lbnRzLCBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzLCBjcmVhdGVNYXAsIG1hcDtcbiAgc3ZnQ2FtZWxDYXNlRWxlbWVudHMgPSBcImFsdEdseXBoIGFsdEdseXBoRGVmIGFsdEdseXBoSXRlbSBhbmltYXRlQ29sb3IgYW5pbWF0ZU1vdGlvbiBhbmltYXRlVHJhbnNmb3JtIGNsaXBQYXRoIGZlQmxlbmQgZmVDb2xvck1hdHJpeCBmZUNvbXBvbmVudFRyYW5zZmVyIGZlQ29tcG9zaXRlIGZlQ29udm9sdmVNYXRyaXggZmVEaWZmdXNlTGlnaHRpbmcgZmVEaXNwbGFjZW1lbnRNYXAgZmVEaXN0YW50TGlnaHQgZmVGbG9vZCBmZUZ1bmNBIGZlRnVuY0IgZmVGdW5jRyBmZUZ1bmNSIGZlR2F1c3NpYW5CbHVyIGZlSW1hZ2UgZmVNZXJnZSBmZU1lcmdlTm9kZSBmZU1vcnBob2xvZ3kgZmVPZmZzZXQgZmVQb2ludExpZ2h0IGZlU3BlY3VsYXJMaWdodGluZyBmZVNwb3RMaWdodCBmZVRpbGUgZmVUdXJidWxlbmNlIGZvcmVpZ25PYmplY3QgZ2x5cGhSZWYgbGluZWFyR3JhZGllbnQgcmFkaWFsR3JhZGllbnQgdGV4dFBhdGggdmtlcm5cIi5zcGxpdChcIiBcIik7XG4gIHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMgPSBcImF0dHJpYnV0ZU5hbWUgYXR0cmlidXRlVHlwZSBiYXNlRnJlcXVlbmN5IGJhc2VQcm9maWxlIGNhbGNNb2RlIGNsaXBQYXRoVW5pdHMgY29udGVudFNjcmlwdFR5cGUgY29udGVudFN0eWxlVHlwZSBkaWZmdXNlQ29uc3RhbnQgZWRnZU1vZGUgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCBmaWx0ZXJSZXMgZmlsdGVyVW5pdHMgZ2x5cGhSZWYgZ3JhZGllbnRUcmFuc2Zvcm0gZ3JhZGllbnRVbml0cyBrZXJuZWxNYXRyaXgga2VybmVsVW5pdExlbmd0aCBrZXlQb2ludHMga2V5U3BsaW5lcyBrZXlUaW1lcyBsZW5ndGhBZGp1c3QgbGltaXRpbmdDb25lQW5nbGUgbWFya2VySGVpZ2h0IG1hcmtlclVuaXRzIG1hcmtlcldpZHRoIG1hc2tDb250ZW50VW5pdHMgbWFza1VuaXRzIG51bU9jdGF2ZXMgcGF0aExlbmd0aCBwYXR0ZXJuQ29udGVudFVuaXRzIHBhdHRlcm5UcmFuc2Zvcm0gcGF0dGVyblVuaXRzIHBvaW50c0F0WCBwb2ludHNBdFkgcG9pbnRzQXRaIHByZXNlcnZlQWxwaGEgcHJlc2VydmVBc3BlY3RSYXRpbyBwcmltaXRpdmVVbml0cyByZWZYIHJlZlkgcmVwZWF0Q291bnQgcmVwZWF0RHVyIHJlcXVpcmVkRXh0ZW5zaW9ucyByZXF1aXJlZEZlYXR1cmVzIHNwZWN1bGFyQ29uc3RhbnQgc3BlY3VsYXJFeHBvbmVudCBzcHJlYWRNZXRob2Qgc3RhcnRPZmZzZXQgc3RkRGV2aWF0aW9uIHN0aXRjaFRpbGVzIHN1cmZhY2VTY2FsZSBzeXN0ZW1MYW5ndWFnZSB0YWJsZVZhbHVlcyB0YXJnZXRYIHRhcmdldFkgdGV4dExlbmd0aCB2aWV3Qm94IHZpZXdUYXJnZXQgeENoYW5uZWxTZWxlY3RvciB5Q2hhbm5lbFNlbGVjdG9yIHpvb21BbmRQYW5cIi5zcGxpdChcIiBcIik7XG5cbiAgY3JlYXRlTWFwID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gIFx0dmFyIG1hcCA9IHt9LFxuICBcdCAgICBpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdG1hcFtpdGVtc1tpXS50b0xvd2VyQ2FzZSgpXSA9IGl0ZW1zW2ldO1xuICBcdH1cbiAgXHRyZXR1cm4gbWFwO1xuICB9O1xuXG4gIG1hcCA9IGNyZWF0ZU1hcChzdmdDYW1lbENhc2VFbGVtZW50cy5jb25jYXQoc3ZnQ2FtZWxDYXNlQXR0cmlidXRlcykpO1xuXG4gIHZhciBlbmZvcmNlQ2FzZSA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSkge1xuICBcdHZhciBsb3dlckNhc2VFbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIFx0cmV0dXJuIG1hcFtsb3dlckNhc2VFbGVtZW50TmFtZV0gfHwgbG93ZXJDYXNlRWxlbWVudE5hbWU7XG4gIH07XG5cbiAgdmFyIGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBuYW1lKSB7XG4gIFx0dmFyIGNvbG9uSW5kZXgsIG5hbWVzcGFjZVByZWZpeDtcblxuICBcdC8vIGFyZSB3ZSBkZWFsaW5nIHdpdGggYSBuYW1lc3BhY2VkIGF0dHJpYnV0ZSwgZS5nLiB4bGluazpocmVmP1xuICBcdGNvbG9uSW5kZXggPSBuYW1lLmluZGV4T2YoXCI6XCIpO1xuICBcdGlmIChjb2xvbkluZGV4ICE9PSAtMSkge1xuXG4gIFx0XHQvLyBsb29rcyBsaWtlIHdlIGFyZSwgeWVzLi4uXG4gIFx0XHRuYW1lc3BhY2VQcmVmaXggPSBuYW1lLnN1YnN0cigwLCBjb2xvbkluZGV4KTtcblxuICBcdFx0Ly8gLi4udW5sZXNzIGl0J3MgYSBuYW1lc3BhY2UgKmRlY2xhcmF0aW9uKiwgd2hpY2ggd2UgaWdub3JlIChvbiB0aGUgYXNzdW1wdGlvblxuICBcdFx0Ly8gdGhhdCBvbmx5IHZhbGlkIG5hbWVzcGFjZXMgd2lsbCBiZSB1c2VkKVxuICBcdFx0aWYgKG5hbWVzcGFjZVByZWZpeCAhPT0gXCJ4bWxuc1wiKSB7XG4gIFx0XHRcdG5hbWUgPSBuYW1lLnN1YnN0cmluZyhjb2xvbkluZGV4ICsgMSk7XG5cbiAgXHRcdFx0YXR0cmlidXRlLm5hbWUgPSBlbmZvcmNlQ2FzZShuYW1lKTtcbiAgXHRcdFx0YXR0cmlidXRlLm5hbWVzcGFjZSA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlUHJlZml4LnRvTG93ZXJDYXNlKCldO1xuICBcdFx0XHRhdHRyaWJ1dGUubmFtZXNwYWNlUHJlZml4ID0gbmFtZXNwYWNlUHJlZml4O1xuXG4gIFx0XHRcdGlmICghYXR0cmlidXRlLm5hbWVzcGFjZSkge1xuICBcdFx0XHRcdHRocm93IFwiVW5rbm93biBuYW1lc3BhY2UgKFxcXCJcIiArIG5hbWVzcGFjZVByZWZpeCArIFwiXFxcIilcIjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBTVkcgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlIHNlbnNpdGl2ZVxuICBcdGF0dHJpYnV0ZS5uYW1lID0gYXR0cmlidXRlLmVsZW1lbnQubmFtZXNwYWNlICE9PSBuYW1lc3BhY2VzLmh0bWwgPyBlbmZvcmNlQ2FzZShuYW1lKSA6IG5hbWU7XG4gIH07XG5cbiAgdmFyIGhlbHBlcnNfZ2V0SW50ZXJwb2xhdG9yID0gZ2V0SW50ZXJwb2xhdG9yO1xuICBmdW5jdGlvbiBnZXRJbnRlcnBvbGF0b3IoYXR0cmlidXRlKSB7XG4gIFx0dmFyIGl0ZW1zID0gYXR0cmlidXRlLmZyYWdtZW50Lml0ZW1zO1xuXG4gIFx0aWYgKGl0ZW1zLmxlbmd0aCAhPT0gMSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmIChpdGVtc1swXS50eXBlID09PSBJTlRFUlBPTEFUT1IpIHtcbiAgXHRcdHJldHVybiBpdGVtc1swXTtcbiAgXHR9XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2luaXQgPSBBdHRyaWJ1dGUkaW5pdDtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJGluaXQob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IEFUVFJJQlVURTtcbiAgXHR0aGlzLmVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuXG4gIFx0ZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSh0aGlzLCBvcHRpb25zLm5hbWUpO1xuICBcdHRoaXMuaXNCb29sZWFuID0gYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCh0aGlzLm5hbWUpO1xuXG4gIFx0Ly8gaWYgaXQncyBhbiBlbXB0eSBhdHRyaWJ1dGUsIG9yIGp1c3QgYSBzdHJhaWdodCBrZXktdmFsdWUgcGFpciwgd2l0aCBub1xuICBcdC8vIG11c3RhY2hlIHNoZW5hbmlnYW5zLCBzZXQgdGhlIGF0dHJpYnV0ZSBhY2NvcmRpbmdseSBhbmQgZ28gaG9tZVxuICBcdGlmICghb3B0aW9ucy52YWx1ZSB8fCB0eXBlb2Ygb3B0aW9ucy52YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0dGhpcy52YWx1ZSA9IHRoaXMuaXNCb29sZWFuID8gdHJ1ZSA6IG9wdGlvbnMudmFsdWUgfHwgXCJcIjtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBkbyBzb21lIHdvcmtcblxuICBcdC8vIHNoYXJlIHBhcmVudEZyYWdtZW50IHdpdGggcGFyZW50IGVsZW1lbnRcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdHRlbXBsYXRlOiBvcHRpb25zLnZhbHVlLFxuICBcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0b3duZXI6IHRoaXNcbiAgXHR9KTtcblxuICBcdC8vIFRPRE8gY2FuIHdlIHVzZSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCkgaW4gc29tZSBjYXNlcz8gSXQncyBxdWlja2VyXG4gIFx0dGhpcy52YWx1ZSA9IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblxuICBcdC8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoaXMgYXR0cmlidXRlJ3MgaW50ZXJwb2xhdG9yLCBpZiBpdHMgZnJhZ21lbnRcbiAgXHQvLyB0YWtlcyB0aGUgZm9ybSBge3tmb299fWAuIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciB0d28td2F5IGJpbmRpbmcgYW5kXG4gIFx0Ly8gZm9yIGNvcnJlY3RseSByZW5kZXJpbmcgSFRNTCBsYXRlclxuICBcdHRoaXMuaW50ZXJwb2xhdG9yID0gaGVscGVyc19nZXRJbnRlcnBvbGF0b3IodGhpcyk7XG4gIFx0dGhpcy5pc0JpbmRhYmxlID0gISF0aGlzLmludGVycG9sYXRvciAmJiAhdGhpcy5pbnRlcnBvbGF0b3IuaXNTdGF0aWM7XG5cbiAgXHQvLyBtYXJrIGFzIHJlYWR5XG4gIFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIH1cblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV9yZWJpbmQgPSBBdHRyaWJ1dGUkcmViaW5kO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV9yZW5kZXIgPSBBdHRyaWJ1dGUkcmVuZGVyO1xuICB2YXIgcHJvcGVydHlOYW1lcyA9IHtcbiAgXHRcImFjY2VwdC1jaGFyc2V0XCI6IFwiYWNjZXB0Q2hhcnNldFwiLFxuICBcdGFjY2Vzc2tleTogXCJhY2Nlc3NLZXlcIixcbiAgXHRiZ2NvbG9yOiBcImJnQ29sb3JcIixcbiAgXHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCIsXG4gIFx0Y29kZWJhc2U6IFwiY29kZUJhc2VcIixcbiAgXHRjb2xzcGFuOiBcImNvbFNwYW5cIixcbiAgXHRjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCIsXG4gIFx0ZGF0ZXRpbWU6IFwiZGF0ZVRpbWVcIixcbiAgXHRkaXJuYW1lOiBcImRpck5hbWVcIixcbiAgXHRcImZvclwiOiBcImh0bWxGb3JcIixcbiAgXHRcImh0dHAtZXF1aXZcIjogXCJodHRwRXF1aXZcIixcbiAgXHRpc21hcDogXCJpc01hcFwiLFxuICBcdG1heGxlbmd0aDogXCJtYXhMZW5ndGhcIixcbiAgXHRub3ZhbGlkYXRlOiBcIm5vVmFsaWRhdGVcIixcbiAgXHRwdWJkYXRlOiBcInB1YkRhdGVcIixcbiAgXHRyZWFkb25seTogXCJyZWFkT25seVwiLFxuICBcdHJvd3NwYW46IFwicm93U3BhblwiLFxuICBcdHRhYmluZGV4OiBcInRhYkluZGV4XCIsXG4gIFx0dXNlbWFwOiBcInVzZU1hcFwiXG4gIH07XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSRyZW5kZXIobm9kZSkge1xuICBcdHZhciBwcm9wZXJ0eU5hbWU7XG5cbiAgXHR0aGlzLm5vZGUgPSBub2RlO1xuXG4gIFx0Ly8gc2hvdWxkIHdlIHVzZSBkaXJlY3QgcHJvcGVydHkgYWNjZXNzLCBvciBzZXRBdHRyaWJ1dGU/XG4gIFx0aWYgKCFub2RlLm5hbWVzcGFjZVVSSSB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sKSB7XG4gIFx0XHRwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVzW3RoaXMubmFtZV0gfHwgdGhpcy5uYW1lO1xuXG4gIFx0XHRpZiAobm9kZVtwcm9wZXJ0eU5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlzIGF0dHJpYnV0ZSBhIGJvb2xlYW4gYXR0cmlidXRlIG9yICd2YWx1ZSc/IElmIHNvIHdlJ3JlIGJldHRlciBvZmYgZG9pbmcgZS5nLlxuICBcdFx0Ly8gbm9kZS5zZWxlY3RlZCA9IHRydWUgcmF0aGVyIHRoYW4gbm9kZS5zZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcsICcnIClcbiAgXHRcdGlmICh0aGlzLmlzQm9vbGVhbiB8fCB0aGlzLmlzVHdvd2F5KSB7XG4gIFx0XHRcdHRoaXMudXNlUHJvcGVydHkgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocHJvcGVydHlOYW1lID09PSBcInZhbHVlXCIpIHtcbiAgXHRcdFx0bm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHRoaXMudmFsdWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0dGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3RvU3RyaW5nID0gQXR0cmlidXRlJHRvU3RyaW5nO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR0b1N0cmluZygpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgXHR2YXIgbmFtZXNwYWNlUHJlZml4ID0gX3JlZi5uYW1lc3BhY2VQcmVmaXg7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgXHR2YXIgaW50ZXJwb2xhdG9yID0gX3JlZi5pbnRlcnBvbGF0b3I7XG4gIFx0dmFyIGZyYWdtZW50ID0gX3JlZi5mcmFnbWVudDtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdCBhbmQgdGV4dGFyZWEgdmFsdWVzIChzaG91bGQgbm90IGJlIHN0cmluZ2lmaWVkKVxuICBcdGlmIChuYW1lID09PSBcInZhbHVlXCIgJiYgKHRoaXMuZWxlbWVudC5uYW1lID09PSBcInNlbGVjdFwiIHx8IHRoaXMuZWxlbWVudC5uYW1lID09PSBcInRleHRhcmVhXCIpKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudCBlZGl0YWJsZVxuICBcdGlmIChuYW1lID09PSBcInZhbHVlXCIgJiYgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZXNcbiAgXHRpZiAobmFtZSA9PT0gXCJuYW1lXCIgJiYgdGhpcy5lbGVtZW50Lm5hbWUgPT09IFwiaW5wdXRcIiAmJiBpbnRlcnBvbGF0b3IpIHtcbiAgXHRcdHJldHVybiBcIm5hbWU9e3tcIiArIChpbnRlcnBvbGF0b3Iua2V5cGF0aC5zdHIgfHwgaW50ZXJwb2xhdG9yLnJlZikgKyBcIn19XCI7XG4gIFx0fVxuXG4gIFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzXG4gIFx0aWYgKHRoaXMuaXNCb29sZWFuKSB7XG4gIFx0XHRyZXR1cm4gdmFsdWUgPyBuYW1lIDogXCJcIjtcbiAgXHR9XG5cbiAgXHRpZiAoZnJhZ21lbnQpIHtcbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIHRoaXMgY2F0Y2hlcyB1bmRlZmluZWQvbnVsbCB2YWx1ZXMgKCMxMjExKVxuICBcdFx0aWYgKGZyYWdtZW50Lml0ZW1zLmxlbmd0aCA9PT0gMSAmJiBmcmFnbWVudC5pdGVtc1swXS52YWx1ZSA9PSBudWxsKSB7XG4gIFx0XHRcdHJldHVybiBcIlwiO1xuICBcdFx0fVxuXG4gIFx0XHR2YWx1ZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0fVxuXG4gIFx0aWYgKG5hbWVzcGFjZVByZWZpeCkge1xuICBcdFx0bmFtZSA9IG5hbWVzcGFjZVByZWZpeCArIFwiOlwiICsgbmFtZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWUgPyBuYW1lICsgXCI9XFxcIlwiICsgQXR0cmlidXRlX3Byb3RvdHlwZV90b1N0cmluZ19fZXNjYXBlKHZhbHVlKSArIFwiXFxcIlwiIDogbmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZV9wcm90b3R5cGVfdG9TdHJpbmdfX2VzY2FwZSh2YWx1ZSkge1xuICBcdHJldHVybiB2YWx1ZS5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikucmVwbGFjZSgvJy9nLCBcIiYjMzk7XCIpO1xuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfdW5iaW5kID0gQXR0cmlidXRlJHVuYmluZDtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdW5iaW5kKCkge1xuICBcdC8vIGlnbm9yZSBub24tZHluYW1pYyBhdHRyaWJ1dGVzXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJpZFwiKSB7XG4gIFx0XHRkZWxldGUgdGhpcy5yb290Lm5vZGVzW3RoaXMudmFsdWVdO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVTZWxlY3RWYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVTZWxlY3Q7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVNlbGVjdCgpIHtcbiAgXHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLFxuICBcdCAgICBvcHRpb25zLFxuICBcdCAgICBvcHRpb24sXG4gIFx0ICAgIG9wdGlvblZhbHVlLFxuICBcdCAgICBpO1xuXG4gIFx0aWYgKCF0aGlzLmxvY2tlZCkge1xuICBcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcbiAgXHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuICBcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTsgLy8gb3B0aW9ucyBpbnNlcnRlZCB2aWEgYSB0cmlwbGUgZG9uJ3QgaGF2ZSBfcmFjdGl2ZVxuXG4gIFx0XHRcdGlmIChvcHRpb25WYWx1ZSA9PSB2YWx1ZSkge1xuICBcdFx0XHRcdC8vIGRvdWJsZSBlcXVhbHMgYXMgd2UgbWF5IGJlIGNvbXBhcmluZyBudW1iZXJzIHdpdGggc3RyaW5nc1xuICBcdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBpZiB3ZSdyZSBzdGlsbCBoZXJlLCBpdCBtZWFucyB0aGUgbmV3IHZhbHVlIGRpZG4ndCBtYXRjaCBhbnkgb2YgdGhlIG9wdGlvbnMuLi5cbiAgXHQvLyBUT0RPIGZpZ3VyZSBvdXQgd2hhdCB0byBkbyBpbiB0aGlzIHNpdHVhdGlvblxuICB9XG5cbiAgdmFyIHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlTXVsdGlwbGVTZWxlY3Q7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVNdWx0aXBsZVNlbGVjdCgpIHtcbiAgXHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLFxuICBcdCAgICBvcHRpb25zLFxuICBcdCAgICBpLFxuICBcdCAgICBvcHRpb24sXG4gIFx0ICAgIG9wdGlvblZhbHVlO1xuXG4gIFx0aWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICBcdFx0dmFsdWUgPSBbdmFsdWVdO1xuICBcdH1cblxuICBcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcbiAgXHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuICBcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7IC8vIG9wdGlvbnMgaW5zZXJ0ZWQgdmlhIGEgdHJpcGxlIGRvbid0IGhhdmUgX3JhY3RpdmVcbiAgXHRcdG9wdGlvbi5zZWxlY3RlZCA9IGFycmF5Q29udGFpbnModmFsdWUsIG9wdGlvblZhbHVlKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlUmFkaW9OYW1lID0gQXR0cmlidXRlJHVwZGF0ZVJhZGlvTmFtZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9OYW1lKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgXHRub2RlLmNoZWNrZWQgPSB2YWx1ZSA9PSBub2RlLl9yYWN0aXZlLnZhbHVlO1xuICB9XG5cbiAgdmFyIHVwZGF0ZVJhZGlvVmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9WYWx1ZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVJhZGlvVmFsdWUoKSB7XG4gIFx0dmFyIHdhc0NoZWNrZWQsXG4gIFx0ICAgIG5vZGUgPSB0aGlzLm5vZGUsXG4gIFx0ICAgIGJpbmRpbmcsXG4gIFx0ICAgIGJpbmRpbmdzLFxuICBcdCAgICBpO1xuXG4gIFx0d2FzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZDtcblxuICBcdG5vZGUudmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0bm9kZS5jaGVja2VkID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcblxuICBcdC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgLSBpZiB0aGUgaW5wdXQgd2FzIGNoZWNrZWQsIGFuZCB0aGUgdmFsdWVcbiAgXHQvLyBjaGFuZ2VkIHNvIHRoYXQgaXQncyBubyBsb25nZXIgY2hlY2tlZCwgdGhlIHR3b3dheSBiaW5kaW5nIGlzXG4gIFx0Ly8gbW9zdCBsaWtlbHkgb3V0IG9mIGRhdGUuIFRvIGZpeCBpdCB3ZSBoYXZlIHRvIGp1bXAgdGhyb3VnaCBzb21lXG4gIFx0Ly8gaG9vcHMuLi4gdGhpcyBpcyBhIGxpdHRsZSBrbHVkZ3kgYnV0IGl0IHdvcmtzXG4gIFx0aWYgKHdhc0NoZWNrZWQgJiYgIW5vZGUuY2hlY2tlZCAmJiB0aGlzLmVsZW1lbnQuYmluZGluZykge1xuICBcdFx0YmluZGluZ3MgPSB0aGlzLmVsZW1lbnQuYmluZGluZy5zaWJsaW5ncztcblxuICBcdFx0aWYgKGkgPSBiaW5kaW5ncy5sZW5ndGgpIHtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcblxuICBcdFx0XHRcdGlmICghYmluZGluZy5lbGVtZW50Lm5vZGUpIHtcbiAgXHRcdFx0XHRcdC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyLCBzaWJsaW5ncyBhcmUgc3RpbGwgcmVuZGVyaW5nIVxuICBcdFx0XHRcdFx0Ly8gd2UnbGwgY29tZSBiYWNrIGxhdGVyLi4uXG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKGJpbmRpbmcuZWxlbWVudC5ub2RlLmNoZWNrZWQpIHtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUoYmluZGluZy5yb290KTtcbiAgXHRcdFx0XHRcdHJldHVybiBiaW5kaW5nLmhhbmRsZUNoYW5nZSgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KGJpbmRpbmcua2V5cGF0aCwgdW5kZWZpbmVkKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlQ2hlY2tib3hOYW1lID0gQXR0cmlidXRlJHVwZGF0ZUNoZWNrYm94TmFtZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNoZWNrYm94TmFtZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgZWxlbWVudCA9IF9yZWYuZWxlbWVudDtcbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO3ZhciBiaW5kaW5nID0gZWxlbWVudC5iaW5kaW5nO3ZhciB2YWx1ZUF0dHJpYnV0ZTt2YXIgaTtcblxuICBcdHZhbHVlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdGJpbmRpbmcuaXNDaGVja2VkID0gbm9kZS5jaGVja2VkID0gdmFsdWUgPT0gdmFsdWVBdHRyaWJ1dGU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGkgPSB2YWx1ZS5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmICh2YWx1ZUF0dHJpYnV0ZSA9PSB2YWx1ZVtpXSkge1xuICBcdFx0XHRcdGJpbmRpbmcuaXNDaGVja2VkID0gbm9kZS5jaGVja2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGJpbmRpbmcuaXNDaGVja2VkID0gbm9kZS5jaGVja2VkID0gZmFsc2U7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZUNsYXNzTmFtZSA9IEF0dHJpYnV0ZSR1cGRhdGVDbGFzc05hbWU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDbGFzc05hbWUoKSB7XG4gIFx0dGhpcy5ub2RlLmNsYXNzTmFtZSA9IHNhZmVUb1N0cmluZ1ZhbHVlKHRoaXMudmFsdWUpO1xuICB9XG5cbiAgdmFyIHVwZGF0ZUlkQXR0cmlidXRlID0gQXR0cmlidXRlJHVwZGF0ZUlkQXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVJZEF0dHJpYnV0ZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuXG4gIFx0dGhpcy5yb290Lm5vZGVzW3ZhbHVlXSA9IG5vZGU7XG4gIFx0bm9kZS5pZCA9IHZhbHVlO1xuICB9XG5cbiAgdmFyIHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUgPSBBdHRyaWJ1dGUkdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSgpIHtcbiAgXHR2YXIgbm9kZSwgdmFsdWU7XG5cbiAgXHRub2RlID0gdGhpcy5ub2RlO1xuICBcdHZhbHVlID0gdGhpcy52YWx1ZTtcblxuICBcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHR2YWx1ZSA9IFwiXCI7XG4gIFx0fVxuXG4gIFx0bm9kZS5zdHlsZS5zZXRBdHRyaWJ1dGUoXCJjc3NUZXh0XCIsIHZhbHVlKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUoKSB7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcblxuICBcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHR2YWx1ZSA9IFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKCF0aGlzLmxvY2tlZCkge1xuICBcdFx0dGhpcy5ub2RlLmlubmVySFRNTCA9IHZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVWYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVWYWx1ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlVmFsdWUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcblxuICBcdC8vIHN0b3JlIGFjdHVhbCB2YWx1ZSwgc28gaXQgZG9lc24ndCBnZXQgY29lcmNlZCB0byBhIHN0cmluZ1xuICBcdG5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblxuICBcdC8vIHdpdGggdHdvLXdheSBiaW5kaW5nLCBvbmx5IHVwZGF0ZSBpZiB0aGUgY2hhbmdlIHdhc24ndCBpbml0aWF0ZWQgYnkgdGhlIHVzZXJcbiAgXHQvLyBvdGhlcndpc2UgdGhlIGN1cnNvciB3aWxsIG9mdGVuIGJlIHNlbnQgdG8gdGhlIHdyb25nIHBsYWNlXG4gIFx0aWYgKCF0aGlzLmxvY2tlZCkge1xuICBcdFx0bm9kZS52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/IFwiXCIgOiB2YWx1ZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlQm9vbGVhbiA9IEF0dHJpYnV0ZSR1cGRhdGVCb29sZWFuQXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVCb29sZWFuQXR0cmlidXRlKCkge1xuICBcdC8vIHdpdGggdHdvLXdheSBiaW5kaW5nLCBvbmx5IHVwZGF0ZSBpZiB0aGUgY2hhbmdlIHdhc24ndCBpbml0aWF0ZWQgYnkgdGhlIHVzZXJcbiAgXHQvLyBvdGhlcndpc2UgdGhlIGN1cnNvciB3aWxsIG9mdGVuIGJlIHNlbnQgdG8gdGhlIHdyb25nIHBsYWNlXG4gIFx0aWYgKCF0aGlzLmxvY2tlZCkge1xuICBcdFx0dGhpcy5ub2RlW3RoaXMucHJvcGVydHlOYW1lXSA9IHRoaXMudmFsdWU7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlID0gQXR0cmlidXRlJHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVFdmVyeXRoaW5nRWxzZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgbmFtZXNwYWNlID0gX3JlZi5uYW1lc3BhY2U7XG4gIFx0dmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgXHR2YXIgZnJhZ21lbnQgPSBfcmVmLmZyYWdtZW50O1xuXG4gIFx0aWYgKG5hbWVzcGFjZSkge1xuICBcdFx0bm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUsIChmcmFnbWVudCB8fCB2YWx1ZSkudG9TdHJpbmcoKSk7XG4gIFx0fSBlbHNlIGlmICghdGhpcy5pc0Jvb2xlYW4pIHtcbiAgXHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gIFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgKGZyYWdtZW50IHx8IHZhbHVlKS50b1N0cmluZygpKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgLSB0cnV0aHkgYmVjb21lcyAnJywgZmFsc3kgbWVhbnMgJ3JlbW92ZSBhdHRyaWJ1dGUnXG4gIFx0ZWxzZSB7XG4gIFx0XHRpZiAodmFsdWUpIHtcbiAgXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgXCJcIik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICAvLyBUaGVyZSBhcmUgYSBmZXcgc3BlY2lhbCBjYXNlcyB3aGVuIGl0IGNvbWVzIHRvIHVwZGF0aW5nIGF0dHJpYnV0ZXMuIEZvciB0aGlzIHJlYXNvbixcbiAgLy8gdGhlIHByb3RvdHlwZSAudXBkYXRlKCkgbWV0aG9kIHBvaW50cyB0byB0aGlzIG1ldGhvZCwgd2hpY2ggd2FpdHMgdW50aWwgdGhlXG4gIC8vIGF0dHJpYnV0ZSBoYXMgZmluaXNoZWQgaW5pdGlhbGlzaW5nLCB0aGVuIHJlcGxhY2VzIHRoZSBwcm90b3R5cGUgbWV0aG9kIHdpdGggYSBtb3JlXG4gIC8vIHN1aXRhYmxlIG9uZS4gVGhhdCB3YXksIHdlIHNhdmUgb3Vyc2VsdmVzIGRvaW5nIGEgYnVuY2ggb2YgdGVzdHMgb24gZWFjaCBjYWxsXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3VwZGF0ZSA9IEF0dHJpYnV0ZSR1cGRhdGU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gIFx0dmFyIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7dmFyIHR5cGU7dmFyIHVwZGF0ZU1ldGhvZDtcblxuICBcdGlmIChuYW1lID09PSBcImlkXCIpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUlkQXR0cmlidXRlO1xuICBcdH0gZWxzZSBpZiAobmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBzZWxlY3RzXG4gIFx0XHRpZiAoZWxlbWVudC5uYW1lID09PSBcInNlbGVjdFwiICYmIG5hbWUgPT09IFwidmFsdWVcIikge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpID8gdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSA6IHVwZGF0ZVNlbGVjdFZhbHVlO1xuICBcdFx0fSBlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwidGV4dGFyZWFcIikge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVWYWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY29udGVudGVkaXRhYmxlXG4gIFx0XHRlbHNlIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSAhPSBudWxsKSB7XG4gIFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSA8aW5wdXQ+XG4gIFx0XHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwiaW5wdXRcIikge1xuICBcdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXG4gIFx0XHRcdC8vIHR5cGU9J2ZpbGUnIHZhbHVlPSd7e2ZpbGVMaXN0fX0nPlxuICBcdFx0XHRpZiAodHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgXHRcdFx0XHR1cGRhdGVNZXRob2QgPSBub29wOyAvLyByZWFkLW9ubHlcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIHR5cGU9J3JhZGlvJyBuYW1lPSd7e3R3b3dheX19J1xuICBcdFx0XHRlbHNlIGlmICh0eXBlID09PSBcInJhZGlvXCIgJiYgZWxlbWVudC5iaW5kaW5nICYmIGVsZW1lbnQuYmluZGluZy5uYW1lID09PSBcIm5hbWVcIikge1xuICBcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVJhZGlvVmFsdWU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlVmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBzcGVjaWFsIGNhc2UgLSA8aW5wdXQgdHlwZT0ncmFkaW8nIG5hbWU9J3t7dHdvd2F5fX0nIHZhbHVlPSdmb28nPlxuICBcdGVsc2UgaWYgKHRoaXMuaXNUd293YXkgJiYgbmFtZSA9PT0gXCJuYW1lXCIpIHtcbiAgXHRcdGlmIChub2RlLnR5cGUgPT09IFwicmFkaW9cIikge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVSYWRpb05hbWU7XG4gIFx0XHR9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gIFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNoZWNrYm94TmFtZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBzcGVjaWFsIGNhc2UgLSBzdHlsZSBhdHRyaWJ1dGVzIGluIEludGVybmV0IEV4cGxvZGVyXG4gIFx0ZWxzZSBpZiAobmFtZSA9PT0gXCJzdHlsZVwiICYmIG5vZGUuc3R5bGUuc2V0QXR0cmlidXRlKSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVJRVN0eWxlQXR0cmlidXRlO1xuICBcdH1cblxuICBcdC8vIHNwZWNpYWwgY2FzZSAtIGNsYXNzIG5hbWVzLiBJRSBmdWNrcyB0aGluZ3MgdXAsIGFnYWluXG4gIFx0ZWxzZSBpZiAobmFtZSA9PT0gXCJjbGFzc1wiICYmICghbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCkpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNsYXNzTmFtZTtcbiAgXHR9IGVsc2UgaWYgKHRoaXMudXNlUHJvcGVydHkpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUJvb2xlYW47XG4gIFx0fVxuXG4gIFx0aWYgKCF1cGRhdGVNZXRob2QpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlO1xuICBcdH1cblxuICBcdHRoaXMudXBkYXRlID0gdXBkYXRlTWV0aG9kO1xuICBcdHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLmluaXQob3B0aW9ucyk7XG4gIH07XG5cbiAgQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IEF0dHJpYnV0ZV9wcm90b3R5cGVfYnViYmxlLFxuICBcdGluaXQ6IHByb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogQXR0cmlidXRlX3Byb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVuZGVyOiBBdHRyaWJ1dGVfcHJvdG90eXBlX3JlbmRlcixcbiAgXHR0b1N0cmluZzogQXR0cmlidXRlX3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IEF0dHJpYnV0ZV9wcm90b3R5cGVfdW5iaW5kLFxuICBcdHVwZGF0ZTogQXR0cmlidXRlX3Byb3RvdHlwZV91cGRhdGVcbiAgfTtcblxuICB2YXIgX0F0dHJpYnV0ZSA9IEF0dHJpYnV0ZTtcblxuICB2YXIgY3JlYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIFx0dmFyIG5hbWUsXG4gIFx0ICAgIGF0dHJpYnV0ZSxcbiAgXHQgICAgcmVzdWx0ID0gW107XG5cbiAgXHRmb3IgKG5hbWUgaW4gYXR0cmlidXRlcykge1xuICBcdFx0Ly8gc2tpcCBiaW5kaW5nIGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChuYW1lID09PSBcInR3b3dheVwiIHx8IG5hbWUgPT09IFwibGF6eVwiKSB7XG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICBcdFx0XHRhdHRyaWJ1dGUgPSBuZXcgX0F0dHJpYnV0ZSh7XG4gIFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcbiAgXHRcdFx0XHRuYW1lOiBuYW1lLFxuICBcdFx0XHRcdHZhbHVlOiBhdHRyaWJ1dGVzW25hbWVdLFxuICBcdFx0XHRcdHJvb3Q6IGVsZW1lbnQucm9vdFxuICBcdFx0XHR9KTtcblxuICBcdFx0XHRyZXN1bHRbbmFtZV0gPSBhdHRyaWJ1dGU7XG5cbiAgXHRcdFx0aWYgKG5hbWUgIT09IFwidmFsdWVcIikge1xuICBcdFx0XHRcdHJlc3VsdC5wdXNoKGF0dHJpYnV0ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyB2YWx1ZSBhdHRyaWJ1dGUgZ29lcyBsYXN0LiBUaGlzIGlzIGJlY2F1c2UgaXRcbiAgXHQvLyBtYXkgZ2V0IGNsYW1wZWQgb24gcmVuZGVyIG90aGVyd2lzZSwgZS5nLiBpblxuICBcdC8vIGA8aW5wdXQgdHlwZT0ncmFuZ2UnIHZhbHVlPSc5OTknIG1pbj0nMCcgbWF4PScxMDAwJz5gXG4gIFx0Ly8gc2luY2UgZGVmYXVsdCBtYXggaXMgMTAwXG4gIFx0aWYgKGF0dHJpYnV0ZSA9IHJlc3VsdC52YWx1ZSkge1xuICBcdFx0cmVzdWx0LnB1c2goYXR0cmlidXRlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBfQ29uZGl0aW9uYWxBdHRyaWJ1dGVfX2RpdjtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0X0NvbmRpdGlvbmFsQXR0cmlidXRlX19kaXYgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB9XG5cbiAgdmFyIENvbmRpdGlvbmFsQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRlbXBsYXRlKSB7XG4gIFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHR0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcblxuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRyb290OiBlbGVtZW50LnJvb3QsXG4gIFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdHRlbXBsYXRlOiBbdGVtcGxhdGVdXG4gIFx0fSk7XG4gIH07XG5cbiAgQ29uZGl0aW9uYWxBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMubm9kZSkge1xuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmVsZW1lbnQuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gIFx0XHR0aGlzLm5vZGUgPSBub2RlO1xuICBcdFx0dGhpcy5pc1N2ZyA9IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLnN2ZztcblxuICBcdFx0dGhpcy51cGRhdGUoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciBzdHIsIGF0dHJzO1xuXG4gIFx0XHRzdHIgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0XHRhdHRycyA9IHBhcnNlQXR0cmlidXRlcyhzdHIsIHRoaXMuaXNTdmcpO1xuXG4gIFx0XHQvLyBhbnkgYXR0cmlidXRlcyB0aGF0IHByZXZpb3VzbHkgZXhpc3RlZCBidXQgbm8gbG9uZ2VyIGRvXG4gIFx0XHQvLyBtdXN0IGJlIHJlbW92ZWRcbiAgXHRcdHRoaXMuYXR0cmlidXRlcy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgXHRcdFx0cmV0dXJuIG5vdEluKGF0dHJzLCBhKTtcbiAgXHRcdH0pLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgXHRcdFx0X3RoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoYS5uYW1lKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRcdF90aGlzLm5vZGUuc2V0QXR0cmlidXRlKGEubmFtZSwgYS52YWx1ZSk7XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgX0NvbmRpdGlvbmFsQXR0cmlidXRlID0gQ29uZGl0aW9uYWxBdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKHN0ciwgaXNTdmcpIHtcbiAgXHR2YXIgdGFnID0gaXNTdmcgPyBcInN2Z1wiIDogXCJkaXZcIjtcbiAgXHRfQ29uZGl0aW9uYWxBdHRyaWJ1dGVfX2Rpdi5pbm5lckhUTUwgPSBcIjxcIiArIHRhZyArIFwiIFwiICsgc3RyICsgXCI+PC9cIiArIHRhZyArIFwiPlwiO1xuXG4gIFx0cmV0dXJuIHRvQXJyYXkoX0NvbmRpdGlvbmFsQXR0cmlidXRlX19kaXYuY2hpbGROb2Rlc1swXS5hdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdEluKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgXHR2YXIgaSA9IGhheXN0YWNrLmxlbmd0aDtcblxuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmIChoYXlzdGFja1tpXS5uYW1lID09PSBuZWVkbGUubmFtZSkge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgXHRpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgXHRcdHJldHVybiBbXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXR0cmlidXRlcy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgXHRcdHJldHVybiBuZXcgX0NvbmRpdGlvbmFsQXR0cmlidXRlKGVsZW1lbnQsIGEpO1xuICBcdH0pO1xuICB9O1xuXG4gIHZhciBCaW5kaW5nID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgXHR2YXIgaW50ZXJwb2xhdG9yLCBrZXlwYXRoLCB2YWx1ZSwgcGFyZW50Rm9ybTtcblxuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuICBcdHRoaXMuYXR0cmlidXRlID0gZWxlbWVudC5hdHRyaWJ1dGVzW3RoaXMubmFtZSB8fCBcInZhbHVlXCJdO1xuXG4gIFx0aW50ZXJwb2xhdG9yID0gdGhpcy5hdHRyaWJ1dGUuaW50ZXJwb2xhdG9yO1xuICBcdGludGVycG9sYXRvci50d293YXlCaW5kaW5nID0gdGhpcztcblxuICBcdGlmIChrZXlwYXRoID0gaW50ZXJwb2xhdG9yLmtleXBhdGgpIHtcbiAgXHRcdGlmIChrZXlwYXRoLnN0ci5zbGljZSgtMSkgPT09IFwifVwiKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhcIlR3by13YXkgYmluZGluZyBkb2VzIG5vdCB3b3JrIHdpdGggZXhwcmVzc2lvbnMgKGAlc2Agb24gPCVzPilcIiwgaW50ZXJwb2xhdG9yLnJlc29sdmVyLnVuaXF1ZVN0cmluZywgZWxlbWVudC5uYW1lLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKFwiVHdvLXdheSBiaW5kaW5nIGRvZXMgbm90IHdvcmsgd2l0aCAlc1wiLCBpbnRlcnBvbGF0b3IucmVzb2x2ZXIucmVmLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBBIG11c3RhY2hlIG1heSBiZSAqYW1iaWd1b3VzKi4gTGV0J3Mgc2F5IHdlIHdlcmUgZ2l2ZW5cbiAgXHRcdC8vIGB2YWx1ZT1cInt7YmFyfX1cImAuIElmIHRoZSBjb250ZXh0IHdhcyBgZm9vYCwgYW5kIGBmb28uYmFyYFxuICBcdFx0Ly8gKndhc24ndCogYHVuZGVmaW5lZGAsIHRoZSBrZXlwYXRoIHdvdWxkIGJlIGBmb28uYmFyYC5cbiAgXHRcdC8vIFRoZW4sIGFueSB1c2VyIGlucHV0IHdvdWxkIHJlc3VsdCBpbiBgZm9vLmJhcmAgYmVpbmcgdXBkYXRlZC5cbiAgXHRcdC8vXG4gIFx0XHQvLyBJZiwgaG93ZXZlciwgYGZvby5iYXJgICp3YXMqIHVuZGVmaW5lZCwgYW5kIHNvIHdhcyBgYmFyYCwgd2Ugd291bGQgYmVcbiAgXHRcdC8vIGxlZnQgd2l0aCBhbiB1bnJlc29sdmVkIHBhcnRpYWwga2V5cGF0aCAtIHNvIHdlIGFyZSBmb3JjZWQgdG8gbWFrZSBhblxuICBcdFx0Ly8gYXNzdW1wdGlvbi4gVGhhdCBhc3N1bXB0aW9uIGlzIHRoYXQgdGhlIGlucHV0IGluIHF1ZXN0aW9uIHNob3VsZFxuICBcdFx0Ly8gYmUgZm9yY2VkIHRvIHJlc29sdmUgdG8gYGJhcmAsIGFuZCBhbnkgdXNlciBpbnB1dCB3b3VsZCBhZmZlY3QgYGJhcmBcbiAgXHRcdC8vIGFuZCBub3QgYGZvby5iYXJgLlxuICBcdFx0Ly9cbiAgXHRcdC8vIERpZCB0aGF0IG1ha2UgYW55IHNlbnNlPyBObz8gT2guIFNvcnJ5LiBXZWxsIHRoZSBtb3JhbCBvZiB0aGUgc3RvcnkgaXNcbiAgXHRcdC8vIGJlIGV4cGxpY2l0IHdoZW4gdXNpbmcgdHdvLXdheSBkYXRhLWJpbmRpbmcgYWJvdXQgd2hhdCBrZXlwYXRoIHlvdSdyZVxuICBcdFx0Ly8gdXBkYXRpbmcuIFVzaW5nIGl0IGluIGxpc3RzIGlzIHByb2JhYmx5IGEgcmVjaXBlIGZvciBjb25mdXNpb24uLi5cbiAgXHRcdHZhciByZWYgPSBpbnRlcnBvbGF0b3IudGVtcGxhdGUuciA/IFwiJ1wiICsgaW50ZXJwb2xhdG9yLnRlbXBsYXRlLnIgKyBcIicgcmVmZXJlbmNlXCIgOiBcImV4cHJlc3Npb25cIjtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiVGhlICVzIGJlaW5nIHVzZWQgZm9yIHR3by13YXkgYmluZGluZyBpcyBhbWJpZ3VvdXMsIGFuZCBtYXkgY2F1c2UgdW5leHBlY3RlZCByZXN1bHRzLiBDb25zaWRlciBpbml0aWFsaXNpbmcgeW91ciBkYXRhIHRvIGVsaW1pbmF0ZSB0aGUgYW1iaWd1aXR5XCIsIHJlZiwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHRpbnRlcnBvbGF0b3IucmVzb2x2ZXIuZm9yY2VSZXNvbHV0aW9uKCk7XG4gIFx0XHRrZXlwYXRoID0gaW50ZXJwb2xhdG9yLmtleXBhdGg7XG4gIFx0fVxuXG4gIFx0dGhpcy5hdHRyaWJ1dGUuaXNUd293YXkgPSB0cnVlO1xuICBcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cbiAgXHQvLyBpbml0aWFsaXNlIHZhbHVlLCBpZiBpdCdzIHVuZGVmaW5lZFxuICBcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxWYWx1ZSkge1xuICBcdFx0dmFsdWUgPSB0aGlzLmdldEluaXRpYWxWYWx1ZSgpO1xuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldChrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHBhcmVudEZvcm0gPSBmaW5kUGFyZW50Rm9ybShlbGVtZW50KSkge1xuICBcdFx0dGhpcy5yZXNldFZhbHVlID0gdmFsdWU7XG4gIFx0XHRwYXJlbnRGb3JtLmZvcm1CaW5kaW5ncy5wdXNoKHRoaXMpO1xuICBcdH1cbiAgfTtcblxuICBCaW5kaW5nLnByb3RvdHlwZSA9IHtcbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMucm9vdCk7XG4gIFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuICBcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQodGhpcy5rZXlwYXRoLCB0aGlzLmdldFZhbHVlKCkpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIF90aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcbiAgXHRcdH0pO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0fSxcblxuICBcdHJlYm91bmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBiaW5kaW5ncywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aDtcblxuICBcdFx0b2xkS2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcbiAgXHRcdG5ld0tleXBhdGggPSB0aGlzLmF0dHJpYnV0ZS5pbnRlcnBvbGF0b3Iua2V5cGF0aDtcblxuICBcdFx0Ly8gVGhlIGF0dHJpYnV0ZSB0aGlzIGJpbmRpbmcgaXMgbGlua2VkIHRvIGhhcyBhbHJlYWR5IGRvbmUgdGhlIHdvcmtcbiAgXHRcdGlmIChvbGRLZXlwYXRoID09PSBuZXdLZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3Nbb2xkS2V5cGF0aC5zdHJdLCB0aGlzKTtcblxuICBcdFx0dGhpcy5rZXlwYXRoID0gbmV3S2V5cGF0aDtcblxuICBcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW25ld0tleXBhdGguc3RyXSB8fCAodGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tuZXdLZXlwYXRoLnN0cl0gPSBbXSk7XG4gIFx0XHRiaW5kaW5ncy5wdXNoKHRoaXMpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHt9XG4gIH07XG5cbiAgQmluZGluZy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICBcdHZhciBQYXJlbnQgPSB0aGlzLFxuICBcdCAgICBTcGVjaWFsaXNlZEJpbmRpbmc7XG5cbiAgXHRTcGVjaWFsaXNlZEJpbmRpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBcdFx0QmluZGluZy5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuXG4gIFx0XHRpZiAodGhpcy5pbml0KSB7XG4gIFx0XHRcdHRoaXMuaW5pdCgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlID0gY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuICBcdHV0aWxzX29iamVjdF9fZXh0ZW5kKFNwZWNpYWxpc2VkQmluZGluZy5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuXG4gIFx0U3BlY2lhbGlzZWRCaW5kaW5nLmV4dGVuZCA9IEJpbmRpbmcuZXh0ZW5kO1xuXG4gIFx0cmV0dXJuIFNwZWNpYWxpc2VkQmluZGluZztcbiAgfTtcblxuICB2YXIgQmluZGluZ19CaW5kaW5nID0gQmluZGluZztcblxuICBmdW5jdGlvbiBmaW5kUGFyZW50Rm9ybShlbGVtZW50KSB7XG4gIFx0d2hpbGUgKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCkge1xuICBcdFx0aWYgKGVsZW1lbnQubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgLy8gdGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBpcyB1bmJvdW5kLlxuICAvLyBTcGVjaWFsaXNlZCBiaW5kaW5ncyBjYW4gb3ZlcnJpZGUgaXRcblxuICAvLyBUaGlzIGlzIHRoZSBoYW5kbGVyIGZvciBET00gZXZlbnRzIHRoYXQgd291bGQgbGVhZCB0byBhIGNoYW5nZSBpbiB0aGUgbW9kZWxcbiAgLy8gKGkuZS4gY2hhbmdlLCBzb21ldGltZXMsIGlucHV0LCBhbmQgb2NjYXNpb25hbGx5IGNsaWNrIGFuZCBrZXl1cClcbiAgdmFyIGhhbmRsZURvbUV2ZW50ID0gaGFuZGxlQ2hhbmdlO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSgpIHtcbiAgXHR0aGlzLl9yYWN0aXZlLmJpbmRpbmcuaGFuZGxlQ2hhbmdlKCk7XG4gIH1cblxuICB2YXIgR2VuZXJpY0JpbmRpbmc7XG5cbiAgR2VuZXJpY0JpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBcIlwiO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLnZhbHVlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGUsXG4gIFx0XHQgICAgbGF6eSxcbiAgXHRcdCAgICB0aW1lb3V0ID0gZmFsc2U7XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblxuICBcdFx0Ly8gYW55IGxhenkgc2V0dGluZyBmb3IgdGhpcyBlbGVtZW50IG92ZXJyaWRlcyB0aGUgcm9vdFxuICBcdFx0Ly8gaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLCBpdCdzIGEgdGltZW91dFxuICBcdFx0bGF6eSA9IHRoaXMucm9vdC5sYXp5O1xuICBcdFx0aWYgKHRoaXMuZWxlbWVudC5sYXp5ID09PSB0cnVlKSB7XG4gIFx0XHRcdGxhenkgPSB0cnVlO1xuICBcdFx0fSBlbHNlIGlmICh0aGlzLmVsZW1lbnQubGF6eSA9PT0gZmFsc2UpIHtcbiAgXHRcdFx0bGF6eSA9IGZhbHNlO1xuICBcdFx0fSBlbHNlIGlmIChpc19faXNOdW1lcmljKHRoaXMuZWxlbWVudC5sYXp5KSkge1xuICBcdFx0XHRsYXp5ID0gZmFsc2U7XG4gIFx0XHRcdHRpbWVvdXQgPSArdGhpcy5lbGVtZW50Lmxhenk7XG4gIFx0XHR9IGVsc2UgaWYgKGlzX19pc051bWVyaWMobGF6eSB8fCBcIlwiKSkge1xuICBcdFx0XHR0aW1lb3V0ID0gK2xhenk7XG4gIFx0XHRcdGxhenkgPSBmYWxzZTtcblxuICBcdFx0XHQvLyBtYWtlIHN1cmUgdGhlIHRpbWVvdXQgaXMgYXZhaWxhYmxlIHRvIHRoZSBoYW5kbGVyXG4gIFx0XHRcdHRoaXMuZWxlbWVudC5sYXp5ID0gdGltZW91dDtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5oYW5kbGVyID0gdGltZW91dCA/IGhhbmRsZURlbGF5IDogaGFuZGxlRG9tRXZlbnQ7XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHRpZiAoIWxhenkpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG5cbiAgXHRcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGhhbmRsZUJsdXIsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgaGFuZGxlQmx1ciwgZmFsc2UpO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfR2VuZXJpY0JpbmRpbmcgPSBHZW5lcmljQmluZGluZztcblxuICBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICBcdHZhciB2YWx1ZTtcblxuICBcdGhhbmRsZURvbUV2ZW50LmNhbGwodGhpcyk7XG5cbiAgXHR2YWx1ZSA9IHRoaXMuX3JhY3RpdmUucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMuX3JhY3RpdmUuYmluZGluZy5rZXlwYXRoKTtcbiAgXHR0aGlzLnZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gXCJcIiA6IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRGVsYXkoKSB7XG4gIFx0dmFyIGJpbmRpbmcgPSB0aGlzLl9yYWN0aXZlLmJpbmRpbmcsXG4gIFx0ICAgIGVsID0gdGhpcztcblxuICBcdGlmICghIWJpbmRpbmcuX3RpbWVvdXQpIGNsZWFyVGltZW91dChiaW5kaW5nLl90aW1lb3V0KTtcblxuICBcdGJpbmRpbmcuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmIChiaW5kaW5nLnJlbmRlcmVkKSBoYW5kbGVEb21FdmVudC5jYWxsKGVsKTtcbiAgXHRcdGJpbmRpbmcuX3RpbWVvdXQgPSB1bmRlZmluZWQ7XG4gIFx0fSwgYmluZGluZy5lbGVtZW50LmxhenkpO1xuICB9XG5cbiAgdmFyIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcgPSBCaW5kaW5nX0dlbmVyaWNCaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmZyYWdtZW50ID8gdGhpcy5lbGVtZW50LmZyYWdtZW50LnRvU3RyaW5nKCkgOiBcIlwiO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmlubmVySFRNTDtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX0NvbnRlbnRFZGl0YWJsZUJpbmRpbmcgPSBDb250ZW50RWRpdGFibGVCaW5kaW5nO1xuXG4gIHZhciBzaGFyZWRfZ2V0U2libGluZ3MgPSBnZXRTaWJsaW5ncztcbiAgdmFyIHNldHMgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0U2libGluZ3MoaWQsIGdyb3VwLCBrZXlwYXRoKSB7XG4gIFx0dmFyIGhhc2ggPSBpZCArIGdyb3VwICsga2V5cGF0aDtcbiAgXHRyZXR1cm4gc2V0c1toYXNoXSB8fCAoc2V0c1toYXNoXSA9IFtdKTtcbiAgfVxuXG4gIHZhciBSYWRpb0JpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRuYW1lOiBcImNoZWNrZWRcIixcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuc2libGluZ3MgPSBzaGFyZWRfZ2V0U2libGluZ3ModGhpcy5yb290Ll9ndWlkLCBcInJhZGlvXCIsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpKTtcbiAgXHRcdHRoaXMuc2libGluZ3MucHVzaCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLnJvb3QpO1xuXG4gIFx0XHR0aGlzLnNpYmxpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgXHRcdFx0YmluZGluZy5yb290LnZpZXdtb2RlbC5zZXQoYmluZGluZy5rZXlwYXRoLCBiaW5kaW5nLmdldFZhbHVlKCkpO1xuICBcdFx0fSk7XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuc2libGluZ3MsIHRoaXMpO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfUmFkaW9CaW5kaW5nID0gUmFkaW9CaW5kaW5nO1xuXG4gIHZhciBSYWRpb05hbWVCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJuYW1lXCIsXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnNpYmxpbmdzID0gc2hhcmVkX2dldFNpYmxpbmdzKHRoaXMucm9vdC5fZ3VpZCwgXCJyYWRpb25hbWVcIiwgdGhpcy5rZXlwYXRoLnN0cik7XG4gIFx0XHR0aGlzLnNpYmxpbmdzLnB1c2godGhpcyk7XG5cbiAgXHRcdHRoaXMucmFkaW9OYW1lID0gdHJ1ZTsgLy8gc28gdGhhdCByYWN0aXZlLnVwZGF0ZU1vZGVsKCkga25vd3Mgd2hhdCB0byBkbyB3aXRoIHRoaXNcbiAgXHR9LFxuXG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImNoZWNrZWRcIikpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLm5hbWUgPSBcInt7XCIgKyB0aGlzLmtleXBhdGguc3RyICsgXCJ9fVwiO1xuICBcdFx0bm9kZS5jaGVja2VkID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5rZXlwYXRoKSA9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHRpZiAobm9kZS5hdHRhY2hFdmVudCkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcbiAgXHRcdHJldHVybiBub2RlLl9yYWN0aXZlID8gbm9kZS5fcmFjdGl2ZS52YWx1ZSA6IG5vZGUudmFsdWU7XG4gIFx0fSxcblxuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gSWYgdGhpcyA8aW5wdXQ+IGlzIHRoZSBvbmUgdGhhdCdzIGNoZWNrZWQsIHRoZW4gdGhlIHZhbHVlIG9mIGl0c1xuICBcdFx0Ly8gYG5hbWVgIGtleXBhdGggZ2V0cyBzZXQgdG8gaXRzIHZhbHVlXG4gIFx0XHRpZiAodGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZCkge1xuICBcdFx0XHRCaW5kaW5nX0JpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZWJvdW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dmFyIG5vZGU7XG5cbiAgXHRcdEJpbmRpbmdfQmluZGluZy5wcm90b3R5cGUucmVib3VuZC5jYWxsKHRoaXMsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuXG4gIFx0XHRpZiAobm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlKSB7XG4gIFx0XHRcdG5vZGUubmFtZSA9IFwie3tcIiArIHRoaXMua2V5cGF0aC5zdHIgKyBcIn19XCI7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuc2libGluZ3MsIHRoaXMpO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfUmFkaW9OYW1lQmluZGluZyA9IFJhZGlvTmFtZUJpbmRpbmc7XG5cbiAgdmFyIENoZWNrYm94TmFtZUJpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRuYW1lOiBcIm5hbWVcIixcblxuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gVGhpcyBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIGdyb3VwIChvZiBpbnB1dHMgdGhhdFxuICBcdFx0Ly8gc2hhcmUgYSBuYW1lKSwgYmVjYXVzZSBpdCBvbmx5IGdldHMgY2FsbGVkIGlmIHRoZXJlXG4gIFx0XHQvLyBpc24ndCBhbiBpbml0aWFsIHZhbHVlLiBCeSB0aGUgc2FtZSB0b2tlbiwgd2UgY2FuIG1ha2VcbiAgXHRcdC8vIGEgbm90ZSBvZiB0aGF0IGZhY3QgdGhhdCB0aGVyZSB3YXMgbm8gaW5pdGlhbCB2YWx1ZSxcbiAgXHRcdC8vIGFuZCBwb3B1bGF0ZSBpdCB1c2luZyBhbnkgYGNoZWNrZWRgIGF0dHJpYnV0ZXMgdGhhdFxuICBcdFx0Ly8gZXhpc3QgKHdoaWNoIHVzZXJzIHNob3VsZCBhdm9pZCwgYnV0IHdoaWNoIHdlIHNob3VsZFxuICBcdFx0Ly8gc3VwcG9ydCBhbnl3YXkgdG8gYXZvaWQgYnJlYWtpbmcgZXhwZWN0YXRpb25zKVxuICBcdFx0dGhpcy5ub0luaXRpYWxWYWx1ZSA9IHRydWU7XG4gIFx0XHRyZXR1cm4gW107XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBleGlzdGluZ1ZhbHVlLCBiaW5kaW5nVmFsdWU7XG5cbiAgXHRcdHRoaXMuY2hlY2tib3hOYW1lID0gdHJ1ZTsgLy8gc28gdGhhdCByYWN0aXZlLnVwZGF0ZU1vZGVsKCkga25vd3Mgd2hhdCB0byBkbyB3aXRoIHRoaXNcblxuICBcdFx0Ly8gRWFjaCBpbnB1dCBoYXMgYSByZWZlcmVuY2UgdG8gYW4gYXJyYXkgY29udGFpbmluZyBpdCBhbmQgaXRzXG4gIFx0XHQvLyBzaWJsaW5ncywgYXMgdHdvLXdheSBiaW5kaW5nIGRlcGVuZHMgb24gYmVpbmcgYWJsZSB0byBhc2NlcnRhaW5cbiAgXHRcdC8vIHRoZSBzdGF0dXMgb2YgYWxsIGlucHV0cyB3aXRoaW4gdGhlIGdyb3VwXG4gIFx0XHR0aGlzLnNpYmxpbmdzID0gc2hhcmVkX2dldFNpYmxpbmdzKHRoaXMucm9vdC5fZ3VpZCwgXCJjaGVja2JveGVzXCIsIHRoaXMua2V5cGF0aC5zdHIpO1xuICBcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKHRoaXMpO1xuXG4gIFx0XHRpZiAodGhpcy5ub0luaXRpYWxWYWx1ZSkge1xuICBcdFx0XHR0aGlzLnNpYmxpbmdzLm5vSW5pdGlhbFZhbHVlID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSWYgbm8gaW5pdGlhbCB2YWx1ZSB3YXMgc2V0LCBhbmQgdGhpcyBpbnB1dCBpcyBjaGVja2VkLCB3ZVxuICBcdFx0Ly8gdXBkYXRlIHRoZSBtb2RlbFxuICBcdFx0aWYgKHRoaXMuc2libGluZ3Mubm9Jbml0aWFsVmFsdWUgJiYgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImNoZWNrZWRcIikpIHtcbiAgXHRcdFx0ZXhpc3RpbmdWYWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCk7XG4gIFx0XHRcdGJpbmRpbmdWYWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdFx0XHRleGlzdGluZ1ZhbHVlLnB1c2goYmluZGluZ1ZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5zaWJsaW5ncywgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSxcbiAgXHRcdCAgICBleGlzdGluZ1ZhbHVlLFxuICBcdFx0ICAgIGJpbmRpbmdWYWx1ZTtcblxuICBcdFx0ZXhpc3RpbmdWYWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCk7XG4gIFx0XHRiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRcdGlmIChpc0FycmF5KGV4aXN0aW5nVmFsdWUpKSB7XG4gIFx0XHRcdHRoaXMuaXNDaGVja2VkID0gYXJyYXlDb250YWlucyhleGlzdGluZ1ZhbHVlLCBiaW5kaW5nVmFsdWUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5pc0NoZWNrZWQgPSBleGlzdGluZ1ZhbHVlID09IGJpbmRpbmdWYWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0bm9kZS5uYW1lID0gXCJ7e1wiICsgdGhpcy5rZXlwYXRoLnN0ciArIFwifX1cIjtcbiAgXHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMuaXNDaGVja2VkO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0Ly8gaW4gY2FzZSBvZiBJRSBlbWVyZ2VuY3ksIGJpbmQgdG8gY2xpY2sgZXZlbnQgYXMgd2VsbFxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Y2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHdhc0NoZWNrZWQgPSAhIXRoaXMuaXNDaGVja2VkO1xuICBcdFx0dGhpcy5pc0NoZWNrZWQgPSB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuICBcdFx0cmV0dXJuIHRoaXMuaXNDaGVja2VkID09PSB3YXNDaGVja2VkO1xuICBcdH0sXG5cbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcbiAgXHRcdEJpbmRpbmdfQmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwodGhpcyk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zaWJsaW5ncy5maWx0ZXIoaXNDaGVja2VkKS5tYXAoQmluZGluZ19DaGVja2JveE5hbWVCaW5kaW5nX19nZXRWYWx1ZSk7XG4gIFx0fVxuICB9KTtcblxuICBmdW5jdGlvbiBpc0NoZWNrZWQoYmluZGluZykge1xuICBcdHJldHVybiBiaW5kaW5nLmlzQ2hlY2tlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZ19fZ2V0VmFsdWUoYmluZGluZykge1xuICBcdHJldHVybiBiaW5kaW5nLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIH1cblxuICB2YXIgQmluZGluZ19DaGVja2JveE5hbWVCaW5kaW5nID0gQ2hlY2tib3hOYW1lQmluZGluZztcblxuICB2YXIgQ2hlY2tib3hCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJjaGVja2VkXCIsXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHRpZiAobm9kZS5hdHRhY2hFdmVudCkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19DaGVja2JveEJpbmRpbmcgPSBDaGVja2JveEJpbmRpbmc7XG5cbiAgdmFyIFNlbGVjdEJpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5lbGVtZW50Lm9wdGlvbnMsXG4gIFx0XHQgICAgbGVuLFxuICBcdFx0ICAgIGksXG4gIFx0XHQgICAgdmFsdWUsXG4gIFx0XHQgICAgb3B0aW9uV2FzU2VsZWN0ZWQ7XG5cbiAgXHRcdGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGkgPSBsZW4gPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdFx0aWYgKCFsZW4pIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyB0YWtlIHRoZSBmaW5hbCBzZWxlY3RlZCBvcHRpb24uLi5cbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKG9wdGlvbnNbaV0uZ2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIikpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnNbaV0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHRcdFx0b3B0aW9uV2FzU2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG9yIHRoZSBmaXJzdCBub24tZGlzYWJsZWQgb3B0aW9uLCBpZiBub25lIGFyZSBzZWxlY3RlZFxuICBcdFx0aWYgKCFvcHRpb25XYXNTZWxlY3RlZCkge1xuICBcdFx0XHR3aGlsZSAoKytpIDwgbGVuKSB7XG4gIFx0XHRcdFx0aWYgKCFvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSB7XG4gIFx0XHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnNbaV0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gVGhpcyBpcyBhbiBvcHRpbWlzYXRpb24gKGFrYSBoYWNrKSB0aGF0IGFsbG93cyB1cyB0byBmb3JnbyBzb21lXG4gIFx0XHQvLyBvdGhlciBtb3JlIGV4cGVuc2l2ZSB3b3JrXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cmlidXRlcy52YWx1ZS52YWx1ZSA9IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHQvLyBUT0RPIHRoaXMgbWV0aG9kIGlzIGFuIGFub21hbHkuLi4gaXMgaXQgbmVjZXNzYXJ5P1xuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG9wdGlvbnMsIGksIGxlbiwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblxuICBcdFx0b3B0aW9ucyA9IHRoaXMuZWxlbWVudC5ub2RlLm9wdGlvbnM7XG4gIFx0XHRsZW4gPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbaV07XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQpIHtcbiAgXHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcbiAgXHRcdFx0XHRyZXR1cm4gb3B0aW9uVmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Zm9yY2VVcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gX3RoaXMuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuICBcdFx0XHR9KTtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQodGhpcy5rZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19TZWxlY3RCaW5kaW5nID0gU2VsZWN0QmluZGluZztcblxuICB2YXIgTXVsdGlwbGVTZWxlY3RCaW5kaW5nID0gQmluZGluZ19TZWxlY3RCaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgXHRcdFx0cmV0dXJuIG9wdGlvbi5nZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKTtcbiAgXHRcdH0pLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHR9KTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdmFsdWVGcm9tTW9kZWw7XG5cbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0dmFsdWVGcm9tTW9kZWwgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpO1xuXG4gIFx0XHRpZiAodmFsdWVGcm9tTW9kZWwgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHQvLyBnZXQgdmFsdWUgZnJvbSBET00sIGlmIHBvc3NpYmxlXG4gIFx0XHRcdHRoaXMuaGFuZGxlQ2hhbmdlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUT0RPIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgc2VsZWN0ZWRWYWx1ZXMsIG9wdGlvbnMsIGksIGxlbiwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblxuICBcdFx0c2VsZWN0ZWRWYWx1ZXMgPSBbXTtcbiAgXHRcdG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQubm9kZS5vcHRpb25zO1xuICBcdFx0bGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gIFx0XHRcdGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcbiAgXHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcbiAgXHRcdFx0XHRzZWxlY3RlZFZhbHVlcy5wdXNoKG9wdGlvblZhbHVlKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc2VsZWN0ZWRWYWx1ZXM7XG4gIFx0fSxcblxuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGF0dHJpYnV0ZSwgcHJldmlvdXNWYWx1ZSwgdmFsdWU7XG5cbiAgXHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlO1xuICBcdFx0cHJldmlvdXNWYWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcblxuICBcdFx0dmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmIChwcmV2aW91c1ZhbHVlID09PSB1bmRlZmluZWQgfHwgIWFycmF5Q29udGVudHNNYXRjaCh2YWx1ZSwgcHJldmlvdXNWYWx1ZSkpIHtcbiAgXHRcdFx0QmluZGluZ19TZWxlY3RCaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIF90aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGVNb2RlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuYXR0cmlidXRlLnZhbHVlID09PSB1bmRlZmluZWQgfHwgIXRoaXMuYXR0cmlidXRlLnZhbHVlLmxlbmd0aCkge1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHRoaXMuaW5pdGlhbFZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX011bHRpcGxlU2VsZWN0QmluZGluZyA9IE11bHRpcGxlU2VsZWN0QmluZGluZztcblxuICB2YXIgRmlsZUxpc3RCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuZmlsZXM7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19GaWxlTGlzdEJpbmRpbmcgPSBGaWxlTGlzdEJpbmRpbmc7XG5cbiAgdmFyIE51bWVyaWNCaW5kaW5nID0gQmluZGluZ19HZW5lcmljQmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5lbGVtZW50Lm5vZGUudmFsdWUpO1xuICBcdFx0cmV0dXJuIGlzTmFOKHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIGluaXRfY3JlYXRlVHdvd2F5QmluZGluZyA9IGNyZWF0ZVR3b3dheUJpbmRpbmc7XG5cbiAgZnVuY3Rpb24gY3JlYXRlVHdvd2F5QmluZGluZyhlbGVtZW50KSB7XG4gIFx0dmFyIGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXMsXG4gIFx0ICAgIHR5cGUsXG4gIFx0ICAgIEJpbmRpbmcsXG4gIFx0ICAgIGJpbmROYW1lLFxuICBcdCAgICBiaW5kQ2hlY2tlZCxcbiAgXHQgICAgYmluZGluZztcblxuICBcdC8vIGlmIHRoaXMgaXMgYSBsYXRlIGJpbmRpbmcsIGFuZCB0aGVyZSdzIGFscmVhZHkgb25lLCBpdFxuICBcdC8vIG5lZWRzIHRvIGJlIHRvcm4gZG93blxuICBcdGlmIChlbGVtZW50LmJpbmRpbmcpIHtcbiAgXHRcdGVsZW1lbnQuYmluZGluZy50ZWFyZG93bigpO1xuICBcdFx0ZWxlbWVudC5iaW5kaW5nID0gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBjb250ZW50ZWRpdGFibGVcbiAgXHRpZiAoXG4gIFx0Ly8gaWYgdGhlIGNvbnRlbnRlZGl0YWJsZSBhdHRyaWJ1dGUgaXMgdHJ1ZSBvciBpcyBiaW5kYWJsZSBhbmQgbWF5IHRodXMgYmVjb21lIHRydWVcbiAgXHQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgfHwgISFhdHRyaWJ1dGVzLmNvbnRlbnRlZGl0YWJsZSAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMuY29udGVudGVkaXRhYmxlKSkgJiYgaXNCaW5kYWJsZShhdHRyaWJ1dGVzLnZhbHVlKSkge1xuICBcdFx0QmluZGluZyA9IEJpbmRpbmdfQ29udGVudEVkaXRhYmxlQmluZGluZztcbiAgXHR9XG5cbiAgXHQvLyA8aW5wdXQ+XG4gIFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcImlucHV0XCIpIHtcbiAgXHRcdHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG5cbiAgXHRcdGlmICh0eXBlID09PSBcInJhZGlvXCIgfHwgdHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gIFx0XHRcdGJpbmROYW1lID0gaXNCaW5kYWJsZShhdHRyaWJ1dGVzLm5hbWUpO1xuICBcdFx0XHRiaW5kQ2hlY2tlZCA9IGlzQmluZGFibGUoYXR0cmlidXRlcy5jaGVja2VkKTtcblxuICBcdFx0XHQvLyB3ZSBjYW4gZWl0aGVyIGJpbmQgdGhlIG5hbWUgYXR0cmlidXRlLCBvciB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUgLSBub3QgYm90aFxuICBcdFx0XHRpZiAoYmluZE5hbWUgJiYgYmluZENoZWNrZWQpIHtcbiAgXHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIkEgcmFkaW8gaW5wdXQgY2FuIGhhdmUgdHdvLXdheSBiaW5kaW5nIG9uIGl0cyBuYW1lIGF0dHJpYnV0ZSwgb3IgaXRzIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGhcIiwgeyByYWN0aXZlOiBlbGVtZW50LnJvb3QgfSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoYmluZE5hbWUpIHtcbiAgXHRcdFx0XHRCaW5kaW5nID0gdHlwZSA9PT0gXCJyYWRpb1wiID8gQmluZGluZ19SYWRpb05hbWVCaW5kaW5nIDogQmluZGluZ19DaGVja2JveE5hbWVCaW5kaW5nO1xuICBcdFx0XHR9IGVsc2UgaWYgKGJpbmRDaGVja2VkKSB7XG4gIFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09IFwicmFkaW9cIiA/IEJpbmRpbmdfUmFkaW9CaW5kaW5nIDogQmluZGluZ19DaGVja2JveEJpbmRpbmc7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJmaWxlXCIgJiYgaXNCaW5kYWJsZShhdHRyaWJ1dGVzLnZhbHVlKSkge1xuICBcdFx0XHRCaW5kaW5nID0gQmluZGluZ19GaWxlTGlzdEJpbmRpbmc7XG4gIFx0XHR9IGVsc2UgaWYgKGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdFx0QmluZGluZyA9IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJyYW5nZVwiID8gTnVtZXJpY0JpbmRpbmcgOiBCaW5kaW5nX0dlbmVyaWNCaW5kaW5nO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIDxzZWxlY3Q+XG4gIFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcInNlbGVjdFwiICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdEJpbmRpbmcgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpID8gQmluZGluZ19NdWx0aXBsZVNlbGVjdEJpbmRpbmcgOiBCaW5kaW5nX1NlbGVjdEJpbmRpbmc7XG4gIFx0fVxuXG4gIFx0Ly8gPHRleHRhcmVhPlxuICBcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdEJpbmRpbmcgPSBCaW5kaW5nX0dlbmVyaWNCaW5kaW5nO1xuICBcdH1cblxuICBcdGlmIChCaW5kaW5nICYmIChiaW5kaW5nID0gbmV3IEJpbmRpbmcoZWxlbWVudCkpICYmIGJpbmRpbmcua2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIGJpbmRpbmc7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gaXNCaW5kYWJsZShhdHRyaWJ1dGUpIHtcbiAgXHRyZXR1cm4gYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5pc0JpbmRhYmxlO1xuICB9XG5cbiAgLy8gYW5kIHRoaXMgZWxlbWVudCBhbHNvIGhhcyBhIHZhbHVlIGF0dHJpYnV0ZSB0byBiaW5kXG5cbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfYnViYmxlID0gRXZlbnRIYW5kbGVyJGJ1YmJsZTtcblxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkYnViYmxlKCkge1xuICBcdHZhciBoYXNBY3Rpb24gPSB0aGlzLmdldEFjdGlvbigpO1xuXG4gIFx0aWYgKGhhc0FjdGlvbiAmJiAhdGhpcy5oYXNMaXN0ZW5lcikge1xuICBcdFx0dGhpcy5saXN0ZW4oKTtcbiAgXHR9IGVsc2UgaWYgKCFoYXNBY3Rpb24gJiYgdGhpcy5oYXNMaXN0ZW5lcikge1xuICBcdFx0dGhpcy51bnJlbmRlcigpO1xuICBcdH1cbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gbWF5IGJlIG92ZXJ3cml0dGVuLCBpZiB0aGUgZXZlbnQgZGlyZWN0aXZlXG4gIC8vIGluY2x1ZGVzIHBhcmFtZXRlcnNcbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfZmlyZSA9IEV2ZW50SGFuZGxlciRmaXJlO1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkZmlyZShldmVudCkge1xuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7IGV2ZW50OiBldmVudCB9KTtcbiAgfVxuXG4gIHZhciBnZXRBY3Rpb24gPSBFdmVudEhhbmRsZXIkZ2V0QWN0aW9uO1xuXG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRnZXRBY3Rpb24oKSB7XG4gIFx0cmV0dXJuIHRoaXMuYWN0aW9uLnRvU3RyaW5nKCkudHJpbSgpO1xuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfaW5pdCA9IEV2ZW50SGFuZGxlciRpbml0O1xuXG4gIHZhciBldmVudFBhdHRlcm4gPSAvXmV2ZW50KD86XFwuKC4rKSk/LztcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGluaXQoZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIGFjdGlvbiwgcmVmcywgcmFjdGl2ZTtcblxuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgXHRpZiAobmFtZS5pbmRleE9mKFwiKlwiKSAhPT0gLTEpIHtcbiAgXHRcdGZhdGFsKFwiT25seSBjb21wb25lbnQgcHJveHktZXZlbnRzIG1heSBjb250YWluIFxcXCIqXFxcIiB3aWxkY2FyZHMsIDwlcyBvbi0lcz1cXFwiLi4uXFxcIi8+IGlzIG5vdCB2YWxpZFwiLCBlbGVtZW50Lm5hbWUsIG5hbWUpO1xuICBcdFx0dGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHRpZiAodGVtcGxhdGUubSkge1xuICBcdFx0cmVmcyA9IHRlbXBsYXRlLmEucjtcblxuICBcdFx0Ly8gVGhpcyBpcyBhIG1ldGhvZCBjYWxsXG4gIFx0XHR0aGlzLm1ldGhvZCA9IHRlbXBsYXRlLm07XG4gIFx0XHR0aGlzLmtleXBhdGhzID0gW107XG4gIFx0XHR0aGlzLmZuID0gc2hhcmVkX2dldEZ1bmN0aW9uRnJvbVN0cmluZyh0ZW1wbGF0ZS5hLnMsIHJlZnMubGVuZ3RoKTtcblxuICBcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0XHRyYWN0aXZlID0gdGhpcy5yb290O1xuXG4gIFx0XHQvLyBDcmVhdGUgcmVzb2x2ZXJzIGZvciBlYWNoIHJlZmVyZW5jZVxuICBcdFx0dGhpcy5yZWZSZXNvbHZlcnMgPSBbXTtcbiAgXHRcdHJlZnMuZm9yRWFjaChmdW5jdGlvbiAocmVmLCBpKSB7XG4gIFx0XHRcdHZhciBtYXRjaCA9IHVuZGVmaW5lZDtcblxuICBcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSB0aGUgYGV2ZW50YCBvYmplY3RcbiAgXHRcdFx0aWYgKG1hdGNoID0gZXZlbnRQYXR0ZXJuLmV4ZWMocmVmKSkge1xuICBcdFx0XHRcdF90aGlzLmtleXBhdGhzW2ldID0ge1xuICBcdFx0XHRcdFx0ZXZlbnRPYmplY3Q6IHRydWUsXG4gIFx0XHRcdFx0XHRyZWZpbmVtZW50czogbWF0Y2hbMV0gPyBtYXRjaFsxXS5zcGxpdChcIi5cIikgOiBbXVxuICBcdFx0XHRcdH07XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0X3RoaXMucmVmUmVzb2x2ZXJzLnB1c2goUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKF90aGlzLCByZWYsIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gX3RoaXMucmVzb2x2ZShpLCBrZXlwYXRoKTtcbiAgXHRcdFx0XHR9KSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLmZpcmUgPSBmaXJlTWV0aG9kQ2FsbDtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gR2V0IGFjdGlvbiAoJ2ZvbycgaW4gJ29uLWNsaWNrPSdmb28nKVxuICBcdFx0YWN0aW9uID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcbiAgXHRcdGlmICh0eXBlb2YgYWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGFjdGlvbiA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0XHR0ZW1wbGF0ZTogYWN0aW9uLFxuICBcdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0XHRvd25lcjogdGhpc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5hY3Rpb24gPSBhY3Rpb247XG5cbiAgXHRcdC8vIEdldCBwYXJhbWV0ZXJzXG4gIFx0XHRpZiAodGVtcGxhdGUuZCkge1xuICBcdFx0XHR0aGlzLmR5bmFtaWNQYXJhbXMgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG4gIFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0XHRcdG93bmVyOiB0aGlzLmVsZW1lbnRcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0dGhpcy5maXJlID0gZmlyZUV2ZW50V2l0aER5bmFtaWNQYXJhbXM7XG4gIFx0XHR9IGVsc2UgaWYgKHRlbXBsYXRlLmEpIHtcbiAgXHRcdFx0dGhpcy5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuICBcdFx0XHR0aGlzLmZpcmUgPSBmaXJlRXZlbnRXaXRoUGFyYW1zO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVNZXRob2RDYWxsKGV2ZW50KSB7XG4gIFx0dmFyIHJhY3RpdmUsIHZhbHVlcywgYXJncztcblxuICBcdHJhY3RpdmUgPSB0aGlzLnJvb3Q7XG5cbiAgXHRpZiAodHlwZW9mIHJhY3RpdmVbdGhpcy5tZXRob2RdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBjYWxsIGEgbm9uLWV4aXN0ZW50IG1ldGhvZCAoXFxcIlwiICsgdGhpcy5tZXRob2QgKyBcIlxcXCIpXCIpO1xuICBcdH1cblxuICBcdHZhbHVlcyA9IHRoaXMua2V5cGF0aHMubWFwKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgdmFsdWUsIGxlbiwgaTtcblxuICBcdFx0aWYgKGtleXBhdGggPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHQvLyBub3QgeWV0IHJlc29sdmVkXG4gIFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFRPRE8gdGhlIHJlZmluZW1lbnRzIHN0dWZmIHdvdWxkIGJlIGJldHRlciBoYW5kbGVkIGF0IHBhcnNlIHRpbWVcbiAgXHRcdGlmIChrZXlwYXRoLmV2ZW50T2JqZWN0KSB7XG4gIFx0XHRcdHZhbHVlID0gZXZlbnQ7XG5cbiAgXHRcdFx0aWYgKGxlbiA9IGtleXBhdGgucmVmaW5lbWVudHMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW2tleXBhdGgucmVmaW5lbWVudHNbaV1dO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB2YWx1ZTtcbiAgXHR9KTtcblxuICBcdHNoYXJlZF9ldmVudFN0YWNrLmVucXVldWUocmFjdGl2ZSwgZXZlbnQpO1xuXG4gIFx0YXJncyA9IHRoaXMuZm4uYXBwbHkobnVsbCwgdmFsdWVzKTtcbiAgXHRyYWN0aXZlW3RoaXMubWV0aG9kXS5hcHBseShyYWN0aXZlLCBhcmdzKTtcblxuICBcdHNoYXJlZF9ldmVudFN0YWNrLmRlcXVldWUocmFjdGl2ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlRXZlbnRXaXRoUGFyYW1zKGV2ZW50KSB7XG4gIFx0c2hhcmVkX2ZpcmVFdmVudCh0aGlzLnJvb3QsIHRoaXMuZ2V0QWN0aW9uKCksIHsgZXZlbnQ6IGV2ZW50LCBhcmdzOiB0aGlzLnBhcmFtcyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zKGV2ZW50KSB7XG4gIFx0dmFyIGFyZ3MgPSB0aGlzLmR5bmFtaWNQYXJhbXMuZ2V0QXJnc0xpc3QoKTtcblxuICBcdC8vIG5lZWQgdG8gc3RyaXAgW10gZnJvbSBlbmRzIGlmIGEgc3RyaW5nIVxuICBcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0YXJncyA9IGFyZ3Muc3Vic3RyKDEsIGFyZ3MubGVuZ3RoIC0gMik7XG4gIFx0fVxuXG4gIFx0c2hhcmVkX2ZpcmVFdmVudCh0aGlzLnJvb3QsIHRoaXMuZ2V0QWN0aW9uKCksIHsgZXZlbnQ6IGV2ZW50LCBhcmdzOiBhcmdzIH0pO1xuICB9XG5cbiAgdmFyIHNoYXJlZF9nZW5lcmljSGFuZGxlciA9IGdlbmVyaWNIYW5kbGVyO1xuICBmdW5jdGlvbiBnZW5lcmljSGFuZGxlcihldmVudCkge1xuICBcdHZhciBzdG9yYWdlLFxuICBcdCAgICBoYW5kbGVyLFxuICBcdCAgICBpbmRpY2VzLFxuICBcdCAgICBpbmRleCA9IHt9O1xuXG4gIFx0c3RvcmFnZSA9IHRoaXMuX3JhY3RpdmU7XG4gIFx0aGFuZGxlciA9IHN0b3JhZ2UuZXZlbnRzW2V2ZW50LnR5cGVdO1xuXG4gIFx0aWYgKGluZGljZXMgPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcyhoYW5kbGVyLmVsZW1lbnQucGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRpbmRleCA9IFJlc29sdmVyc19maW5kSW5kZXhSZWZzLnJlc29sdmUoaW5kaWNlcyk7XG4gIFx0fVxuXG4gIFx0aGFuZGxlci5maXJlKHtcbiAgXHRcdG5vZGU6IHRoaXMsXG4gIFx0XHRvcmlnaW5hbDogZXZlbnQsXG4gIFx0XHRpbmRleDogaW5kZXgsXG4gIFx0XHRrZXlwYXRoOiBzdG9yYWdlLmtleXBhdGguc3RyLFxuICBcdFx0Y29udGV4dDogc3RvcmFnZS5yb290LnZpZXdtb2RlbC5nZXQoc3RvcmFnZS5rZXlwYXRoKVxuICBcdH0pO1xuICB9XG5cbiAgdmFyIGxpc3RlbiA9IEV2ZW50SGFuZGxlciRsaXN0ZW47XG5cbiAgdmFyIGN1c3RvbUhhbmRsZXJzID0ge30sXG4gICAgICB0b3VjaEV2ZW50cyA9IHtcbiAgXHR0b3VjaHN0YXJ0OiB0cnVlLFxuICBcdHRvdWNobW92ZTogdHJ1ZSxcbiAgXHR0b3VjaGVuZDogdHJ1ZSxcbiAgXHR0b3VjaGNhbmNlbDogdHJ1ZSxcbiAgXHQvL25vdCB3M2MsIGJ1dCBzdXBwb3J0ZWQgaW4gc29tZSBicm93c2Vyc1xuICBcdHRvdWNobGVhdmU6IHRydWVcbiAgfTtcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGxpc3RlbigpIHtcbiAgXHR2YXIgZGVmaW5pdGlvbixcbiAgXHQgICAgbmFtZSA9IHRoaXMubmFtZTtcblxuICBcdGlmICh0aGlzLmludmFsaWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAoZGVmaW5pdGlvbiA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJldmVudHNcIiwgdGhpcy5yb290LCBuYW1lKSkge1xuICBcdFx0dGhpcy5jdXN0b20gPSBkZWZpbml0aW9uKHRoaXMubm9kZSwgZ2V0Q3VzdG9tSGFuZGxlcihuYW1lKSk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIExvb2tzIGxpa2Ugd2UncmUgZGVhbGluZyB3aXRoIGEgc3RhbmRhcmQgRE9NIGV2ZW50Li4uIGJ1dCBsZXQncyBjaGVja1xuICBcdFx0aWYgKCEoXCJvblwiICsgbmFtZSBpbiB0aGlzLm5vZGUpICYmICEod2luZG93ICYmIFwib25cIiArIG5hbWUgaW4gd2luZG93KSAmJiAhaXNKc2RvbSkge1xuXG4gIFx0XHRcdC8vIG9rYXkgdG8gdXNlIHRvdWNoIGV2ZW50cyBpZiB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZW1cbiAgXHRcdFx0aWYgKCF0b3VjaEV2ZW50c1tuYW1lXSkge1xuICBcdFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGx1Z2luKG5hbWUsIFwiZXZlbnRcIiksIHsgbm9kZTogdGhpcy5ub2RlIH0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBzaGFyZWRfZ2VuZXJpY0hhbmRsZXIsIGZhbHNlKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmhhc0xpc3RlbmVyID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1c3RvbUhhbmRsZXIobmFtZSkge1xuICBcdGlmICghY3VzdG9tSGFuZGxlcnNbbmFtZV0pIHtcbiAgXHRcdGN1c3RvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIFx0XHRcdHZhciBzdG9yYWdlID0gZXZlbnQubm9kZS5fcmFjdGl2ZTtcblxuICBcdFx0XHRldmVudC5pbmRleCA9IHN0b3JhZ2UuaW5kZXg7XG4gIFx0XHRcdGV2ZW50LmtleXBhdGggPSBzdG9yYWdlLmtleXBhdGguc3RyO1xuICBcdFx0XHRldmVudC5jb250ZXh0ID0gc3RvcmFnZS5yb290LnZpZXdtb2RlbC5nZXQoc3RvcmFnZS5rZXlwYXRoKTtcblxuICBcdFx0XHRzdG9yYWdlLmV2ZW50c1tuYW1lXS5maXJlKGV2ZW50KTtcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGN1c3RvbUhhbmRsZXJzW25hbWVdO1xuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfcmViaW5kID0gRXZlbnRIYW5kbGVyJHJlYmluZDtcblxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHR2YXIgZnJhZ21lbnQ7XG4gIFx0aWYgKHRoaXMubWV0aG9kKSB7XG4gIFx0XHRmcmFnbWVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXJzLmZvckVhY2gocmViaW5kKTtcblxuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2YgdGhpcy5hY3Rpb24gIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmFjdGlvbik7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZHluYW1pY1BhcmFtcykge1xuICBcdFx0cmViaW5kKHRoaXMuZHluYW1pY1BhcmFtcyk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gcmViaW5kKHRoaW5nKSB7XG4gIFx0XHR0aGluZyAmJiB0aGluZy5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfcmVuZGVyID0gRXZlbnRIYW5kbGVyJHJlbmRlcjtcblxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmVuZGVyKCkge1xuICBcdHRoaXMubm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuICBcdC8vIHN0b3JlIHRoaXMgb24gdGhlIG5vZGUgaXRzZWxmLCBzbyBpdCBjYW4gYmUgcmV0cmlldmVkIGJ5IGFcbiAgXHQvLyB1bml2ZXJzYWwgaGFuZGxlclxuICBcdHRoaXMubm9kZS5fcmFjdGl2ZS5ldmVudHNbdGhpcy5uYW1lXSA9IHRoaXM7XG5cbiAgXHRpZiAodGhpcy5tZXRob2QgfHwgdGhpcy5nZXRBY3Rpb24oKSkge1xuICBcdFx0dGhpcy5saXN0ZW4oKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3Jlc29sdmUgPSBFdmVudEhhbmRsZXIkcmVzb2x2ZTtcblxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmVzb2x2ZShpbmRleCwga2V5cGF0aCkge1xuICBcdHRoaXMua2V5cGF0aHNbaW5kZXhdID0ga2V5cGF0aDtcbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3VuYmluZCA9IEV2ZW50SGFuZGxlciR1bmJpbmQ7XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciR1bmJpbmQoKSB7XG4gIFx0aWYgKHRoaXMubWV0aG9kKSB7XG4gIFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gVGVhciBkb3duIGR5bmFtaWMgbmFtZVxuICBcdGlmICh0eXBlb2YgdGhpcy5hY3Rpb24gIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRoaXMuYWN0aW9uLnVuYmluZCgpO1xuICBcdH1cblxuICBcdC8vIFRlYXIgZG93biBkeW5hbWljIHBhcmFtZXRlcnNcbiAgXHRpZiAodGhpcy5keW5hbWljUGFyYW1zKSB7XG4gIFx0XHR0aGlzLmR5bmFtaWNQYXJhbXMudW5iaW5kKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfdW5yZW5kZXIgPSBFdmVudEhhbmRsZXIkdW5yZW5kZXI7XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciR1bnJlbmRlcigpIHtcblxuICBcdGlmICh0aGlzLmN1c3RvbSkge1xuICBcdFx0dGhpcy5jdXN0b20udGVhcmRvd24oKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5uYW1lLCBzaGFyZWRfZ2VuZXJpY0hhbmRsZXIsIGZhbHNlKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmhhc0xpc3RlbmVyID0gZmFsc2U7XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlKSB7XG4gIFx0dGhpcy5pbml0KGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlKTtcbiAgfTtcblxuICBFdmVudEhhbmRsZXIucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9idWJibGUsXG4gIFx0ZmlyZTogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9maXJlLFxuICBcdGdldEFjdGlvbjogZ2V0QWN0aW9uLFxuICBcdGluaXQ6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfaW5pdCxcbiAgXHRsaXN0ZW46IGxpc3RlbixcbiAgXHRyZWJpbmQ6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0cmVzb2x2ZTogcHJvdG90eXBlX3Jlc29sdmUsXG4gIFx0dW5iaW5kOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV91bnJlbmRlclxuICB9O1xuXG4gIHZhciBfRXZlbnRIYW5kbGVyID0gRXZlbnRIYW5kbGVyO1xuXG4gIHZhciBjcmVhdGVFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRlbXBsYXRlKSB7XG4gIFx0dmFyIGksXG4gIFx0ICAgIG5hbWUsXG4gIFx0ICAgIG5hbWVzLFxuICBcdCAgICBoYW5kbGVyLFxuICBcdCAgICByZXN1bHQgPSBbXTtcblxuICBcdGZvciAobmFtZSBpbiB0ZW1wbGF0ZSkge1xuICBcdFx0aWYgKHRlbXBsYXRlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gIFx0XHRcdG5hbWVzID0gbmFtZS5zcGxpdChcIi1cIik7XG4gIFx0XHRcdGkgPSBuYW1lcy5sZW5ndGg7XG5cbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGhhbmRsZXIgPSBuZXcgX0V2ZW50SGFuZGxlcihlbGVtZW50LCBuYW1lc1tpXSwgdGVtcGxhdGVbbmFtZV0pO1xuICBcdFx0XHRcdHJlc3VsdC5wdXNoKGhhbmRsZXIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgRGVjb3JhdG9yID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRlbXBsYXRlKSB7XG4gIFx0dmFyIHNlbGYgPSB0aGlzLFxuICBcdCAgICByYWN0aXZlLFxuICBcdCAgICBuYW1lLFxuICBcdCAgICBmcmFnbWVudDtcblxuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IGVsZW1lbnQucm9vdDtcblxuICBcdG5hbWUgPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuXG4gIFx0aWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IG5hbWUsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiBlbGVtZW50XG4gIFx0XHR9KTtcblxuICBcdFx0bmFtZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblxuICBcdFx0aWYgKG5hbWUgPT09IFwiXCIpIHtcbiAgXHRcdFx0Ly8gZW1wdHkgc3RyaW5nIG9rYXksIGp1c3Qgbm8gZGVjb3JhdG9yXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAodGVtcGxhdGUuYSkge1xuICBcdFx0dGhpcy5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuICBcdH0gZWxzZSBpZiAodGVtcGxhdGUuZCkge1xuICBcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiBlbGVtZW50XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5wYXJhbXMgPSB0aGlzLmZyYWdtZW50LmdldEFyZ3NMaXN0KCk7XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnQuYnViYmxlID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHR0aGlzLmRpcnR5QXJncyA9IHRoaXMuZGlydHlWYWx1ZSA9IHRydWU7XG4gIFx0XHRcdHNlbGYucGFyYW1zID0gdGhpcy5nZXRBcmdzTGlzdCgpO1xuXG4gIFx0XHRcdGlmIChzZWxmLnJlYWR5KSB7XG4gIFx0XHRcdFx0c2VsZi51cGRhdGUoKTtcbiAgXHRcdFx0fVxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHR0aGlzLmZuID0gZmluZEluVmlld0hpZXJhcmNoeShcImRlY29yYXRvcnNcIiwgcmFjdGl2ZSwgbmFtZSk7XG5cbiAgXHRpZiAoIXRoaXMuZm4pIHtcbiAgXHRcdGZhdGFsKG1pc3NpbmdQbHVnaW4obmFtZSwgXCJkZWNvcmF0b3JcIikpO1xuICBcdH1cbiAgfTtcblxuICBEZWNvcmF0b3IucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlLCByZXN1bHQsIGFyZ3M7XG5cbiAgXHRcdG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0aWYgKHRoaXMucGFyYW1zKSB7XG4gIFx0XHRcdGFyZ3MgPSBbbm9kZV0uY29uY2F0KHRoaXMucGFyYW1zKTtcbiAgXHRcdFx0cmVzdWx0ID0gdGhpcy5mbi5hcHBseSh0aGlzLnJvb3QsIGFyZ3MpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmVzdWx0ID0gdGhpcy5mbi5jYWxsKHRoaXMucm9vdCwgbm9kZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghcmVzdWx0IHx8ICFyZXN1bHQudGVhcmRvd24pIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRGVjb3JhdG9yIGRlZmluaXRpb24gbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdpdGggYSB0ZWFyZG93biBtZXRob2RcIik7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFRPRE8gZG9lcyB0aGlzIG1ha2Ugc2Vuc2U/XG4gIFx0XHR0aGlzLmFjdHVhbCA9IHJlc3VsdDtcbiAgXHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmFjdHVhbC51cGRhdGUpIHtcbiAgXHRcdFx0dGhpcy5hY3R1YWwudXBkYXRlLmFwcGx5KHRoaXMucm9vdCwgdGhpcy5wYXJhbXMpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5hY3R1YWwudGVhcmRvd24odHJ1ZSk7XG4gIFx0XHRcdHRoaXMuaW5pdCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dGVhcmRvd246IGZ1bmN0aW9uICh1cGRhdGluZykge1xuICBcdFx0dGhpcy50b3JuZG93biA9IHRydWU7XG4gIFx0XHRpZiAodGhpcy5yZWFkeSkge1xuICBcdFx0XHR0aGlzLmFjdHVhbC50ZWFyZG93bigpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXVwZGF0aW5nICYmIHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIF9EZWNvcmF0b3IgPSBEZWNvcmF0b3I7XG5cbiAgZnVuY3Rpb24gc2VsZWN0X19idWJibGUoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdGlmICghdGhpcy5kaXJ0eSkge1xuICBcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHN5bmMoX3RoaXMpO1xuICBcdFx0XHRfdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTsgLy8gZGVmYXVsdCBiZWhhdmlvdXJcbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bmMoc2VsZWN0RWxlbWVudCkge1xuICBcdHZhciBzZWxlY3ROb2RlLCBzZWxlY3RWYWx1ZSwgaXNNdWx0aXBsZSwgb3B0aW9ucywgb3B0aW9uV2FzU2VsZWN0ZWQ7XG5cbiAgXHRzZWxlY3ROb2RlID0gc2VsZWN0RWxlbWVudC5ub2RlO1xuXG4gIFx0aWYgKCFzZWxlY3ROb2RlKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0b3B0aW9ucyA9IHRvQXJyYXkoc2VsZWN0Tm9kZS5vcHRpb25zKTtcblxuICBcdHNlbGVjdFZhbHVlID0gc2VsZWN0RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgXHRpc011bHRpcGxlID0gc2VsZWN0RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKTtcblxuICBcdC8vIElmIHRoZSA8c2VsZWN0PiBoYXMgYSBzcGVjaWZpZWQgdmFsdWUsIHRoYXQgc2hvdWxkIG92ZXJyaWRlXG4gIFx0Ly8gdGhlc2Ugb3B0aW9uc1xuICBcdGlmIChzZWxlY3RWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRvcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgXHRcdFx0dmFyIG9wdGlvblZhbHVlLCBzaG91bGRTZWxlY3Q7XG5cbiAgXHRcdFx0b3B0aW9uVmFsdWUgPSBvLl9yYWN0aXZlID8gby5fcmFjdGl2ZS52YWx1ZSA6IG8udmFsdWU7XG4gIFx0XHRcdHNob3VsZFNlbGVjdCA9IGlzTXVsdGlwbGUgPyB2YWx1ZUNvbnRhaW5zKHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSkgOiBzZWxlY3RWYWx1ZSA9PSBvcHRpb25WYWx1ZTtcblxuICBcdFx0XHRpZiAoc2hvdWxkU2VsZWN0KSB7XG4gIFx0XHRcdFx0b3B0aW9uV2FzU2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0by5zZWxlY3RlZCA9IHNob3VsZFNlbGVjdDtcbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAoIW9wdGlvbldhc1NlbGVjdGVkKSB7XG4gIFx0XHRcdGlmIChvcHRpb25zWzBdKSB7XG4gIFx0XHRcdFx0b3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoc2VsZWN0RWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRcdFx0c2VsZWN0RWxlbWVudC5iaW5kaW5nLmZvcmNlVXBkYXRlKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBPdGhlcndpc2UgdGhlIHZhbHVlIHNob3VsZCBiZSBpbml0aWFsaXNlZCBhY2NvcmRpbmcgdG8gd2hpY2hcbiAgXHQvLyA8b3B0aW9uPiBlbGVtZW50IGlzIHNlbGVjdGVkLCBpZiB0d293YXkgYmluZGluZyBpcyBpbiBlZmZlY3RcbiAgXHRlbHNlIGlmIChzZWxlY3RFbGVtZW50LmJpbmRpbmcpIHtcbiAgXHRcdHNlbGVjdEVsZW1lbnQuYmluZGluZy5mb3JjZVVwZGF0ZSgpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbHVlQ29udGFpbnMoc2VsZWN0VmFsdWUsIG9wdGlvblZhbHVlKSB7XG4gIFx0dmFyIGkgPSBzZWxlY3RWYWx1ZS5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKHNlbGVjdFZhbHVlW2ldID09IG9wdGlvblZhbHVlKSB7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNwZWNpYWxfb3B0aW9uX19pbml0KG9wdGlvbiwgdGVtcGxhdGUpIHtcbiAgXHRvcHRpb24uc2VsZWN0ID0gZmluZFBhcmVudFNlbGVjdChvcHRpb24ucGFyZW50KTtcblxuICBcdC8vIHdlIG1pZ2h0IGJlIGluc2lkZSBhIDxkYXRhbGlzdD4gZWxlbWVudFxuICBcdGlmICghb3B0aW9uLnNlbGVjdCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdG9wdGlvbi5zZWxlY3Qub3B0aW9ucy5wdXNoKG9wdGlvbik7XG5cbiAgXHQvLyBJZiB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIG1pc3NpbmcsIHVzZSB0aGUgZWxlbWVudCdzIGNvbnRlbnRcbiAgXHRpZiAoIXRlbXBsYXRlLmEpIHtcbiAgXHRcdHRlbXBsYXRlLmEgPSB7fTtcbiAgXHR9XG5cbiAgXHQvLyAuLi5hcyBsb25nIGFzIGl0IGlzbid0IGRpc2FibGVkXG4gIFx0aWYgKHRlbXBsYXRlLmEudmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhdGVtcGxhdGUuYS5oYXNPd25Qcm9wZXJ0eShcImRpc2FibGVkXCIpKSB7XG4gIFx0XHR0ZW1wbGF0ZS5hLnZhbHVlID0gdGVtcGxhdGUuZjtcbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGVyZSBpcyBhIGBzZWxlY3RlZGAgYXR0cmlidXRlLCBidXQgdGhlIDxzZWxlY3Q+XG4gIFx0Ly8gYWxyZWFkeSBoYXMgYSB2YWx1ZSwgZGVsZXRlIGl0XG4gIFx0aWYgKFwic2VsZWN0ZWRcIiBpbiB0ZW1wbGF0ZS5hICYmIG9wdGlvbi5zZWxlY3QuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0ZGVsZXRlIHRlbXBsYXRlLmEuc2VsZWN0ZWQ7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gc3BlY2lhbF9vcHRpb25fX3VuYmluZChvcHRpb24pIHtcbiAgXHRpZiAob3B0aW9uLnNlbGVjdCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KG9wdGlvbi5zZWxlY3Qub3B0aW9ucywgb3B0aW9uKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kUGFyZW50U2VsZWN0KGVsZW1lbnQpIHtcbiAgXHRpZiAoIWVsZW1lbnQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAoZWxlbWVudC5uYW1lID09PSBcInNlbGVjdFwiKSB7XG4gIFx0XHRcdHJldHVybiBlbGVtZW50O1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCk7XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfaW5pdCA9IEVsZW1lbnQkaW5pdDtcbiAgZnVuY3Rpb24gRWxlbWVudCRpbml0KG9wdGlvbnMpIHtcbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLCByYWN0aXZlLCBiaW5kaW5nLCBiaW5kaW5ncywgdHdvd2F5LCBiaW5kaW5nQXR0cnM7XG5cbiAgXHR0aGlzLnR5cGUgPSBFTEVNRU5UO1xuXG4gIFx0Ly8gc3R1ZmYgd2UnbGwgbmVlZCBsYXRlclxuICBcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblxuICBcdHRoaXMucGFyZW50ID0gb3B0aW9ucy5wRWxlbWVudCB8fCBwYXJlbnRGcmFnbWVudC5wRWxlbWVudDtcblxuICBcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuICBcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICBcdHRoaXMua2V5ID0gb3B0aW9ucy5rZXk7XG5cbiAgXHR0aGlzLm5hbWUgPSBlbmZvcmNlQ2FzZSh0ZW1wbGF0ZS5lKTtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIDxvcHRpb24+IGVsZW1lbnRzXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJvcHRpb25cIikge1xuICBcdFx0c3BlY2lhbF9vcHRpb25fX2luaXQodGhpcywgdGVtcGxhdGUpO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIDxzZWxlY3Q+IGVsZW1lbnRzXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICBcdFx0dGhpcy5vcHRpb25zID0gW107XG4gIFx0XHR0aGlzLmJ1YmJsZSA9IHNlbGVjdF9fYnViYmxlOyAvLyBUT0RPIHRoaXMgaXMgYSBrbHVkZ2VcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSA8Zm9ybT4gZWxlbWVudHNcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcImZvcm1cIikge1xuICBcdFx0dGhpcy5mb3JtQmluZGluZ3MgPSBbXTtcbiAgXHR9XG5cbiAgXHQvLyBoYW5kbGUgYmluZGluZyBhdHRyaWJ1dGVzIGZpcnN0ICh0d293YXksIGxhenkpXG4gIFx0YmluZGluZ0F0dHJzID0gcHJvY2Vzc0JpbmRpbmdBdHRyaWJ1dGVzKHRoaXMsIHRlbXBsYXRlKTtcblxuICBcdC8vIGNyZWF0ZSBhdHRyaWJ1dGVzXG4gIFx0dGhpcy5hdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlcyh0aGlzLCB0ZW1wbGF0ZS5hKTtcbiAgXHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcyA9IGNyZWF0ZUNvbmRpdGlvbmFsQXR0cmlidXRlcyh0aGlzLCB0ZW1wbGF0ZS5tKTtcblxuICBcdC8vIGFwcGVuZCBjaGlsZHJlbiwgaWYgdGhlcmUgYXJlIGFueVxuICBcdGlmICh0ZW1wbGF0ZS5mKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZixcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRcdHBFbGVtZW50OiB0aGlzLFxuICBcdFx0XHRjc3NJZHM6IG51bGxcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIHRoZSBlbGVtZW50IHNldHRpbmcgc2hvdWxkIG92ZXJyaWRlIHRoZSByYWN0aXZlIHNldHRpbmdcbiAgXHR0d293YXkgPSByYWN0aXZlLnR3b3dheTtcbiAgXHRpZiAoYmluZGluZ0F0dHJzLnR3b3dheSA9PT0gZmFsc2UpIHR3b3dheSA9IGZhbHNlO2Vsc2UgaWYgKGJpbmRpbmdBdHRycy50d293YXkgPT09IHRydWUpIHR3b3dheSA9IHRydWU7XG5cbiAgXHR0aGlzLnR3b3dheSA9IHR3b3dheTtcbiAgXHR0aGlzLmxhenkgPSBiaW5kaW5nQXR0cnMubGF6eTtcblxuICBcdC8vIGNyZWF0ZSB0d293YXkgYmluZGluZ1xuICBcdGlmICh0d293YXkgJiYgKGJpbmRpbmcgPSBpbml0X2NyZWF0ZVR3b3dheUJpbmRpbmcodGhpcywgdGVtcGxhdGUuYSkpKSB7XG4gIFx0XHR0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuXG4gIFx0XHQvLyByZWdpc3RlciB0aGlzIHdpdGggdGhlIHJvb3QsIHNvIHRoYXQgd2UgY2FuIGRvIHJhY3RpdmUudXBkYXRlTW9kZWwoKVxuICBcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW2JpbmRpbmcua2V5cGF0aC5zdHJdIHx8ICh0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW2JpbmRpbmcua2V5cGF0aC5zdHJdID0gW10pO1xuICBcdFx0YmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgXHR9XG5cbiAgXHQvLyBjcmVhdGUgZXZlbnQgcHJveGllc1xuICBcdGlmICh0ZW1wbGF0ZS52KSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMgPSBjcmVhdGVFdmVudEhhbmRsZXJzKHRoaXMsIHRlbXBsYXRlLnYpO1xuICBcdH1cblxuICBcdC8vIGNyZWF0ZSBkZWNvcmF0b3JcbiAgXHRpZiAodGVtcGxhdGUubykge1xuICBcdFx0dGhpcy5kZWNvcmF0b3IgPSBuZXcgX0RlY29yYXRvcih0aGlzLCB0ZW1wbGF0ZS5vKTtcbiAgXHR9XG5cbiAgXHQvLyBjcmVhdGUgdHJhbnNpdGlvbnNcbiAgXHR0aGlzLmludHJvID0gdGVtcGxhdGUudDAgfHwgdGVtcGxhdGUudDE7XG4gIFx0dGhpcy5vdXRybyA9IHRlbXBsYXRlLnQwIHx8IHRlbXBsYXRlLnQyO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3JlYmluZCA9IEVsZW1lbnQkcmViaW5kO1xuICBmdW5jdGlvbiBFbGVtZW50JHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0dmFyIGksIHN0b3JhZ2UsIGxpdmVRdWVyaWVzLCByYWN0aXZlO1xuXG4gIFx0aWYgKHRoaXMuYXR0cmlidXRlcykge1xuICBcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2gocmViaW5kKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMpIHtcbiAgXHRcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLmZvckVhY2gocmViaW5kKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChyZWJpbmQpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmRlY29yYXRvcikge1xuICBcdFx0cmViaW5kKHRoaXMuZGVjb3JhdG9yKTtcbiAgXHR9XG5cbiAgXHQvLyByZWJpbmQgY2hpbGRyZW5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0cmViaW5kKHRoaXMuZnJhZ21lbnQpO1xuICBcdH1cblxuICBcdC8vIFVwZGF0ZSBsaXZlIHF1ZXJpZXMsIGlmIG5lY2Vzc2FyeVxuICBcdGlmIChsaXZlUXVlcmllcyA9IHRoaXMubGl2ZVF1ZXJpZXMpIHtcbiAgXHRcdHJhY3RpdmUgPSB0aGlzLnJvb3Q7XG5cbiAgXHRcdGkgPSBsaXZlUXVlcmllcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGxpdmVRdWVyaWVzW2ldLl9tYWtlRGlydHkoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5ub2RlICYmIChzdG9yYWdlID0gdGhpcy5ub2RlLl9yYWN0aXZlKSkge1xuXG4gIFx0XHQvLyBhZGp1c3Qga2V5cGF0aCBpZiBuZWVkZWRcbiAgXHRcdGFzc2lnbk5ld0tleXBhdGgoc3RvcmFnZSwgXCJrZXlwYXRoXCIsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlYmluZCh0aGluZykge1xuICBcdFx0dGhpbmcucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNwZWNpYWxfaW1nX19yZW5kZXIoaW1nKSB7XG4gIFx0dmFyIGxvYWRIYW5kbGVyO1xuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhbiA8aW1nPiwgYW5kIHdlJ3JlIGluIGEgY3JhcCBicm93c2VyLCB3ZSBtYXkgbmVlZCB0byBwcmV2ZW50IGl0XG4gIFx0Ly8gZnJvbSBvdmVycmlkaW5nIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBpdCBsb2FkcyB0aGUgc3JjXG4gIFx0aWYgKGltZy5hdHRyaWJ1dGVzLndpZHRoIHx8IGltZy5hdHRyaWJ1dGVzLmhlaWdodCkge1xuICBcdFx0aW1nLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbG9hZEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHZhciB3aWR0aCA9IGltZy5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSxcbiAgXHRcdFx0ICAgIGhlaWdodCA9IGltZy5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIik7XG5cbiAgXHRcdFx0aWYgKHdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRpbWcubm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRpbWcubm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGltZy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHR9LCBmYWxzZSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZm9ybV9fcmVuZGVyKGVsZW1lbnQpIHtcbiAgXHRlbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0XCIsIGhhbmRsZVJlc2V0LCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtX191bnJlbmRlcihlbGVtZW50KSB7XG4gIFx0ZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBoYW5kbGVSZXNldCwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVzZXQoKSB7XG4gIFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9yYWN0aXZlLnByb3h5O1xuXG4gIFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQoKTtcbiAgXHRlbGVtZW50LmZvcm1CaW5kaW5ncy5mb3JFYWNoKHVwZGF0ZU1vZGVsKTtcbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU1vZGVsKGJpbmRpbmcpIHtcbiAgXHRiaW5kaW5nLnJvb3Qudmlld21vZGVsLnNldChiaW5kaW5nLmtleXBhdGgsIGJpbmRpbmcucmVzZXRWYWx1ZSk7XG4gIH1cblxuICB2YXIgVHJhbnNpdGlvbl9wcm90b3R5cGVfaW5pdCA9IFRyYW5zaXRpb24kaW5pdDtcbiAgZnVuY3Rpb24gVHJhbnNpdGlvbiRpbml0KGVsZW1lbnQsIHRlbXBsYXRlLCBpc0ludHJvKSB7XG4gIFx0dmFyIHJhY3RpdmUsIG5hbWUsIGZyYWdtZW50O1xuXG4gIFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlID0gZWxlbWVudC5yb290O1xuICBcdHRoaXMuaXNJbnRybyA9IGlzSW50cm87XG5cbiAgXHRuYW1lID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblxuICBcdGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiBuYW1lLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogZWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuICBcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cbiAgXHRcdGlmIChuYW1lID09PSBcIlwiKSB7XG4gIFx0XHRcdC8vIGVtcHR5IHN0cmluZyBva2F5LCBqdXN0IG5vIHRyYW5zaXRpb25cbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgXHRpZiAodGVtcGxhdGUuYSkge1xuICBcdFx0dGhpcy5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuICBcdH0gZWxzZSBpZiAodGVtcGxhdGUuZCkge1xuICBcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIHdheSB0byBpbnRlcnByZXQgZHluYW1pYyBhcmd1bWVudHMgd2l0aG91dCBhbGwgdGhlXG4gIFx0XHQvLyAnZGVwZW5kZW5jeSB0aHJhc2hpbmcnP1xuICBcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogZWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMucGFyYW1zID0gZnJhZ21lbnQuZ2V0QXJnc0xpc3QoKTtcbiAgXHRcdGZyYWdtZW50LnVuYmluZCgpO1xuICBcdH1cblxuICBcdHRoaXMuX2ZuID0gZmluZEluVmlld0hpZXJhcmNoeShcInRyYW5zaXRpb25zXCIsIHJhY3RpdmUsIG5hbWUpO1xuXG4gIFx0aWYgKCF0aGlzLl9mbikge1xuICBcdFx0d2Fybk9uY2VJZkRlYnVnKG1pc3NpbmdQbHVnaW4obmFtZSwgXCJ0cmFuc2l0aW9uXCIpLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHR9XG4gIH1cblxuICB2YXIgY2FtZWxDYXNlID0gZnVuY3Rpb24gKGh5cGhlbmF0ZWRTdHIpIHtcbiAgXHRyZXR1cm4gaHlwaGVuYXRlZFN0ci5yZXBsYWNlKC8tKFthLXpBLVpdKS9nLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gIFx0XHRyZXR1cm4gJDEudG9VcHBlckNhc2UoKTtcbiAgXHR9KTtcbiAgfTtcblxuICB2YXIgaGVscGVyc19wcmVmaXhfX3ByZWZpeCwgcHJlZml4Q2FjaGUsIGhlbHBlcnNfcHJlZml4X190ZXN0U3R5bGU7XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdGhlbHBlcnNfcHJlZml4X19wcmVmaXggPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdHByZWZpeENhY2hlID0ge307XG4gIFx0aGVscGVyc19wcmVmaXhfX3Rlc3RTdHlsZSA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGU7XG5cbiAgXHRoZWxwZXJzX3ByZWZpeF9fcHJlZml4ID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgXHRcdHZhciBpLCB2ZW5kb3IsIGNhcHBlZDtcblxuICBcdFx0cHJvcCA9IGNhbWVsQ2FzZShwcm9wKTtcblxuICBcdFx0aWYgKCFwcmVmaXhDYWNoZVtwcm9wXSkge1xuICBcdFx0XHRpZiAoaGVscGVyc19wcmVmaXhfX3Rlc3RTdHlsZVtwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0cHJlZml4Q2FjaGVbcHJvcF0gPSBwcm9wO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdC8vIHRlc3QgdmVuZG9ycy4uLlxuICBcdFx0XHRcdGNhcHBlZCA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnN1YnN0cmluZygxKTtcblxuICBcdFx0XHRcdGkgPSB2ZW5kb3JzLmxlbmd0aDtcbiAgXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0XHR2ZW5kb3IgPSB2ZW5kb3JzW2ldO1xuICBcdFx0XHRcdFx0aWYgKGhlbHBlcnNfcHJlZml4X190ZXN0U3R5bGVbdmVuZG9yICsgY2FwcGVkXSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHRcdHByZWZpeENhY2hlW3Byb3BdID0gdmVuZG9yICsgY2FwcGVkO1xuICBcdFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHByZWZpeENhY2hlW3Byb3BdO1xuICBcdH07XG4gIH1cblxuICB2YXIgaGVscGVyc19wcmVmaXggPSBoZWxwZXJzX3ByZWZpeF9fcHJlZml4O1xuXG4gIHZhciBnZXRTdHlsZSwgcHJvdG90eXBlX2dldFN0eWxlX19nZXRDb21wdXRlZFN0eWxlO1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRnZXRTdHlsZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0cHJvdG90eXBlX2dldFN0eWxlX19nZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgfHwgbGVnYWN5LmdldENvbXB1dGVkU3R5bGU7XG5cbiAgXHRnZXRTdHlsZSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICBcdFx0dmFyIGNvbXB1dGVkU3R5bGUsIHN0eWxlcywgaSwgcHJvcCwgdmFsdWU7XG5cbiAgXHRcdGNvbXB1dGVkU3R5bGUgPSBwcm90b3R5cGVfZ2V0U3R5bGVfX2dldENvbXB1dGVkU3R5bGUodGhpcy5ub2RlKTtcblxuICBcdFx0aWYgKHR5cGVvZiBwcm9wcyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHR2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbaGVscGVyc19wcmVmaXgocHJvcHMpXTtcbiAgXHRcdFx0aWYgKHZhbHVlID09PSBcIjBweFwiKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSAwO1xuICBcdFx0XHR9XG4gIFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpc0FycmF5KHByb3BzKSkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2l0aW9uJGdldFN0eWxlIG11c3QgYmUgcGFzc2VkIGEgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBDU1MgcHJvcGVydGllc1wiKTtcbiAgXHRcdH1cblxuICBcdFx0c3R5bGVzID0ge307XG5cbiAgXHRcdGkgPSBwcm9wcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdHByb3AgPSBwcm9wc1tpXTtcbiAgXHRcdFx0dmFsdWUgPSBjb21wdXRlZFN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXTtcbiAgXHRcdFx0aWYgKHZhbHVlID09PSBcIjBweFwiKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSAwO1xuICBcdFx0XHR9XG4gIFx0XHRcdHN0eWxlc1twcm9wXSA9IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc3R5bGVzO1xuICBcdH07XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2dldFN0eWxlID0gZ2V0U3R5bGU7XG5cbiAgdmFyIHNldFN0eWxlID0gZnVuY3Rpb24gKHN0eWxlLCB2YWx1ZSkge1xuICBcdHZhciBwcm9wO1xuXG4gIFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0dGhpcy5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHN0eWxlKV0gPSB2YWx1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Zm9yIChwcm9wIGluIHN0eWxlKSB7XG4gIFx0XHRcdGlmIChzdHlsZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICBcdFx0XHRcdHRoaXMubm9kZS5zdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV0gPSBzdHlsZVtwcm9wXTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBUaWNrZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBlYXNpbmc7XG5cbiAgXHR0aGlzLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgXHR0aGlzLnN0ZXAgPSBvcHRpb25zLnN0ZXA7XG4gIFx0dGhpcy5jb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cbiAgXHQvLyBlYXNpbmdcbiAgXHRpZiAodHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRlYXNpbmcgPSBvcHRpb25zLnJvb3QuZWFzaW5nW29wdGlvbnMuZWFzaW5nXTtcblxuICBcdFx0aWYgKCFlYXNpbmcpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKG1pc3NpbmdQbHVnaW4ob3B0aW9ucy5lYXNpbmcsIFwiZWFzaW5nXCIpKTtcbiAgXHRcdFx0ZWFzaW5nID0gbGluZWFyO1xuICBcdFx0fVxuICBcdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRlYXNpbmcgPSBsaW5lYXI7XG4gIFx0fVxuXG4gIFx0dGhpcy5lYXNpbmcgPSBlYXNpbmc7XG5cbiAgXHR0aGlzLnN0YXJ0ID0gdXRpbHNfZ2V0VGltZSgpO1xuICBcdHRoaXMuZW5kID0gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG5cbiAgXHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICBcdHNoYXJlZF9hbmltYXRpb25zLmFkZCh0aGlzKTtcbiAgfTtcblxuICBUaWNrZXIucHJvdG90eXBlID0ge1xuICBcdHRpY2s6IGZ1bmN0aW9uIChub3cpIHtcbiAgXHRcdHZhciBlbGFwc2VkLCBlYXNlZDtcblxuICBcdFx0aWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobm93ID4gdGhpcy5lbmQpIHtcbiAgXHRcdFx0aWYgKHRoaXMuc3RlcCkge1xuICBcdFx0XHRcdHRoaXMuc3RlcCgxKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICh0aGlzLmNvbXBsZXRlKSB7XG4gIFx0XHRcdFx0dGhpcy5jb21wbGV0ZSgxKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0ZWxhcHNlZCA9IG5vdyAtIHRoaXMuc3RhcnQ7XG4gIFx0XHRlYXNlZCA9IHRoaXMuZWFzaW5nKGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uKTtcblxuICBcdFx0aWYgKHRoaXMuc3RlcCkge1xuICBcdFx0XHR0aGlzLnN0ZXAoZWFzZWQpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0c3RvcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuYWJvcnQpIHtcbiAgXHRcdFx0dGhpcy5hYm9ydCgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9UaWNrZXIgPSBUaWNrZXI7XG4gIGZ1bmN0aW9uIGxpbmVhcih0KSB7XG4gIFx0cmV0dXJuIHQ7XG4gIH1cblxuICB2YXIgdW5wcmVmaXhQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4tKD86XCIgKyB2ZW5kb3JzLmpvaW4oXCJ8XCIpICsgXCIpLVwiKTtcblxuICB2YXIgdW5wcmVmaXggPSBmdW5jdGlvbiAocHJvcCkge1xuICBcdHJldHVybiBwcm9wLnJlcGxhY2UodW5wcmVmaXhQYXR0ZXJuLCBcIlwiKTtcbiAgfTtcblxuICB2YXIgdmVuZG9yUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeKD86XCIgKyB2ZW5kb3JzLmpvaW4oXCJ8XCIpICsgXCIpKFtBLVpdKVwiKTtcblxuICB2YXIgaHlwaGVuYXRlID0gZnVuY3Rpb24gKHN0cikge1xuICBcdHZhciBoeXBoZW5hdGVkO1xuXG4gIFx0aWYgKCFzdHIpIHtcbiAgXHRcdHJldHVybiBcIlwiOyAvLyBlZGdlIGNhc2VcbiAgXHR9XG5cbiAgXHRpZiAodmVuZG9yUGF0dGVybi50ZXN0KHN0cikpIHtcbiAgXHRcdHN0ciA9IFwiLVwiICsgc3RyO1xuICBcdH1cblxuICBcdGh5cGhlbmF0ZWQgPSBzdHIucmVwbGFjZSgvW0EtWl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gIFx0XHRyZXR1cm4gXCItXCIgKyBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIGh5cGhlbmF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVRyYW5zaXRpb25zLFxuICAgICAgYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zX190ZXN0U3R5bGUsXG4gICAgICBUUkFOU0lUSU9OLFxuICAgICAgVFJBTlNJVElPTkVORCxcbiAgICAgIENTU19UUkFOU0lUSU9OU19FTkFCTEVELFxuICAgICAgVFJBTlNJVElPTl9EVVJBVElPTixcbiAgICAgIFRSQU5TSVRJT05fUFJPUEVSVFksXG4gICAgICBUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTixcbiAgICAgIGNhblVzZUNzc1RyYW5zaXRpb25zID0ge30sXG4gICAgICBjYW5ub3RVc2VDc3NUcmFuc2l0aW9ucyA9IHt9O1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRjcmVhdGVUcmFuc2l0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0YW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zX190ZXN0U3R5bGUgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlO1xuXG4gIFx0Ly8gZGV0ZXJtaW5lIHNvbWUgZmFjdHMgYWJvdXQgb3VyIGVudmlyb25tZW50XG4gIFx0KGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmIChhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnNfX3Rlc3RTdHlsZS50cmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0VFJBTlNJVElPTiA9IFwidHJhbnNpdGlvblwiO1xuICBcdFx0XHRUUkFOU0lUSU9ORU5EID0gXCJ0cmFuc2l0aW9uZW5kXCI7XG4gIFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSBpZiAoYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zX190ZXN0U3R5bGUud2Via2l0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFRSQU5TSVRJT04gPSBcIndlYmtpdFRyYW5zaXRpb25cIjtcbiAgXHRcdFx0VFJBTlNJVElPTkVORCA9IFwid2Via2l0VHJhbnNpdGlvbkVuZFwiO1xuICBcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IHRydWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH0pKCk7XG5cbiAgXHRpZiAoVFJBTlNJVElPTikge1xuICBcdFx0VFJBTlNJVElPTl9EVVJBVElPTiA9IFRSQU5TSVRJT04gKyBcIkR1cmF0aW9uXCI7XG4gIFx0XHRUUkFOU0lUSU9OX1BST1BFUlRZID0gVFJBTlNJVElPTiArIFwiUHJvcGVydHlcIjtcbiAgXHRcdFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OID0gVFJBTlNJVElPTiArIFwiVGltaW5nRnVuY3Rpb25cIjtcbiAgXHR9XG5cbiAgXHRjcmVhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uICh0LCB0bywgb3B0aW9ucywgY2hhbmdlZFByb3BlcnRpZXMsIHJlc29sdmUpIHtcblxuICBcdFx0Ly8gV2FpdCBhIGJlYXQgKG90aGVyd2lzZSB0aGUgdGFyZ2V0IHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgaW1tZWRpYXRlbHkpXG4gIFx0XHQvLyBUT0RPIHVzZSBhIGZhc3Rkb20tc3R5bGUgbWVjaGFuaXNtP1xuICBcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cbiAgXHRcdFx0dmFyIGhhc2hQcmVmaXgsIGpzVHJhbnNpdGlvbnNDb21wbGV0ZSwgY3NzVHJhbnNpdGlvbnNDb21wbGV0ZSwgY2hlY2tDb21wbGV0ZSwgdHJhbnNpdGlvbkVuZEhhbmRsZXI7XG5cbiAgXHRcdFx0Y2hlY2tDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRpZiAoanNUcmFuc2l0aW9uc0NvbXBsZXRlICYmIGNzc1RyYW5zaXRpb25zQ29tcGxldGUpIHtcbiAgXHRcdFx0XHRcdC8vIHdpbGwgY2hhbmdlcyB0byBldmVudHMgYW5kIGZpcmUgaGF2ZSBhbiB1bmV4cGVjdGVkIGNvbnNlcXVlbmNlIGhlcmU/XG4gIFx0XHRcdFx0XHR0LnJvb3QuZmlyZSh0Lm5hbWUgKyBcIjplbmRcIiwgdC5ub2RlLCB0LmlzSW50cm8pO1xuICBcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fTtcblxuICBcdFx0XHQvLyB0aGlzIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBlbGVtZW50cyBjYW4gdXNlIENTUyB0byBhbmltYXRlXG4gIFx0XHRcdC8vIHdoaWNoIHByb3BlcnRpZXNcbiAgXHRcdFx0aGFzaFByZWZpeCA9ICh0Lm5vZGUubmFtZXNwYWNlVVJJIHx8IFwiXCIpICsgdC5ub2RlLnRhZ05hbWU7XG5cbiAgXHRcdFx0dC5ub2RlLnN0eWxlW1RSQU5TSVRJT05fUFJPUEVSVFldID0gY2hhbmdlZFByb3BlcnRpZXMubWFwKGhlbHBlcnNfcHJlZml4KS5tYXAoaHlwaGVuYXRlKS5qb2luKFwiLFwiKTtcbiAgXHRcdFx0dC5ub2RlLnN0eWxlW1RSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OXSA9IGh5cGhlbmF0ZShvcHRpb25zLmVhc2luZyB8fCBcImxpbmVhclwiKTtcbiAgXHRcdFx0dC5ub2RlLnN0eWxlW1RSQU5TSVRJT05fRFVSQVRJT05dID0gb3B0aW9ucy5kdXJhdGlvbiAvIDEwMDAgKyBcInNcIjtcblxuICBcdFx0XHR0cmFuc2l0aW9uRW5kSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBcdFx0XHRcdHZhciBpbmRleDtcblxuICBcdFx0XHRcdGluZGV4ID0gY2hhbmdlZFByb3BlcnRpZXMuaW5kZXhPZihjYW1lbENhc2UodW5wcmVmaXgoZXZlbnQucHJvcGVydHlOYW1lKSkpO1xuICBcdFx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICBcdFx0XHRcdFx0Ly8gc3RpbGwgdHJhbnNpdGlvbmluZy4uLlxuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSk7XG5cbiAgXHRcdFx0XHRjc3NUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0dC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlKTtcblxuICBcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHR2YXIgaSA9IGNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCxcbiAgXHRcdFx0XHQgICAgaGFzaCxcbiAgXHRcdFx0XHQgICAgb3JpZ2luYWxWYWx1ZSxcbiAgXHRcdFx0XHQgICAgaW5kZXgsXG4gIFx0XHRcdFx0ICAgIHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzID0gW10sXG4gIFx0XHRcdFx0ICAgIHByb3AsXG4gIFx0XHRcdFx0ICAgIHN1ZmZpeDtcblxuICBcdFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRcdHByb3AgPSBjaGFuZ2VkUHJvcGVydGllc1tpXTtcbiAgXHRcdFx0XHRcdGhhc2ggPSBoYXNoUHJlZml4ICsgcHJvcDtcblxuICBcdFx0XHRcdFx0aWYgKENTU19UUkFOU0lUSU9OU19FTkFCTEVEICYmICFjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1toYXNoXSkge1xuICBcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldID0gdG9bcHJvcF07XG5cbiAgXHRcdFx0XHRcdFx0Ly8gSWYgd2UncmUgbm90IHN1cmUgaWYgQ1NTIHRyYW5zaXRpb25zIGFyZSBzdXBwb3J0ZWQgZm9yXG4gIFx0XHRcdFx0XHRcdC8vIHRoaXMgdGFnL3Byb3BlcnR5IGNvbWJvLCBmaW5kIG91dCBub3dcbiAgXHRcdFx0XHRcdFx0aWYgKCFjYW5Vc2VDc3NUcmFuc2l0aW9uc1toYXNoXSkge1xuICBcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKHByb3ApO1xuXG4gIFx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhpcyBwcm9wZXJ0eSBpcyB0cmFuc2l0aW9uYWJsZSBpbiB0aGlzIGJyb3dzZXIsXG4gIFx0XHRcdFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgc3R5bGUgd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgdGFyZ2V0IHN0eWxlXG4gIFx0XHRcdFx0XHRcdFx0Y2FuVXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0gPSB0LmdldFN0eWxlKHByb3ApICE9IHRvW3Byb3BdO1xuICBcdFx0XHRcdFx0XHRcdGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zW2hhc2hdID0gIWNhblVzZUNzc1RyYW5zaXRpb25zW2hhc2hdO1xuXG4gIFx0XHRcdFx0XHRcdFx0Ly8gUmVzZXQsIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSB0aW1lcnMgYWZ0ZXIgYWxsXG4gIFx0XHRcdFx0XHRcdFx0aWYgKGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zW2hhc2hdKSB7XG4gIFx0XHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldID0gb3JpZ2luYWxWYWx1ZTtcbiAgXHRcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0aWYgKCFDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCB8fCBjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1toYXNoXSkge1xuICBcdFx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aW1lci1iYXNlZCBzdHVmZlxuICBcdFx0XHRcdFx0XHRpZiAob3JpZ2luYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZSA9IHQuZ2V0U3R5bGUocHJvcCk7XG4gIFx0XHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0XHQvLyBuZWVkIHRvIHJlbW92ZSB0aGlzIGZyb20gY2hhbmdlZFByb3BlcnRpZXMsIG90aGVyd2lzZSB0cmFuc2l0aW9uRW5kSGFuZGxlclxuICBcdFx0XHRcdFx0XHQvLyB3aWxsIGdldCBjb25mdXNlZFxuICBcdFx0XHRcdFx0XHRpbmRleCA9IGNoYW5nZWRQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCk7XG4gIFx0XHRcdFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0XHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIlNvbWV0aGluZyB2ZXJ5IHN0cmFuZ2UgaGFwcGVuZWQgd2l0aCB0cmFuc2l0aW9ucy4gUGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MhXCIsIHsgbm9kZTogdC5ub2RlIH0pO1xuICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0XHQvLyBUT0RPIERldGVybWluZSB3aGV0aGVyIHRoaXMgcHJvcGVydHkgaXMgYW5pbWF0YWJsZSBhdCBhbGxcblxuICBcdFx0XHRcdFx0XHRzdWZmaXggPSAvW15cXGRdKiQvLmV4ZWModG9bcHJvcF0pWzBdO1xuXG4gIFx0XHRcdFx0XHRcdC8vIC4uLnRoZW4ga2ljayBvZmYgYSB0aW1lci1iYXNlZCB0cmFuc2l0aW9uXG4gIFx0XHRcdFx0XHRcdHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLnB1c2goe1xuICBcdFx0XHRcdFx0XHRcdG5hbWU6IGhlbHBlcnNfcHJlZml4KHByb3ApLFxuICBcdFx0XHRcdFx0XHRcdGludGVycG9sYXRvcjogc2hhcmVkX2ludGVycG9sYXRlKHBhcnNlRmxvYXQob3JpZ2luYWxWYWx1ZSksIHBhcnNlRmxvYXQodG9bcHJvcF0pKSxcbiAgXHRcdFx0XHRcdFx0XHRzdWZmaXg6IHN1ZmZpeFxuICBcdFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyBqYXZhc2NyaXB0IHRyYW5zaXRpb25zXG4gIFx0XHRcdFx0aWYgKHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLmxlbmd0aCkge1xuICBcdFx0XHRcdFx0bmV3IHNoYXJlZF9UaWNrZXIoe1xuICBcdFx0XHRcdFx0XHRyb290OiB0LnJvb3QsXG4gIFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICBcdFx0XHRcdFx0XHRlYXNpbmc6IGNhbWVsQ2FzZShvcHRpb25zLmVhc2luZyB8fCBcIlwiKSxcbiAgXHRcdFx0XHRcdFx0c3RlcDogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0XHRcdFx0XHRcdHZhciBwcm9wLCBpO1xuXG4gIFx0XHRcdFx0XHRcdFx0aSA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLmxlbmd0aDtcbiAgXHRcdFx0XHRcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRwcm9wID0gcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnNbaV07XG4gIFx0XHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbcHJvcC5uYW1lXSA9IHByb3AuaW50ZXJwb2xhdG9yKHBvcykgKyBwcm9wLnN1ZmZpeDtcbiAgXHRcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcdH0sXG4gIFx0XHRcdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRcdFx0anNUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRqc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmICghY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGFuZCBkZWFsIHdpdGhcbiAgXHRcdFx0XHRcdC8vIHRoZSBmYWN0IHRoYXQgaXQgd2lsbCBuZXZlciBmaXJlXG4gIFx0XHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UpO1xuICBcdFx0XHRcdFx0Y3NzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9LCAwKTtcbiAgXHRcdH0sIG9wdGlvbnMuZGVsYXkgfHwgMCk7XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnMgPSBjcmVhdGVUcmFuc2l0aW9ucztcblxuICB2YXIgaGlkZGVuLCB2ZW5kb3IsIGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXgsIGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19pLCB2aXNpYmlsaXR5O1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgXHRoaWRkZW4gPSBcImhpZGRlblwiO1xuXG4gIFx0dmlzaWJpbGl0eSA9IHt9O1xuXG4gIFx0aWYgKGhpZGRlbiBpbiBkb2N1bWVudCkge1xuICBcdFx0YW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX3ByZWZpeCA9IFwiXCI7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19pID0gdmVuZG9ycy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX2ktLSkge1xuICBcdFx0XHR2ZW5kb3IgPSB2ZW5kb3JzW2FuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19pXTtcbiAgXHRcdFx0aGlkZGVuID0gdmVuZG9yICsgXCJIaWRkZW5cIjtcblxuICBcdFx0XHRpZiAoaGlkZGVuIGluIGRvY3VtZW50KSB7XG4gIFx0XHRcdFx0YW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX3ByZWZpeCA9IHZlbmRvcjtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9fcHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX3ByZWZpeCArIFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvbkNoYW5nZSk7XG5cbiAgXHRcdC8vIGluaXRpYWxpc2VcbiAgXHRcdG9uQ2hhbmdlKCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIGdhaCwgd2UncmUgaW4gYW4gb2xkIGJyb3dzZXJcbiAgXHRcdGlmIChcIm9uZm9jdXNvdXRcIiBpbiBkb2N1bWVudCkge1xuICBcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgb25IaWRlKTtcbiAgXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgb25TaG93KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgb25IaWRlKTtcbiAgXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIG9uSGlkZSk7XG5cbiAgXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCBvblNob3cpO1xuICBcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIG9uU2hvdyk7XG4gIFx0XHR9XG5cbiAgXHRcdHZpc2liaWxpdHkuaGlkZGVuID0gZmFsc2U7IC8vIHVudGlsIHByb3ZlbiBvdGhlcndpc2UuIE5vdCBpZGVhbCBidXQgaGV5XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gIFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBkb2N1bWVudFtoaWRkZW5dO1xuICB9XG5cbiAgZnVuY3Rpb24gb25IaWRlKCkge1xuICBcdHZpc2liaWxpdHkuaGlkZGVuID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2hvdygpIHtcbiAgXHR2aXNpYmlsaXR5LmhpZGRlbiA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcblxuICB2YXIgYW5pbWF0ZVN0eWxlLCBfYW5pbWF0ZVN0eWxlX19nZXRDb21wdXRlZFN0eWxlLCByZXNvbHZlZDtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0YW5pbWF0ZVN0eWxlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRfYW5pbWF0ZVN0eWxlX19nZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgfHwgbGVnYWN5LmdldENvbXB1dGVkU3R5bGU7XG5cbiAgXHRhbmltYXRlU3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdG87XG5cbiAgXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcInQuYW5pbWF0ZVN0eWxlKCkgcmV0dXJucyBhIHByb21pc2UgLSB1c2UgLnRoZW4oKSBpbnN0ZWFkIG9mIHBhc3NpbmcgYSBjYWxsYmFja1wiKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gcGFnZSBpc24ndCB2aXNpYmxlLiBEb24ndCBhbmltYXRlIGFueXRoaW5nLCBiZWNhdXNlXG4gIFx0XHQvLyB0aGF0IHdheSB5b3UnbGwgbmV2ZXIgZ2V0IENTUyB0cmFuc2l0aW9uZW5kIGV2ZW50c1xuICBcdFx0aWYgKGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5LmhpZGRlbikge1xuICBcdFx0XHR0aGlzLnNldFN0eWxlKHN0eWxlLCB2YWx1ZSk7XG4gIFx0XHRcdHJldHVybiByZXNvbHZlZCB8fCAocmVzb2x2ZWQgPSB1dGlsc19Qcm9taXNlLnJlc29sdmUoKSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0dG8gPSB7fTtcbiAgXHRcdFx0dG9bc3R5bGVdID0gdmFsdWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0byA9IHN0eWxlO1xuXG4gIFx0XHRcdC8vIHNodWZmbGUgYXJndW1lbnRzXG4gIFx0XHRcdG9wdGlvbnMgPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gQXMgb2YgMC4zLjksIHRyYW5zaXRpb24gYXV0aG9ycyBzaG91bGQgc3VwcGx5IGFuIGBvcHRpb25gIG9iamVjdCB3aXRoXG4gIFx0XHQvLyBgZHVyYXRpb25gIGFuZCBgZWFzaW5nYCBwcm9wZXJ0aWVzIChhbmQgb3B0aW9uYWwgYGRlbGF5YCksIHBsdXMgYVxuICBcdFx0Ly8gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlc1xuXG4gIFx0XHQvLyBUT0RPIHJlbW92ZSB0aGlzIGNoZWNrIGluIGEgZnV0dXJlIHZlcnNpb25cbiAgXHRcdGlmICghb3B0aW9ucykge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcoXCJUaGUgXFxcIiVzXFxcIiB0cmFuc2l0aW9uIGRvZXMgbm90IHN1cHBseSBhbiBvcHRpb25zIG9iamVjdCB0byBgdC5hbmltYXRlU3R5bGUoKWAuIFRoaXMgd2lsbCBicmVhayBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUuIEZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMvMzQwXCIsIHRoaXMubmFtZSk7XG4gIFx0XHRcdG9wdGlvbnMgPSB0aGlzO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgcHJvbWlzZSA9IG5ldyB1dGlsc19Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gIFx0XHRcdHZhciBwcm9wZXJ0eU5hbWVzLCBjaGFuZ2VkUHJvcGVydGllcywgY29tcHV0ZWRTdHlsZSwgY3VycmVudCwgZnJvbSwgaSwgcHJvcDtcblxuICBcdFx0XHQvLyBFZGdlIGNhc2UgLSBpZiBkdXJhdGlvbiBpcyB6ZXJvLCBzZXQgc3R5bGUgc3luY2hyb25vdXNseSBhbmQgY29tcGxldGVcbiAgXHRcdFx0aWYgKCFvcHRpb25zLmR1cmF0aW9uKSB7XG4gIFx0XHRcdFx0X3RoaXMuc2V0U3R5bGUodG8pO1xuICBcdFx0XHRcdHJlc29sdmUoKTtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBHZXQgYSBsaXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHdlJ3JlIGFuaW1hdGluZ1xuICBcdFx0XHRwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmtleXModG8pO1xuICBcdFx0XHRjaGFuZ2VkUHJvcGVydGllcyA9IFtdO1xuXG4gIFx0XHRcdC8vIFN0b3JlIHRoZSBjdXJyZW50IHN0eWxlc1xuICBcdFx0XHRjb21wdXRlZFN0eWxlID0gX2FuaW1hdGVTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZShfdGhpcy5ub2RlKTtcblxuICBcdFx0XHRmcm9tID0ge307XG4gIFx0XHRcdGkgPSBwcm9wZXJ0eU5hbWVzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdHByb3AgPSBwcm9wZXJ0eU5hbWVzW2ldO1xuICBcdFx0XHRcdGN1cnJlbnQgPSBjb21wdXRlZFN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXTtcblxuICBcdFx0XHRcdGlmIChjdXJyZW50ID09PSBcIjBweFwiKSB7XG4gIFx0XHRcdFx0XHRjdXJyZW50ID0gMDtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGtub3cgaWYgd2UncmUgYWN0dWFsbHkgY2hhbmdpbmcgYW55dGhpbmdcbiAgXHRcdFx0XHRpZiAoY3VycmVudCAhPSB0b1twcm9wXSkge1xuICBcdFx0XHRcdFx0Ly8gdXNlICE9IGluc3RlYWQgb2YgIT09LCBzbyB3ZSBjYW4gY29tcGFyZSBzdHJpbmdzIHdpdGggbnVtYmVyc1xuICBcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMucHVzaChwcm9wKTtcblxuICBcdFx0XHRcdFx0Ly8gbWFrZSB0aGUgY29tcHV0ZWQgc3R5bGUgZXhwbGljaXQsIHNvIHdlIGNhbiBhbmltYXRlIHdoZXJlXG4gIFx0XHRcdFx0XHQvLyBlLmcuIGhlaWdodD0nYXV0bydcbiAgXHRcdFx0XHRcdF90aGlzLm5vZGUuc3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldID0gY3VycmVudDtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBJZiB3ZSdyZSBub3QgYWN0dWFsbHkgY2hhbmdpbmcgYW55dGhpbmcsIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50XG4gIFx0XHRcdC8vIHdpbGwgbmV2ZXIgZmlyZSEgU28gd2UgY29tcGxldGUgZWFybHlcbiAgXHRcdFx0aWYgKCFjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRyZXNvbHZlKCk7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0YW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zKF90aGlzLCB0bywgb3B0aW9ucywgY2hhbmdlZFByb3BlcnRpZXMsIHJlc29sdmUpO1xuICBcdFx0fSk7XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH07XG4gIH1cblxuICB2YXIgX2FuaW1hdGVTdHlsZSA9IGFuaW1hdGVTdHlsZTtcblxuICB2YXIgcHJvY2Vzc1BhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGRlZmF1bHRzKSB7XG4gIFx0aWYgKHR5cGVvZiBwYXJhbXMgPT09IFwibnVtYmVyXCIpIHtcbiAgXHRcdHBhcmFtcyA9IHsgZHVyYXRpb246IHBhcmFtcyB9O1xuICBcdH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0aWYgKHBhcmFtcyA9PT0gXCJzbG93XCIpIHtcbiAgXHRcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogNjAwIH07XG4gIFx0XHR9IGVsc2UgaWYgKHBhcmFtcyA9PT0gXCJmYXN0XCIpIHtcbiAgXHRcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogMjAwIH07XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXJhbXMgPSB7IGR1cmF0aW9uOiA0MDAgfTtcbiAgXHRcdH1cbiAgXHR9IGVsc2UgaWYgKCFwYXJhbXMpIHtcbiAgXHRcdHBhcmFtcyA9IHt9O1xuICBcdH1cblxuICBcdHJldHVybiBmaWxsR2Fwcyh7fSwgcGFyYW1zLCBkZWZhdWx0cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvdHlwZV9zdGFydCA9IFRyYW5zaXRpb24kc3RhcnQ7XG5cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbiRzdGFydCgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUsIG9yaWdpbmFsU3R5bGUsIGNvbXBsZXRlZDtcblxuICBcdG5vZGUgPSB0aGlzLm5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcbiAgXHRvcmlnaW5hbFN0eWxlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcblxuICBcdC8vIGNyZWF0ZSB0LmNvbXBsZXRlKCkgLSB3ZSBkb24ndCB3YW50IHRoaXMgb24gdGhlIHByb3RvdHlwZSxcbiAgXHQvLyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYHRoaXNgIHNpbGxpbmVzcyB3aGVuIHBhc3NpbmcgaXQgYXNcbiAgXHQvLyBhbiBhcmd1bWVudFxuICBcdHRoaXMuY29tcGxldGUgPSBmdW5jdGlvbiAobm9SZXNldCkge1xuICBcdFx0aWYgKGNvbXBsZXRlZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghbm9SZXNldCAmJiBfdGhpcy5pc0ludHJvKSB7XG4gIFx0XHRcdHJlc2V0U3R5bGUobm9kZSwgb3JpZ2luYWxTdHlsZSk7XG4gIFx0XHR9XG5cbiAgXHRcdG5vZGUuX3JhY3RpdmUudHJhbnNpdGlvbiA9IG51bGw7XG4gIFx0XHRfdGhpcy5fbWFuYWdlci5yZW1vdmUoX3RoaXMpO1xuXG4gIFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuICBcdH07XG5cbiAgXHQvLyBJZiB0aGUgdHJhbnNpdGlvbiBmdW5jdGlvbiBkb2Vzbid0IGV4aXN0LCBhYm9ydFxuICBcdGlmICghdGhpcy5fZm4pIHtcbiAgXHRcdHRoaXMuY29tcGxldGUoKTtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR0aGlzLl9mbi5hcHBseSh0aGlzLnJvb3QsIFt0aGlzXS5jb25jYXQodGhpcy5wYXJhbXMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0U3R5bGUobm9kZSwgc3R5bGUpIHtcbiAgXHRpZiAoc3R5bGUpIHtcbiAgXHRcdG5vZGUuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgc3R5bGUpO1xuICBcdH0gZWxzZSB7XG5cbiAgXHRcdC8vIE5leHQgbGluZSBpcyBuZWNlc3NhcnksIHRvIHJlbW92ZSBlbXB0eSBzdHlsZSBhdHRyaWJ1dGUhXG4gIFx0XHQvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE2NzU1M1xuICBcdFx0bm9kZS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgXHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gIFx0fVxuICB9XG5cbiAgdmFyIFRyYW5zaXRpb24gPSBmdW5jdGlvbiAob3duZXIsIHRlbXBsYXRlLCBpc0ludHJvKSB7XG4gIFx0dGhpcy5pbml0KG93bmVyLCB0ZW1wbGF0ZSwgaXNJbnRybyk7XG4gIH07XG5cbiAgVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG4gIFx0aW5pdDogVHJhbnNpdGlvbl9wcm90b3R5cGVfaW5pdCxcbiAgXHRzdGFydDogcHJvdG90eXBlX3N0YXJ0LFxuICBcdGdldFN0eWxlOiBwcm90b3R5cGVfZ2V0U3R5bGUsXG4gIFx0c2V0U3R5bGU6IHNldFN0eWxlLFxuICBcdGFuaW1hdGVTdHlsZTogX2FuaW1hdGVTdHlsZSxcbiAgXHRwcm9jZXNzUGFyYW1zOiBwcm9jZXNzUGFyYW1zXG4gIH07XG5cbiAgdmFyIF9UcmFuc2l0aW9uID0gVHJhbnNpdGlvbjtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfcmVuZGVyID0gRWxlbWVudCRyZW5kZXI7XG5cbiAgdmFyIHVwZGF0ZUNzcywgdXBkYXRlU2NyaXB0O1xuXG4gIHVwZGF0ZUNzcyA9IGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcbiAgXHQgICAgY29udGVudCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoZmFsc2UpO1xuXG4gIFx0Ly8gSUU4IGhhcyBubyBzdHlsZVNoZWV0IHVubGVzcyB0aGVyZSdzIGEgdHlwZSB0ZXh0L2Nzc1xuICBcdGlmICh3aW5kb3cgJiYgd2luZG93LmFwcGVhcnNUb0JlSUVMZXNzRXF1YWw4KSB7XG4gIFx0XHRub2RlLnR5cGUgPSBcInRleHQvY3NzXCI7XG4gIFx0fVxuXG4gIFx0aWYgKG5vZGUuc3R5bGVTaGVldCkge1xuICBcdFx0bm9kZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjb250ZW50O1xuICBcdH0gZWxzZSB7XG5cbiAgXHRcdHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICBcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gIFx0XHR9XG5cbiAgXHRcdG5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpO1xuICBcdH1cbiAgfTtcblxuICB1cGRhdGVTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XG4gIFx0aWYgKCF0aGlzLm5vZGUudHlwZSB8fCB0aGlzLm5vZGUudHlwZSA9PT0gXCJ0ZXh0L2phdmFzY3JpcHRcIikge1xuICBcdFx0d2FybklmRGVidWcoXCJTY3JpcHQgdGFnIHdhcyB1cGRhdGVkLiBUaGlzIGRvZXMgbm90IGNhdXNlIHRoZSBjb2RlIHRvIGJlIHJlLWV2YWx1YXRlZCFcIiwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHQvLyBBcyBpdCBoYXBwZW5zLCB3ZSBBUkUgaW4gYSBwb3NpdGlvbiB0byByZS1ldmFsdWF0ZSB0aGUgY29kZSBpZiB3ZSB3YW50ZWRcbiAgXHRcdC8vIHRvIC0gd2UgY291bGQgZXZhbCgpIGl0LCBvciBpbnNlcnQgaXQgaW50byBhIGZyZXNoICh0ZW1wb3JhcnkpIHNjcmlwdCB0YWcuXG4gIFx0XHQvLyBCdXQgdGhpcyB3b3VsZCBiZSBhIHRlcnJpYmxlIGlkZWEgd2l0aCB1bnByZWRpY3RhYmxlIHJlc3VsdHMsIHNvIGxldCdzIG5vdC5cbiAgXHR9XG5cbiAgXHR0aGlzLm5vZGUudGV4dCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoZmFsc2UpO1xuICB9O1xuICBmdW5jdGlvbiBFbGVtZW50JHJlbmRlcigpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHJvb3QgPSB0aGlzLnJvb3QsXG4gIFx0ICAgIG5hbWVzcGFjZSxcbiAgXHQgICAgbm9kZSxcbiAgXHQgICAgdHJhbnNpdGlvbjtcblxuICBcdG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZSh0aGlzKTtcbiAgXHRub2RlID0gdGhpcy5ub2RlID0gY3JlYXRlRWxlbWVudCh0aGlzLm5hbWUsIG5hbWVzcGFjZSk7XG5cbiAgXHQvLyBJcyB0aGlzIGEgdG9wLWxldmVsIG5vZGUgb2YgYSBjb21wb25lbnQ/IElmIHNvLCB3ZSBtYXkgbmVlZCB0byBhZGRcbiAgXHQvLyBhIGRhdGEtcmFjdGl2ZS1jc3MgYXR0cmlidXRlLCBmb3IgQ1NTIGVuY2Fwc3VsYXRpb25cbiAgXHRpZiAodGhpcy5wYXJlbnRGcmFnbWVudC5jc3NJZHMpIHtcbiAgXHRcdHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJhY3RpdmUtY3NzXCIsIHRoaXMucGFyZW50RnJhZ21lbnQuY3NzSWRzLm1hcChmdW5jdGlvbiAoeCkge1xuICBcdFx0XHRyZXR1cm4gXCJ7XCIgKyB4ICsgXCJ9XCI7XG4gIFx0XHR9KS5qb2luKFwiIFwiKSk7XG4gIFx0fVxuXG4gIFx0Ly8gQWRkIF9yYWN0aXZlIHByb3BlcnR5IHRvIHRoZSBub2RlIC0gd2UgdXNlIHRoaXMgb2JqZWN0IHRvIHN0b3JlIHN0dWZmXG4gIFx0Ly8gcmVsYXRlZCB0byBwcm94eSBldmVudHMsIHR3by13YXkgYmluZGluZ3MgZXRjXG4gIFx0ZGVmaW5lUHJvcGVydHkodGhpcy5ub2RlLCBcIl9yYWN0aXZlXCIsIHtcbiAgXHRcdHZhbHVlOiB7XG4gIFx0XHRcdHByb3h5OiB0aGlzLFxuICBcdFx0XHRrZXlwYXRoOiBnZXRJbm5lckNvbnRleHQodGhpcy5wYXJlbnRGcmFnbWVudCksXG4gIFx0XHRcdGV2ZW50czogY3JlYXRlKG51bGwpLFxuICBcdFx0XHRyb290OiByb290XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHQvLyBSZW5kZXIgYXR0cmlidXRlc1xuICBcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRyZXR1cm4gYS5yZW5kZXIobm9kZSk7XG4gIFx0fSk7XG4gIFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICBcdFx0cmV0dXJuIGEucmVuZGVyKG5vZGUpO1xuICBcdH0pO1xuXG4gIFx0Ly8gUmVuZGVyIGNoaWxkcmVuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxzY3JpcHQ+IGVsZW1lbnRcbiAgXHRcdGlmICh0aGlzLm5hbWUgPT09IFwic2NyaXB0XCIpIHtcbiAgXHRcdFx0dGhpcy5idWJibGUgPSB1cGRhdGVTY3JpcHQ7XG4gIFx0XHRcdHRoaXMubm9kZS50ZXh0ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyhmYWxzZSk7IC8vIGJ5cGFzcyB3YXJuaW5nIGluaXRpYWxseVxuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDsgLy8gVE9ETyB0aGlzIGlzIGEga2x1ZGdlXG4gIFx0XHR9XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxzdHlsZT4gZWxlbWVudFxuICBcdFx0ZWxzZSBpZiAodGhpcy5uYW1lID09PSBcInN0eWxlXCIpIHtcbiAgXHRcdFx0dGhpcy5idWJibGUgPSB1cGRhdGVDc3M7XG4gIFx0XHRcdHRoaXMuYnViYmxlKCk7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBjb250ZW50ZWRpdGFibGVcbiAgXHRcdGVsc2UgaWYgKHRoaXMuYmluZGluZyAmJiB0aGlzLmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmZyYWdtZW50LnJlbmRlcigpKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBkZWFsIHdpdGggdHdvLXdheSBiaW5kaW5nc1xuICBcdGlmICh0aGlzLmJpbmRpbmcpIHtcbiAgXHRcdHRoaXMuYmluZGluZy5yZW5kZXIoKTtcbiAgXHRcdHRoaXMubm9kZS5fcmFjdGl2ZS5iaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuICBcdH1cblxuICBcdC8vIEFkZCBwcm94eSBldmVudCBoYW5kbGVyc1xuICBcdGlmICh0aGlzLmV2ZW50SGFuZGxlcnMpIHtcbiAgXHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7XG4gIFx0XHRcdHJldHVybiBoLnJlbmRlcigpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJvcHRpb25cIikge1xuICBcdFx0cHJvY2Vzc09wdGlvbih0aGlzKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2VzXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJpbWdcIikge1xuICBcdFx0Ly8gaWYgdGhpcyBpcyBhbiA8aW1nPiwgYW5kIHdlJ3JlIGluIGEgY3JhcCBicm93c2VyLCB3ZSBtYXlcbiAgXHRcdC8vIG5lZWQgdG8gcHJldmVudCBpdCBmcm9tIG92ZXJyaWRpbmcgd2lkdGggYW5kIGhlaWdodCB3aGVuXG4gIFx0XHQvLyBpdCBsb2FkcyB0aGUgc3JjXG4gIFx0XHRzcGVjaWFsX2ltZ19fcmVuZGVyKHRoaXMpO1xuICBcdH0gZWxzZSBpZiAodGhpcy5uYW1lID09PSBcImZvcm1cIikge1xuICBcdFx0Ly8gZm9ybXMgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHRoZWlyIGJpbmRpbmdzLCBpbiBjYXNlIG9mIHJlc2V0XG4gIFx0XHRmb3JtX19yZW5kZXIodGhpcyk7XG4gIFx0fSBlbHNlIGlmICh0aGlzLm5hbWUgPT09IFwiaW5wdXRcIiB8fCB0aGlzLm5hbWUgPT09IFwidGV4dGFyZWFcIikge1xuICBcdFx0Ly8gaW5wdXRzIGFuZCB0ZXh0YXJlYXMgc2hvdWxkIHN0b3JlIHRoZWlyIGluaXRpYWwgdmFsdWUgYXNcbiAgXHRcdC8vIGBkZWZhdWx0VmFsdWVgIGluIGNhc2Ugb2YgcmVzZXRcbiAgXHRcdHRoaXMubm9kZS5kZWZhdWx0VmFsdWUgPSB0aGlzLm5vZGUudmFsdWU7XG4gIFx0fSBlbHNlIGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdC8vIHNpbWlsYXJseSBmb3Igb3B0aW9uIG5vZGVzXG4gIFx0XHR0aGlzLm5vZGUuZGVmYXVsdFNlbGVjdGVkID0gdGhpcy5ub2RlLnNlbGVjdGVkO1xuICBcdH1cblxuICBcdC8vIGFwcGx5IGRlY29yYXRvcihzKVxuICBcdGlmICh0aGlzLmRlY29yYXRvciAmJiB0aGlzLmRlY29yYXRvci5mbikge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0aWYgKCFfdGhpcy5kZWNvcmF0b3IudG9ybmRvd24pIHtcbiAgXHRcdFx0XHRfdGhpcy5kZWNvcmF0b3IuaW5pdCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9LCB0cnVlKTtcbiAgXHR9XG5cbiAgXHQvLyB0cmlnZ2VyIGludHJvIHRyYW5zaXRpb25cbiAgXHRpZiAocm9vdC50cmFuc2l0aW9uc0VuYWJsZWQgJiYgdGhpcy5pbnRybykge1xuICBcdFx0dHJhbnNpdGlvbiA9IG5ldyBfVHJhbnNpdGlvbih0aGlzLCB0aGlzLmludHJvLCB0cnVlKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnJlZ2lzdGVyVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiB0cmFuc2l0aW9uLnN0YXJ0KCk7XG4gIFx0XHR9LCB0cnVlKTtcblxuICBcdFx0dGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5ub2RlLmF1dG9mb2N1cykge1xuICBcdFx0Ly8gU3BlY2lhbCBjYXNlLiBTb21lIGJyb3dzZXJzICgqY291Z2gqIEZpcmVmaXggKmNvdWdoKikgaGF2ZSBhIHByb2JsZW1cbiAgXHRcdC8vIHdpdGggZHluYW1pY2FsbHktZ2VuZXJhdGVkIGVsZW1lbnRzIGhhdmluZyBhdXRvZm9jdXMsIGFuZCB0aGV5IHdvbid0XG4gIFx0XHQvLyBhbGxvdyB5b3UgdG8gcHJvZ3JhbW1hdGljYWxseSBmb2N1cyB0aGUgZWxlbWVudCB1bnRpbCBpdCdzIGluIHRoZSBET01cbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiBfdGhpcy5ub2RlLmZvY3VzKCk7XG4gIFx0XHR9LCB0cnVlKTtcbiAgXHR9XG5cbiAgXHR1cGRhdGVMaXZlUXVlcmllcyh0aGlzKTtcbiAgXHRyZXR1cm4gdGhpcy5ub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmFtZXNwYWNlKGVsZW1lbnQpIHtcbiAgXHR2YXIgbmFtZXNwYWNlLCB4bWxucywgcGFyZW50O1xuXG4gIFx0Ly8gVXNlIHNwZWNpZmllZCBuYW1lc3BhY2UuLi5cbiAgXHRpZiAoeG1sbnMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInhtbG5zXCIpKSB7XG4gIFx0XHRuYW1lc3BhY2UgPSB4bWxucztcbiAgXHR9XG5cbiAgXHQvLyAuLi5vciBTVkcgbmFtZXNwYWNlLCBpZiB0aGlzIGlzIGFuIDxzdmc+IGVsZW1lbnRcbiAgXHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwic3ZnXCIpIHtcbiAgXHRcdG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuc3ZnO1xuICBcdH0gZWxzZSBpZiAocGFyZW50ID0gZWxlbWVudC5wYXJlbnQpIHtcbiAgXHRcdC8vIC4uLm9yIEhUTUwsIGlmIHRoZSBwYXJlbnQgaXMgYSA8Zm9yZWlnbk9iamVjdD5cbiAgXHRcdGlmIChwYXJlbnQubmFtZSA9PT0gXCJmb3JlaWduT2JqZWN0XCIpIHtcbiAgXHRcdFx0bmFtZXNwYWNlID0gbmFtZXNwYWNlcy5odG1sO1xuICBcdFx0fVxuXG4gIFx0XHQvLyAuLi5vciBpbmhlcml0IGZyb20gdGhlIHBhcmVudCBub2RlXG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0bmFtZXNwYWNlID0gcGFyZW50Lm5vZGUubmFtZXNwYWNlVVJJO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRuYW1lc3BhY2UgPSBlbGVtZW50LnJvb3QuZWwubmFtZXNwYWNlVVJJO1xuICBcdH1cblxuICBcdHJldHVybiBuYW1lc3BhY2U7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzT3B0aW9uKG9wdGlvbikge1xuICBcdHZhciBvcHRpb25WYWx1ZSwgc2VsZWN0VmFsdWUsIGk7XG5cbiAgXHRpZiAoIW9wdGlvbi5zZWxlY3QpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRzZWxlY3RWYWx1ZSA9IG9wdGlvbi5zZWxlY3QuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0aWYgKHNlbGVjdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdGlmIChvcHRpb24uc2VsZWN0Lm5vZGUubXVsdGlwbGUgJiYgaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgXHRcdGkgPSBzZWxlY3RWYWx1ZS5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmIChvcHRpb25WYWx1ZSA9PSBzZWxlY3RWYWx1ZVtpXSkge1xuICBcdFx0XHRcdG9wdGlvbi5ub2RlLnNlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRvcHRpb24ubm9kZS5zZWxlY3RlZCA9IG9wdGlvblZhbHVlID09IHNlbGVjdFZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpdmVRdWVyaWVzKGVsZW1lbnQpIHtcbiAgXHR2YXIgaW5zdGFuY2UsIGxpdmVRdWVyaWVzLCBpLCBzZWxlY3RvciwgcXVlcnk7XG5cbiAgXHQvLyBEb2VzIHRoaXMgbmVlZCB0byBiZSBhZGRlZCB0byBhbnkgbGl2ZSBxdWVyaWVzP1xuICBcdGluc3RhbmNlID0gZWxlbWVudC5yb290O1xuXG4gIFx0ZG8ge1xuICBcdFx0bGl2ZVF1ZXJpZXMgPSBpbnN0YW5jZS5fbGl2ZVF1ZXJpZXM7XG5cbiAgXHRcdGkgPSBsaXZlUXVlcmllcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdHNlbGVjdG9yID0gbGl2ZVF1ZXJpZXNbaV07XG4gIFx0XHRcdHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbXCJfXCIgKyBzZWxlY3Rvcl07XG5cbiAgXHRcdFx0aWYgKHF1ZXJ5Ll90ZXN0KGVsZW1lbnQpKSB7XG4gIFx0XHRcdFx0Ly8ga2VlcCByZWdpc3RlciBvZiBhcHBsaWNhYmxlIHNlbGVjdG9ycywgZm9yIHdoZW4gd2UgdGVhcmRvd25cbiAgXHRcdFx0XHQoZWxlbWVudC5saXZlUXVlcmllcyB8fCAoZWxlbWVudC5saXZlUXVlcmllcyA9IFtdKSkucHVzaChxdWVyeSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9IHdoaWxlIChpbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudCk7XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfdG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIHN0ciwgZXNjYXBlO1xuXG4gIFx0aWYgKHRoaXMudGVtcGxhdGUueSkge1xuICBcdFx0Ly8gRE9DVFlQRSBkZWNsYXJhdGlvblxuICBcdFx0cmV0dXJuIFwiPCFET0NUWVBFXCIgKyB0aGlzLnRlbXBsYXRlLmRkICsgXCI+XCI7XG4gIFx0fVxuXG4gIFx0c3RyID0gXCI8XCIgKyB0aGlzLnRlbXBsYXRlLmU7XG5cbiAgXHRzdHIgKz0gdGhpcy5hdHRyaWJ1dGVzLm1hcChzdHJpbmdpZnlBdHRyaWJ1dGUpLmpvaW4oXCJcIikgKyB0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5tYXAoc3RyaW5naWZ5QXR0cmlidXRlKS5qb2luKFwiXCIpO1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gc2VsZWN0ZWQgb3B0aW9uc1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIgJiYgb3B0aW9uSXNTZWxlY3RlZCh0aGlzKSkge1xuICBcdFx0c3RyICs9IFwiIHNlbGVjdGVkXCI7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gdHdvLXdheSByYWRpbyBuYW1lIGJpbmRpbmdzXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJpbnB1dFwiICYmIGlucHV0SXNDaGVja2VkUmFkaW8odGhpcykpIHtcbiAgXHRcdHN0ciArPSBcIiBjaGVja2VkXCI7XG4gIFx0fVxuXG4gIFx0c3RyICs9IFwiPlwiO1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gdGV4dGFyZWFcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcInRleHRhcmVhXCIgJiYgdGhpcy5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRzdHIgKz0gZXNjYXBlSHRtbCh0aGlzLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSBjb250ZW50ZWRpdGFibGVcbiAgXHRlbHNlIGlmICh0aGlzLmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRzdHIgKz0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSB8fCBcIlwiO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRlc2NhcGUgPSB0aGlzLm5hbWUgIT09IFwic2NyaXB0XCIgJiYgdGhpcy5uYW1lICE9PSBcInN0eWxlXCI7XG4gIFx0XHRzdHIgKz0gdGhpcy5mcmFnbWVudC50b1N0cmluZyhlc2NhcGUpO1xuICBcdH1cblxuICBcdC8vIGFkZCBhIGNsb3NpbmcgdGFnIGlmIHRoaXMgaXNuJ3QgYSB2b2lkIGVsZW1lbnRcbiAgXHRpZiAoIXZvaWRFbGVtZW50TmFtZXMudGVzdCh0aGlzLnRlbXBsYXRlLmUpKSB7XG4gIFx0XHRzdHIgKz0gXCI8L1wiICsgdGhpcy50ZW1wbGF0ZS5lICsgXCI+XCI7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0cjtcbiAgfTtcblxuICBmdW5jdGlvbiBvcHRpb25Jc1NlbGVjdGVkKGVsZW1lbnQpIHtcbiAgXHR2YXIgb3B0aW9uVmFsdWUsIHNlbGVjdFZhbHVlLCBpO1xuXG4gIFx0b3B0aW9uVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0aWYgKG9wdGlvblZhbHVlID09PSB1bmRlZmluZWQgfHwgIWVsZW1lbnQuc2VsZWN0KSB7XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0c2VsZWN0VmFsdWUgPSBlbGVtZW50LnNlbGVjdC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdGlmIChzZWxlY3RWYWx1ZSA9PSBvcHRpb25WYWx1ZSkge1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuXG4gIFx0aWYgKGVsZW1lbnQuc2VsZWN0LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpICYmIGlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gIFx0XHRpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAoc2VsZWN0VmFsdWVbaV0gPT0gb3B0aW9uVmFsdWUpIHtcbiAgXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlucHV0SXNDaGVja2VkUmFkaW8oZWxlbWVudCkge1xuICBcdHZhciBhdHRyaWJ1dGVzLCB0eXBlQXR0cmlidXRlLCB2YWx1ZUF0dHJpYnV0ZSwgbmFtZUF0dHJpYnV0ZTtcblxuICBcdGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG5cbiAgXHR0eXBlQXR0cmlidXRlID0gYXR0cmlidXRlcy50eXBlO1xuICBcdHZhbHVlQXR0cmlidXRlID0gYXR0cmlidXRlcy52YWx1ZTtcbiAgXHRuYW1lQXR0cmlidXRlID0gYXR0cmlidXRlcy5uYW1lO1xuXG4gIFx0aWYgKCF0eXBlQXR0cmlidXRlIHx8IHR5cGVBdHRyaWJ1dGUudmFsdWUgIT09IFwicmFkaW9cIiB8fCAhdmFsdWVBdHRyaWJ1dGUgfHwgIW5hbWVBdHRyaWJ1dGUuaW50ZXJwb2xhdG9yKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKHZhbHVlQXR0cmlidXRlLnZhbHVlID09PSBuYW1lQXR0cmlidXRlLmludGVycG9sYXRvci52YWx1ZSkge1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5QXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICBcdHZhciBzdHIgPSBhdHRyaWJ1dGUudG9TdHJpbmcoKTtcbiAgXHRyZXR1cm4gc3RyID8gXCIgXCIgKyBzdHIgOiBcIlwiO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3VuYmluZCA9IEVsZW1lbnQkdW5iaW5kO1xuICBmdW5jdGlvbiBFbGVtZW50JHVuYmluZCgpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5iaW5kaW5nKSB7XG4gIFx0XHR0aGlzLmJpbmRpbmcudW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZXZlbnRIYW5kbGVycykge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSA8b3B0aW9uPlxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdHNwZWNpYWxfb3B0aW9uX191bmJpbmQodGhpcyk7XG4gIFx0fVxuXG4gIFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfdW5yZW5kZXIgPSBFbGVtZW50JHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkdW5yZW5kZXIoc2hvdWxkRGVzdHJveSkge1xuICBcdHZhciBiaW5kaW5nLCBiaW5kaW5ncywgdHJhbnNpdGlvbjtcblxuICBcdGlmICh0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uKSB7XG4gIFx0XHR0cmFuc2l0aW9uLmNvbXBsZXRlKCk7XG4gIFx0fVxuXG4gIFx0Ly8gRGV0YWNoIGFzIHNvb24gYXMgd2UgY2FuXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJvcHRpb25cIikge1xuICBcdFx0Ly8gPG9wdGlvbj4gZWxlbWVudHMgZGV0YWNoIGltbWVkaWF0ZWx5LCBzbyB0aGF0XG4gIFx0XHQvLyB0aGVpciBwYXJlbnQgPHNlbGVjdD4gZWxlbWVudCBzeW5jcyBjb3JyZWN0bHksIGFuZFxuICBcdFx0Ly8gc2luY2Ugb3B0aW9uIGVsZW1lbnRzIGNhbid0IGhhdmUgdHJhbnNpdGlvbnMgYW55d2F5XG4gIFx0XHR0aGlzLmRldGFjaCgpO1xuICBcdH0gZWxzZSBpZiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZGV0YWNoV2hlblJlYWR5KHRoaXMpO1xuICBcdH1cblxuICBcdC8vIENoaWxkcmVuIGZpcnN0LiB0aGF0IHdheSwgYW55IHRyYW5zaXRpb25zIG9uIGNoaWxkIGVsZW1lbnRzIHdpbGwgYmVcbiAgXHQvLyBoYW5kbGVkIGJ5IHRoZSBjdXJyZW50IHRyYW5zaXRpb25NYW5hZ2VyXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoZmFsc2UpO1xuICBcdH1cblxuICBcdGlmIChiaW5kaW5nID0gdGhpcy5iaW5kaW5nKSB7XG4gIFx0XHR0aGlzLmJpbmRpbmcudW5yZW5kZXIoKTtcblxuICBcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLmJpbmRpbmcgPSBudWxsO1xuICBcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW2JpbmRpbmcua2V5cGF0aC5zdHJdO1xuICBcdFx0YmluZGluZ3Muc3BsaWNlKGJpbmRpbmdzLmluZGV4T2YoYmluZGluZyksIDEpO1xuICBcdH1cblxuICBcdC8vIFJlbW92ZSBldmVudCBoYW5kbGVyc1xuICBcdGlmICh0aGlzLmV2ZW50SGFuZGxlcnMpIHtcbiAgXHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VucmVuZGVyKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5kZWNvcmF0b3IpIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnJlZ2lzdGVyRGVjb3JhdG9yKHRoaXMuZGVjb3JhdG9yKTtcbiAgXHR9XG5cbiAgXHQvLyB0cmlnZ2VyIG91dHJvIHRyYW5zaXRpb24gaWYgbmVjZXNzYXJ5XG4gIFx0aWYgKHRoaXMucm9vdC50cmFuc2l0aW9uc0VuYWJsZWQgJiYgdGhpcy5vdXRybykge1xuICBcdFx0dHJhbnNpdGlvbiA9IG5ldyBfVHJhbnNpdGlvbih0aGlzLCB0aGlzLm91dHJvLCBmYWxzZSk7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5yZWdpc3RlclRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdHJhbnNpdGlvbi5zdGFydCgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gUmVtb3ZlIHRoaXMgbm9kZSBmcm9tIGFueSBsaXZlIHF1ZXJpZXNcbiAgXHRpZiAodGhpcy5saXZlUXVlcmllcykge1xuICBcdFx0cmVtb3ZlRnJvbUxpdmVRdWVyaWVzKHRoaXMpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiZm9ybVwiKSB7XG4gIFx0XHRmb3JtX191bnJlbmRlcih0aGlzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGcm9tTGl2ZVF1ZXJpZXMoZWxlbWVudCkge1xuICBcdHZhciBxdWVyeSwgc2VsZWN0b3IsIGk7XG5cbiAgXHRpID0gZWxlbWVudC5saXZlUXVlcmllcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0cXVlcnkgPSBlbGVtZW50LmxpdmVRdWVyaWVzW2ldO1xuICBcdFx0c2VsZWN0b3IgPSBxdWVyeS5zZWxlY3RvcjtcblxuICBcdFx0cXVlcnkuX3JlbW92ZShlbGVtZW50Lm5vZGUpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFbGVtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLmluaXQob3B0aW9ucyk7XG4gIH07XG5cbiAgRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBFbGVtZW50X3Byb3RvdHlwZV9idWJibGUsXG4gIFx0ZGV0YWNoOiBFbGVtZW50X3Byb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogRWxlbWVudF9wcm90b3R5cGVfZmluZCxcbiAgXHRmaW5kQWxsOiBFbGVtZW50X3Byb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBFbGVtZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBFbGVtZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50LFxuICBcdGZpbmROZXh0Tm9kZTogRWxlbWVudF9wcm90b3R5cGVfZmluZE5leHROb2RlLFxuICBcdGZpcnN0Tm9kZTogRWxlbWVudF9wcm90b3R5cGVfZmlyc3ROb2RlLFxuICBcdGdldEF0dHJpYnV0ZTogZ2V0QXR0cmlidXRlLFxuICBcdGluaXQ6IEVsZW1lbnRfcHJvdG90eXBlX2luaXQsXG4gIFx0cmViaW5kOiBFbGVtZW50X3Byb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVuZGVyOiBFbGVtZW50X3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IEVsZW1lbnRfcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogRWxlbWVudF9wcm90b3R5cGVfdW5iaW5kLFxuICBcdHVucmVuZGVyOiBFbGVtZW50X3Byb3RvdHlwZV91bnJlbmRlclxuICB9O1xuXG4gIHZhciBfRWxlbWVudCA9IEVsZW1lbnQ7XG5cbiAgdmFyIGRlSW5kZW50X19lbXB0eSA9IC9eXFxzKiQvLFxuICAgICAgZGVJbmRlbnRfX2xlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMqLztcblxuICB2YXIgZGVJbmRlbnQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIFx0dmFyIGxpbmVzLCBmaXJzdExpbmUsIGxhc3RMaW5lLCBtaW5JbmRlbnQ7XG5cbiAgXHRsaW5lcyA9IHN0ci5zcGxpdChcIlxcblwiKTtcblxuICBcdC8vIHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBsaW5lLCBpZiB0aGV5IG9ubHkgY29udGFpbiB3aGl0ZXNwYWNlXG4gIFx0Zmlyc3RMaW5lID0gbGluZXNbMF07XG4gIFx0aWYgKGZpcnN0TGluZSAhPT0gdW5kZWZpbmVkICYmIGRlSW5kZW50X19lbXB0eS50ZXN0KGZpcnN0TGluZSkpIHtcbiAgXHRcdGxpbmVzLnNoaWZ0KCk7XG4gIFx0fVxuXG4gIFx0bGFzdExpbmUgPSBsYXN0SXRlbShsaW5lcyk7XG4gIFx0aWYgKGxhc3RMaW5lICE9PSB1bmRlZmluZWQgJiYgZGVJbmRlbnRfX2VtcHR5LnRlc3QobGFzdExpbmUpKSB7XG4gIFx0XHRsaW5lcy5wb3AoKTtcbiAgXHR9XG5cbiAgXHRtaW5JbmRlbnQgPSBsaW5lcy5yZWR1Y2UocmVkdWNlciwgbnVsbCk7XG5cbiAgXHRpZiAobWluSW5kZW50KSB7XG4gIFx0XHRzdHIgPSBsaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgXHRcdFx0cmV0dXJuIGxpbmUucmVwbGFjZShtaW5JbmRlbnQsIFwiXCIpO1xuICBcdFx0fSkuam9pbihcIlxcblwiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RyO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIocHJldmlvdXMsIGxpbmUpIHtcbiAgXHR2YXIgbGluZUluZGVudCA9IGRlSW5kZW50X19sZWFkaW5nV2hpdGVzcGFjZS5leGVjKGxpbmUpWzBdO1xuXG4gIFx0aWYgKHByZXZpb3VzID09PSBudWxsIHx8IGxpbmVJbmRlbnQubGVuZ3RoIDwgcHJldmlvdXMubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm4gbGluZUluZGVudDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcHJldmlvdXM7XG4gIH1cblxuICB2YXIgUGFydGlhbF9nZXRQYXJ0aWFsVGVtcGxhdGUgPSBnZXRQYXJ0aWFsVGVtcGxhdGU7XG5cbiAgZnVuY3Rpb24gZ2V0UGFydGlhbFRlbXBsYXRlKHJhY3RpdmUsIG5hbWUsIHBhcmVudEZyYWdtZW50KSB7XG4gIFx0dmFyIHBhcnRpYWw7XG5cbiAgXHQvLyBJZiB0aGUgcGFydGlhbCBpbiBpbnN0YW5jZSBvciB2aWV3IGhlaXJhcmNoeSBpbnN0YW5jZXMsIGdyZWF0XG4gIFx0aWYgKHBhcnRpYWwgPSBnZXRQYXJ0aWFsRnJvbVJlZ2lzdHJ5KHJhY3RpdmUsIG5hbWUsIHBhcmVudEZyYWdtZW50IHx8IHt9KSkge1xuICBcdFx0cmV0dXJuIHBhcnRpYWw7XG4gIFx0fVxuXG4gIFx0Ly8gRG9lcyBpdCBleGlzdCBvbiB0aGUgcGFnZSBhcyBhIHNjcmlwdCB0YWc/XG4gIFx0cGFydGlhbCA9IHRlbXBsYXRlX3BhcnNlci5mcm9tSWQobmFtZSwgeyBub1Rocm93OiB0cnVlIH0pO1xuXG4gIFx0aWYgKHBhcnRpYWwpIHtcbiAgXHRcdC8vIGlzIHRoaXMgbmVjZXNzYXJ5P1xuICBcdFx0cGFydGlhbCA9IGRlSW5kZW50KHBhcnRpYWwpO1xuXG4gIFx0XHQvLyBwYXJzZSBhbmQgcmVnaXN0ZXIgdG8gdGhpcyByYWN0aXZlIGluc3RhbmNlXG4gIFx0XHR2YXIgcGFyc2VkID0gdGVtcGxhdGVfcGFyc2VyLnBhcnNlKHBhcnRpYWwsIHRlbXBsYXRlX3BhcnNlci5nZXRQYXJzZU9wdGlvbnMocmFjdGl2ZSkpO1xuXG4gIFx0XHQvLyByZWdpc3RlciAoYW5kIHJldHVybiBtYWluIHBhcnRpYWwgaWYgdGhlcmUgYXJlIG90aGVycyBpbiB0aGUgdGVtcGxhdGUpXG4gIFx0XHRyZXR1cm4gcmFjdGl2ZS5wYXJ0aWFsc1tuYW1lXSA9IHBhcnNlZC50O1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcnRpYWxGcm9tUmVnaXN0cnkocmFjdGl2ZSwgbmFtZSwgcGFyZW50RnJhZ21lbnQpIHtcbiAgXHR2YXIgZm4gPSB1bmRlZmluZWQsXG4gIFx0ICAgIHBhcnRpYWwgPSBmaW5kUGFyZW50UGFydGlhbChuYW1lLCBwYXJlbnRGcmFnbWVudC5vd25lcik7XG5cbiAgXHQvLyBpZiB0aGVyZSB3YXMgYW4gaW5zdGFuY2UgdXAtaGllcmFyY2h5LCBjb29sXG4gIFx0aWYgKHBhcnRpYWwpIHJldHVybiBwYXJ0aWFsO1xuXG4gIFx0Ly8gZmluZCBmaXJzdCBpbnN0YW5jZSBpbiB0aGUgcmFjdGl2ZSBvciB2aWV3IGhpZXJhcmNoeSB0aGF0IGhhcyB0aGlzIHBhcnRpYWxcbiAgXHR2YXIgaW5zdGFuY2UgPSBmaW5kSW5zdGFuY2UoXCJwYXJ0aWFsc1wiLCByYWN0aXZlLCBuYW1lKTtcblxuICBcdGlmICghaW5zdGFuY2UpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRwYXJ0aWFsID0gaW5zdGFuY2UucGFydGlhbHNbbmFtZV07XG5cbiAgXHQvLyBwYXJ0aWFsIGlzIGEgZnVuY3Rpb24/XG4gIFx0aWYgKHR5cGVvZiBwYXJ0aWFsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdGZuID0gcGFydGlhbC5iaW5kKGluc3RhbmNlKTtcbiAgXHRcdGZuLmlzT3duZXIgPSBpbnN0YW5jZS5wYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgXHRcdHBhcnRpYWwgPSBmbi5jYWxsKHJhY3RpdmUsIHRlbXBsYXRlX3BhcnNlcik7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJ0aWFsICYmIHBhcnRpYWwgIT09IFwiXCIpIHtcbiAgXHRcdHdhcm5JZkRlYnVnKG5vUmVnaXN0cnlGdW5jdGlvblJldHVybiwgbmFtZSwgXCJwYXJ0aWFsXCIsIFwicGFydGlhbFwiLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhpcyB3YXMgYWRkZWQgbWFudWFsbHkgdG8gdGhlIHJlZ2lzdHJ5LFxuICBcdC8vIGJ1dCBoYXNuJ3QgYmVlbiBwYXJzZWQsIHBhcnNlIGl0IG5vd1xuICBcdGlmICghdGVtcGxhdGVfcGFyc2VyLmlzUGFyc2VkKHBhcnRpYWwpKSB7XG5cbiAgXHRcdC8vIHVzZSB0aGUgcGFyc2VPcHRpb25zIG9mIHRoZSByYWN0aXZlIGluc3RhbmNlIG9uIHdoaWNoIGl0IHdhcyBmb3VuZFxuICBcdFx0dmFyIHBhcnNlZCA9IHRlbXBsYXRlX3BhcnNlci5wYXJzZShwYXJ0aWFsLCB0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKGluc3RhbmNlKSk7XG5cbiAgXHRcdC8vIFBhcnRpYWxzIGNhbm5vdCBjb250YWluIG5lc3RlZCBwYXJ0aWFscyFcbiAgXHRcdC8vIFRPRE8gYWRkIGEgdGVzdCBmb3IgdGhpc1xuICBcdFx0aWYgKHBhcnNlZC5wKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKFwiUGFydGlhbHMgKHt7PiVzfX0pIGNhbm5vdCBjb250YWluIG5lc3RlZCBpbmxpbmUgcGFydGlhbHNcIiwgbmFtZSwgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBpZiBmbiwgdXNlIGluc3RhbmNlIHRvIHN0b3JlIHJlc3VsdCwgb3RoZXJ3aXNlIG5lZWRzIHRvIGdvXG4gIFx0XHQvLyBpbiB0aGUgY29ycmVjdCBwb2ludCBpbiBwcm90b3R5cGUgY2hhaW4gb24gaW5zdGFuY2Ugb3IgY29uc3RydWN0b3JcbiAgXHRcdHZhciB0YXJnZXQgPSBmbiA/IGluc3RhbmNlIDogZmluZE93bmVyKGluc3RhbmNlLCBuYW1lKTtcblxuICBcdFx0Ly8gbWF5IGJlIGEgdGVtcGxhdGUgd2l0aCBwYXJ0aWFscywgd2hpY2ggbmVlZCB0byBiZSByZWdpc3RlcmVkIGFuZCBtYWluIHRlbXBsYXRlIGV4dHJhY3RlZFxuICBcdFx0dGFyZ2V0LnBhcnRpYWxzW25hbWVdID0gcGFydGlhbCA9IHBhcnNlZC50O1xuICBcdH1cblxuICBcdC8vIHN0b3JlIGZvciByZXNldFxuICBcdGlmIChmbikge1xuICBcdFx0cGFydGlhbC5fZm4gPSBmbjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcGFydGlhbC52ID8gcGFydGlhbC50IDogcGFydGlhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRPd25lcihyYWN0aXZlLCBrZXkpIHtcbiAgXHRyZXR1cm4gcmFjdGl2ZS5wYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gcmFjdGl2ZSA6IGZpbmRDb25zdHJ1Y3RvcihyYWN0aXZlLmNvbnN0cnVjdG9yLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZENvbnN0cnVjdG9yKGNvbnN0cnVjdG9yLCBrZXkpIHtcbiAgXHRpZiAoIWNvbnN0cnVjdG9yKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuICBcdHJldHVybiBjb25zdHJ1Y3Rvci5wYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gY29uc3RydWN0b3IgOiBmaW5kQ29uc3RydWN0b3IoY29uc3RydWN0b3IuX1BhcmVudCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRQYXJlbnRQYXJ0aWFsKG5hbWUsIHBhcmVudCkge1xuICBcdGlmIChwYXJlbnQpIHtcbiAgXHRcdGlmIChwYXJlbnQudGVtcGxhdGUgJiYgcGFyZW50LnRlbXBsYXRlLnAgJiYgcGFyZW50LnRlbXBsYXRlLnBbbmFtZV0pIHtcbiAgXHRcdFx0cmV0dXJuIHBhcmVudC50ZW1wbGF0ZS5wW25hbWVdO1xuICBcdFx0fSBlbHNlIGlmIChwYXJlbnQucGFyZW50RnJhZ21lbnQgJiYgcGFyZW50LnBhcmVudEZyYWdtZW50Lm93bmVyKSB7XG4gIFx0XHRcdHJldHVybiBmaW5kUGFyZW50UGFydGlhbChuYW1lLCBwYXJlbnQucGFyZW50RnJhZ21lbnQub3duZXIpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBhcHBseUluZGVudCA9IGZ1bmN0aW9uIChzdHJpbmcsIGluZGVudCkge1xuICBcdHZhciBpbmRlbnRlZDtcblxuICBcdGlmICghaW5kZW50KSB7XG4gIFx0XHRyZXR1cm4gc3RyaW5nO1xuICBcdH1cblxuICBcdGluZGVudGVkID0gc3RyaW5nLnNwbGl0KFwiXFxuXCIpLm1hcChmdW5jdGlvbiAobGluZSwgbm90Rmlyc3RMaW5lKSB7XG4gIFx0XHRyZXR1cm4gbm90Rmlyc3RMaW5lID8gaW5kZW50ICsgbGluZSA6IGxpbmU7XG4gIFx0fSkuam9pbihcIlxcblwiKTtcblxuICBcdHJldHVybiBpbmRlbnRlZDtcbiAgfTtcblxuICB2YXIgbWlzc2luZ1BhcnRpYWxNZXNzYWdlID0gXCJDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSBmb3IgcGFydGlhbCBcXFwiJXNcXFwiXCI7XG5cbiAgdmFyIFBhcnRpYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGU7XG5cbiAgXHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0dGhpcy5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHR0aGlzLnR5cGUgPSBQQVJUSUFMO1xuICBcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICBcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUucjtcbiAgXHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gdGhpcy5mcmFnbWVudFRvUmVuZGVyID0gdGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgPSBudWxsO1xuXG4gIFx0TXVzdGFjaGUuaW5pdCh0aGlzLCBvcHRpb25zKTtcblxuICBcdC8vIElmIHRoaXMgZGlkbid0IHJlc29sdmUsIGl0IG1vc3QgbGlrZWx5IG1lYW5zIHdlIGhhdmUgYSBuYW1lZCBwYXJ0aWFsXG4gIFx0Ly8gKGkuZS4gYHt7PmZvb319YCBtZWFucyAndXNlIHRoZSBmb28gcGFydGlhbCcsIG5vdCAndXNlIHRoZSBwYXJ0aWFsXG4gIFx0Ly8gd2hvc2UgbmFtZSBpcyB0aGUgdmFsdWUgb2YgYGZvb2AnKVxuICBcdGlmICghdGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRpZiAodGVtcGxhdGUgPSBQYXJ0aWFsX2dldFBhcnRpYWxUZW1wbGF0ZSh0aGlzLnJvb3QsIHRoaXMubmFtZSwgcGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRcdHNoYXJlZF91bmJpbmQuY2FsbCh0aGlzKTsgLy8gcHJldmVudCBhbnkgZnVydGhlciBjaGFuZ2VzXG4gIFx0XHRcdHRoaXMuaXNOYW1lZCA9IHRydWU7XG4gIFx0XHRcdHRoaXMuc2V0VGVtcGxhdGUodGVtcGxhdGUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKG1pc3NpbmdQYXJ0aWFsTWVzc2FnZSwgdGhpcy5uYW1lKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgUGFydGlhbC5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuICBcdH0sXG5cbiAgXHRkZXRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmRldGFjaCgpO1xuICBcdH0sXG5cbiAgXHRmaW5kOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoc2VsZWN0b3IpO1xuICBcdH0sXG5cbiAgXHRmaW5kQWxsOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fSxcblxuICBcdGZpbmRDb21wb25lbnQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudChzZWxlY3Rvcik7XG4gIFx0fSxcblxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH0sXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuICBcdH0sXG5cbiAgXHRmaW5kTmV4dE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Z2V0UGFydGlhbE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmlzTmFtZWQgJiYgdGhpcy5uYW1lKSByZXR1cm4gdGhpcy5uYW1lO2Vsc2UgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMubmFtZTtlbHNlIHJldHVybiB0aGlzLnZhbHVlO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0Ly8gbmFtZWQgcGFydGlhbHMgYXJlbid0IGJvdW5kLCBzbyBkb24ndCByZWJpbmRcbiAgXHRcdGlmICghdGhpcy5pc05hbWVkKSB7XG4gIFx0XHRcdE11c3RhY2hlX3JlYmluZC5jYWxsKHRoaXMsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG4gIFx0fSxcblxuICBcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGU7XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID09PSB0aGlzLnZhbHVlKSB7XG4gIFx0XHRcdC8vIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHNvIG5vIHdvcmsgdG8gYmUgZG9uZVxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRlbXBsYXRlID0gUGFydGlhbF9nZXRQYXJ0aWFsVGVtcGxhdGUodGhpcy5yb290LCBcIlwiICsgdmFsdWUsIHRoaXMucGFyZW50RnJhZ21lbnQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyB3ZSBtYXkgYmUgaGVyZSBpZiB3ZSBoYXZlIGEgcGFydGlhbCBsaWtlIGB7ez5mb299fWAgYW5kIGBmb29gIGlzIHRoZVxuICBcdFx0Ly8gbmFtZSBvZiBib3RoIGEgZGF0YSBwcm9wZXJ0eSAod2hvc2UgdmFsdWUgSVNOJ1QgdGhlIG5hbWUgb2YgYSBwYXJ0aWFsKVxuICBcdFx0Ly8gYW5kIGEgcGFydGlhbC4gSW4gdGhvc2UgY2FzZXMsIHRoaXMgYmVjb21lcyBhIG5hbWVkIHBhcnRpYWxcbiAgXHRcdGlmICghdGVtcGxhdGUgJiYgdGhpcy5uYW1lICYmICh0ZW1wbGF0ZSA9IFBhcnRpYWxfZ2V0UGFydGlhbFRlbXBsYXRlKHRoaXMucm9vdCwgdGhpcy5uYW1lLCB0aGlzLnBhcmVudEZyYWdtZW50KSkpIHtcbiAgXHRcdFx0c2hhcmVkX3VuYmluZC5jYWxsKHRoaXMpO1xuICBcdFx0XHR0aGlzLmlzTmFtZWQgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRlbXBsYXRlKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGFydGlhbE1lc3NhZ2UsIHRoaXMubmFtZSwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0dGhpcy5zZXRUZW1wbGF0ZSh0ZW1wbGF0ZSB8fCBbXSk7XG5cbiAgXHRcdHRoaXMuYnViYmxlKCk7XG5cbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHNldFRlbXBsYXRlOiBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgPSB0aGlzLmZyYWdtZW50O1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgXHRcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdFx0cEVsZW1lbnQ6IHRoaXMucGFyZW50RnJhZ21lbnQucEVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50VG9SZW5kZXIgPSB0aGlzLmZyYWdtZW50O1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKHRvU3RyaW5nKSB7XG4gIFx0XHR2YXIgc3RyaW5nLCBwcmV2aW91c0l0ZW0sIGxhc3RMaW5lLCBtYXRjaDtcblxuICBcdFx0c3RyaW5nID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyh0b1N0cmluZyk7XG5cbiAgXHRcdHByZXZpb3VzSXRlbSA9IHRoaXMucGFyZW50RnJhZ21lbnQuaXRlbXNbdGhpcy5pbmRleCAtIDFdO1xuXG4gIFx0XHRpZiAoIXByZXZpb3VzSXRlbSB8fCBwcmV2aW91c0l0ZW0udHlwZSAhPT0gVEVYVCkge1xuICBcdFx0XHRyZXR1cm4gc3RyaW5nO1xuICBcdFx0fVxuXG4gIFx0XHRsYXN0TGluZSA9IHByZXZpb3VzSXRlbS50ZXh0LnNwbGl0KFwiXFxuXCIpLnBvcCgpO1xuXG4gIFx0XHRpZiAobWF0Y2ggPSAvXlxccyskLy5leGVjKGxhc3RMaW5lKSkge1xuICBcdFx0XHRyZXR1cm4gYXBwbHlJbmRlbnQoc3RyaW5nLCBtYXRjaFswXSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBzdHJpbmc7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLmlzTmFtZWQpIHtcbiAgXHRcdFx0Ly8gZHluYW1pYyBwYXJ0aWFsIC0gbmVlZCB0byB1bmJpbmQgc2VsZlxuICBcdFx0XHRzaGFyZWRfdW5iaW5kLmNhbGwodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKHNob3VsZERlc3Ryb3kpO1xuICBcdFx0XHR9XG4gIFx0XHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdGFyZ2V0LCBhbmNob3I7XG5cbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50VG9VbnJlbmRlcikge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50VG9VbnJlbmRlci51bnJlbmRlcih0cnVlKTtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudFRvUmVuZGVyKSB7XG4gIFx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCh0aGlzLmZyYWdtZW50VG9SZW5kZXIucmVuZGVyKCkpO1xuICBcdFx0XHR0aGlzLmZyYWdtZW50VG9SZW5kZXIgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHR0YXJnZXQgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcbiAgXHRcdFx0YW5jaG9yID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5kb2NGcmFnLCBhbmNob3IpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgX1BhcnRpYWwgPSBQYXJ0aWFsO1xuXG4gIC8vIGZpbmRzIHRoZSBjb21wb25lbnQgY29uc3RydWN0b3IgaW4gdGhlIHJlZ2lzdHJ5IG9yIHZpZXcgaGllcmFyY2h5IHJlZ2lzdHJpZXNcblxuICB2YXIgQ29tcG9uZW50X2dldENvbXBvbmVudCA9IGdldENvbXBvbmVudDtcbiAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50KHJhY3RpdmUsIG5hbWUpIHtcblxuICBcdHZhciBDb21wb25lbnQsXG4gIFx0ICAgIGluc3RhbmNlID0gZmluZEluc3RhbmNlKFwiY29tcG9uZW50c1wiLCByYWN0aXZlLCBuYW1lKTtcblxuICBcdGlmIChpbnN0YW5jZSkge1xuICBcdFx0Q29tcG9uZW50ID0gaW5zdGFuY2UuY29tcG9uZW50c1tuYW1lXTtcblxuICBcdFx0Ly8gYmVzdCB0ZXN0IHdlIGhhdmUgZm9yIG5vdCBSYWN0aXZlLmV4dGVuZFxuICBcdFx0aWYgKCFDb21wb25lbnQuX1BhcmVudCkge1xuICBcdFx0XHQvLyBmdW5jdGlvbiBvcHRpb24sIGV4ZWN1dGUgYW5kIHN0b3JlIGZvciByZXNldFxuICBcdFx0XHR2YXIgZm4gPSBDb21wb25lbnQuYmluZChpbnN0YW5jZSk7XG4gIFx0XHRcdGZuLmlzT3duZXIgPSBpbnN0YW5jZS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KG5hbWUpO1xuICBcdFx0XHRDb21wb25lbnQgPSBmbigpO1xuXG4gIFx0XHRcdGlmICghQ29tcG9uZW50KSB7XG4gIFx0XHRcdFx0d2FybklmRGVidWcobm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuLCBuYW1lLCBcImNvbXBvbmVudFwiLCBcImNvbXBvbmVudFwiLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG5cbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdC8vIGFsbG93IHN0cmluZyBsb29rdXBcbiAgXHRcdFx0XHRDb21wb25lbnQgPSBnZXRDb21wb25lbnQocmFjdGl2ZSwgQ29tcG9uZW50KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdENvbXBvbmVudC5fZm4gPSBmbjtcbiAgXHRcdFx0aW5zdGFuY2UuY29tcG9uZW50c1tuYW1lXSA9IENvbXBvbmVudDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gQ29tcG9uZW50O1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZGV0YWNoID0gQ29tcG9uZW50JGRldGFjaDtcbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZGV0YWNoX19kZXRhY2hIb29rID0gbmV3IGhvb2tzX0hvb2soXCJkZXRhY2hcIik7XG4gIGZ1bmN0aW9uIENvbXBvbmVudCRkZXRhY2goKSB7XG4gIFx0dmFyIGRldGFjaGVkID0gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHRDb21wb25lbnRfcHJvdG90eXBlX2RldGFjaF9fZGV0YWNoSG9vay5maXJlKHRoaXMuaW5zdGFuY2UpO1xuICBcdHJldHVybiBkZXRhY2hlZDtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmQgPSBDb21wb25lbnQkZmluZDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZChzZWxlY3Rvcikge1xuICBcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmQoc2VsZWN0b3IpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmluZEFsbCA9IENvbXBvbmVudCRmaW5kQWxsO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQWxsKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzID0gQ29tcG9uZW50JGZpbmRBbGxDb21wb25lbnRzO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRxdWVyeS5fdGVzdCh0aGlzLCB0cnVlKTtcblxuICBcdGlmICh0aGlzLmluc3RhbmNlLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCA9IENvbXBvbmVudCRmaW5kQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQ29tcG9uZW50KHNlbGVjdG9yKSB7XG4gIFx0aWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gdGhpcy5uYW1lKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5pbnN0YW5jZS5mcmFnbWVudCkge1xuICBcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZENvbXBvbmVudChzZWxlY3Rvcik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kTmV4dE5vZGUgPSBDb21wb25lbnQkZmluZE5leHROb2RlO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kTmV4dE5vZGUoKSB7XG4gIFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmlyc3ROb2RlID0gQ29tcG9uZW50JGZpcnN0Tm9kZTtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmlyc3ROb2RlKCkge1xuICBcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maXJzdE5vZGUoKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcm9jZXNzV3JhcHBlciA9IGZ1bmN0aW9uICh3cmFwcGVyLCBhcnJheSwgbWV0aG9kTmFtZSwgbmV3SW5kaWNlcykge1xuICBcdHZhciByb290ID0gd3JhcHBlci5yb290O1xuICBcdHZhciBrZXlwYXRoID0gd3JhcHBlci5rZXlwYXRoO1xuXG4gIFx0aWYgKCEhbmV3SW5kaWNlcykge1xuICBcdFx0cm9vdC52aWV3bW9kZWwuc21hcnRVcGRhdGUoa2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBJZiB0aGlzIGlzIGEgc29ydCBvciByZXZlcnNlLCB3ZSBqdXN0IGRvIHJvb3Quc2V0KCkuLi5cbiAgXHRcdC8vIFRPRE8gdXNlIG1lcmdlIGxvZ2ljP1xuICBcdFx0cm9vdC52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIHBhdGNoZWRBcnJheVByb3RvID0gW10sXG4gICAgICBtdXRhdG9yTWV0aG9kcyA9IFtcInBvcFwiLCBcInB1c2hcIiwgXCJyZXZlcnNlXCIsIFwic2hpZnRcIiwgXCJzb3J0XCIsIFwic3BsaWNlXCIsIFwidW5zaGlmdFwiXSxcbiAgICAgIHRlc3RPYmosXG4gICAgICBwYXRjaEFycmF5TWV0aG9kcyxcbiAgICAgIHVucGF0Y2hBcnJheU1ldGhvZHM7XG5cbiAgbXV0YXRvck1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICBcdHZhciBtZXRob2QgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0XHRhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgbmV3SW5kaWNlcywgcmVzdWx0LCB3cmFwcGVyLCBpO1xuXG4gIFx0XHRuZXdJbmRpY2VzID0gc2hhcmVkX2dldE5ld0luZGljZXModGhpcywgbWV0aG9kTmFtZSwgYXJncyk7XG5cbiAgXHRcdC8vIGFwcGx5IHRoZSB1bmRlcmx5aW5nIG1ldGhvZFxuICBcdFx0cmVzdWx0ID0gQXJyYXkucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgXHRcdC8vIHRyaWdnZXIgY2hhbmdlc1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQoKTtcblxuICBcdFx0dGhpcy5fcmFjdGl2ZS5zZXR0aW5nID0gdHJ1ZTtcbiAgXHRcdGkgPSB0aGlzLl9yYWN0aXZlLndyYXBwZXJzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0d3JhcHBlciA9IHRoaXMuX3JhY3RpdmUud3JhcHBlcnNbaV07XG5cbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkUmFjdGl2ZSh3cmFwcGVyLnJvb3QpO1xuICBcdFx0XHRwcm9jZXNzV3JhcHBlcih3cmFwcGVyLCB0aGlzLCBtZXRob2ROYW1lLCBuZXdJbmRpY2VzKTtcbiAgXHRcdH1cblxuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRcdHRoaXMuX3JhY3RpdmUuc2V0dGluZyA9IGZhbHNlO1xuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9O1xuXG4gIFx0ZGVmaW5lUHJvcGVydHkocGF0Y2hlZEFycmF5UHJvdG8sIG1ldGhvZE5hbWUsIHtcbiAgXHRcdHZhbHVlOiBtZXRob2RcbiAgXHR9KTtcbiAgfSk7XG5cbiAgLy8gY2FuIHdlIHVzZSBwcm90b3R5cGUgY2hhaW4gaW5qZWN0aW9uP1xuICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9ob3ctZWNtYXNjcmlwdC01LXN0aWxsLWRvZXMtbm90LWFsbG93LXRvLXN1YmNsYXNzLWFuLWFycmF5LyN3cmFwcGVyc19wcm90b3R5cGVfY2hhaW5faW5qZWN0aW9uXG4gIHRlc3RPYmogPSB7fTtcblxuICBpZiAodGVzdE9iai5fX3Byb3RvX18pIHtcbiAgXHQvLyB5ZXMsIHdlIGNhblxuICBcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIFx0XHRhcnJheS5fX3Byb3RvX18gPSBwYXRjaGVkQXJyYXlQcm90bztcbiAgXHR9O1xuXG4gIFx0dW5wYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICBcdFx0YXJyYXkuX19wcm90b19fID0gQXJyYXkucHJvdG90eXBlO1xuICBcdH07XG4gIH0gZWxzZSB7XG4gIFx0Ly8gbm8sIHdlIGNhbid0XG4gIFx0cGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgXHRcdHZhciBpLCBtZXRob2ROYW1lO1xuXG4gIFx0XHRpID0gbXV0YXRvck1ldGhvZHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRtZXRob2ROYW1lID0gbXV0YXRvck1ldGhvZHNbaV07XG4gIFx0XHRcdGRlZmluZVByb3BlcnR5KGFycmF5LCBtZXRob2ROYW1lLCB7XG4gIFx0XHRcdFx0dmFsdWU6IHBhdGNoZWRBcnJheVByb3RvW21ldGhvZE5hbWVdLFxuICBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICBcdFx0XHR9KTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0dW5wYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICBcdFx0dmFyIGk7XG5cbiAgXHRcdGkgPSBtdXRhdG9yTWV0aG9kcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGRlbGV0ZSBhcnJheVttdXRhdG9yTWV0aG9kc1tpXV07XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHBhdGNoQXJyYXlNZXRob2RzLnVucGF0Y2ggPSB1bnBhdGNoQXJyYXlNZXRob2RzO1xuICB2YXIgcGF0Y2ggPSBwYXRjaEFycmF5TWV0aG9kcztcblxuICB2YXIgYXJyYXlBZGFwdG9yLFxuXG4gIC8vIGhlbHBlcnNcbiAgQXJyYXlXcmFwcGVyLCBhcnJheV9pbmRleF9fZXJyb3JNZXNzYWdlO1xuXG4gIGFycmF5QWRhcHRvciA9IHtcbiAgXHRmaWx0ZXI6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgXHRcdC8vIHdyYXAgdGhlIGFycmF5IGlmIGEpIGIpIGl0J3MgYW4gYXJyYXksIGFuZCBiKSBlaXRoZXIgaXQgaGFzbid0IGJlZW4gd3JhcHBlZCBhbHJlYWR5LFxuICBcdFx0Ly8gb3IgdGhlIGFycmF5IGRpZG4ndCB0cmlnZ2VyIHRoZSBnZXQoKSBpdHNlbGZcbiAgXHRcdHJldHVybiBpc0FycmF5KG9iamVjdCkgJiYgKCFvYmplY3QuX3JhY3RpdmUgfHwgIW9iamVjdC5fcmFjdGl2ZS5zZXR0aW5nKTtcbiAgXHR9LFxuICBcdHdyYXA6IGZ1bmN0aW9uIChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIG5ldyBBcnJheVdyYXBwZXIocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpO1xuICBcdH1cbiAgfTtcblxuICBBcnJheVdyYXBwZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpIHtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuICBcdHRoaXMudmFsdWUgPSBhcnJheTtcbiAgXHR0aGlzLmtleXBhdGggPSBnZXRLZXlwYXRoKGtleXBhdGgpO1xuXG4gIFx0Ly8gaWYgdGhpcyBhcnJheSBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJhY3RpZmllZCwgcmFjdGlmeSBpdFxuICBcdGlmICghYXJyYXkuX3JhY3RpdmUpIHtcblxuICBcdFx0Ly8gZGVmaW5lIGEgbm9uLWVudW1lcmFibGUgX3JhY3RpdmUgcHJvcGVydHkgdG8gc3RvcmUgdGhlIHdyYXBwZXJzXG4gIFx0XHRkZWZpbmVQcm9wZXJ0eShhcnJheSwgXCJfcmFjdGl2ZVwiLCB7XG4gIFx0XHRcdHZhbHVlOiB7XG4gIFx0XHRcdFx0d3JhcHBlcnM6IFtdLFxuICBcdFx0XHRcdGluc3RhbmNlczogW10sXG4gIFx0XHRcdFx0c2V0dGluZzogZmFsc2VcbiAgXHRcdFx0fSxcbiAgXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG4gIFx0XHR9KTtcblxuICBcdFx0cGF0Y2goYXJyYXkpO1xuICBcdH1cblxuICBcdC8vIHN0b3JlIHRoZSByYWN0aXZlIGluc3RhbmNlLCBzbyB3ZSBjYW4gaGFuZGxlIHRyYW5zaXRpb25zIGxhdGVyXG4gIFx0aWYgKCFhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbcmFjdGl2ZS5fZ3VpZF0pIHtcbiAgXHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1tyYWN0aXZlLl9ndWlkXSA9IDA7XG4gIFx0XHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXMucHVzaChyYWN0aXZlKTtcbiAgXHR9XG5cbiAgXHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbcmFjdGl2ZS5fZ3VpZF0gKz0gMTtcbiAgXHRhcnJheS5fcmFjdGl2ZS53cmFwcGVycy5wdXNoKHRoaXMpO1xuICB9O1xuXG4gIEFycmF5V3JhcHBlci5wcm90b3R5cGUgPSB7XG4gIFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHR9LFxuICBcdHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYXJyYXksIHN0b3JhZ2UsIHdyYXBwZXJzLCBpbnN0YW5jZXMsIGluZGV4O1xuXG4gIFx0XHRhcnJheSA9IHRoaXMudmFsdWU7XG4gIFx0XHRzdG9yYWdlID0gYXJyYXkuX3JhY3RpdmU7XG4gIFx0XHR3cmFwcGVycyA9IHN0b3JhZ2Uud3JhcHBlcnM7XG4gIFx0XHRpbnN0YW5jZXMgPSBzdG9yYWdlLmluc3RhbmNlcztcblxuICBcdFx0Ly8gaWYgdGVhcmRvd24oKSB3YXMgaW52b2tlZCBiZWNhdXNlIHdlJ3JlIGNsZWFyaW5nIHRoZSBjYWNoZSBhcyBhIHJlc3VsdCBvZlxuICBcdFx0Ly8gYSBjaGFuZ2UgdGhhdCB0aGUgYXJyYXkgaXRzZWxmIHRyaWdnZXJlZCwgd2UgY2FuIHNhdmUgb3Vyc2VsdmVzIHRoZSB0ZWFyZG93blxuICBcdFx0Ly8gYW5kIGltbWVkaWF0ZSBzZXR1cFxuICBcdFx0aWYgKHN0b3JhZ2Uuc2V0dGluZykge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIHNvIHRoYXQgd2UgZG9uJ3QgcmVtb3ZlIGl0IGZyb20gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkXG4gIFx0XHR9XG5cbiAgXHRcdGluZGV4ID0gd3JhcHBlcnMuaW5kZXhPZih0aGlzKTtcbiAgXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKGFycmF5X2luZGV4X19lcnJvck1lc3NhZ2UpO1xuICBcdFx0fVxuXG4gIFx0XHR3cmFwcGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIFx0XHQvLyBpZiBub3RoaW5nIGVsc2UgZGVwZW5kcyBvbiB0aGlzIGFycmF5LCB3ZSBjYW4gcmV2ZXJ0IGl0IHRvIGl0c1xuICBcdFx0Ly8gbmF0dXJhbCBzdGF0ZVxuICBcdFx0aWYgKCF3cmFwcGVycy5sZW5ndGgpIHtcbiAgXHRcdFx0ZGVsZXRlIGFycmF5Ll9yYWN0aXZlO1xuICBcdFx0XHRwYXRjaC51bnBhdGNoKHRoaXMudmFsdWUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Ly8gcmVtb3ZlIHJhY3RpdmUgaW5zdGFuY2UgaWYgcG9zc2libGVcbiAgXHRcdFx0aW5zdGFuY2VzW3RoaXMucm9vdC5fZ3VpZF0gLT0gMTtcbiAgXHRcdFx0aWYgKCFpbnN0YW5jZXNbdGhpcy5yb290Ll9ndWlkXSkge1xuICBcdFx0XHRcdGluZGV4ID0gaW5zdGFuY2VzLmluZGV4T2YodGhpcy5yb290KTtcblxuICBcdFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihhcnJheV9pbmRleF9fZXJyb3JNZXNzYWdlKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICBhcnJheV9pbmRleF9fZXJyb3JNZXNzYWdlID0gXCJTb21ldGhpbmcgd2VudCB3cm9uZyBpbiBhIHJhdGhlciBpbnRlcmVzdGluZyB3YXlcIjtcbiAgdmFyIGFycmF5X2luZGV4ID0gYXJyYXlBZGFwdG9yO1xuXG4gIHZhciBudW1lcmljID0gL15cXHMqWzAtOV0rXFxzKiQvO1xuXG4gIHZhciBjcmVhdGVCcmFuY2ggPSBmdW5jdGlvbiAoa2V5KSB7XG4gIFx0cmV0dXJuIG51bWVyaWMudGVzdChrZXkpID8gW10gOiB7fTtcbiAgfTtcblxuICB2YXIgbWFnaWNBZGFwdG9yLCBNYWdpY1dyYXBwZXI7XG5cbiAgdHJ5IHtcbiAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwidGVzdFwiLCB7IHZhbHVlOiAwIH0pO1xuXG4gIFx0bWFnaWNBZGFwdG9yID0ge1xuICBcdFx0ZmlsdGVyOiBmdW5jdGlvbiAob2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlKSB7XG4gIFx0XHRcdHZhciBwYXJlbnRXcmFwcGVyLCBwYXJlbnRWYWx1ZTtcblxuICBcdFx0XHRpZiAoIWtleXBhdGgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChrZXlwYXRoKTtcblxuICBcdFx0XHQvLyBJZiB0aGUgcGFyZW50IHZhbHVlIGlzIGEgd3JhcHBlciwgb3RoZXIgdGhhbiBhIG1hZ2ljIHdyYXBwZXIsXG4gIFx0XHRcdC8vIHdlIHNob3VsZG4ndCB3cmFwIHRoaXMgcHJvcGVydHlcbiAgXHRcdFx0aWYgKChwYXJlbnRXcmFwcGVyID0gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdKSAmJiAhcGFyZW50V3JhcHBlci5tYWdpYykge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHBhcmVudFZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KGtleXBhdGgucGFyZW50KTtcblxuICBcdFx0XHQvLyBpZiBwYXJlbnRWYWx1ZSBpcyBhbiBhcnJheSB0aGF0IGRvZXNuJ3QgaW5jbHVkZSB0aGlzIG1lbWJlcixcbiAgXHRcdFx0Ly8gd2Ugc2hvdWxkIHJldHVybiBmYWxzZSBvdGhlcndpc2UgbGVuZ3RocyB3aWxsIGdldCBtZXNzZWQgdXBcbiAgXHRcdFx0aWYgKGlzQXJyYXkocGFyZW50VmFsdWUpICYmIC9eWzAtOV0rJC8udGVzdChrZXlwYXRoLmxhc3RLZXkpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIHBhcmVudFZhbHVlICYmICh0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHBhcmVudFZhbHVlID09PSBcImZ1bmN0aW9uXCIpO1xuICBcdFx0fSxcbiAgXHRcdHdyYXA6IGZ1bmN0aW9uIChyYWN0aXZlLCBwcm9wZXJ0eSwga2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gbmV3IE1hZ2ljV3JhcHBlcihyYWN0aXZlLCBwcm9wZXJ0eSwga2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdE1hZ2ljV3JhcHBlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCkge1xuICBcdFx0dmFyIG9iaktleXBhdGgsIHRlbXBsYXRlLCBzaWJsaW5ncztcblxuICBcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgoa2V5cGF0aCk7XG5cbiAgXHRcdHRoaXMubWFnaWMgPSB0cnVlO1xuXG4gIFx0XHR0aGlzLnJhY3RpdmUgPSByYWN0aXZlO1xuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0dGhpcy5wcm9wID0ga2V5cGF0aC5sYXN0S2V5O1xuXG4gIFx0XHRvYmpLZXlwYXRoID0ga2V5cGF0aC5wYXJlbnQ7XG4gIFx0XHR0aGlzLm9iaiA9IG9iaktleXBhdGguaXNSb290ID8gcmFjdGl2ZS52aWV3bW9kZWwuZGF0YSA6IHJhY3RpdmUudmlld21vZGVsLmdldChvYmpLZXlwYXRoKTtcblxuICBcdFx0dGVtcGxhdGUgPSB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcy5vYmosIHRoaXMucHJvcCk7XG5cbiAgXHRcdC8vIEhhcyB0aGlzIHByb3BlcnR5IGFscmVhZHkgYmVlbiB3cmFwcGVkP1xuICBcdFx0aWYgKHRlbXBsYXRlICYmIHRlbXBsYXRlLnNldCAmJiAoc2libGluZ3MgPSB0ZW1wbGF0ZS5zZXQuX3JhY3RpdmVXcmFwcGVycykpIHtcblxuICBcdFx0XHQvLyBZZXMuIFJlZ2lzdGVyIHRoaXMgd3JhcHBlciB0byB0aGlzIHByb3BlcnR5LCBpZiBpdCBoYXNuJ3QgYmVlbiBhbHJlYWR5XG4gIFx0XHRcdGlmIChzaWJsaW5ncy5pbmRleE9mKHRoaXMpID09PSAtMSkge1xuICBcdFx0XHRcdHNpYmxpbmdzLnB1c2godGhpcyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47IC8vIGFscmVhZHkgd3JhcHBlZFxuICBcdFx0fVxuXG4gIFx0XHQvLyBObywgaXQgaGFzbid0IGJlZW4gd3JhcHBlZFxuICBcdFx0Y3JlYXRlQWNjZXNzb3JzKHRoaXMsIHZhbHVlLCB0ZW1wbGF0ZSk7XG4gIFx0fTtcblxuICBcdE1hZ2ljV3JhcHBlci5wcm90b3R5cGUgPSB7XG4gIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0XHR9LFxuICBcdFx0cmVzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuICBcdFx0XHR0aGlzLm9ialt0aGlzLnByb3BdID0gdmFsdWU7IC8vIHRyaWdnZXIgc2V0KCkgYWNjZXNzb3JcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkUmFjdGl2ZSh0aGlzLnJhY3RpdmUpO1xuICBcdFx0XHR0aGlzLnJhY3RpdmUudmlld21vZGVsLm1hcmsodGhpcy5rZXlwYXRoLCB7IGtlZXBFeGlzdGluZ1dyYXBwZXI6IHRydWUgfSk7XG4gIFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9LFxuICBcdFx0c2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICBcdFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghdGhpcy5vYmpbdGhpcy5wcm9wXSkge1xuICBcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuICBcdFx0XHRcdHRoaXMub2JqW3RoaXMucHJvcF0gPSBjcmVhdGVCcmFuY2goa2V5KTtcbiAgXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLm9ialt0aGlzLnByb3BdW2tleV0gPSB2YWx1ZTtcbiAgXHRcdH0sXG4gIFx0XHR0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgdGVtcGxhdGUsIHNldCwgdmFsdWUsIHdyYXBwZXJzLCBpbmRleDtcblxuICBcdFx0XHQvLyBJZiB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkIGJlY2F1c2UgdGhlIGNhY2hlIHdhcyBiZWluZyBjbGVhcmVkIGFzIGFcbiAgXHRcdFx0Ly8gcmVzdWx0IG9mIGEgc2V0KCkvdXBkYXRlKCkgY2FsbCBtYWRlIGJ5IHRoaXMgd3JhcHBlciwgd2UgcmV0dXJuIGZhbHNlXG4gIFx0XHRcdC8vIHNvIHRoYXQgaXQgZG9lc24ndCBnZXQgdG9ybiBkb3duXG4gIFx0XHRcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGVtcGxhdGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMub2JqLCB0aGlzLnByb3ApO1xuICBcdFx0XHRzZXQgPSB0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5zZXQ7XG5cbiAgXHRcdFx0aWYgKCFzZXQpIHtcbiAgXHRcdFx0XHQvLyBtb3N0IGxpa2VseSwgdGhpcyB3YXMgYW4gYXJyYXkgbWVtYmVyIHRoYXQgd2FzIHNwbGljZWQgb3V0XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0d3JhcHBlcnMgPSBzZXQuX3JhY3RpdmVXcmFwcGVycztcblxuICBcdFx0XHRpbmRleCA9IHdyYXBwZXJzLmluZGV4T2YodGhpcyk7XG4gIFx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0XHR3cmFwcGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gTGFzdCBvbmUgb3V0LCB0dXJuIG9mZiB0aGUgbGlnaHRzXG4gIFx0XHRcdGlmICghd3JhcHBlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSB0aGlzLm9ialt0aGlzLnByb3BdO1xuXG4gIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMub2JqLCB0aGlzLnByb3AsIHRoaXMub3JpZ2luYWxEZXNjcmlwdG9yIHx8IHtcbiAgXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuICBcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiAgXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICBcdFx0XHRcdH0pO1xuXG4gIFx0XHRcdFx0dGhpcy5vYmpbdGhpcy5wcm9wXSA9IHZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIFx0bWFnaWNBZGFwdG9yID0gZmFsc2U7IC8vIG5vIG1hZ2ljIGluIHRoaXMgYnJvd3NlclxuICB9XG5cbiAgdmFyIGFkYXB0b3JzX21hZ2ljID0gbWFnaWNBZGFwdG9yO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFjY2Vzc29ycyhvcmlnaW5hbFdyYXBwZXIsIHZhbHVlLCB0ZW1wbGF0ZSkge1xuXG4gIFx0dmFyIG9iamVjdCwgcHJvcGVydHksIG9sZEdldCwgb2xkU2V0LCBnZXQsIHNldDtcblxuICBcdG9iamVjdCA9IG9yaWdpbmFsV3JhcHBlci5vYmo7XG4gIFx0cHJvcGVydHkgPSBvcmlnaW5hbFdyYXBwZXIucHJvcDtcblxuICBcdC8vIElzIHRoaXMgdGVtcGxhdGUgY29uZmlndXJhYmxlP1xuICBcdGlmICh0ZW1wbGF0ZSAmJiAhdGVtcGxhdGUuY29uZmlndXJhYmxlKSB7XG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBhcnJheSBsZW5ndGhcbiAgXHRcdGlmIChwcm9wZXJ0eSA9PT0gXCJsZW5ndGhcIikge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgbWFnaWMgbW9kZSB3aXRoIHByb3BlcnR5IFxcXCJcIiArIHByb3BlcnR5ICsgXCJcXFwiIC0gb2JqZWN0IGlzIG5vdCBjb25maWd1cmFibGVcIik7XG4gIFx0fVxuXG4gIFx0Ly8gVGltZSB0byB3cmFwIHRoaXMgcHJvcGVydHlcbiAgXHRpZiAodGVtcGxhdGUpIHtcbiAgXHRcdG9sZEdldCA9IHRlbXBsYXRlLmdldDtcbiAgXHRcdG9sZFNldCA9IHRlbXBsYXRlLnNldDtcbiAgXHR9XG5cbiAgXHRnZXQgPSBvbGRHZXQgfHwgZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHZhbHVlO1xuICBcdH07XG5cbiAgXHRzZXQgPSBmdW5jdGlvbiAodikge1xuICBcdFx0aWYgKG9sZFNldCkge1xuICBcdFx0XHRvbGRTZXQodik7XG4gIFx0XHR9XG5cbiAgXHRcdHZhbHVlID0gb2xkR2V0ID8gb2xkR2V0KCkgOiB2O1xuICBcdFx0c2V0Ll9yYWN0aXZlV3JhcHBlcnMuZm9yRWFjaCh1cGRhdGVXcmFwcGVyKTtcbiAgXHR9O1xuXG4gIFx0ZnVuY3Rpb24gdXBkYXRlV3JhcHBlcih3cmFwcGVyKSB7XG4gIFx0XHR2YXIga2V5cGF0aCwgcmFjdGl2ZTtcblxuICBcdFx0d3JhcHBlci52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHRpZiAod3JhcHBlci51cGRhdGluZykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHJhY3RpdmUgPSB3cmFwcGVyLnJhY3RpdmU7XG4gIFx0XHRrZXlwYXRoID0gd3JhcHBlci5rZXlwYXRoO1xuXG4gIFx0XHR3cmFwcGVyLnVwZGF0aW5nID0gdHJ1ZTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KHJhY3RpdmUpO1xuXG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHRcdHdyYXBwZXIudXBkYXRpbmcgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHQvLyBDcmVhdGUgYW4gYXJyYXkgb2Ygd3JhcHBlcnMsIGluIGNhc2Ugb3RoZXIga2V5cGF0aHMvcmFjdGl2ZXMgZGVwZW5kIG9uIHRoaXMgcHJvcGVydHkuXG4gIFx0Ly8gSGFuZGlseSwgd2UgY2FuIHN0b3JlIHRoZW0gYXMgYSBwcm9wZXJ0eSBvZiB0aGUgc2V0IGZ1bmN0aW9uLiBZYXkgSmF2YVNjcmlwdC5cbiAgXHRzZXQuX3JhY3RpdmVXcmFwcGVycyA9IFtvcmlnaW5hbFdyYXBwZXJdO1xuICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7IGdldDogZ2V0LCBzZXQ6IHNldCwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9XG5cbiAgdmFyIG1hZ2ljQXJyYXlBZGFwdG9yLCBNYWdpY0FycmF5V3JhcHBlcjtcblxuICBpZiAoYWRhcHRvcnNfbWFnaWMpIHtcbiAgXHRtYWdpY0FycmF5QWRhcHRvciA9IHtcbiAgXHRcdGZpbHRlcjogZnVuY3Rpb24gKG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSkge1xuICBcdFx0XHRyZXR1cm4gYWRhcHRvcnNfbWFnaWMuZmlsdGVyKG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSkgJiYgYXJyYXlfaW5kZXguZmlsdGVyKG9iamVjdCk7XG4gIFx0XHR9LFxuXG4gIFx0XHR3cmFwOiBmdW5jdGlvbiAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5ldyBNYWdpY0FycmF5V3JhcHBlcihyYWN0aXZlLCBhcnJheSwga2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdE1hZ2ljQXJyYXlXcmFwcGVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gYXJyYXk7XG5cbiAgXHRcdHRoaXMubWFnaWMgPSB0cnVlO1xuXG4gIFx0XHR0aGlzLm1hZ2ljV3JhcHBlciA9IGFkYXB0b3JzX21hZ2ljLndyYXAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpO1xuICBcdFx0dGhpcy5hcnJheVdyYXBwZXIgPSBhcnJheV9pbmRleC53cmFwKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKTtcbiAgXHR9O1xuXG4gIFx0TWFnaWNBcnJheVdyYXBwZXIucHJvdG90eXBlID0ge1xuICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdFx0fSxcbiAgXHRcdHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHRoaXMuYXJyYXlXcmFwcGVyLnRlYXJkb3duKCk7XG4gIFx0XHRcdHRoaXMubWFnaWNXcmFwcGVyLnRlYXJkb3duKCk7XG4gIFx0XHR9LFxuICBcdFx0cmVzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5tYWdpY1dyYXBwZXIucmVzZXQodmFsdWUpO1xuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB2YXIgbWFnaWNBcnJheSA9IG1hZ2ljQXJyYXlBZGFwdG9yO1xuXG4gIHZhciBwcm90b3R5cGVfYWRhcHQgPSBWaWV3bW9kZWwkYWRhcHQ7XG5cbiAgdmFyIHByZWZpeGVycyA9IHt9O1xuICBmdW5jdGlvbiBWaWV3bW9kZWwkYWRhcHQoa2V5cGF0aCwgdmFsdWUpIHtcbiAgXHR2YXIgbGVuLCBpLCBhZGFwdG9yLCB3cmFwcGVkO1xuXG4gIFx0aWYgKCF0aGlzLmFkYXB0b3JzKSByZXR1cm47XG5cbiAgXHQvLyBEbyB3ZSBoYXZlIGFuIGFkYXB0b3IgZm9yIHRoaXMgdmFsdWU/XG4gIFx0bGVuID0gdGhpcy5hZGFwdG9ycy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRhZGFwdG9yID0gdGhpcy5hZGFwdG9yc1tpXTtcblxuICBcdFx0aWYgKGFkYXB0b3IuZmlsdGVyKHZhbHVlLCBrZXlwYXRoLCB0aGlzLnJhY3RpdmUpKSB7XG4gIFx0XHRcdHdyYXBwZWQgPSB0aGlzLndyYXBwZWRba2V5cGF0aF0gPSBhZGFwdG9yLndyYXAodGhpcy5yYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCwgZ2V0UHJlZml4ZXIoa2V5cGF0aCkpO1xuICBcdFx0XHR3cmFwcGVkLnZhbHVlID0gdmFsdWU7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmaXhLZXlwYXRoKG9iaiwgcHJlZml4KSB7XG4gIFx0dmFyIHByZWZpeGVkID0ge30sXG4gIFx0ICAgIGtleTtcblxuICBcdGlmICghcHJlZml4KSB7XG4gIFx0XHRyZXR1cm4gb2JqO1xuICBcdH1cblxuICBcdHByZWZpeCArPSBcIi5cIjtcblxuICBcdGZvciAoa2V5IGluIG9iaikge1xuICBcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdHByZWZpeGVkW3ByZWZpeCArIGtleV0gPSBvYmpba2V5XTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcHJlZml4ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcmVmaXhlcihyb290S2V5cGF0aCkge1xuICBcdHZhciByb290RG90O1xuXG4gIFx0aWYgKCFwcmVmaXhlcnNbcm9vdEtleXBhdGhdKSB7XG4gIFx0XHRyb290RG90ID0gcm9vdEtleXBhdGggPyByb290S2V5cGF0aCArIFwiLlwiIDogXCJcIjtcblxuICBcdFx0cHJlZml4ZXJzW3Jvb3RLZXlwYXRoXSA9IGZ1bmN0aW9uIChyZWxhdGl2ZUtleXBhdGgsIHZhbHVlKSB7XG4gIFx0XHRcdHZhciBvYmo7XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiByZWxhdGl2ZUtleXBhdGggPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHRvYmogPSB7fTtcbiAgXHRcdFx0XHRvYmpbcm9vdERvdCArIHJlbGF0aXZlS2V5cGF0aF0gPSB2YWx1ZTtcbiAgXHRcdFx0XHRyZXR1cm4gb2JqO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiByZWxhdGl2ZUtleXBhdGggPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdFx0XHQvLyAncmVsYXRpdmVLZXlwYXRoJyBpcyBpbiBmYWN0IGEgaGFzaCwgbm90IGEga2V5cGF0aFxuICBcdFx0XHRcdHJldHVybiByb290RG90ID8gcHJlZml4S2V5cGF0aChyZWxhdGl2ZUtleXBhdGgsIHJvb3RLZXlwYXRoKSA6IHJlbGF0aXZlS2V5cGF0aDtcbiAgXHRcdFx0fVxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcHJlZml4ZXJzW3Jvb3RLZXlwYXRoXTtcbiAgfVxuXG4gIC8vIFRFTVBcblxuICB2YXIgaGVscGVyc19nZXRVcHN0cmVhbUNoYW5nZXMgPSBnZXRVcHN0cmVhbUNoYW5nZXM7XG4gIGZ1bmN0aW9uIGdldFVwc3RyZWFtQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gIFx0dmFyIHVwc3RyZWFtQ2hhbmdlcyA9IFtyb290S2V5cGF0aF0sXG4gIFx0ICAgIGksXG4gIFx0ICAgIGtleXBhdGg7XG5cbiAgXHRpID0gY2hhbmdlcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0a2V5cGF0aCA9IGNoYW5nZXNbaV0ucGFyZW50O1xuXG4gIFx0XHR3aGlsZSAoa2V5cGF0aCAmJiAha2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdFx0aWYgKGNoYW5nZXMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEpIHtcbiAgXHRcdFx0XHRhZGRUb0FycmF5KHVwc3RyZWFtQ2hhbmdlcywga2V5cGF0aCk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0a2V5cGF0aCA9IGtleXBhdGgucGFyZW50O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB1cHN0cmVhbUNoYW5nZXM7XG4gIH1cblxuICB2YXIgYXBwbHlDaGFuZ2VzX25vdGlmeVBhdHRlcm5PYnNlcnZlcnMgPSBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzO1xuXG4gIGZ1bmN0aW9uIG5vdGlmeVBhdHRlcm5PYnNlcnZlcnModmlld21vZGVsLCBrZXlwYXRoLCBvbmx5RGlyZWN0KSB7XG4gIFx0dmFyIHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcztcblxuICBcdHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyh2aWV3bW9kZWwsIGtleXBhdGgpO1xuXG4gIFx0aWYgKG9ubHlEaXJlY3QpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgPSBrZXlwYXRoLndpbGRjYXJkTWF0Y2hlcygpO1xuICBcdHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uICh1cHN0cmVhbVBhdHRlcm4pIHtcbiAgXHRcdGNhc2NhZGUodmlld21vZGVsLCB1cHN0cmVhbVBhdHRlcm4sIGtleXBhdGgpO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FzY2FkZSh2aWV3bW9kZWwsIHVwc3RyZWFtUGF0dGVybiwga2V5cGF0aCkge1xuICBcdHZhciBncm91cCwgbWFwLCBhY3R1YWxDaGlsZEtleXBhdGg7XG5cbiAgXHQvLyBUT0RPIHNob3VsZCBiZSBvbmUgb3IgdGhlIG90aGVyXG4gIFx0dXBzdHJlYW1QYXR0ZXJuID0gdXBzdHJlYW1QYXR0ZXJuLnN0ciB8fCB1cHN0cmVhbVBhdHRlcm47XG5cbiAgXHRncm91cCA9IHZpZXdtb2RlbC5kZXBzTWFwLnBhdHRlcm5PYnNlcnZlcnM7XG4gIFx0bWFwID0gZ3JvdXAgJiYgZ3JvdXBbdXBzdHJlYW1QYXR0ZXJuXTtcblxuICBcdGlmICghbWFwKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0bWFwLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkS2V5cGF0aCkge1xuICBcdFx0YWN0dWFsQ2hpbGRLZXlwYXRoID0ga2V5cGF0aC5qb2luKGNoaWxkS2V5cGF0aC5sYXN0S2V5KTsgLy8gJ2Zvby5iYXIuYmF6J1xuXG4gIFx0XHR1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnModmlld21vZGVsLCBhY3R1YWxDaGlsZEtleXBhdGgpO1xuICBcdFx0Y2FzY2FkZSh2aWV3bW9kZWwsIGNoaWxkS2V5cGF0aCwgYWN0dWFsQ2hpbGRLZXlwYXRoKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyh2aWV3bW9kZWwsIGtleXBhdGgpIHtcbiAgXHR2aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICBcdFx0aWYgKG9ic2VydmVyLnJlZ2V4LnRlc3Qoa2V5cGF0aC5zdHIpKSB7XG4gIFx0XHRcdG9ic2VydmVyLnVwZGF0ZShrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBhcHBseUNoYW5nZXMgPSBWaWV3bW9kZWwkYXBwbHlDaGFuZ2VzO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRhcHBseUNoYW5nZXMoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBzZWxmID0gdGhpcyxcbiAgXHQgICAgY2hhbmdlcyxcbiAgXHQgICAgdXBzdHJlYW1DaGFuZ2VzLFxuICBcdCAgICBoYXNoID0ge30sXG4gIFx0ICAgIGJpbmRpbmdzO1xuXG4gIFx0Y2hhbmdlcyA9IHRoaXMuY2hhbmdlcztcblxuICBcdGlmICghY2hhbmdlcy5sZW5ndGgpIHtcbiAgXHRcdC8vIFRPRE8gd2UgZW5kIHVwIGhlcmUgb24gaW5pdGlhbCByZW5kZXIuIFBlcmhhcHMgd2Ugc2hvdWxkbid0P1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIGludmFsaWRhdGVDb21wdXRhdGlvbihjb21wdXRhdGlvbikge1xuICBcdFx0dmFyIGtleSA9IGNvbXB1dGF0aW9uLmtleTtcblxuICBcdFx0aWYgKGNvbXB1dGF0aW9uLnZpZXdtb2RlbCA9PT0gc2VsZikge1xuICBcdFx0XHRzZWxmLmNsZWFyQ2FjaGUoa2V5LnN0cik7XG4gIFx0XHRcdGNvbXB1dGF0aW9uLmludmFsaWRhdGUoKTtcblxuICBcdFx0XHRjaGFuZ2VzLnB1c2goa2V5KTtcbiAgXHRcdFx0Y2FzY2FkZShrZXkpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y29tcHV0YXRpb24udmlld21vZGVsLm1hcmsoa2V5KTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBjYXNjYWRlKGtleXBhdGgpIHtcbiAgXHRcdHZhciBtYXAsIGNvbXB1dGF0aW9ucztcblxuICBcdFx0aWYgKHNlbGYubm9DYXNjYWRlLmhhc093blByb3BlcnR5KGtleXBhdGguc3RyKSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChjb21wdXRhdGlvbnMgPSBzZWxmLmRlcHMuY29tcHV0ZWRba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdGNvbXB1dGF0aW9ucy5mb3JFYWNoKGludmFsaWRhdGVDb21wdXRhdGlvbik7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChtYXAgPSBzZWxmLmRlcHNNYXAuY29tcHV0ZWRba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdG1hcC5mb3JFYWNoKGNhc2NhZGUpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGNoYW5nZXMuc2xpY2UoKS5mb3JFYWNoKGNhc2NhZGUpO1xuXG4gIFx0dXBzdHJlYW1DaGFuZ2VzID0gaGVscGVyc19nZXRVcHN0cmVhbUNoYW5nZXMoY2hhbmdlcyk7XG4gIFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhciBjb21wdXRhdGlvbnM7XG5cbiAgXHRcdC8vIG1ha2Ugc3VyZSB3ZSBoYXZlbid0IGFscmVhZHkgYmVlbiBkb3duIHRoaXMgcGFydGljdWxhciBrZXlwYXRoIGluIHRoaXMgdHVyblxuICBcdFx0aWYgKGNoYW5nZXMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEgJiYgKGNvbXB1dGF0aW9ucyA9IHNlbGYuZGVwcy5jb21wdXRlZFtrZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHRcdGNvbXB1dGF0aW9ucy5mb3JFYWNoKGludmFsaWRhdGVDb21wdXRhdGlvbik7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHR0aGlzLmNoYW5nZXMgPSBbXTtcblxuICBcdC8vIFBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSBhIHdlaXJkIHNwZWNpYWwgY2FzZVxuICBcdGlmICh0aGlzLnBhdHRlcm5PYnNlcnZlcnMubGVuZ3RoKSB7XG4gIFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gYXBwbHlDaGFuZ2VzX25vdGlmeVBhdHRlcm5PYnNlcnZlcnMoX3RoaXMsIGtleXBhdGgsIHRydWUpO1xuICBcdFx0fSk7XG4gIFx0XHRjaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKF90aGlzLCBrZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmRlcHMub2JzZXJ2ZXJzKSB7XG4gIFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKF90aGlzLCBudWxsLCBrZXlwYXRoLCBcIm9ic2VydmVyc1wiKTtcbiAgXHRcdH0pO1xuICBcdFx0bm90aWZ5QWxsRGVwZW5kYW50cyh0aGlzLCBjaGFuZ2VzLCBcIm9ic2VydmVyc1wiKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5kZXBzW1wiZGVmYXVsdFwiXSkge1xuICBcdFx0YmluZGluZ3MgPSBbXTtcbiAgXHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBub3RpZnlVcHN0cmVhbURlcGVuZGFudHMoX3RoaXMsIGJpbmRpbmdzLCBrZXlwYXRoLCBcImRlZmF1bHRcIik7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKGJpbmRpbmdzLmxlbmd0aCkge1xuICBcdFx0XHRub3RpZnlCaW5kaW5ncyh0aGlzLCBiaW5kaW5ncywgY2hhbmdlcyk7XG4gIFx0XHR9XG5cbiAgXHRcdG5vdGlmeUFsbERlcGVuZGFudHModGhpcywgY2hhbmdlcywgXCJkZWZhdWx0XCIpO1xuICBcdH1cblxuICBcdC8vIFJldHVybiBhIGhhc2ggb2Yga2V5cGF0aHMgdG8gdXBkYXRlZCB2YWx1ZXNcbiAgXHRjaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGhhc2hba2V5cGF0aC5zdHJdID0gX3RoaXMuZ2V0KGtleXBhdGgpO1xuICBcdH0pO1xuXG4gIFx0dGhpcy5pbXBsaWNpdENoYW5nZXMgPSB7fTtcbiAgXHR0aGlzLm5vQ2FzY2FkZSA9IHt9O1xuXG4gIFx0cmV0dXJuIGhhc2g7XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlVcHN0cmVhbURlcGVuZGFudHModmlld21vZGVsLCBiaW5kaW5ncywga2V5cGF0aCwgZ3JvdXBOYW1lKSB7XG4gIFx0dmFyIGRlcGVuZGFudHMsIHZhbHVlO1xuXG4gIFx0aWYgKGRlcGVuZGFudHMgPSBmaW5kRGVwZW5kYW50cyh2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSkpIHtcbiAgXHRcdHZhbHVlID0gdmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0ZGVwZW5kYW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdC8vIGRvbid0IFwic2V0XCIgdGhlIHBhcmVudCB2YWx1ZSwgcmVmaW5lIGl0XG4gIFx0XHRcdC8vIGkuZS4gbm90IGRhdGEgPSB2YWx1ZSwgYnV0IGRhdGFbZm9vXSA9IGZvb1ZhbHVlXG4gIFx0XHRcdGlmIChiaW5kaW5ncyAmJiBkLnJlZmluZVZhbHVlKSB7XG4gIFx0XHRcdFx0YmluZGluZ3MucHVzaChkKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRkLnNldFZhbHVlKHZhbHVlKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5QmluZGluZ3Modmlld21vZGVsLCBiaW5kaW5ncywgY2hhbmdlcykge1xuXG4gIFx0YmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYmluZGluZykge1xuICBcdFx0dmFyIHVzZVNldCA9IGZhbHNlLFxuICBcdFx0ICAgIGkgPSAwLFxuICBcdFx0ICAgIGxlbmd0aCA9IGNoYW5nZXMubGVuZ3RoLFxuICBcdFx0ICAgIHJlZmluZW1lbnRzID0gW107XG5cbiAgXHRcdHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gIFx0XHRcdHZhciBrZXlwYXRoID0gY2hhbmdlc1tpXTtcblxuICBcdFx0XHRpZiAoa2V5cGF0aCA9PT0gYmluZGluZy5rZXlwYXRoKSB7XG4gIFx0XHRcdFx0dXNlU2V0ID0gdHJ1ZTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChrZXlwYXRoLnNsaWNlKDAsIGJpbmRpbmcua2V5cGF0aC5sZW5ndGgpID09PSBiaW5kaW5nLmtleXBhdGgpIHtcbiAgXHRcdFx0XHRyZWZpbmVtZW50cy5wdXNoKGtleXBhdGgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aSsrO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodXNlU2V0KSB7XG4gIFx0XHRcdGJpbmRpbmcuc2V0VmFsdWUodmlld21vZGVsLmdldChiaW5kaW5nLmtleXBhdGgpKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHJlZmluZW1lbnRzLmxlbmd0aCkge1xuICBcdFx0XHRiaW5kaW5nLnJlZmluZVZhbHVlKHJlZmluZW1lbnRzKTtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeUFsbERlcGVuZGFudHModmlld21vZGVsLCBrZXlwYXRocywgZ3JvdXBOYW1lKSB7XG4gIFx0dmFyIHF1ZXVlID0gW107XG5cbiAgXHRhZGRLZXlwYXRocyhrZXlwYXRocyk7XG4gIFx0cXVldWUuZm9yRWFjaChkaXNwYXRjaCk7XG5cbiAgXHRmdW5jdGlvbiBhZGRLZXlwYXRocyhrZXlwYXRocykge1xuICBcdFx0a2V5cGF0aHMuZm9yRWFjaChhZGRLZXlwYXRoKTtcbiAgXHRcdGtleXBhdGhzLmZvckVhY2goY2FzY2FkZSk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gYWRkS2V5cGF0aChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgZGVwcyA9IGZpbmREZXBlbmRhbnRzKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lKTtcblxuICBcdFx0aWYgKGRlcHMpIHtcbiAgXHRcdFx0cXVldWUucHVzaCh7XG4gIFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aCxcbiAgXHRcdFx0XHRkZXBzOiBkZXBzXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGZ1bmN0aW9uIGNhc2NhZGUoa2V5cGF0aCkge1xuICBcdFx0dmFyIGNoaWxkRGVwcztcblxuICBcdFx0aWYgKGNoaWxkRGVwcyA9IHZpZXdtb2RlbC5kZXBzTWFwW2dyb3VwTmFtZV1ba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdGFkZEtleXBhdGhzKGNoaWxkRGVwcyk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gZGlzcGF0Y2goc2V0KSB7XG4gIFx0XHR2YXIgdmFsdWUgPSB2aWV3bW9kZWwuZ2V0KHNldC5rZXlwYXRoKTtcbiAgXHRcdHNldC5kZXBzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0cmV0dXJuIGQuc2V0VmFsdWUodmFsdWUpO1xuICBcdFx0fSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZERlcGVuZGFudHModmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUpIHtcbiAgXHR2YXIgZ3JvdXAgPSB2aWV3bW9kZWwuZGVwc1tncm91cE5hbWVdO1xuICBcdHJldHVybiBncm91cCA/IGdyb3VwW2tleXBhdGguc3RyXSA6IG51bGw7XG4gIH1cblxuICB2YXIgY2FwdHVyZSA9IFZpZXdtb2RlbCRjYXB0dXJlO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRjYXB0dXJlKCkge1xuICBcdHRoaXMuY2FwdHVyZUdyb3Vwcy5wdXNoKFtdKTtcbiAgfVxuXG4gIHZhciBjbGVhckNhY2hlID0gVmlld21vZGVsJGNsZWFyQ2FjaGU7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJGNsZWFyQ2FjaGUoa2V5cGF0aCwga2VlcEV4aXN0aW5nV3JhcHBlcikge1xuICBcdHZhciBjYWNoZU1hcCwgd3JhcHBlcjtcblxuICBcdGlmICgha2VlcEV4aXN0aW5nV3JhcHBlcikge1xuICBcdFx0Ly8gSXMgdGhlcmUgYSB3cmFwcGVkIHByb3BlcnR5IGF0IHRoaXMga2V5cGF0aD9cbiAgXHRcdGlmICh3cmFwcGVyID0gdGhpcy53cmFwcGVkW2tleXBhdGhdKSB7XG4gIFx0XHRcdC8vIERpZCB3ZSB1bndyYXAgaXQ/XG4gIFx0XHRcdGlmICh3cmFwcGVyLnRlYXJkb3duKCkgIT09IGZhbHNlKSB7XG4gIFx0XHRcdFx0Ly8gSXMgdGhpcyByaWdodD9cbiAgXHRcdFx0XHQvLyBXaGF0J3MgdGhlIG1lYW5pbmcgb2YgcmV0dXJuaW5nIGZhbHNlIGZyb20gdGVhcmRvd24/XG4gIFx0XHRcdFx0Ly8gQ291bGQgdGhlcmUgYmUgYSBHQyByYW1pZmljYXRpb24gaWYgdGhpcyBpcyBhIFwicmVhbFwiIHJhY3RpdmUudGVhcmRvd24oKT9cbiAgXHRcdFx0XHR0aGlzLndyYXBwZWRba2V5cGF0aF0gPSBudWxsO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy5jYWNoZVtrZXlwYXRoXSA9IHVuZGVmaW5lZDtcblxuICBcdGlmIChjYWNoZU1hcCA9IHRoaXMuY2FjaGVNYXBba2V5cGF0aF0pIHtcbiAgXHRcdHdoaWxlIChjYWNoZU1hcC5sZW5ndGgpIHtcbiAgXHRcdFx0dGhpcy5jbGVhckNhY2hlKGNhY2hlTWFwLnBvcCgpKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgVW5yZXNvbHZlZERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoY29tcHV0YXRpb24sIHJlZikge1xuICBcdHRoaXMuY29tcHV0YXRpb24gPSBjb21wdXRhdGlvbjtcbiAgXHR0aGlzLnZpZXdtb2RlbCA9IGNvbXB1dGF0aW9uLnZpZXdtb2RlbDtcbiAgXHR0aGlzLnJlZiA9IHJlZjtcblxuICBcdC8vIFRPRE8gdGhpcyBzZWVtcyBsaWtlIGEgcmVkIGZsYWchXG4gIFx0dGhpcy5yb290ID0gdGhpcy52aWV3bW9kZWwucmFjdGl2ZTtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gdGhpcy5yb290LmNvbXBvbmVudCAmJiB0aGlzLnJvb3QuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICB9O1xuXG4gIFVucmVzb2x2ZWREZXBlbmRlbmN5LnByb3RvdHlwZSA9IHtcbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dGhpcy5jb21wdXRhdGlvbi5zb2Z0RGVwcy5wdXNoKGtleXBhdGgpO1xuICBcdFx0dGhpcy5jb21wdXRhdGlvbi51bnJlc29sdmVkRGVwc1trZXlwYXRoLnN0cl0gPSBudWxsO1xuICBcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIoa2V5cGF0aCwgdGhpcy5jb21wdXRhdGlvbiwgXCJjb21wdXRlZFwiKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIENvbXB1dGF0aW9uX1VucmVzb2x2ZWREZXBlbmRlbmN5ID0gVW5yZXNvbHZlZERlcGVuZGVuY3k7XG5cbiAgdmFyIENvbXB1dGF0aW9uID0gZnVuY3Rpb24gKGtleSwgc2lnbmF0dXJlKSB7XG4gIFx0dGhpcy5rZXkgPSBrZXk7XG5cbiAgXHR0aGlzLmdldHRlciA9IHNpZ25hdHVyZS5nZXR0ZXI7XG4gIFx0dGhpcy5zZXR0ZXIgPSBzaWduYXR1cmUuc2V0dGVyO1xuXG4gIFx0dGhpcy5oYXJkRGVwcyA9IHNpZ25hdHVyZS5kZXBzIHx8IFtdO1xuICBcdHRoaXMuc29mdERlcHMgPSBbXTtcbiAgXHR0aGlzLnVucmVzb2x2ZWREZXBzID0ge307XG5cbiAgXHR0aGlzLmRlcFZhbHVlcyA9IHt9O1xuXG4gIFx0dGhpcy5fZGlydHkgPSB0aGlzLl9maXJzdFJ1biA9IHRydWU7XG4gIH07XG5cbiAgQ29tcHV0YXRpb24ucHJvdG90eXBlID0ge1xuICBcdGNvbnN0cnVjdG9yOiBDb21wdXRhdGlvbixcblxuICBcdGluaXQ6IGZ1bmN0aW9uICh2aWV3bW9kZWwpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciBpbml0aWFsO1xuXG4gIFx0XHR0aGlzLnZpZXdtb2RlbCA9IHZpZXdtb2RlbDtcbiAgXHRcdHRoaXMuYnlwYXNzID0gdHJ1ZTtcblxuICBcdFx0aW5pdGlhbCA9IHZpZXdtb2RlbC5nZXQodGhpcy5rZXkpO1xuICBcdFx0dmlld21vZGVsLmNsZWFyQ2FjaGUodGhpcy5rZXkuc3RyKTtcblxuICBcdFx0dGhpcy5ieXBhc3MgPSBmYWxzZTtcblxuICBcdFx0aWYgKHRoaXMuc2V0dGVyICYmIGluaXRpYWwgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLnNldChpbml0aWFsKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuaGFyZERlcHMpIHtcbiAgXHRcdFx0dGhpcy5oYXJkRGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHZpZXdtb2RlbC5yZWdpc3RlcihkLCBfdGhpcywgXCJjb21wdXRlZFwiKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGludmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgbmV3RGVwcyxcbiAgXHRcdCAgICBkZXBlbmRlbmNpZXNDaGFuZ2VkLFxuICBcdFx0ICAgIGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkID0gZmFsc2U7XG5cbiAgXHRcdGlmICh0aGlzLmdldHRpbmcpIHtcbiAgXHRcdFx0Ly8gcHJldmVudCBkb3VibGUtY29tcHV0YXRpb24gKGUuZy4gY2F1c2VkIGJ5IGFycmF5IG11dGF0aW9uIGluc2lkZSBjb21wdXRhdGlvbilcbiAgXHRcdFx0dmFyIG1zZyA9IFwiVGhlIFwiICsgdGhpcy5rZXkuc3RyICsgXCIgY29tcHV0YXRpb24gaW5kaXJlY3RseSBjYWxsZWQgaXRzZWxmLiBUaGlzIHByb2JhYmx5IGluZGljYXRlcyBhIGJ1ZyBpbiB0aGUgY29tcHV0YXRpb24uIEl0IGlzIGNvbW1vbmx5IGNhdXNlZCBieSBgYXJyYXkuc29ydCguLi4pYCAtIGlmIHRoYXQncyB0aGUgY2FzZSwgY2xvbmUgdGhlIGFycmF5IGZpcnN0IHdpdGggYGFycmF5LnNsaWNlKCkuc29ydCguLi4pYFwiO1xuICBcdFx0XHR3YXJuT25jZShtc2cpO1xuICBcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5nZXR0aW5nID0gdHJ1ZTtcblxuICBcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG4gIFx0XHRcdC8vIGRldGVybWluZSB3aGV0aGVyIHRoZSBpbnB1dHMgaGF2ZSBjaGFuZ2VkLCBpbiBjYXNlIHRoaXMgZGVwZW5kcyBvblxuICBcdFx0XHQvLyBvdGhlciBjb21wdXRlZCB2YWx1ZXNcbiAgXHRcdFx0aWYgKHRoaXMuX2ZpcnN0UnVuIHx8ICF0aGlzLmhhcmREZXBzLmxlbmd0aCAmJiAhdGhpcy5zb2Z0RGVwcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0W3RoaXMuaGFyZERlcHMsIHRoaXMuc29mdERlcHNdLmZvckVhY2goZnVuY3Rpb24gKGRlcHMpIHtcbiAgXHRcdFx0XHRcdHZhciBrZXlwYXRoLCB2YWx1ZSwgaTtcblxuICBcdFx0XHRcdFx0aWYgKGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkKSB7XG4gIFx0XHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0aSA9IGRlcHMubGVuZ3RoO1xuICBcdFx0XHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdFx0XHRrZXlwYXRoID0gZGVwc1tpXTtcbiAgXHRcdFx0XHRcdFx0dmFsdWUgPSBfdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHRcdFx0XHRcdGlmICghaXNFcXVhbCh2YWx1ZSwgX3RoaXMuZGVwVmFsdWVzW2tleXBhdGguc3RyXSkpIHtcbiAgXHRcdFx0XHRcdFx0XHRfdGhpcy5kZXBWYWx1ZXNba2V5cGF0aC5zdHJdID0gdmFsdWU7XG4gIFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSB0cnVlO1xuXG4gIFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQpIHtcbiAgXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5jYXB0dXJlKCk7XG5cbiAgXHRcdFx0XHR0cnkge1xuICBcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZ2V0dGVyKCk7XG4gIFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG4gIFx0XHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIkZhaWxlZCB0byBjb21wdXRlIFxcXCIlc1xcXCJcIiwgdGhpcy5rZXkuc3RyKTtcbiAgXHRcdFx0XHRcdGxvZ0lmRGVidWcoZXJyLnN0YWNrIHx8IGVycik7XG5cbiAgXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0bmV3RGVwcyA9IHRoaXMudmlld21vZGVsLnJlbGVhc2UoKTtcbiAgXHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdGhpcy51cGRhdGVEZXBlbmRlbmNpZXMobmV3RGVwcyk7XG5cbiAgXHRcdFx0XHRpZiAoZGVwZW5kZW5jaWVzQ2hhbmdlZCkge1xuICBcdFx0XHRcdFx0W3RoaXMuaGFyZERlcHMsIHRoaXMuc29mdERlcHNdLmZvckVhY2goZnVuY3Rpb24gKGRlcHMpIHtcbiAgXHRcdFx0XHRcdFx0ZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdFx0XHRcdFx0X3RoaXMuZGVwVmFsdWVzW2tleXBhdGguc3RyXSA9IF90aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5nZXR0aW5nID0gdGhpcy5fZmlyc3RSdW4gPSBmYWxzZTtcbiAgXHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdH0sXG5cbiAgXHRzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0aWYgKHRoaXMuc2V0dGluZykge1xuICBcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLnNldHRlcikge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb21wdXRlZCBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVycyBhcmUgcmVhZC1vbmx5LiAoVGhpcyBtYXkgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmFjdGl2ZSEpXCIpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnNldHRlcih2YWx1ZSk7XG4gIFx0fSxcblxuICBcdHVwZGF0ZURlcGVuZGVuY2llczogZnVuY3Rpb24gKG5ld0RlcHMpIHtcbiAgXHRcdHZhciBpLCBvbGREZXBzLCBrZXlwYXRoLCBkZXBlbmRlbmNpZXNDaGFuZ2VkLCB1bnJlc29sdmVkO1xuXG4gIFx0XHRvbGREZXBzID0gdGhpcy5zb2Z0RGVwcztcblxuICBcdFx0Ly8gcmVtb3ZlIGRlcGVuZGVuY2llcyB0aGF0IGFyZSBubyBsb25nZXIgdXNlZFxuICBcdFx0aSA9IG9sZERlcHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRrZXlwYXRoID0gb2xkRGVwc1tpXTtcblxuICBcdFx0XHRpZiAobmV3RGVwcy5pbmRleE9mKGtleXBhdGgpID09PSAtMSkge1xuICBcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIoa2V5cGF0aCwgdGhpcywgXCJjb21wdXRlZFwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBjcmVhdGUgcmVmZXJlbmNlcyBmb3IgYW55IG5ldyBkZXBlbmRlbmNpZXNcbiAgXHRcdGkgPSBuZXdEZXBzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0a2V5cGF0aCA9IG5ld0RlcHNbaV07XG5cbiAgXHRcdFx0aWYgKG9sZERlcHMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEgJiYgKCF0aGlzLmhhcmREZXBzIHx8IHRoaXMuaGFyZERlcHMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEpKSB7XG4gIFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRydWU7XG5cbiAgXHRcdFx0XHQvLyBpZiB0aGlzIGtleXBhdGggaXMgY3VycmVudGx5IHVucmVzb2x2ZWQsIHdlIG5lZWQgdG8gbWFya1xuICBcdFx0XHRcdC8vIGl0IGFzIHN1Y2guIFRPRE8gdGhpcyBpcyBhIGJpdCBtdWRkeS4uLlxuICBcdFx0XHRcdGlmIChpc1VucmVzb2x2ZWQodGhpcy52aWV3bW9kZWwsIGtleXBhdGgpICYmICF0aGlzLnVucmVzb2x2ZWREZXBzW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRcdFx0dW5yZXNvbHZlZCA9IG5ldyBDb21wdXRhdGlvbl9VbnJlc29sdmVkRGVwZW5kZW5jeSh0aGlzLCBrZXlwYXRoLnN0cik7XG4gIFx0XHRcdFx0XHRuZXdEZXBzLnNwbGljZShpLCAxKTtcblxuICBcdFx0XHRcdFx0dGhpcy51bnJlc29sdmVkRGVwc1trZXlwYXRoLnN0cl0gPSB1bnJlc29sdmVkO1xuICBcdFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVW5yZXNvbHZlZCh1bnJlc29sdmVkKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIoa2V5cGF0aCwgdGhpcywgXCJjb21wdXRlZFwiKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKGRlcGVuZGVuY2llc0NoYW5nZWQpIHtcbiAgXHRcdFx0dGhpcy5zb2Z0RGVwcyA9IG5ld0RlcHMuc2xpY2UoKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGRlcGVuZGVuY2llc0NoYW5nZWQ7XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzVW5yZXNvbHZlZCh2aWV3bW9kZWwsIGtleXBhdGgpIHtcbiAgXHR2YXIga2V5ID0ga2V5cGF0aC5maXJzdEtleTtcblxuICBcdHJldHVybiAhKGtleSBpbiB2aWV3bW9kZWwuZGF0YSkgJiYgIShrZXkgaW4gdmlld21vZGVsLmNvbXB1dGF0aW9ucykgJiYgIShrZXkgaW4gdmlld21vZGVsLm1hcHBpbmdzKTtcbiAgfVxuXG4gIHZhciBDb21wdXRhdGlvbl9Db21wdXRhdGlvbiA9IENvbXB1dGF0aW9uO1xuXG4gIHZhciBjb21wdXRlID0gVmlld21vZGVsJGNvbXB1dGU7XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRjb21wdXRlKGtleSwgc2lnbmF0dXJlKSB7XG4gIFx0dmFyIGNvbXB1dGF0aW9uID0gbmV3IENvbXB1dGF0aW9uX0NvbXB1dGF0aW9uKGtleSwgc2lnbmF0dXJlKTtcblxuICBcdGlmICh0aGlzLnJlYWR5KSB7XG4gIFx0XHRjb21wdXRhdGlvbi5pbml0KHRoaXMpO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLmNvbXB1dGF0aW9uc1trZXkuc3RyXSA9IGNvbXB1dGF0aW9uO1xuICB9XG5cbiAgdmFyIEZBSUxFRF9MT09LVVAgPSB7IEZBSUxFRF9MT09LVVA6IHRydWUgfTtcblxuICB2YXIgdmlld21vZGVsX3Byb3RvdHlwZV9nZXQgPSBWaWV3bW9kZWwkZ2V0O1xuXG4gIHZhciB2aWV3bW9kZWxfcHJvdG90eXBlX2dldF9fZW1wdHkgPSB7fTtcbiAgZnVuY3Rpb24gVmlld21vZGVsJGdldChrZXlwYXRoLCBvcHRpb25zKSB7XG4gIFx0dmFyIGNhY2hlID0gdGhpcy5jYWNoZSxcbiAgXHQgICAgdmFsdWUsXG4gIFx0ICAgIGNvbXB1dGF0aW9uLFxuICBcdCAgICB3cmFwcGVkLFxuICBcdCAgICBjYXB0dXJlR3JvdXAsXG4gIFx0ICAgIGtleXBhdGhTdHIgPSBrZXlwYXRoLnN0cixcbiAgXHQgICAga2V5O1xuXG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwgdmlld21vZGVsX3Byb3RvdHlwZV9nZXRfX2VtcHR5O1xuXG4gIFx0Ly8gY2FwdHVyZSB0aGUga2V5cGF0aCwgaWYgd2UncmUgaW5zaWRlIGEgY29tcHV0YXRpb25cbiAgXHRpZiAob3B0aW9ucy5jYXB0dXJlICYmIChjYXB0dXJlR3JvdXAgPSBsYXN0SXRlbSh0aGlzLmNhcHR1cmVHcm91cHMpKSkge1xuICBcdFx0aWYgKCEgfmNhcHR1cmVHcm91cC5pbmRleE9mKGtleXBhdGgpKSB7XG4gIFx0XHRcdGNhcHR1cmVHcm91cC5wdXNoKGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChoYXNPd24uY2FsbCh0aGlzLm1hcHBpbmdzLCBrZXlwYXRoLmZpcnN0S2V5KSkge1xuICBcdFx0cmV0dXJuIHRoaXMubWFwcGluZ3Nba2V5cGF0aC5maXJzdEtleV0uZ2V0KGtleXBhdGgsIG9wdGlvbnMpO1xuICBcdH1cblxuICBcdGlmIChrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0cmV0dXJuIGtleXBhdGgudmFsdWU7XG4gIFx0fVxuXG4gIFx0aWYgKGNhY2hlW2tleXBhdGhTdHJdID09PSB1bmRlZmluZWQpIHtcblxuICBcdFx0Ly8gSXMgdGhpcyBhIGNvbXB1dGVkIHByb3BlcnR5P1xuICBcdFx0aWYgKChjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zW2tleXBhdGhTdHJdKSAmJiAhY29tcHV0YXRpb24uYnlwYXNzKSB7XG4gIFx0XHRcdHZhbHVlID0gY29tcHV0YXRpb24uZ2V0KCk7XG4gIFx0XHRcdHRoaXMuYWRhcHQoa2V5cGF0aFN0ciwgdmFsdWUpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBJcyB0aGlzIGEgd3JhcHBlZCBwcm9wZXJ0eT9cbiAgXHRcdGVsc2UgaWYgKHdyYXBwZWQgPSB0aGlzLndyYXBwZWRba2V5cGF0aFN0cl0pIHtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVkLnZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBJcyBpdCB0aGUgcm9vdD9cbiAgXHRcdGVsc2UgaWYgKGtleXBhdGguaXNSb290KSB7XG4gIFx0XHRcdHRoaXMuYWRhcHQoXCJcIiwgdGhpcy5kYXRhKTtcbiAgXHRcdFx0dmFsdWUgPSB0aGlzLmRhdGE7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIE5vPyBUaGVuIHdlIG5lZWQgdG8gcmV0cmlldmUgdGhlIHZhbHVlIG9uZSBrZXkgYXQgYSB0aW1lXG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0dmFsdWUgPSByZXRyaWV2ZSh0aGlzLCBrZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0Y2FjaGVba2V5cGF0aFN0cl0gPSB2YWx1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dmFsdWUgPSBjYWNoZVtrZXlwYXRoU3RyXTtcbiAgXHR9XG5cbiAgXHRpZiAoIW9wdGlvbnMubm9VbndyYXAgJiYgKHdyYXBwZWQgPSB0aGlzLndyYXBwZWRba2V5cGF0aFN0cl0pKSB7XG4gIFx0XHR2YWx1ZSA9IHdyYXBwZWQuZ2V0KCk7XG4gIFx0fVxuXG4gIFx0aWYgKGtleXBhdGguaXNSb290ICYmIG9wdGlvbnMuZnVsbFJvb3RHZXQpIHtcbiAgXHRcdGZvciAoa2V5IGluIHRoaXMubWFwcGluZ3MpIHtcbiAgXHRcdFx0dmFsdWVba2V5XSA9IHRoaXMubWFwcGluZ3Nba2V5XS5nZXRWYWx1ZSgpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB2YWx1ZSA9PT0gRkFJTEVEX0xPT0tVUCA/IHZvaWQgMCA6IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0cmlldmUodmlld21vZGVsLCBrZXlwYXRoKSB7XG5cbiAgXHR2YXIgcGFyZW50VmFsdWUsIGNhY2hlTWFwLCB2YWx1ZSwgd3JhcHBlZDtcblxuICBcdHBhcmVudFZhbHVlID0gdmlld21vZGVsLmdldChrZXlwYXRoLnBhcmVudCk7XG5cbiAgXHRpZiAod3JhcHBlZCA9IHZpZXdtb2RlbC53cmFwcGVkW2tleXBhdGgucGFyZW50LnN0cl0pIHtcbiAgXHRcdHBhcmVudFZhbHVlID0gd3JhcHBlZC5nZXQoKTtcbiAgXHR9XG5cbiAgXHRpZiAocGFyZW50VmFsdWUgPT09IG51bGwgfHwgcGFyZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIHVwZGF0ZSBjYWNoZSBtYXBcbiAgXHRpZiAoIShjYWNoZU1hcCA9IHZpZXdtb2RlbC5jYWNoZU1hcFtrZXlwYXRoLnBhcmVudC5zdHJdKSkge1xuICBcdFx0dmlld21vZGVsLmNhY2hlTWFwW2tleXBhdGgucGFyZW50LnN0cl0gPSBba2V5cGF0aC5zdHJdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRpZiAoY2FjaGVNYXAuaW5kZXhPZihrZXlwYXRoLnN0cikgPT09IC0xKSB7XG4gIFx0XHRcdGNhY2hlTWFwLnB1c2goa2V5cGF0aC5zdHIpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIElmIHRoaXMgcHJvcGVydHkgZG9lc24ndCBleGlzdCwgd2UgcmV0dXJuIGEgc2VudGluZWwgdmFsdWVcbiAgXHQvLyBzbyB0aGF0IHdlIGtub3cgdG8gcXVlcnkgcGFyZW50IHNjb3BlIChpZiBzdWNoIHRoZXJlIGJlKVxuICBcdGlmICh0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIShrZXlwYXRoLmxhc3RLZXkgaW4gcGFyZW50VmFsdWUpKSB7XG4gIFx0XHRyZXR1cm4gdmlld21vZGVsLmNhY2hlW2tleXBhdGguc3RyXSA9IEZBSUxFRF9MT09LVVA7XG4gIFx0fVxuXG4gIFx0dmFsdWUgPSBwYXJlbnRWYWx1ZVtrZXlwYXRoLmxhc3RLZXldO1xuXG4gIFx0Ly8gRG8gd2UgaGF2ZSBhbiBhZGFwdG9yIGZvciB0aGlzIHZhbHVlP1xuICBcdHZpZXdtb2RlbC5hZGFwdChrZXlwYXRoLnN0ciwgdmFsdWUsIGZhbHNlKTtcblxuICBcdC8vIFVwZGF0ZSBjYWNoZVxuICBcdHZpZXdtb2RlbC5jYWNoZVtrZXlwYXRoLnN0cl0gPSB2YWx1ZTtcbiAgXHRyZXR1cm4gdmFsdWU7XG4gIH1cblxuICB2YXIgdmlld21vZGVsX3Byb3RvdHlwZV9pbml0ID0gVmlld21vZGVsJGluaXQ7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJGluaXQoKSB7XG4gIFx0dmFyIGtleTtcblxuICBcdGZvciAoa2V5IGluIHRoaXMuY29tcHV0YXRpb25zKSB7XG4gIFx0XHR0aGlzLmNvbXB1dGF0aW9uc1trZXldLmluaXQodGhpcyk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9tYXAgPSBWaWV3bW9kZWwkbWFwO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRtYXAoa2V5LCBvcHRpb25zKSB7XG4gIFx0dmFyIG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleS5zdHJdID0gbmV3IE1hcHBpbmcoa2V5LCBvcHRpb25zKTtcbiAgXHRtYXBwaW5nLmluaXRWaWV3bW9kZWwodGhpcyk7XG4gIFx0cmV0dXJuIG1hcHBpbmc7XG4gIH1cblxuICB2YXIgTWFwcGluZyA9IGZ1bmN0aW9uIChsb2NhbEtleSwgb3B0aW9ucykge1xuICBcdHRoaXMubG9jYWxLZXkgPSBsb2NhbEtleTtcbiAgXHR0aGlzLmtleXBhdGggPSBvcHRpb25zLmtleXBhdGg7XG4gIFx0dGhpcy5vcmlnaW4gPSBvcHRpb25zLm9yaWdpbjtcblxuICBcdHRoaXMuZGVwcyA9IFtdO1xuICBcdHRoaXMudW5yZXNvbHZlZCA9IFtdO1xuXG4gIFx0dGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuICB9O1xuXG4gIE1hcHBpbmcucHJvdG90eXBlID0ge1xuICBcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gVE9ETyB3YXJuLCBhcyBwZXIgIzE2OTI/XG4gIFx0XHR0aGlzLmtleXBhdGggPSB0aGlzLmxvY2FsS2V5O1xuICBcdFx0dGhpcy5zZXR1cCgpO1xuICBcdH0sXG5cbiAgXHRnZXQ6IGZ1bmN0aW9uIChrZXlwYXRoLCBvcHRpb25zKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzLm9yaWdpbi5nZXQodGhpcy5tYXAoa2V5cGF0aCksIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLmtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzLm9yaWdpbi5nZXQodGhpcy5rZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0aW5pdFZpZXdtb2RlbDogZnVuY3Rpb24gKHZpZXdtb2RlbCkge1xuICBcdFx0dGhpcy5sb2NhbCA9IHZpZXdtb2RlbDtcbiAgXHRcdHRoaXMuc2V0dXAoKTtcbiAgXHR9LFxuXG4gIFx0bWFwOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aWYgKHR5cGVvZiB0aGlzLmtleXBhdGggPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5sb2NhbEtleTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBrZXlwYXRoLnJlcGxhY2UodGhpcy5sb2NhbEtleSwgdGhpcy5rZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0cmVnaXN0ZXI6IGZ1bmN0aW9uIChrZXlwYXRoLCBkZXBlbmRhbnQsIGdyb3VwKSB7XG4gIFx0XHR0aGlzLmRlcHMucHVzaCh7IGtleXBhdGg6IGtleXBhdGgsIGRlcDogZGVwZW5kYW50LCBncm91cDogZ3JvdXAgfSk7XG5cbiAgXHRcdGlmICh0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHRoaXMub3JpZ2luLnJlZ2lzdGVyKHRoaXMubWFwKGtleXBhdGgpLCBkZXBlbmRhbnQsIGdyb3VwKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzLmtleXBhdGggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLnVuYmluZCh0cnVlKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMuc2V0dXAoKTtcbiAgXHR9LFxuXG4gIFx0c2V0OiBmdW5jdGlvbiAoa2V5cGF0aCwgdmFsdWUpIHtcbiAgXHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHR0aGlzLmZvcmNlUmVzb2x1dGlvbigpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm9yaWdpbi5zZXQodGhpcy5tYXAoa2V5cGF0aCksIHZhbHVlKTtcbiAgXHR9LFxuXG4gIFx0c2V0dXA6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGlmICh0aGlzLmtleXBhdGggPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucmVzb2x2ZWQgPSB0cnVlO1xuXG4gIFx0XHQvLyBhY2N1bXVsYXRlZCBkZXBlbmRhbnRzIGNhbiBub3cgYmUgcmVnaXN0ZXJlZFxuICBcdFx0aWYgKHRoaXMuZGVwcy5sZW5ndGgpIHtcbiAgXHRcdFx0dGhpcy5kZXBzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0XHR2YXIga2V5cGF0aCA9IF90aGlzLm1hcChkLmtleXBhdGgpO1xuICBcdFx0XHRcdF90aGlzLm9yaWdpbi5yZWdpc3RlcihrZXlwYXRoLCBkLmRlcCwgZC5ncm91cCk7XG5cbiAgXHRcdFx0XHQvLyBUT0RPIHRoaXMgaXMgYSBiaXQgb2YgYSByZWQgZmxhZy4uLiBhbGwgZGVwcyBzaG91bGQgYmUgdGhlIHNhbWU/XG4gIFx0XHRcdFx0aWYgKGQuZGVwLnNldFZhbHVlKSB7XG4gIFx0XHRcdFx0XHRkLmRlcC5zZXRWYWx1ZShfdGhpcy5vcmlnaW4uZ2V0KGtleXBhdGgpKTtcbiAgXHRcdFx0XHR9IGVsc2UgaWYgKGQuZGVwLmludmFsaWRhdGUpIHtcbiAgXHRcdFx0XHRcdGQuZGVwLmludmFsaWRhdGUoKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZC4gUGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MhXCIpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0dGhpcy5vcmlnaW4ubWFyayh0aGlzLmtleXBhdGgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRpZiAoIXRoaXMua2V5cGF0aCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNYXBwaW5nIGRvZXMgbm90IGhhdmUga2V5cGF0aCwgY2Fubm90IHNldCB2YWx1ZS4gUGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MhXCIpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm9yaWdpbi5zZXQodGhpcy5rZXlwYXRoLCB2YWx1ZSk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKGtlZXBMb2NhbCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0aWYgKCFrZWVwTG9jYWwpIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMubG9jYWwubWFwcGluZ3NbdGhpcy5sb2NhbEtleV07XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdF90aGlzLm9yaWdpbi51bnJlZ2lzdGVyKF90aGlzLm1hcChkLmtleXBhdGgpLCBkLmRlcCwgZC5ncm91cCk7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKHRoaXMudHJhY2tlcikge1xuICBcdFx0XHR0aGlzLm9yaWdpbi51bnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcy50cmFja2VyKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZWdpc3RlcjogZnVuY3Rpb24gKGtleXBhdGgsIGRlcGVuZGFudCwgZ3JvdXApIHtcbiAgXHRcdHZhciBkZXBzLCBpO1xuXG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRkZXBzID0gdGhpcy5kZXBzO1xuICBcdFx0aSA9IGRlcHMubGVuZ3RoO1xuXG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmIChkZXBzW2ldLmRlcCA9PT0gZGVwZW5kYW50KSB7XG4gIFx0XHRcdFx0ZGVwcy5zcGxpY2UoaSwgMSk7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHRoaXMub3JpZ2luLnVucmVnaXN0ZXIodGhpcy5tYXAoa2V5cGF0aCksIGRlcGVuZGFudCwgZ3JvdXApO1xuICBcdH1cbiAgfTtcblxuICB2YXIgbWFyayA9IFZpZXdtb2RlbCRtYXJrO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRtYXJrKGtleXBhdGgsIG9wdGlvbnMpIHtcbiAgXHR2YXIgY29tcHV0YXRpb24sXG4gIFx0ICAgIGtleXBhdGhTdHIgPSBrZXlwYXRoLnN0cjtcblxuICBcdC8vIGltcGxpY2l0IGNoYW5nZXMgKGkuZS4gYGZvby5sZW5ndGhgIG9uIGByYWN0aXZlLnB1c2goJ2ZvbycsNDIpYClcbiAgXHQvLyBzaG91bGQgbm90IGJlIHBpY2tlZCB1cCBieSBwYXR0ZXJuIG9ic2VydmVyc1xuICBcdGlmIChvcHRpb25zKSB7XG4gIFx0XHRpZiAob3B0aW9ucy5pbXBsaWNpdCkge1xuICBcdFx0XHR0aGlzLmltcGxpY2l0Q2hhbmdlc1trZXlwYXRoU3RyXSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0XHRpZiAob3B0aW9ucy5ub0Nhc2NhZGUpIHtcbiAgXHRcdFx0dGhpcy5ub0Nhc2NhZGVba2V5cGF0aFN0cl0gPSB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zW2tleXBhdGhTdHJdKSB7XG4gIFx0XHRjb21wdXRhdGlvbi5pbnZhbGlkYXRlKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuY2hhbmdlcy5pbmRleE9mKGtleXBhdGgpID09PSAtMSkge1xuICBcdFx0dGhpcy5jaGFuZ2VzLnB1c2goa2V5cGF0aCk7XG4gIFx0fVxuXG4gIFx0Ly8gcGFzcyBvbiBrZWVwRXhpc3RpbmdXcmFwcGVyLCBpZiB3ZSBjYW5cbiAgXHR2YXIga2VlcEV4aXN0aW5nV3JhcHBlciA9IG9wdGlvbnMgPyBvcHRpb25zLmtlZXBFeGlzdGluZ1dyYXBwZXIgOiBmYWxzZTtcblxuICBcdHRoaXMuY2xlYXJDYWNoZShrZXlwYXRoU3RyLCBrZWVwRXhpc3RpbmdXcmFwcGVyKTtcblxuICBcdGlmICh0aGlzLnJlYWR5KSB7XG4gIFx0XHR0aGlzLm9uY2hhbmdlKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIG1hcE9sZFRvTmV3SW5kZXggPSBmdW5jdGlvbiAob2xkQXJyYXksIG5ld0FycmF5KSB7XG4gIFx0dmFyIHVzZWRJbmRpY2VzLCBmaXJzdFVudXNlZEluZGV4LCBuZXdJbmRpY2VzLCBjaGFuZ2VkO1xuXG4gIFx0dXNlZEluZGljZXMgPSB7fTtcbiAgXHRmaXJzdFVudXNlZEluZGV4ID0gMDtcblxuICBcdG5ld0luZGljZXMgPSBvbGRBcnJheS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgXHRcdHZhciBpbmRleCwgc3RhcnQsIGxlbjtcblxuICBcdFx0c3RhcnQgPSBmaXJzdFVudXNlZEluZGV4O1xuICBcdFx0bGVuID0gbmV3QXJyYXkubGVuZ3RoO1xuXG4gIFx0XHRkbyB7XG4gIFx0XHRcdGluZGV4ID0gbmV3QXJyYXkuaW5kZXhPZihpdGVtLCBzdGFydCk7XG5cbiAgXHRcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHRcdHJldHVybiAtMTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHN0YXJ0ID0gaW5kZXggKyAxO1xuICBcdFx0fSB3aGlsZSAodXNlZEluZGljZXNbaW5kZXhdICYmIHN0YXJ0IDwgbGVuKTtcblxuICBcdFx0Ly8ga2VlcCB0cmFjayBvZiB0aGUgZmlyc3QgdW51c2VkIGluZGV4LCBzbyB3ZSBkb24ndCBzZWFyY2hcbiAgXHRcdC8vIHRoZSB3aG9sZSBvZiBuZXdBcnJheSBmb3IgZWFjaCBpdGVtIGluIG9sZEFycmF5IHVubmVjZXNzYXJpbHlcbiAgXHRcdGlmIChpbmRleCA9PT0gZmlyc3RVbnVzZWRJbmRleCkge1xuICBcdFx0XHRmaXJzdFVudXNlZEluZGV4ICs9IDE7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpbmRleCAhPT0gaSkge1xuICBcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0dXNlZEluZGljZXNbaW5kZXhdID0gdHJ1ZTtcbiAgXHRcdHJldHVybiBpbmRleDtcbiAgXHR9KTtcblxuICBcdHJldHVybiBuZXdJbmRpY2VzO1xuICB9O1xuXG4gIHZhciBtZXJnZSA9IFZpZXdtb2RlbCRtZXJnZTtcblxuICB2YXIgY29tcGFyYXRvcnMgPSB7fTtcbiAgZnVuY3Rpb24gVmlld21vZGVsJG1lcmdlKGtleXBhdGgsIGN1cnJlbnRBcnJheSwgYXJyYXksIG9wdGlvbnMpIHtcbiAgXHR2YXIgb2xkQXJyYXksIG5ld0FycmF5LCBjb21wYXJhdG9yLCBuZXdJbmRpY2VzO1xuXG4gIFx0dGhpcy5tYXJrKGtleXBhdGgpO1xuXG4gIFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYXJlKSB7XG5cbiAgXHRcdGNvbXBhcmF0b3IgPSBnZXRDb21wYXJhdG9yRnVuY3Rpb24ob3B0aW9ucy5jb21wYXJlKTtcblxuICBcdFx0dHJ5IHtcbiAgXHRcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXkubWFwKGNvbXBhcmF0b3IpO1xuICBcdFx0XHRuZXdBcnJheSA9IGFycmF5Lm1hcChjb21wYXJhdG9yKTtcbiAgXHRcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0XHQvLyBmYWxsYmFjayB0byBhbiBpZGVudGl0eSBjaGVjayAtIHdvcnN0IGNhc2Ugc2NlbmFyaW8gd2UgaGF2ZVxuICBcdFx0XHQvLyB0byBkbyBtb3JlIERPTSBtYW5pcHVsYXRpb24gdGhhbiB3ZSB0aG91Z2h0Li4uXG4gIFx0XHRcdHdhcm5JZkRlYnVnKFwibWVyZ2UoKTogXFxcIiVzXFxcIiBjb21wYXJpc29uIGZhaWxlZC4gRmFsbGluZyBiYWNrIHRvIGlkZW50aXR5IGNoZWNraW5nXCIsIGtleXBhdGgpO1xuXG4gIFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5O1xuICBcdFx0XHRuZXdBcnJheSA9IGFycmF5O1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheTtcbiAgXHRcdG5ld0FycmF5ID0gYXJyYXk7XG4gIFx0fVxuXG4gIFx0Ly8gZmluZCBuZXcgaW5kaWNlcyBmb3IgbWVtYmVycyBvZiBvbGRBcnJheVxuICBcdG5ld0luZGljZXMgPSBtYXBPbGRUb05ld0luZGV4KG9sZEFycmF5LCBuZXdBcnJheSk7XG5cbiAgXHR0aGlzLnNtYXJ0VXBkYXRlKGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzLCBjdXJyZW50QXJyYXkubGVuZ3RoICE9PSBhcnJheS5sZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5KGl0ZW0pIHtcbiAgXHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb21wYXJhdG9yRnVuY3Rpb24oY29tcGFyYXRvcikge1xuICBcdC8vIElmIGBjb21wYXJlYCBpcyBgdHJ1ZWAsIHdlIHVzZSBKU09OLnN0cmluZ2lmeSB0byBjb21wYXJlXG4gIFx0Ly8gb2JqZWN0cyB0aGF0IGFyZSB0aGUgc2FtZSBzaGFwZSwgYnV0IG5vbi1pZGVudGljYWwgLSBpLmUuXG4gIFx0Ly8geyBmb286ICdiYXInIH0gIT09IHsgZm9vOiAnYmFyJyB9XG4gIFx0aWYgKGNvbXBhcmF0b3IgPT09IHRydWUpIHtcbiAgXHRcdHJldHVybiBzdHJpbmdpZnk7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRpZiAoIWNvbXBhcmF0b3JzW2NvbXBhcmF0b3JdKSB7XG4gIFx0XHRcdGNvbXBhcmF0b3JzW2NvbXBhcmF0b3JdID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdFx0XHRyZXR1cm4gaXRlbVtjb21wYXJhdG9yXTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGNvbXBhcmF0b3JzW2NvbXBhcmF0b3JdO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRyZXR1cm4gY29tcGFyYXRvcjtcbiAgXHR9XG5cbiAgXHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYGNvbXBhcmVgIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24sIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBpZGVudGlmeWluZyBmaWVsZCAob3IgYHRydWVgIHRvIHVzZSBKU09OLnN0cmluZ2lmeSlcIik7XG4gIH1cblxuICB2YXIgcmVnaXN0ZXIgPSBWaWV3bW9kZWwkcmVnaXN0ZXI7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHJlZ2lzdGVyKGtleXBhdGgsIGRlcGVuZGFudCkge1xuICBcdHZhciBncm91cCA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gXCJkZWZhdWx0XCIgOiBhcmd1bWVudHNbMl07XG5cbiAgXHR2YXIgbWFwcGluZywgZGVwc0J5S2V5cGF0aCwgZGVwcztcblxuICBcdGlmIChkZXBlbmRhbnQuaXNTdGF0aWMpIHtcbiAgXHRcdHJldHVybjsgLy8gVE9ETyB3ZSBzaG91bGQgbmV2ZXIgZ2V0IGhlcmUgaWYgYSBkZXBlbmRhbnQgaXMgc3RhdGljLi4uXG4gIFx0fVxuXG4gIFx0aWYgKG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleXBhdGguZmlyc3RLZXldKSB7XG4gIFx0XHRtYXBwaW5nLnJlZ2lzdGVyKGtleXBhdGgsIGRlcGVuZGFudCwgZ3JvdXApO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRkZXBzQnlLZXlwYXRoID0gdGhpcy5kZXBzW2dyb3VwXSB8fCAodGhpcy5kZXBzW2dyb3VwXSA9IHt9KTtcbiAgXHRcdGRlcHMgPSBkZXBzQnlLZXlwYXRoW2tleXBhdGguc3RyXSB8fCAoZGVwc0J5S2V5cGF0aFtrZXlwYXRoLnN0cl0gPSBbXSk7XG5cbiAgXHRcdGRlcHMucHVzaChkZXBlbmRhbnQpO1xuXG4gIFx0XHRpZiAoIXRoaXMuZGVwc01hcFtncm91cF0pIHtcbiAgXHRcdFx0dGhpcy5kZXBzTWFwW2dyb3VwXSA9IHt9O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWtleXBhdGguaXNSb290KSB7XG4gIFx0XHRcdHJlZ2lzdGVyX191cGRhdGVEZXBlbmRhbnRzTWFwKHRoaXMsIGtleXBhdGgsIGdyb3VwKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3Rlcl9fdXBkYXRlRGVwZW5kYW50c01hcCh2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwKSB7XG4gIFx0dmFyIG1hcCwgcGFyZW50LCBrZXlwYXRoU3RyO1xuXG4gIFx0Ly8gdXBkYXRlIGRlcGVuZGFudHMgbWFwXG4gIFx0d2hpbGUgKCFrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0bWFwID0gdmlld21vZGVsLmRlcHNNYXBbZ3JvdXBdO1xuICBcdFx0cGFyZW50ID0gbWFwW2tleXBhdGgucGFyZW50LnN0cl0gfHwgKG1hcFtrZXlwYXRoLnBhcmVudC5zdHJdID0gW10pO1xuXG4gIFx0XHRrZXlwYXRoU3RyID0ga2V5cGF0aC5zdHI7XG5cbiAgXHRcdC8vIFRPRE8gZmluZCBhbiBhbHRlcm5hdGl2ZSB0byB0aGlzIG5hc3R5IGFwcHJvYWNoXG4gIFx0XHRpZiAocGFyZW50W1wiX1wiICsga2V5cGF0aFN0cl0gPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRwYXJlbnRbXCJfXCIgKyBrZXlwYXRoU3RyXSA9IDA7XG4gIFx0XHRcdHBhcmVudC5wdXNoKGtleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJlbnRbXCJfXCIgKyBrZXlwYXRoU3RyXSArPSAxO1xuICBcdFx0a2V5cGF0aCA9IGtleXBhdGgucGFyZW50O1xuICBcdH1cbiAgfVxuXG4gIHZhciByZWxlYXNlID0gVmlld21vZGVsJHJlbGVhc2U7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHJlbGVhc2UoKSB7XG4gIFx0cmV0dXJuIHRoaXMuY2FwdHVyZUdyb3Vwcy5wb3AoKTtcbiAgfVxuXG4gIHZhciByZXNldCA9IFZpZXdtb2RlbCRyZXNldDtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkcmVzZXQoZGF0YSkge1xuICBcdHRoaXMuZGF0YSA9IGRhdGE7XG4gIFx0dGhpcy5jbGVhckNhY2hlKFwiXCIpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9zZXQgPSBWaWV3bW9kZWwkc2V0O1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRzZXQoa2V5cGF0aCwgdmFsdWUpIHtcbiAgXHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgXHR2YXIgbWFwcGluZywgY29tcHV0YXRpb24sIHdyYXBwZXIsIGtlZXBFeGlzdGluZ1dyYXBwZXI7XG5cbiAgXHQvLyB1bmxlc3MgZGF0YSBpcyBiZWluZyBzZXQgZm9yIGRhdGEgdHJhY2tpbmcgcHVycG9zZXNcbiAgXHRpZiAoIW9wdGlvbnMubm9NYXBwaW5nKSB7XG4gIFx0XHQvLyBJZiB0aGlzIGRhdGEgYmVsb25ncyB0byBhIGRpZmZlcmVudCB2aWV3bW9kZWwsXG4gIFx0XHQvLyBwYXNzIHRoZSBjaGFuZ2UgYWxvbmdcbiAgXHRcdGlmIChtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXlwYXRoLmZpcnN0S2V5XSkge1xuICBcdFx0XHRyZXR1cm4gbWFwcGluZy5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNba2V5cGF0aC5zdHJdO1xuICBcdGlmIChjb21wdXRhdGlvbikge1xuICBcdFx0aWYgKGNvbXB1dGF0aW9uLnNldHRpbmcpIHtcbiAgXHRcdFx0Ly8gbGV0IHRoZSBvdGhlciBjb21wdXRhdGlvbiBzZXQoKSBoYW5kbGUgdGhpbmdzLi4uXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdGNvbXB1dGF0aW9uLnNldCh2YWx1ZSk7XG4gIFx0XHR2YWx1ZSA9IGNvbXB1dGF0aW9uLmdldCgpO1xuICBcdH1cblxuICBcdGlmIChpc0VxdWFsKHRoaXMuY2FjaGVba2V5cGF0aC5zdHJdLCB2YWx1ZSkpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR3cmFwcGVyID0gdGhpcy53cmFwcGVkW2tleXBhdGguc3RyXTtcblxuICBcdC8vIElmIHdlIGhhdmUgYSB3cmFwcGVyIHdpdGggYSBgcmVzZXQoKWAgbWV0aG9kLCB3ZSB0cnkgYW5kIHVzZSBpdC4gSWYgdGhlXG4gIFx0Ly8gYHJlc2V0KClgIG1ldGhvZCByZXR1cm5zIGZhbHNlLCB0aGUgd3JhcHBlciBzaG91bGQgYmUgdG9ybiBkb3duLCBhbmRcbiAgXHQvLyAobW9zdCBsaWtlbHkpIGEgbmV3IG9uZSBzaG91bGQgYmUgY3JlYXRlZCBsYXRlclxuICBcdGlmICh3cmFwcGVyICYmIHdyYXBwZXIucmVzZXQpIHtcbiAgXHRcdGtlZXBFeGlzdGluZ1dyYXBwZXIgPSB3cmFwcGVyLnJlc2V0KHZhbHVlKSAhPT0gZmFsc2U7XG5cbiAgXHRcdGlmIChrZWVwRXhpc3RpbmdXcmFwcGVyKSB7XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoIWNvbXB1dGF0aW9uICYmICFrZWVwRXhpc3RpbmdXcmFwcGVyKSB7XG4gIFx0XHRyZXNvbHZlU2V0KHRoaXMsIGtleXBhdGgsIHZhbHVlKTtcbiAgXHR9XG5cbiAgXHRpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gIFx0XHR0aGlzLm1hcmsoa2V5cGF0aCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIFdlJ3JlIHNldHRpbmcgYSBwYXJlbnQgb2YgdGhlIG9yaWdpbmFsIHRhcmdldCBrZXlwYXRoIChpLmUuXG4gIFx0XHQvLyBjcmVhdGluZyBhIGZyZXNoIGJyYW5jaCkgLSB3ZSBuZWVkIHRvIGNsZWFyIHRoZSBjYWNoZSwgYnV0XG4gIFx0XHQvLyBub3QgbWFyayBpdCBhcyBhIGNoYW5nZVxuICBcdFx0dGhpcy5jbGVhckNhY2hlKGtleXBhdGguc3RyKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlU2V0KHZpZXdtb2RlbCwga2V5cGF0aCwgdmFsdWUpIHtcbiAgXHR2YXIgd3JhcHBlciwgcGFyZW50VmFsdWUsIHdyYXBwZXJTZXQsIHZhbHVlU2V0O1xuXG4gIFx0d3JhcHBlclNldCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh3cmFwcGVyLnNldCkge1xuICBcdFx0XHR3cmFwcGVyLnNldChrZXlwYXRoLmxhc3RLZXksIHZhbHVlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhcmVudFZhbHVlID0gd3JhcHBlci5nZXQoKTtcbiAgXHRcdFx0dmFsdWVTZXQoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0dmFsdWVTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXBhcmVudFZhbHVlKSB7XG4gIFx0XHRcdHBhcmVudFZhbHVlID0gY3JlYXRlQnJhbmNoKGtleXBhdGgubGFzdEtleSk7XG4gIFx0XHRcdHZpZXdtb2RlbC5zZXQoa2V5cGF0aC5wYXJlbnQsIHBhcmVudFZhbHVlLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgXHRcdH1cbiAgXHRcdHBhcmVudFZhbHVlW2tleXBhdGgubGFzdEtleV0gPSB2YWx1ZTtcbiAgXHR9O1xuXG4gIFx0d3JhcHBlciA9IHZpZXdtb2RlbC53cmFwcGVkW2tleXBhdGgucGFyZW50LnN0cl07XG5cbiAgXHRpZiAod3JhcHBlcikge1xuICBcdFx0d3JhcHBlclNldCgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRwYXJlbnRWYWx1ZSA9IHZpZXdtb2RlbC5nZXQoa2V5cGF0aC5wYXJlbnQpO1xuXG4gIFx0XHQvLyBtYXkgaGF2ZSBiZWVuIHdyYXBwZWQgdmlhIHRoZSBhYm92ZSAuZ2V0KClcbiAgXHRcdC8vIGNhbGwgb24gdmlld21vZGVsIGlmIHRoaXMgaXMgZmlyc3QgYWNjZXNzIHZpYSAuc2V0KCkhXG4gIFx0XHRpZiAod3JhcHBlciA9IHZpZXdtb2RlbC53cmFwcGVkW2tleXBhdGgucGFyZW50LnN0cl0pIHtcbiAgXHRcdFx0d3JhcHBlclNldCgpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dmFsdWVTZXQoKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgc21hcnRVcGRhdGUgPSBWaWV3bW9kZWwkc21hcnRVcGRhdGU7XG5cbiAgdmFyIGltcGxpY2l0T3B0aW9uID0geyBpbXBsaWNpdDogdHJ1ZSB9LFxuICAgICAgbm9DYXNjYWRlT3B0aW9uID0geyBub0Nhc2NhZGU6IHRydWUgfTtcbiAgZnVuY3Rpb24gVmlld21vZGVsJHNtYXJ0VXBkYXRlKGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBkZXBlbmRhbnRzLCBvbGRMZW5ndGgsIGk7XG5cbiAgXHRvbGRMZW5ndGggPSBuZXdJbmRpY2VzLmxlbmd0aDtcblxuICBcdC8vIEluZGljZXMgdGhhdCBhcmUgYmVpbmcgcmVtb3ZlZCBzaG91bGQgYmUgbWFya2VkIGFzIGRpcnR5XG4gIFx0bmV3SW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgXHRcdGlmIChuZXdJbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0X3RoaXMubWFyayhrZXlwYXRoLmpvaW4ob2xkSW5kZXgpLCBub0Nhc2NhZGVPcHRpb24pO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0Ly8gVXBkYXRlIHRoZSBtb2RlbFxuICBcdC8vIFRPRE8gYWxsb3cgZXhpc3RpbmcgYXJyYXkgdG8gYmUgdXBkYXRlZCBpbiBwbGFjZSwgcmF0aGVyIHRoYW4gcmVwbGFjZWQ/XG4gIFx0dGhpcy5zZXQoa2V5cGF0aCwgYXJyYXksIHsgc2lsZW50OiB0cnVlIH0pO1xuXG4gIFx0aWYgKGRlcGVuZGFudHMgPSB0aGlzLmRlcHNbXCJkZWZhdWx0XCJdW2tleXBhdGguc3RyXSkge1xuICBcdFx0ZGVwZW5kYW50cy5maWx0ZXIoY2FuU2h1ZmZsZSkuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRyZXR1cm4gZC5zaHVmZmxlKG5ld0luZGljZXMsIGFycmF5KTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGlmIChvbGRMZW5ndGggIT09IGFycmF5Lmxlbmd0aCkge1xuICBcdFx0dGhpcy5tYXJrKGtleXBhdGguam9pbihcImxlbmd0aFwiKSwgaW1wbGljaXRPcHRpb24pO1xuXG4gIFx0XHRmb3IgKGkgPSBuZXdJbmRpY2VzLnRvdWNoZWRGcm9tOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5tYXJrKGtleXBhdGguam9pbihpKSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGRvbid0IGFsbG93IHJlbW92ZWQgaW5kZXhlcyBiZXlvbmQgZW5kIG9mIG5ldyBhcnJheSB0byB0cmlnZ2VyIHJlY29tcHV0YXRpb25zXG4gIFx0XHQvLyBUT0RPIGlzIHRoaXMgc3RpbGwgbmVjZXNzYXJ5LCBub3cgdGhhdCBjb21wdXRhdGlvbnMgYXJlIGxhenk/XG4gIFx0XHRmb3IgKGkgPSBhcnJheS5sZW5ndGg7IGkgPCBvbGRMZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0XHR0aGlzLm1hcmsoa2V5cGF0aC5qb2luKGkpLCBub0Nhc2NhZGVPcHRpb24pO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhblNodWZmbGUoZGVwZW5kYW50KSB7XG4gIFx0cmV0dXJuIHR5cGVvZiBkZXBlbmRhbnQuc2h1ZmZsZSA9PT0gXCJmdW5jdGlvblwiO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV90ZWFyZG93biA9IFZpZXdtb2RlbCR0ZWFyZG93bjtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkdGVhcmRvd24oKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciB1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5O1xuXG4gIFx0Ly8gQ2xlYXIgZW50aXJlIGNhY2hlIC0gdGhpcyBoYXMgdGhlIGRlc2lyZWQgc2lkZS1lZmZlY3RcbiAgXHQvLyBvZiB1bndyYXBwaW5nIGFkYXB0ZWQgdmFsdWVzIChlLmcuIGFycmF5cylcbiAgXHRPYmplY3Qua2V5cyh0aGlzLmNhY2hlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRyZXR1cm4gX3RoaXMuY2xlYXJDYWNoZShrZXlwYXRoKTtcbiAgXHR9KTtcblxuICBcdC8vIFRlYXJkb3duIGFueSBmYWlsZWQgbG9va3VwcyAtIHdlIGRvbid0IG5lZWQgdGhlbSB0byByZXNvbHZlIGFueSBtb3JlXG4gIFx0d2hpbGUgKHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kgPSB0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcy5wb3AoKSkge1xuICBcdFx0dW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeS50ZWFyZG93bigpO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1bnJlZ2lzdGVyID0gVmlld21vZGVsJHVucmVnaXN0ZXI7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHVucmVnaXN0ZXIoa2V5cGF0aCwgZGVwZW5kYW50KSB7XG4gIFx0dmFyIGdyb3VwID0gYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBcImRlZmF1bHRcIiA6IGFyZ3VtZW50c1syXTtcblxuICBcdHZhciBtYXBwaW5nLCBkZXBzLCBpbmRleDtcblxuICBcdGlmIChkZXBlbmRhbnQuaXNTdGF0aWMpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAobWFwcGluZyA9IHRoaXMubWFwcGluZ3Nba2V5cGF0aC5maXJzdEtleV0pIHtcbiAgXHRcdHJldHVybiBtYXBwaW5nLnVucmVnaXN0ZXIoa2V5cGF0aCwgZGVwZW5kYW50LCBncm91cCk7XG4gIFx0fVxuXG4gIFx0ZGVwcyA9IHRoaXMuZGVwc1tncm91cF1ba2V5cGF0aC5zdHJdO1xuICBcdGluZGV4ID0gZGVwcy5pbmRleE9mKGRlcGVuZGFudCk7XG5cbiAgXHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVtb3ZlIGEgZGVwZW5kYW50IHRoYXQgd2FzIG5vIGxvbmdlciByZWdpc3RlcmVkISBUaGlzIHNob3VsZCBub3QgaGFwcGVuLiBJZiB5b3UgYXJlIHNlZWluZyB0aGlzIGJ1ZyBpbiBkZXZlbG9wbWVudCBwbGVhc2UgcmFpc2UgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3VlcyAtIHRoYW5rc1wiKTtcbiAgXHR9XG5cbiAgXHRkZXBzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgXHRpZiAoa2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR1bnJlZ2lzdGVyX191cGRhdGVEZXBlbmRhbnRzTWFwKHRoaXMsIGtleXBhdGgsIGdyb3VwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJfX3VwZGF0ZURlcGVuZGFudHNNYXAodmlld21vZGVsLCBrZXlwYXRoLCBncm91cCkge1xuICBcdHZhciBtYXAsIHBhcmVudDtcblxuICBcdC8vIHVwZGF0ZSBkZXBlbmRhbnRzIG1hcFxuICBcdHdoaWxlICgha2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdG1hcCA9IHZpZXdtb2RlbC5kZXBzTWFwW2dyb3VwXTtcbiAgXHRcdHBhcmVudCA9IG1hcFtrZXlwYXRoLnBhcmVudC5zdHJdO1xuXG4gIFx0XHRwYXJlbnRbXCJfXCIgKyBrZXlwYXRoLnN0cl0gLT0gMTtcblxuICBcdFx0aWYgKCFwYXJlbnRbXCJfXCIgKyBrZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0Ly8gcmVtb3ZlIGZyb20gcGFyZW50IGRlcHMgbWFwXG4gIFx0XHRcdHJlbW92ZUZyb21BcnJheShwYXJlbnQsIGtleXBhdGgpO1xuICBcdFx0XHRwYXJlbnRbXCJfXCIgKyBrZXlwYXRoLnN0cl0gPSB1bmRlZmluZWQ7XG4gIFx0XHR9XG5cbiAgXHRcdGtleXBhdGggPSBrZXlwYXRoLnBhcmVudDtcbiAgXHR9XG4gIH1cblxuICB2YXIgVmlld21vZGVsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIgYWRhcHQgPSBvcHRpb25zLmFkYXB0O1xuICBcdHZhciBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICBcdHZhciByYWN0aXZlID0gb3B0aW9ucy5yYWN0aXZlO1xuICBcdHZhciBjb21wdXRlZCA9IG9wdGlvbnMuY29tcHV0ZWQ7XG4gIFx0dmFyIG1hcHBpbmdzID0gb3B0aW9ucy5tYXBwaW5ncztcbiAgXHR2YXIga2V5O1xuICBcdHZhciBtYXBwaW5nO1xuXG4gIFx0Ly8gVE9ETyBpcyBpdCBwb3NzaWJsZSB0byByZW1vdmUgdGhpcyByZWZlcmVuY2U/XG4gIFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcblxuICBcdHRoaXMuYWRhcHRvcnMgPSBhZGFwdDtcbiAgXHR0aGlzLm9uY2hhbmdlID0gb3B0aW9ucy5vbmNoYW5nZTtcblxuICBcdHRoaXMuY2FjaGUgPSB7fTsgLy8gd2UgbmVlZCB0byBiZSBhYmxlIHRvIHVzZSBoYXNPd25Qcm9wZXJ0eSwgc28gY2FuJ3QgaW5oZXJpdCBmcm9tIG51bGxcbiAgXHR0aGlzLmNhY2hlTWFwID0gY3JlYXRlKG51bGwpO1xuXG4gIFx0dGhpcy5kZXBzID0ge1xuICBcdFx0Y29tcHV0ZWQ6IGNyZWF0ZShudWxsKSxcbiAgXHRcdFwiZGVmYXVsdFwiOiBjcmVhdGUobnVsbClcbiAgXHR9O1xuICBcdHRoaXMuZGVwc01hcCA9IHtcbiAgXHRcdGNvbXB1dGVkOiBjcmVhdGUobnVsbCksXG4gIFx0XHRcImRlZmF1bHRcIjogY3JlYXRlKG51bGwpXG4gIFx0fTtcblxuICBcdHRoaXMucGF0dGVybk9ic2VydmVycyA9IFtdO1xuXG4gIFx0dGhpcy5zcGVjaWFscyA9IGNyZWF0ZShudWxsKTtcblxuICBcdHRoaXMud3JhcHBlZCA9IGNyZWF0ZShudWxsKTtcbiAgXHR0aGlzLmNvbXB1dGF0aW9ucyA9IGNyZWF0ZShudWxsKTtcblxuICBcdHRoaXMuY2FwdHVyZUdyb3VwcyA9IFtdO1xuICBcdHRoaXMudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzID0gW107XG5cbiAgXHR0aGlzLmNoYW5nZXMgPSBbXTtcbiAgXHR0aGlzLmltcGxpY2l0Q2hhbmdlcyA9IHt9O1xuICBcdHRoaXMubm9DYXNjYWRlID0ge307XG5cbiAgXHR0aGlzLmRhdGEgPSBkYXRhO1xuXG4gIFx0Ly8gc2V0IHVwIGV4cGxpY2l0IG1hcHBpbmdzXG4gIFx0dGhpcy5tYXBwaW5ncyA9IGNyZWF0ZShudWxsKTtcbiAgXHRmb3IgKGtleSBpbiBtYXBwaW5ncykge1xuICBcdFx0dGhpcy5tYXAoZ2V0S2V5cGF0aChrZXkpLCBtYXBwaW5nc1trZXldKTtcbiAgXHR9XG5cbiAgXHRpZiAoZGF0YSkge1xuICBcdFx0Ly8gaWYgZGF0YSBleGlzdHMgbG9jYWxseSwgYnV0IGlzIG1pc3Npbmcgb24gdGhlIHBhcmVudCxcbiAgXHRcdC8vIHdlIHRyYW5zZmVyIG93bmVyc2hpcCB0byB0aGUgcGFyZW50XG4gIFx0XHRmb3IgKGtleSBpbiBkYXRhKSB7XG4gIFx0XHRcdGlmICgobWFwcGluZyA9IHRoaXMubWFwcGluZ3Nba2V5XSkgJiYgbWFwcGluZy5nZXRWYWx1ZSgpID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRtYXBwaW5nLnNldFZhbHVlKGRhdGFba2V5XSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmb3IgKGtleSBpbiBjb21wdXRlZCkge1xuICBcdFx0aWYgKG1hcHBpbmdzICYmIGtleSBpbiBtYXBwaW5ncykge1xuICBcdFx0XHRmYXRhbChcIkNhbm5vdCBtYXAgdG8gYSBjb21wdXRlZCBwcm9wZXJ0eSAoJyVzJylcIiwga2V5KTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5jb21wdXRlKGdldEtleXBhdGgoa2V5KSwgY29tcHV0ZWRba2V5XSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIH07XG5cbiAgVmlld21vZGVsLnByb3RvdHlwZSA9IHtcbiAgXHRhZGFwdDogcHJvdG90eXBlX2FkYXB0LFxuICBcdGFwcGx5Q2hhbmdlczogYXBwbHlDaGFuZ2VzLFxuICBcdGNhcHR1cmU6IGNhcHR1cmUsXG4gIFx0Y2xlYXJDYWNoZTogY2xlYXJDYWNoZSxcbiAgXHRjb21wdXRlOiBjb21wdXRlLFxuICBcdGdldDogdmlld21vZGVsX3Byb3RvdHlwZV9nZXQsXG4gIFx0aW5pdDogdmlld21vZGVsX3Byb3RvdHlwZV9pbml0LFxuICBcdG1hcDogcHJvdG90eXBlX21hcCxcbiAgXHRtYXJrOiBtYXJrLFxuICBcdG1lcmdlOiBtZXJnZSxcbiAgXHRyZWdpc3RlcjogcmVnaXN0ZXIsXG4gIFx0cmVsZWFzZTogcmVsZWFzZSxcbiAgXHRyZXNldDogcmVzZXQsXG4gIFx0c2V0OiBwcm90b3R5cGVfc2V0LFxuICBcdHNtYXJ0VXBkYXRlOiBzbWFydFVwZGF0ZSxcbiAgXHR0ZWFyZG93bjogcHJvdG90eXBlX3RlYXJkb3duLFxuICBcdHVucmVnaXN0ZXI6IHVucmVnaXN0ZXJcbiAgfTtcblxuICB2YXIgdmlld21vZGVsX1ZpZXdtb2RlbCA9IFZpZXdtb2RlbDtcblxuICBmdW5jdGlvbiBIb29rUXVldWUoZXZlbnQpIHtcbiAgXHR0aGlzLmhvb2sgPSBuZXcgaG9va3NfSG9vayhldmVudCk7XG4gIFx0dGhpcy5pblByb2Nlc3MgPSB7fTtcbiAgXHR0aGlzLnF1ZXVlID0ge307XG4gIH1cblxuICBIb29rUXVldWUucHJvdG90eXBlID0ge1xuXG4gIFx0Y29uc3RydWN0b3I6IEhvb2tRdWV1ZSxcblxuICBcdGJlZ2luOiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0dGhpcy5pblByb2Nlc3NbcmFjdGl2ZS5fZ3VpZF0gPSB0cnVlO1xuICBcdH0sXG5cbiAgXHRlbmQ6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG5cbiAgXHRcdHZhciBwYXJlbnQgPSByYWN0aXZlLnBhcmVudDtcblxuICBcdFx0Ly8gSWYgdGhpcyBpcyAqaXNuJ3QqIGEgY2hpbGQgb2YgYSBjb21wb25lbnQgdGhhdCdzIGluIHByb2Nlc3MsXG4gIFx0XHQvLyBpdCBzaG91bGQgY2FsbCBtZXRob2RzIG9yIGZpcmUgYXQgdGhpcyBwb2ludFxuICBcdFx0aWYgKCFwYXJlbnQgfHwgIXRoaXMuaW5Qcm9jZXNzW3BhcmVudC5fZ3VpZF0pIHtcbiAgXHRcdFx0ZmlyZSh0aGlzLCByYWN0aXZlKTtcbiAgXHRcdH1cbiAgXHRcdC8vIGVsc2V3aXNlLCBoYW5kb2ZmIHRvIHBhcmVudCB0byBmaXJlIHdoZW4gcmVhZHlcbiAgXHRcdGVsc2Uge1xuICBcdFx0XHRnZXRDaGlsZFF1ZXVlKHRoaXMucXVldWUsIHBhcmVudCkucHVzaChyYWN0aXZlKTtcbiAgXHRcdH1cblxuICBcdFx0ZGVsZXRlIHRoaXMuaW5Qcm9jZXNzW3JhY3RpdmUuX2d1aWRdO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRDaGlsZFF1ZXVlKHF1ZXVlLCByYWN0aXZlKSB7XG4gIFx0cmV0dXJuIHF1ZXVlW3JhY3RpdmUuX2d1aWRdIHx8IChxdWV1ZVtyYWN0aXZlLl9ndWlkXSA9IFtdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmUoaG9va1F1ZXVlLCByYWN0aXZlKSB7XG5cbiAgXHR2YXIgY2hpbGRRdWV1ZSA9IGdldENoaWxkUXVldWUoaG9va1F1ZXVlLnF1ZXVlLCByYWN0aXZlKTtcblxuICBcdGhvb2tRdWV1ZS5ob29rLmZpcmUocmFjdGl2ZSk7XG5cbiAgXHQvLyBxdWV1ZSBpcyBcImxpdmVcIiBiZWNhdXNlIGNvbXBvbmVudHMgY2FuIGVuZCB1cCBiZWluZ1xuICBcdC8vIGFkZGVkIHdoaWxlIGhvb2tzIGZpcmUgb24gcGFyZW50cyB0aGF0IG1vZGlmeSBkYXRhIHZhbHVlcy5cbiAgXHR3aGlsZSAoY2hpbGRRdWV1ZS5sZW5ndGgpIHtcbiAgXHRcdGZpcmUoaG9va1F1ZXVlLCBjaGlsZFF1ZXVlLnNoaWZ0KCkpO1xuICBcdH1cblxuICBcdGRlbGV0ZSBob29rUXVldWUucXVldWVbcmFjdGl2ZS5fZ3VpZF07XG4gIH1cblxuICB2YXIgaG9va3NfSG9va1F1ZXVlID0gSG9va1F1ZXVlO1xuXG4gIHZhciBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlcyA9IGdldENvbXB1dGF0aW9uU2lnbmF0dXJlcztcblxuICB2YXIgaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX3BhdHRlcm4gPSAvXFwkXFx7KFteXFx9XSspXFx9L2c7XG4gIGZ1bmN0aW9uIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlcyhyYWN0aXZlLCBjb21wdXRlZCkge1xuICBcdHZhciBzaWduYXR1cmVzID0ge30sXG4gIFx0ICAgIGtleTtcblxuICBcdGZvciAoa2V5IGluIGNvbXB1dGVkKSB7XG4gIFx0XHRzaWduYXR1cmVzW2tleV0gPSBnZXRDb21wdXRhdGlvblNpZ25hdHVyZShyYWN0aXZlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICBcdH1cblxuICBcdHJldHVybiBzaWduYXR1cmVzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUocmFjdGl2ZSwga2V5LCBzaWduYXR1cmUpIHtcbiAgXHR2YXIgZ2V0dGVyLCBzZXR0ZXI7XG5cbiAgXHRpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRnZXR0ZXIgPSBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fYmluZChzaWduYXR1cmUsIHJhY3RpdmUpO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRnZXR0ZXIgPSBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcocmFjdGl2ZSwgc2lnbmF0dXJlKTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0aWYgKHR5cGVvZiBzaWduYXR1cmUuZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGdldHRlciA9IGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyhyYWN0aXZlLCBzaWduYXR1cmUuZ2V0KTtcbiAgXHRcdH0gZWxzZSBpZiAodHlwZW9mIHNpZ25hdHVyZS5nZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRnZXR0ZXIgPSBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fYmluZChzaWduYXR1cmUuZ2V0LCByYWN0aXZlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZhdGFsKFwiYCVzYCBjb21wdXRhdGlvbiBtdXN0IGhhdmUgYSBgZ2V0KClgIG1ldGhvZFwiLCBrZXkpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodHlwZW9mIHNpZ25hdHVyZS5zZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRzZXR0ZXIgPSBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fYmluZChzaWduYXR1cmUuc2V0LCByYWN0aXZlKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4geyBnZXR0ZXI6IGdldHRlciwgc2V0dGVyOiBzZXR0ZXIgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyhyYWN0aXZlLCBzdHIpIHtcbiAgXHR2YXIgZnVuY3Rpb25Cb2R5LCBoYXNUaGlzLCBmbjtcblxuICBcdGZ1bmN0aW9uQm9keSA9IFwicmV0dXJuIChcIiArIHN0ci5yZXBsYWNlKGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19wYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsIGtleXBhdGgpIHtcbiAgXHRcdGhhc1RoaXMgPSB0cnVlO1xuICBcdFx0cmV0dXJuIFwiX19yYWN0aXZlLmdldChcXFwiXCIgKyBrZXlwYXRoICsgXCJcXFwiKVwiO1xuICBcdH0pICsgXCIpO1wiO1xuXG4gIFx0aWYgKGhhc1RoaXMpIHtcbiAgXHRcdGZ1bmN0aW9uQm9keSA9IFwidmFyIF9fcmFjdGl2ZSA9IHRoaXM7IFwiICsgZnVuY3Rpb25Cb2R5O1xuICBcdH1cblxuICBcdGZuID0gbmV3IEZ1bmN0aW9uKGZ1bmN0aW9uQm9keSk7XG4gIFx0cmV0dXJuIGhhc1RoaXMgPyBmbi5iaW5kKHJhY3RpdmUpIDogZm47XG4gIH1cblxuICBmdW5jdGlvbiBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fYmluZChmbiwgY29udGV4dCkge1xuICBcdHJldHVybiAvdGhpcy8udGVzdChmbi50b1N0cmluZygpKSA/IGZuLmJpbmQoY29udGV4dCkgOiBmbjtcbiAgfVxuXG4gIHZhciBjb25zdHJ1Y3RIb29rID0gbmV3IGhvb2tzX0hvb2soXCJjb25zdHJ1Y3RcIik7XG4gIHZhciBjb25maWdIb29rID0gbmV3IGhvb2tzX0hvb2soXCJjb25maWdcIik7XG4gIHZhciBpbml0SG9vayA9IG5ldyBob29rc19Ib29rUXVldWUoXCJpbml0XCIpO1xuICB2YXIgaW5pdGlhbGlzZV9fdWlkID0gMDtcblxuICB2YXIgaW5pdGlhbGlzZV9fcmVnaXN0cnlOYW1lcyA9IFtcImFkYXB0b3JzXCIsIFwiY29tcG9uZW50c1wiLCBcImRlY29yYXRvcnNcIiwgXCJlYXNpbmdcIiwgXCJldmVudHNcIiwgXCJpbnRlcnBvbGF0b3JzXCIsIFwicGFydGlhbHNcIiwgXCJ0cmFuc2l0aW9uc1wiXTtcblxuICB2YXIgaW5pdGlhbGlzZSA9IGluaXRpYWxpc2VSYWN0aXZlSW5zdGFuY2U7XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGlzZVJhY3RpdmVJbnN0YW5jZShyYWN0aXZlKSB7XG4gIFx0dmFyIHVzZXJPcHRpb25zID0gYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcbiAgXHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgXHR2YXIgZWwsIHZpZXdtb2RlbDtcblxuICBcdGlmIChfUmFjdGl2ZS5ERUJVRykge1xuICBcdFx0d2VsY29tZSgpO1xuICBcdH1cblxuICBcdGluaXRpYWxpc2VQcm9wZXJ0aWVzKHJhY3RpdmUsIG9wdGlvbnMpO1xuXG4gIFx0Ly8gVE9ETyByZW1vdmUgdGhpcywgZXZlbnR1YWxseVxuICBcdGRlZmluZVByb3BlcnR5KHJhY3RpdmUsIFwiZGF0YVwiLCB7IGdldDogZGVwcmVjYXRlUmFjdGl2ZURhdGEgfSk7XG5cbiAgXHQvLyBUT0RPIGRvbid0IGFsbG93IGBvbmNvbnN0cnVjdGAgd2l0aCBgbmV3IFJhY3RpdmUoKWAsIHRoZXJlJ3Mgbm8gbmVlZCBmb3IgaXRcbiAgXHRjb25zdHJ1Y3RIb29rLmZpcmUocmFjdGl2ZSwgdXNlck9wdGlvbnMpO1xuXG4gIFx0Ly8gQWRkIHJlZ2lzdHJpZXNcbiAgXHRpbml0aWFsaXNlX19yZWdpc3RyeU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdHJhY3RpdmVbbmFtZV0gPSB1dGlsc19vYmplY3RfX2V4dGVuZChjcmVhdGUocmFjdGl2ZS5jb25zdHJ1Y3RvcltuYW1lXSB8fCBudWxsKSwgdXNlck9wdGlvbnNbbmFtZV0pO1xuICBcdH0pO1xuXG4gIFx0Ly8gQ3JlYXRlIGEgdmlld21vZGVsXG4gIFx0dmlld21vZGVsID0gbmV3IHZpZXdtb2RlbF9WaWV3bW9kZWwoe1xuICBcdFx0YWRhcHQ6IGdldEFkYXB0b3JzKHJhY3RpdmUsIHJhY3RpdmUuYWRhcHQsIHVzZXJPcHRpb25zKSxcbiAgXHRcdGRhdGE6IGN1c3RvbV9kYXRhLmluaXQocmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSwgdXNlck9wdGlvbnMpLFxuICBcdFx0Y29tcHV0ZWQ6IGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzKHJhY3RpdmUsIHV0aWxzX29iamVjdF9fZXh0ZW5kKGNyZWF0ZShyYWN0aXZlLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wdXRlZCksIHVzZXJPcHRpb25zLmNvbXB1dGVkKSksXG4gIFx0XHRtYXBwaW5nczogb3B0aW9ucy5tYXBwaW5ncyxcbiAgXHRcdHJhY3RpdmU6IHJhY3RpdmUsXG4gIFx0XHRvbmNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gZ2xvYmFsX3J1bmxvb3AuYWRkUmFjdGl2ZShyYWN0aXZlKTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdHJhY3RpdmUudmlld21vZGVsID0gdmlld21vZGVsO1xuXG4gIFx0Ly8gVGhpcyBjYW4ndCBoYXBwZW4gZWFybGllciwgYmVjYXVzZSBjb21wdXRlZCBwcm9wZXJ0aWVzIG1heSBjYWxsIGByYWN0aXZlLmdldCgpYCwgZXRjXG4gIFx0dmlld21vZGVsLmluaXQoKTtcblxuICBcdC8vIGluaXQgY29uZmlnIGZyb20gUGFyZW50IGFuZCBvcHRpb25zXG4gIFx0Y29uZmlnX2NvbmZpZy5pbml0KHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHVzZXJPcHRpb25zKTtcblxuICBcdGNvbmZpZ0hvb2suZmlyZShyYWN0aXZlKTtcbiAgXHRpbml0SG9vay5iZWdpbihyYWN0aXZlKTtcblxuICBcdC8vIC8vIElmIHRoaXMgaXMgYSBjb21wb25lbnQgd2l0aCBhIGZ1bmN0aW9uIGBkYXRhYCBwcm9wZXJ0eSwgY2FsbCB0aGUgZnVuY3Rpb25cbiAgXHQvLyAvLyB3aXRoIGByYWN0aXZlYCBhcyBjb250ZXh0ICh1bmxlc3MgdGhlIGNoaWxkIHdhcyBhbHNvIGEgZnVuY3Rpb24pXG4gIFx0Ly8gaWYgKCB0eXBlb2YgcmFjdGl2ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdXNlck9wdGlvbnMuZGF0YSAhPT0gJ2Z1bmN0aW9uJyApIHtcbiAgXHQvLyBcdHZpZXdtb2RlbC5yZXNldCggcmFjdGl2ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGF0YS5jYWxsKCByYWN0aXZlICkgfHwgZmF0YWwoICdgZGF0YWAgZnVuY3Rpb25zIG11c3QgcmV0dXJuIGEgZGF0YSBvYmplY3QnICkgKTtcbiAgXHQvLyB9XG5cbiAgXHQvLyBSZW5kZXIgdmlydHVhbCBET01cbiAgXHRpZiAocmFjdGl2ZS50ZW1wbGF0ZSkge1xuICBcdFx0dmFyIGNzc0lkcyA9IHVuZGVmaW5lZDtcblxuICBcdFx0aWYgKG9wdGlvbnMuY3NzSWRzIHx8IHJhY3RpdmUuY3NzSWQpIHtcbiAgXHRcdFx0Y3NzSWRzID0gb3B0aW9ucy5jc3NJZHMgPyBvcHRpb25zLmNzc0lkcy5zbGljZSgpIDogW107XG5cbiAgXHRcdFx0aWYgKHJhY3RpdmUuY3NzSWQpIHtcbiAgXHRcdFx0XHRjc3NJZHMucHVzaChyYWN0aXZlLmNzc0lkKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyYWN0aXZlLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogcmFjdGl2ZS50ZW1wbGF0ZSxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IHJhY3RpdmUsIC8vIHNhdmVzIGRvaW5nIGBpZiAoIHRoaXMucGFyZW50ICkgeyAvKi4uLiovIH1gIGxhdGVyIG9uXG4gIFx0XHRcdGNzc0lkczogY3NzSWRzXG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpbml0SG9vay5lbmQocmFjdGl2ZSk7XG5cbiAgXHQvLyByZW5kZXIgYXV0b21hdGljYWxseSAoIGlmIGBlbGAgaXMgc3BlY2lmaWVkIClcbiAgXHRpZiAoZWwgPSBnZXRFbGVtZW50KHJhY3RpdmUuZWwpKSB7XG4gIFx0XHR2YXIgcHJvbWlzZSA9IHJhY3RpdmUucmVuZGVyKGVsLCByYWN0aXZlLmFwcGVuZCk7XG5cbiAgXHRcdGlmIChfUmFjdGl2ZS5ERUJVR19QUk9NSVNFUykge1xuICBcdFx0XHRwcm9taXNlW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICBcdFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhcIlByb21pc2UgZGVidWdnaW5nIGlzIGVuYWJsZWQsIHRvIGhlbHAgc29sdmUgZXJyb3JzIHRoYXQgaGFwcGVuIGFzeW5jaHJvbm91c2x5LiBTb21lIGJyb3dzZXJzIHdpbGwgbG9nIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnMsIGluIHdoaWNoIGNhc2UgeW91IGNhbiBzYWZlbHkgZGlzYWJsZSBwcm9taXNlIGRlYnVnZ2luZzpcXG4gIFJhY3RpdmUuREVCVUdfUFJPTUlTRVMgPSBmYWxzZTtcIik7XG4gIFx0XHRcdFx0d2FybklmRGVidWcoXCJBbiBlcnJvciBoYXBwZW5lZCBkdXJpbmcgcmVuZGVyaW5nXCIsIHsgcmFjdGl2ZTogcmFjdGl2ZSB9KTtcbiAgXHRcdFx0XHRlcnIuc3RhY2sgJiYgbG9nSWZEZWJ1ZyhlcnIuc3RhY2spO1xuXG4gIFx0XHRcdFx0dGhyb3cgZXJyO1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBZGFwdG9ycyhyYWN0aXZlLCBwcm90b0FkYXB0LCB1c2VyT3B0aW9ucykge1xuICBcdHZhciBhZGFwdCwgbWFnaWMsIG1vZGlmeUFycmF5cztcblxuICBcdHByb3RvQWRhcHQgPSBwcm90b0FkYXB0Lm1hcChsb29rdXApO1xuICBcdGFkYXB0ID0gZW5zdXJlQXJyYXkodXNlck9wdGlvbnMuYWRhcHQpLm1hcChsb29rdXApO1xuXG4gIFx0YWRhcHQgPSBpbml0aWFsaXNlX19jb21iaW5lKHByb3RvQWRhcHQsIGFkYXB0KTtcblxuICBcdG1hZ2ljID0gXCJtYWdpY1wiIGluIHVzZXJPcHRpb25zID8gdXNlck9wdGlvbnMubWFnaWMgOiByYWN0aXZlLm1hZ2ljO1xuICBcdG1vZGlmeUFycmF5cyA9IFwibW9kaWZ5QXJyYXlzXCIgaW4gdXNlck9wdGlvbnMgPyB1c2VyT3B0aW9ucy5tb2RpZnlBcnJheXMgOiByYWN0aXZlLm1vZGlmeUFycmF5cztcblxuICBcdGlmIChtYWdpYykge1xuICBcdFx0aWYgKCFlbnZpcm9ubWVudF9fbWFnaWMpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiR2V0dGVycyBhbmQgc2V0dGVycyAobWFnaWMgbW9kZSkgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobW9kaWZ5QXJyYXlzKSB7XG4gIFx0XHRcdGFkYXB0LnB1c2gobWFnaWNBcnJheSk7XG4gIFx0XHR9XG5cbiAgXHRcdGFkYXB0LnB1c2goYWRhcHRvcnNfbWFnaWMpO1xuICBcdH1cblxuICBcdGlmIChtb2RpZnlBcnJheXMpIHtcbiAgXHRcdGFkYXB0LnB1c2goYXJyYXlfaW5kZXgpO1xuICBcdH1cblxuICBcdHJldHVybiBhZGFwdDtcblxuICBcdGZ1bmN0aW9uIGxvb2t1cChhZGFwdG9yKSB7XG4gIFx0XHRpZiAodHlwZW9mIGFkYXB0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0YWRhcHRvciA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJhZGFwdG9yc1wiLCByYWN0aXZlLCBhZGFwdG9yKTtcblxuICBcdFx0XHRpZiAoIWFkYXB0b3IpIHtcbiAgXHRcdFx0XHRmYXRhbChtaXNzaW5nUGx1Z2luKGFkYXB0b3IsIFwiYWRhcHRvclwiKSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGFkYXB0b3I7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGlzZV9fY29tYmluZShhLCBiKSB7XG4gIFx0dmFyIGMgPSBhLnNsaWNlKCksXG4gIFx0ICAgIGkgPSBiLmxlbmd0aDtcblxuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmICghIH5jLmluZGV4T2YoYltpXSkpIHtcbiAgXHRcdFx0Yy5wdXNoKGJbaV0pO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBjO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGlzZVByb3BlcnRpZXMocmFjdGl2ZSwgb3B0aW9ucykge1xuICBcdC8vIEdlbmVyYXRlIGEgdW5pcXVlIGlkZW50aWZpZXIsIGZvciBwbGFjZXMgd2hlcmUgeW91J2QgdXNlIGEgd2VhayBtYXAgaWYgaXRcbiAgXHQvLyBleGlzdGVkXG4gIFx0cmFjdGl2ZS5fZ3VpZCA9IFwici1cIiArIGluaXRpYWxpc2VfX3VpZCsrO1xuXG4gIFx0Ly8gZXZlbnRzXG4gIFx0cmFjdGl2ZS5fc3VicyA9IGNyZWF0ZShudWxsKTtcblxuICBcdC8vIHN0b3JhZ2UgZm9yIGl0ZW0gY29uZmlndXJhdGlvbiBmcm9tIGluc3RhbnRpYXRpb24gdG8gcmVzZXQsXG4gIFx0Ly8gbGlrZSBkeW5hbWljIGZ1bmN0aW9ucyBvciBvcmlnaW5hbCB2YWx1ZXNcbiAgXHRyYWN0aXZlLl9jb25maWcgPSB7fTtcblxuICBcdC8vIHR3by13YXkgYmluZGluZ3NcbiAgXHRyYWN0aXZlLl90d293YXlCaW5kaW5ncyA9IGNyZWF0ZShudWxsKTtcblxuICBcdC8vIGFuaW1hdGlvbnMgKHNvIHdlIGNhbiBzdG9wIGFueSBpbiBwcm9ncmVzcyBhdCB0ZWFyZG93bilcbiAgXHRyYWN0aXZlLl9hbmltYXRpb25zID0gW107XG5cbiAgXHQvLyBub2RlcyByZWdpc3RyeVxuICBcdHJhY3RpdmUubm9kZXMgPSB7fTtcblxuICBcdC8vIGxpdmUgcXVlcmllc1xuICBcdHJhY3RpdmUuX2xpdmVRdWVyaWVzID0gW107XG4gIFx0cmFjdGl2ZS5fbGl2ZUNvbXBvbmVudFF1ZXJpZXMgPSBbXTtcblxuICBcdC8vIGJvdW5kIGRhdGEgZnVuY3Rpb25zXG4gIFx0cmFjdGl2ZS5fYm91bmRGdW5jdGlvbnMgPSBbXTtcblxuICBcdC8vIG9ic2VydmVyc1xuICBcdHJhY3RpdmUuX29ic2VydmVycyA9IFtdO1xuXG4gIFx0Ly8gcHJvcGVydGllcyBzcGVjaWZpYyB0byBpbmxpbmUgY29tcG9uZW50c1xuICBcdGlmIChvcHRpb25zLmNvbXBvbmVudCkge1xuICBcdFx0cmFjdGl2ZS5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgXHRcdHJhY3RpdmUuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIgfHwgbnVsbDtcbiAgXHRcdHJhY3RpdmUucm9vdCA9IHJhY3RpdmUucGFyZW50LnJvb3Q7XG5cbiAgXHRcdHJhY3RpdmUuY29tcG9uZW50ID0gb3B0aW9ucy5jb21wb25lbnQ7XG4gIFx0XHRvcHRpb25zLmNvbXBvbmVudC5pbnN0YW5jZSA9IHJhY3RpdmU7XG5cbiAgXHRcdC8vIGZvciBoYWNrYWJpbGl0eSwgdGhpcyBjb3VsZCBiZSBhbiBvcGVuIG9wdGlvblxuICBcdFx0Ly8gZm9yIGFueSByYWN0aXZlIGluc3RhbmNlLCBidXQgZm9yIG5vdywganVzdFxuICBcdFx0Ly8gZm9yIGNvbXBvbmVudHMgYW5kIGp1c3QgZm9yIHJhY3RpdmUuLi5cbiAgXHRcdHJhY3RpdmUuX2lubGluZVBhcnRpYWxzID0gb3B0aW9ucy5pbmxpbmVQYXJ0aWFscztcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmFjdGl2ZS5yb290ID0gcmFjdGl2ZTtcbiAgXHRcdHJhY3RpdmUucGFyZW50ID0gcmFjdGl2ZS5jb250YWluZXIgPSBudWxsO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZVJhY3RpdmVEYXRhKCkge1xuICBcdHRocm93IG5ldyBFcnJvcihcIlVzaW5nIGByYWN0aXZlLmRhdGFgIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgLSB5b3UgbXVzdCB1c2UgdGhlIGByYWN0aXZlLmdldCgpYCBBUEkgaW5zdGVhZFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbXBsZXhQYXJhbWV0ZXIoY29tcG9uZW50LCB0ZW1wbGF0ZSwgY2FsbGJhY2spIHtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gIFx0XHRyb290OiBjb21wb25lbnQucm9vdCxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fSk7XG5cbiAgXHR0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgdmFyIGluaXRpYWxpc2VfQ29tcGxleFBhcmFtZXRlciA9IENvbXBsZXhQYXJhbWV0ZXI7XG5cbiAgQ29tcGxleFBhcmFtZXRlci5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuZGlydHkpIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5jYWxsYmFjayh0aGlzLmZyYWdtZW50LmdldFZhbHVlKCkpO1xuICBcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBDb21wb25lbnQsIGF0dHJpYnV0ZXMsIHlpZWxkVGVtcGxhdGUsIHBhcnRpYWxzKSB7XG4gIFx0dmFyIGluc3RhbmNlLFxuICBcdCAgICBwYXJlbnRGcmFnbWVudCxcbiAgXHQgICAgcmFjdGl2ZSxcbiAgXHQgICAgZnJhZ21lbnQsXG4gIFx0ICAgIGNvbnRhaW5lcixcbiAgXHQgICAgaW5saW5lUGFydGlhbHMgPSB7fSxcbiAgXHQgICAgZGF0YSA9IHt9LFxuICBcdCAgICBtYXBwaW5ncyA9IHt9LFxuICBcdCAgICByZWFkeSxcbiAgXHQgICAgcmVzb2x2ZXJzID0gW107XG5cbiAgXHRwYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHRyYWN0aXZlID0gY29tcG9uZW50LnJvb3Q7XG5cbiAgXHRwYXJ0aWFscyA9IHBhcnRpYWxzIHx8IHt9O1xuICBcdHV0aWxzX29iamVjdF9fZXh0ZW5kKGlubGluZVBhcnRpYWxzLCBwYXJ0aWFscyk7XG5cbiAgXHQvLyBNYWtlIGNvbnRlbnRzIGF2YWlsYWJsZSBhcyBhIHt7PmNvbnRlbnR9fSBwYXJ0aWFsXG4gIFx0cGFydGlhbHMuY29udGVudCA9IHlpZWxkVGVtcGxhdGUgfHwgW107XG5cbiAgXHQvLyBzZXQgYSBkZWZhdWx0IHBhcnRpYWwgZm9yIHlpZWxkcyB3aXRoIG5vIG5hbWVcbiAgXHRpbmxpbmVQYXJ0aWFsc1tcIlwiXSA9IHBhcnRpYWxzLmNvbnRlbnQ7XG5cbiAgXHRpZiAoQ29tcG9uZW50LmRlZmF1bHRzLmVsKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIlRoZSA8JXMvPiBjb21wb25lbnQgaGFzIGEgZGVmYXVsdCBgZWxgIHByb3BlcnR5OyBpdCBoYXMgYmVlbiBkaXNyZWdhcmRlZFwiLCBjb21wb25lbnQubmFtZSk7XG4gIFx0fVxuXG4gIFx0Ly8gZmluZCBjb250YWluZXJcbiAgXHRmcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuICBcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0aWYgKGZyYWdtZW50Lm93bmVyLnR5cGUgPT09IFlJRUxERVIpIHtcbiAgXHRcdFx0Y29udGFpbmVyID0gZnJhZ21lbnQub3duZXIuY29udGFpbmVyO1xuICBcdFx0XHRicmVhaztcbiAgXHRcdH1cblxuICBcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG4gIFx0fVxuXG4gIFx0Ly8gZWFjaCBhdHRyaWJ1dGUgcmVwcmVzZW50cyBlaXRoZXIgYSkgZGF0YSBvciBiKSBhIG1hcHBpbmdcbiAgXHRpZiAoYXR0cmlidXRlcykge1xuICBcdFx0T2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV0sXG4gIFx0XHRcdCAgICBwYXJzZWQsXG4gIFx0XHRcdCAgICByZXNvbHZlcjtcblxuICBcdFx0XHRpZiAodHlwZW9mIGF0dHJpYnV0ZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdC8vIGl0J3Mgc3RhdGljIGRhdGFcbiAgXHRcdFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oYXR0cmlidXRlKTtcbiAgXHRcdFx0XHRkYXRhW2tleV0gPSBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBhdHRyaWJ1dGU7XG4gIFx0XHRcdH0gZWxzZSBpZiAoYXR0cmlidXRlID09PSAwKSB7XG4gIFx0XHRcdFx0Ly8gaXQgaGFkIG5vICc9Jywgc28gd2UnbGwgY2FsbCBpdCB0cnVlXG4gIFx0XHRcdFx0ZGF0YVtrZXldID0gdHJ1ZTtcbiAgXHRcdFx0fSBlbHNlIGlmIChpc0FycmF5KGF0dHJpYnV0ZSkpIHtcbiAgXHRcdFx0XHQvLyB0aGlzIHJlcHJlc2VudHMgZHluYW1pYyBkYXRhXG4gIFx0XHRcdFx0aWYgKGlzU2luZ2xlSW50ZXJwb2xhdG9yKGF0dHJpYnV0ZSkpIHtcbiAgXHRcdFx0XHRcdG1hcHBpbmdzW2tleV0gPSB7XG4gIFx0XHRcdFx0XHRcdG9yaWdpbjogY29tcG9uZW50LnJvb3Qudmlld21vZGVsLFxuICBcdFx0XHRcdFx0XHRrZXlwYXRoOiB1bmRlZmluZWRcbiAgXHRcdFx0XHRcdH07XG5cbiAgXHRcdFx0XHRcdHJlc29sdmVyID0gY3JlYXRlUmVzb2x2ZXIoY29tcG9uZW50LCBhdHRyaWJ1dGVbMF0sIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdFx0XHRcdGlmIChrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0XHRcdFx0XHRcdGlmIChyZWFkeSkge1xuICBcdFx0XHRcdFx0XHRcdFx0aW5zdGFuY2Uuc2V0KGtleSwga2V5cGF0aC52YWx1ZSk7IC8vIFRPRE8gdXNlIHZpZXdtb2RlbD9cbiAgXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdFx0ZGF0YVtrZXldID0ga2V5cGF0aC52YWx1ZTtcblxuICBcdFx0XHRcdFx0XHRcdFx0Ly8gVE9ETyBlcnJyLi4uLiB3b3VsZCBiZSBiZXR0ZXIgaWYgd2UgZGlkbid0IGhhdmUgdG8gZG8gdGhpc1xuICBcdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIG1hcHBpbmdzW2tleV07XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdGlmIChyZWFkeSkge1xuICBcdFx0XHRcdFx0XHRcdFx0aW5zdGFuY2Uudmlld21vZGVsLm1hcHBpbmdzW2tleV0ucmVzb2x2ZShrZXlwYXRoKTtcbiAgXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdFx0Ly8gcmVzb2x2ZWQgaW1tZWRpYXRlbHlcbiAgXHRcdFx0XHRcdFx0XHRcdG1hcHBpbmdzW2tleV0ua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0cmVzb2x2ZXIgPSBuZXcgaW5pdGlhbGlzZV9Db21wbGV4UGFyYW1ldGVyKGNvbXBvbmVudCwgYXR0cmlidXRlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0XHRcdFx0aWYgKHJlYWR5KSB7XG4gIFx0XHRcdFx0XHRcdFx0aW5zdGFuY2Uuc2V0KGtleSwgdmFsdWUpOyAvLyBUT0RPIHVzZSB2aWV3bW9kZWw/XG4gIFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0ZGF0YVtrZXldID0gdmFsdWU7XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHJlc29sdmVycy5wdXNoKHJlc29sdmVyKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJlcm0gd3V0XCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpbnN0YW5jZSA9IGNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKTtcblxuICBcdGluaXRpYWxpc2UoaW5zdGFuY2UsIHtcbiAgXHRcdGVsOiBudWxsLFxuICBcdFx0YXBwZW5kOiB0cnVlLFxuICBcdFx0ZGF0YTogZGF0YSxcbiAgXHRcdHBhcnRpYWxzOiBwYXJ0aWFscyxcbiAgXHRcdG1hZ2ljOiByYWN0aXZlLm1hZ2ljIHx8IENvbXBvbmVudC5kZWZhdWx0cy5tYWdpYyxcbiAgXHRcdG1vZGlmeUFycmF5czogcmFjdGl2ZS5tb2RpZnlBcnJheXMsXG4gIFx0XHQvLyBuZWVkIHRvIGluaGVyaXQgcnVudGltZSBwYXJlbnQgYWRhcHRvcnNcbiAgXHRcdGFkYXB0OiByYWN0aXZlLmFkYXB0XG4gIFx0fSwge1xuICBcdFx0cGFyZW50OiByYWN0aXZlLFxuICBcdFx0Y29tcG9uZW50OiBjb21wb25lbnQsXG4gIFx0XHRjb250YWluZXI6IGNvbnRhaW5lcixcbiAgXHRcdG1hcHBpbmdzOiBtYXBwaW5ncyxcbiAgXHRcdGlubGluZVBhcnRpYWxzOiBpbmxpbmVQYXJ0aWFscyxcbiAgXHRcdGNzc0lkczogcGFyZW50RnJhZ21lbnQuY3NzSWRzXG4gIFx0fSk7XG5cbiAgXHRyZWFkeSA9IHRydWU7XG4gIFx0Y29tcG9uZW50LnJlc29sdmVycyA9IHJlc29sdmVycztcblxuICBcdHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVSZXNvbHZlcihjb21wb25lbnQsIHRlbXBsYXRlLCBjYWxsYmFjaykge1xuICBcdHZhciByZXNvbHZlcjtcblxuICBcdGlmICh0ZW1wbGF0ZS5yKSB7XG4gIFx0XHRyZXNvbHZlciA9IFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihjb21wb25lbnQsIHRlbXBsYXRlLnIsIGNhbGxiYWNrKTtcbiAgXHR9IGVsc2UgaWYgKHRlbXBsYXRlLngpIHtcbiAgXHRcdHJlc29sdmVyID0gbmV3IFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXIoY29tcG9uZW50LCBjb21wb25lbnQucGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLngsIGNhbGxiYWNrKTtcbiAgXHR9IGVsc2UgaWYgKHRlbXBsYXRlLnJ4KSB7XG4gIFx0XHRyZXNvbHZlciA9IG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyKGNvbXBvbmVudCwgdGVtcGxhdGUucngsIGNhbGxiYWNrKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzb2x2ZXI7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NpbmdsZUludGVycG9sYXRvcih0ZW1wbGF0ZSkge1xuICBcdHJldHVybiB0ZW1wbGF0ZS5sZW5ndGggPT09IDEgJiYgdGVtcGxhdGVbMF0udCA9PT0gSU5URVJQT0xBVE9SO1xuICB9XG5cbiAgLy8gVE9ETyBob3cgc2hvdWxkIGV2ZW50IGFyZ3VtZW50cyBiZSBoYW5kbGVkPyBlLmcuXG4gIC8vIDx3aWRnZXQgb24tZm9vPSdiYXI6MSwyLDMnLz5cbiAgLy8gVGhlIGV2ZW50ICdiYXInIHdpbGwgYmUgZmlyZWQgb24gdGhlIHBhcmVudCBpbnN0YW5jZVxuICAvLyB3aGVuICdmb28nIGZpcmVzIG9uIHRoZSBjaGlsZCwgYnV0IHRoZSAxLDIsMyBhcmd1bWVudHNcbiAgLy8gd2lsbCBiZSBsb3N0XG5cbiAgdmFyIGluaXRpYWxpc2VfcHJvcGFnYXRlRXZlbnRzID0gcHJvcGFnYXRlRXZlbnRzO1xuXG4gIGZ1bmN0aW9uIHByb3BhZ2F0ZUV2ZW50cyhjb21wb25lbnQsIGV2ZW50c0Rlc2NyaXB0b3IpIHtcbiAgXHR2YXIgZXZlbnROYW1lO1xuXG4gIFx0Zm9yIChldmVudE5hbWUgaW4gZXZlbnRzRGVzY3JpcHRvcikge1xuICBcdFx0aWYgKGV2ZW50c0Rlc2NyaXB0b3IuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICBcdFx0XHRwcm9wYWdhdGVFdmVudChjb21wb25lbnQuaW5zdGFuY2UsIGNvbXBvbmVudC5yb290LCBldmVudE5hbWUsIGV2ZW50c0Rlc2NyaXB0b3JbZXZlbnROYW1lXSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvcGFnYXRlRXZlbnQoY2hpbGRJbnN0YW5jZSwgcGFyZW50SW5zdGFuY2UsIGV2ZW50TmFtZSwgcHJveHlFdmVudE5hbWUpIHtcbiAgXHRpZiAodHlwZW9mIHByb3h5RXZlbnROYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRmYXRhbChcIkNvbXBvbmVudHMgY3VycmVudGx5IG9ubHkgc3VwcG9ydCBzaW1wbGUgZXZlbnRzIC0geW91IGNhbm5vdCBpbmNsdWRlIGFyZ3VtZW50cy4gU29ycnkhXCIpO1xuICBcdH1cblxuICBcdGNoaWxkSW5zdGFuY2Uub24oZXZlbnROYW1lLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnQsIGFyZ3M7XG5cbiAgXHRcdC8vIHNlbWktd2VhayB0ZXN0LCBidXQgd2hhdCBlbHNlPyB0YWcgdGhlIGV2ZW50IG9iaiAuX2lzRXZlbnQgP1xuICBcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICYmIGFyZ3VtZW50c1swXS5ub2RlKSB7XG4gIFx0XHRcdGV2ZW50ID0gQXJyYXkucHJvdG90eXBlLnNoaWZ0LmNhbGwoYXJndW1lbnRzKTtcbiAgXHRcdH1cblxuICBcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgXHRcdHNoYXJlZF9maXJlRXZlbnQocGFyZW50SW5zdGFuY2UsIHByb3h5RXZlbnROYW1lLCB7IGV2ZW50OiBldmVudCwgYXJnczogYXJncyB9KTtcblxuICBcdFx0Ly8gY2FuY2VsIGJ1YmJsaW5nXG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgaW5pdGlhbGlzZV91cGRhdGVMaXZlUXVlcmllcyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgXHR2YXIgYW5jZXN0b3IsIHF1ZXJ5O1xuXG4gIFx0Ly8gSWYgdGhlcmUncyBhIGxpdmUgcXVlcnkgZm9yIHRoaXMgY29tcG9uZW50IHR5cGUsIGFkZCBpdFxuICBcdGFuY2VzdG9yID0gY29tcG9uZW50LnJvb3Q7XG4gIFx0d2hpbGUgKGFuY2VzdG9yKSB7XG4gIFx0XHRpZiAocXVlcnkgPSBhbmNlc3Rvci5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbXCJfXCIgKyBjb21wb25lbnQubmFtZV0pIHtcbiAgXHRcdFx0cXVlcnkucHVzaChjb21wb25lbnQuaW5zdGFuY2UpO1xuICBcdFx0fVxuXG4gIFx0XHRhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfaW5pdCA9IENvbXBvbmVudCRpbml0O1xuICBmdW5jdGlvbiBDb21wb25lbnQkaW5pdChvcHRpb25zLCBDb21wb25lbnQpIHtcbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQsIHJvb3Q7XG5cbiAgXHRpZiAoIUNvbXBvbmVudCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IFxcXCJcIiArIHRoaXMubmFtZSArIFwiXFxcIiBub3QgZm91bmRcIik7XG4gIFx0fVxuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcbiAgXHRyb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblxuICBcdHRoaXMucm9vdCA9IHJvb3Q7XG4gIFx0dGhpcy50eXBlID0gQ09NUE9ORU5UO1xuICBcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUuZTtcbiAgXHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHR0aGlzLmluZGV4UmVmQmluZGluZ3MgPSB7fTtcbiAgXHR0aGlzLnlpZWxkZXJzID0ge307XG4gIFx0dGhpcy5yZXNvbHZlcnMgPSBbXTtcblxuICBcdGNyZWF0ZUluc3RhbmNlKHRoaXMsIENvbXBvbmVudCwgb3B0aW9ucy50ZW1wbGF0ZS5hLCBvcHRpb25zLnRlbXBsYXRlLmYsIG9wdGlvbnMudGVtcGxhdGUucCk7XG4gIFx0aW5pdGlhbGlzZV9wcm9wYWdhdGVFdmVudHModGhpcywgb3B0aW9ucy50ZW1wbGF0ZS52KTtcblxuICBcdC8vIGludHJvLCBvdXRybyBhbmQgZGVjb3JhdG9yIGRpcmVjdGl2ZXMgaGF2ZSBubyBlZmZlY3RcbiAgXHRpZiAob3B0aW9ucy50ZW1wbGF0ZS50MCB8fCBvcHRpb25zLnRlbXBsYXRlLnQxIHx8IG9wdGlvbnMudGVtcGxhdGUudDIgfHwgb3B0aW9ucy50ZW1wbGF0ZS5vKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIlRoZSBcXFwiaW50cm9cXFwiLCBcXFwib3V0cm9cXFwiIGFuZCBcXFwiZGVjb3JhdG9yXFxcIiBkaXJlY3RpdmVzIGhhdmUgbm8gZWZmZWN0IG9uIGNvbXBvbmVudHNcIiwgeyByYWN0aXZlOiB0aGlzLmluc3RhbmNlIH0pO1xuICBcdH1cblxuICBcdGluaXRpYWxpc2VfdXBkYXRlTGl2ZVF1ZXJpZXModGhpcyk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9yZWJpbmQgPSBDb21wb25lbnQkcmViaW5kO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdHZhciBxdWVyeTtcblxuICBcdHRoaXMucmVzb2x2ZXJzLmZvckVhY2gocmViaW5kKTtcblxuICBcdGZvciAodmFyIGsgaW4gdGhpcy55aWVsZGVycykge1xuICBcdFx0aWYgKHRoaXMueWllbGRlcnNba11bMF0pIHtcbiAgXHRcdFx0cmViaW5kKHRoaXMueWllbGRlcnNba11bMF0pO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChxdWVyeSA9IHRoaXMucm9vdC5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbXCJfXCIgKyB0aGlzLm5hbWVdKSB7XG4gIFx0XHRxdWVyeS5fbWFrZURpcnR5KCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gcmViaW5kKHgpIHtcbiAgXHRcdHgucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3JlbmRlciA9IENvbXBvbmVudCRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JHJlbmRlcigpIHtcbiAgXHR2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlO1xuXG4gIFx0aW5zdGFuY2UucmVuZGVyKHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpKTtcblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHJldHVybiBpbnN0YW5jZS5mcmFnbWVudC5kZXRhY2goKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3RvU3RyaW5nID0gQ29tcG9uZW50JHRvU3RyaW5nO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCR0b1N0cmluZygpIHtcbiAgXHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC50b1N0cmluZygpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfdW5iaW5kID0gQ29tcG9uZW50JHVuYmluZDtcblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV91bmJpbmRfX3RlYXJkb3duSG9vayA9IG5ldyBob29rc19Ib29rKFwidGVhcmRvd25cIik7XG4gIGZ1bmN0aW9uIENvbXBvbmVudCR1bmJpbmQoKSB7XG4gIFx0dmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZTtcblxuICBcdHRoaXMucmVzb2x2ZXJzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcblxuICBcdHJlbW92ZUZyb21MaXZlQ29tcG9uZW50UXVlcmllcyh0aGlzKTtcblxuICBcdGluc3RhbmNlLl9vYnNlcnZlcnMuZm9yRWFjaChjYW5jZWwpO1xuXG4gIFx0Ly8gdGVhcmRvd24gdGhlIGluc3RhbmNlXG4gIFx0aW5zdGFuY2UuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0aW5zdGFuY2Uudmlld21vZGVsLnRlYXJkb3duKCk7XG5cbiAgXHRpZiAoaW5zdGFuY2UuZnJhZ21lbnQucmVuZGVyZWQgJiYgaW5zdGFuY2UuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkoaW5zdGFuY2UuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCBpbnN0YW5jZSk7XG4gIFx0fVxuXG4gIFx0Q29tcG9uZW50X3Byb3RvdHlwZV91bmJpbmRfX3RlYXJkb3duSG9vay5maXJlKGluc3RhbmNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUZyb21MaXZlQ29tcG9uZW50UXVlcmllcyhjb21wb25lbnQpIHtcbiAgXHR2YXIgaW5zdGFuY2UsIHF1ZXJ5O1xuXG4gIFx0aW5zdGFuY2UgPSBjb21wb25lbnQucm9vdDtcblxuICBcdGRvIHtcbiAgXHRcdGlmIChxdWVyeSA9IGluc3RhbmNlLl9saXZlQ29tcG9uZW50UXVlcmllc1tcIl9cIiArIGNvbXBvbmVudC5uYW1lXSkge1xuICBcdFx0XHRxdWVyeS5fcmVtb3ZlKGNvbXBvbmVudCk7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfdW5yZW5kZXIgPSBDb21wb25lbnQkdW5yZW5kZXI7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHR0aGlzLnNob3VsZERlc3Ryb3kgPSBzaG91bGREZXN0cm95O1xuICBcdHRoaXMuaW5zdGFuY2UudW5yZW5kZXIoKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnQgPSBmdW5jdGlvbiAob3B0aW9ucywgQ29uc3RydWN0b3IpIHtcbiAgXHR0aGlzLmluaXQob3B0aW9ucywgQ29uc3RydWN0b3IpO1xuICB9O1xuXG4gIENvbXBvbmVudC5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBDb21wb25lbnRfcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzLFxuICBcdGZpbmRDb21wb25lbnQ6IENvbXBvbmVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCxcbiAgXHRmaW5kTmV4dE5vZGU6IENvbXBvbmVudF9wcm90b3R5cGVfZmluZE5leHROb2RlLFxuICBcdGZpcnN0Tm9kZTogQ29tcG9uZW50X3Byb3RvdHlwZV9maXJzdE5vZGUsXG4gIFx0aW5pdDogQ29tcG9uZW50X3Byb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogQ29tcG9uZW50X3Byb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVuZGVyOiBDb21wb25lbnRfcHJvdG90eXBlX3JlbmRlcixcbiAgXHR0b1N0cmluZzogQ29tcG9uZW50X3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IENvbXBvbmVudF9wcm90b3R5cGVfdW5iaW5kLFxuICBcdHVucmVuZGVyOiBDb21wb25lbnRfcHJvdG90eXBlX3VucmVuZGVyXG4gIH07XG5cbiAgdmFyIF9Db21wb25lbnQgPSBDb21wb25lbnQ7XG5cbiAgdmFyIENvbW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IENPTU1FTlQ7XG4gIFx0dGhpcy52YWx1ZSA9IG9wdGlvbnMudGVtcGxhdGUuYztcbiAgfTtcblxuICBDb21tZW50LnByb3RvdHlwZSA9IHtcbiAgXHRkZXRhY2g6IHNoYXJlZF9kZXRhY2gsXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLm5vZGUpIHtcbiAgXHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0aGlzLnZhbHVlKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBcIjwhLS1cIiArIHRoaXMudmFsdWUgKyBcIi0tPlwiO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGlmIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRcdHRoaXMubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBpdGVtc19Db21tZW50ID0gQ29tbWVudDtcblxuICB2YXIgWWllbGRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dmFyIGNvbnRhaW5lciwgY29tcG9uZW50O1xuXG4gIFx0dGhpcy50eXBlID0gWUlFTERFUjtcblxuICBcdHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudC5yb290O1xuICBcdHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50ID0gY29udGFpbmVyLmNvbXBvbmVudDtcblxuICBcdHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICBcdHRoaXMuY29udGFpbmVyRnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHR2YXIgbmFtZSA9IHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUubiB8fCBcIlwiO1xuXG4gIFx0dmFyIHRlbXBsYXRlID0gY29udGFpbmVyLl9pbmxpbmVQYXJ0aWFsc1tuYW1lXTtcblxuICBcdGlmICghdGVtcGxhdGUpIHtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZm9yIHBhcnRpYWwgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiLCB7IHJhY3RpdmU6IG9wdGlvbnMucm9vdCB9KTtcbiAgXHRcdHRlbXBsYXRlID0gW107XG4gIFx0fVxuXG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdG93bmVyOiB0aGlzLFxuICBcdFx0cm9vdDogY29udGFpbmVyLnBhcmVudCxcbiAgXHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgXHRcdHBFbGVtZW50OiB0aGlzLmNvbnRhaW5lckZyYWdtZW50LnBFbGVtZW50XG4gIFx0fSk7XG5cbiAgXHQvLyBldmVuIHRob3VnaCBvbmx5IG9uZSB5aWVsZGVyIGlzIGFsbG93ZWQsIHdlIG5lZWQgdG8gaGF2ZSBhbiBhcnJheSBvZiB0aGVtXG4gIFx0Ly8gYXMgaXQncyBwb3NzaWJsZSB0byBjYXVzZSBhIHlpZWxkZXIgdG8gYmUgY3JlYXRlZCBiZWZvcmUgdGhlIGxhc3Qgb25lXG4gIFx0Ly8gd2FzIGRlc3Ryb3llZCBpbiB0aGUgc2FtZSB0dXJuIG9mIHRoZSBydW5sb29wXG4gIFx0aWYgKCFpc0FycmF5KGNvbXBvbmVudC55aWVsZGVyc1tuYW1lXSkpIHtcbiAgXHRcdGNvbXBvbmVudC55aWVsZGVyc1tuYW1lXSA9IFt0aGlzXTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Y29tcG9uZW50LnlpZWxkZXJzW25hbWVdLnB1c2godGhpcyk7XG4gIFx0fVxuXG4gIFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmIChjb21wb25lbnQueWllbGRlcnNbbmFtZV0ubGVuZ3RoID4gMSkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBIGNvbXBvbmVudCB0ZW1wbGF0ZSBjYW4gb25seSBoYXZlIG9uZSB7e3lpZWxkXCIgKyAobmFtZSA/IFwiIFwiICsgbmFtZSA6IFwiXCIpICsgXCJ9fSBkZWNsYXJhdGlvbiBhdCBhIHRpbWVcIik7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH07XG5cbiAgWWllbGRlci5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHR9LFxuXG4gIFx0ZmluZDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgXHR9LFxuXG4gIFx0ZmluZEFsbDogZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdH0sXG5cbiAgXHRmaW5kQ29tcG9uZW50OiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICBcdH0sXG5cbiAgXHRmaW5kQWxsQ29tcG9uZW50czogZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9LFxuXG4gIFx0ZmluZE5leHROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0fSxcblxuICBcdGZpcnN0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUob3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQucmVuZGVyKCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKHNob3VsZERlc3Ryb3kpO1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuY29tcG9uZW50LnlpZWxkZXJzW3RoaXMubmFtZV0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBpdGVtc19ZaWVsZGVyID0gWWllbGRlcjtcblxuICB2YXIgRG9jdHlwZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5kZWNsYXJhdGlvbiA9IG9wdGlvbnMudGVtcGxhdGUuYTtcbiAgfTtcblxuICBEb2N0eXBlLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBub29wLFxuICBcdHJlbmRlcjogbm9vcCxcbiAgXHR1bnJlbmRlcjogbm9vcCxcbiAgXHR0ZWFyZG93bjogbm9vcCxcbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIFwiPCFET0NUWVBFXCIgKyB0aGlzLmRlY2xhcmF0aW9uICsgXCI+XCI7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBpdGVtc19Eb2N0eXBlID0gRG9jdHlwZTtcblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2luaXQgPSBGcmFnbWVudCRpbml0O1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGluaXQob3B0aW9ucykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR0aGlzLm93bmVyID0gb3B0aW9ucy5vd25lcjsgLy8gVGhlIGl0ZW0gdGhhdCBvd25zIHRoaXMgZnJhZ21lbnQgLSBhbiBlbGVtZW50LCBzZWN0aW9uLCBwYXJ0aWFsLCBvciBhdHRyaWJ1dGVcbiAgXHR0aGlzLnBhcmVudCA9IHRoaXMub3duZXIucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHQvLyBpbmhlcml0ZWQgcHJvcGVydGllc1xuICBcdHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdDtcbiAgXHR0aGlzLnBFbGVtZW50ID0gb3B0aW9ucy5wRWxlbWVudDtcbiAgXHR0aGlzLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG4gIFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gIFx0dGhpcy5rZXkgPSBvcHRpb25zLmtleTtcbiAgXHR0aGlzLnJlZ2lzdGVyZWRJbmRleFJlZnMgPSBbXTtcblxuICBcdC8vIGVuY2Fwc3VsYXRlZCBzdHlsZXMgc2hvdWxkIGJlIGluaGVyaXRlZCB1bnRpbCB0aGV5IGdldCBhcHBsaWVkIGJ5IGFuIGVsZW1lbnRcbiAgXHR0aGlzLmNzc0lkcyA9IFwiY3NzSWRzXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuY3NzSWRzIDogdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5jc3NJZHMgOiBudWxsO1xuXG4gIFx0dGhpcy5pdGVtcyA9IG9wdGlvbnMudGVtcGxhdGUubWFwKGZ1bmN0aW9uICh0ZW1wbGF0ZSwgaSkge1xuICBcdFx0cmV0dXJuIGNyZWF0ZUl0ZW0oe1xuICBcdFx0XHRwYXJlbnRGcmFnbWVudDogX3RoaXMsXG4gIFx0XHRcdHBFbGVtZW50OiBvcHRpb25zLnBFbGVtZW50LFxuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gIFx0XHRcdGluZGV4OiBpXG4gIFx0XHR9KTtcbiAgXHR9KTtcblxuICBcdHRoaXMudmFsdWUgPSB0aGlzLmFyZ3NMaXN0ID0gbnVsbDtcbiAgXHR0aGlzLmRpcnR5QXJncyA9IHRoaXMuZGlydHlWYWx1ZSA9IHRydWU7XG5cbiAgXHR0aGlzLmJvdW5kID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUl0ZW0ob3B0aW9ucykge1xuICBcdGlmICh0eXBlb2Ygb3B0aW9ucy50ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0cmV0dXJuIG5ldyBpdGVtc19UZXh0KG9wdGlvbnMpO1xuICBcdH1cblxuICBcdHN3aXRjaCAob3B0aW9ucy50ZW1wbGF0ZS50KSB7XG4gIFx0XHRjYXNlIFlJRUxERVI6XG4gIFx0XHRcdHJldHVybiBuZXcgaXRlbXNfWWllbGRlcihvcHRpb25zKTtcbiAgXHRcdGNhc2UgSU5URVJQT0xBVE9SOlxuICBcdFx0XHRyZXR1cm4gbmV3IGl0ZW1zX0ludGVycG9sYXRvcihvcHRpb25zKTtcbiAgXHRcdGNhc2UgU0VDVElPTjpcbiAgXHRcdFx0cmV0dXJuIG5ldyBfU2VjdGlvbihvcHRpb25zKTtcbiAgXHRcdGNhc2UgVFJJUExFOlxuICBcdFx0XHRyZXR1cm4gbmV3IF9UcmlwbGUob3B0aW9ucyk7XG4gIFx0XHRjYXNlIEVMRU1FTlQ6XG4gIFx0XHRcdHZhciBjb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgXHRcdFx0aWYgKGNvbnN0cnVjdG9yID0gQ29tcG9uZW50X2dldENvbXBvbmVudChvcHRpb25zLnBhcmVudEZyYWdtZW50LnJvb3QsIG9wdGlvbnMudGVtcGxhdGUuZSkpIHtcbiAgXHRcdFx0XHRyZXR1cm4gbmV3IF9Db21wb25lbnQob3B0aW9ucywgY29uc3RydWN0b3IpO1xuICBcdFx0XHR9XG4gIFx0XHRcdHJldHVybiBuZXcgX0VsZW1lbnQob3B0aW9ucyk7XG4gIFx0XHRjYXNlIFBBUlRJQUw6XG4gIFx0XHRcdHJldHVybiBuZXcgX1BhcnRpYWwob3B0aW9ucyk7XG4gIFx0XHRjYXNlIENPTU1FTlQ6XG4gIFx0XHRcdHJldHVybiBuZXcgaXRlbXNfQ29tbWVudChvcHRpb25zKTtcbiAgXHRcdGNhc2UgRE9DVFlQRTpcbiAgXHRcdFx0cmV0dXJuIG5ldyBpdGVtc19Eb2N0eXBlKG9wdGlvbnMpO1xuXG4gIFx0XHRkZWZhdWx0OlxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbmVkLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLiBUaGFua3MhXCIpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfcmViaW5kID0gRnJhZ21lbnQkcmViaW5kO1xuICBmdW5jdGlvbiBGcmFnbWVudCRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuXG4gIFx0Ly8gYXNzaWduIG5ldyBjb250ZXh0IGtleXBhdGggaWYgbmVlZGVkXG4gIFx0aWYgKCF0aGlzLm93bmVyIHx8IHRoaXMub3duZXIuaGFzQ29udGV4dCkge1xuICBcdFx0YXNzaWduTmV3S2V5cGF0aCh0aGlzLCBcImNvbnRleHRcIiwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuXG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRpZiAoaXRlbS5yZWJpbmQpIHtcbiAgXHRcdFx0aXRlbS5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3JlbmRlciA9IEZyYWdtZW50JHJlbmRlcjtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRyZW5kZXIoKSB7XG4gIFx0dmFyIHJlc3VsdDtcblxuICBcdGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmVzdWx0ID0gdGhpcy5pdGVtc1swXS5yZW5kZXIoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0XHR0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdFx0cmVzdWx0LmFwcGVuZENoaWxkKGl0ZW0ucmVuZGVyKCkpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfdG9TdHJpbmcgPSBGcmFnbWVudCR0b1N0cmluZztcblxuICBmdW5jdGlvbiBGcmFnbWVudCR0b1N0cmluZyhlc2NhcGUpIHtcbiAgXHRpZiAoIXRoaXMuaXRlbXMpIHtcbiAgXHRcdHJldHVybiBcIlwiO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLml0ZW1zLm1hcChlc2NhcGUgPyB0b0VzY2FwZWRTdHJpbmcgOiBGcmFnbWVudF9wcm90b3R5cGVfdG9TdHJpbmdfX3RvU3RyaW5nKS5qb2luKFwiXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnRfcHJvdG90eXBlX3RvU3RyaW5nX190b1N0cmluZyhpdGVtKSB7XG4gIFx0cmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvRXNjYXBlZFN0cmluZyhpdGVtKSB7XG4gIFx0cmV0dXJuIGl0ZW0udG9TdHJpbmcodHJ1ZSk7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3VuYmluZCA9IEZyYWdtZW50JHVuYmluZDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCR1bmJpbmQoKSB7XG4gIFx0aWYgKCF0aGlzLmJvdW5kKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKHVuYmluZEl0ZW0pO1xuICBcdHRoaXMuYm91bmQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuYmluZEl0ZW0oaXRlbSkge1xuICBcdGlmIChpdGVtLnVuYmluZCkge1xuICBcdFx0aXRlbS51bmJpbmQoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3VucmVuZGVyID0gRnJhZ21lbnQkdW5yZW5kZXI7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkdW5yZW5kZXIoc2hvdWxkRGVzdHJveSkge1xuICBcdGlmICghdGhpcy5yZW5kZXJlZCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHVucmVuZGVyIGEgZnJhZ21lbnQgdGhhdCB3YXMgbm90IHJlbmRlcmVkXCIpO1xuICBcdH1cblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICBcdFx0cmV0dXJuIGkudW5yZW5kZXIoc2hvdWxkRGVzdHJveSk7XG4gIFx0fSk7XG4gIFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLmluaXQob3B0aW9ucyk7XG4gIH07XG5cbiAgRnJhZ21lbnQucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogcHJvdG90eXBlX2J1YmJsZSxcbiAgXHRkZXRhY2g6IEZyYWdtZW50X3Byb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRBbGwsXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBGcmFnbWVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCxcbiAgXHRmaW5kTmV4dE5vZGU6IHByb3RvdHlwZV9maW5kTmV4dE5vZGUsXG4gIFx0Zmlyc3ROb2RlOiBwcm90b3R5cGVfZmlyc3ROb2RlLFxuICBcdGdldEFyZ3NMaXN0OiBnZXRBcmdzTGlzdCxcbiAgXHRnZXROb2RlOiBnZXROb2RlLFxuICBcdGdldFZhbHVlOiBwcm90b3R5cGVfZ2V0VmFsdWUsXG4gIFx0aW5pdDogRnJhZ21lbnRfcHJvdG90eXBlX2luaXQsXG4gIFx0cmViaW5kOiBGcmFnbWVudF9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlZ2lzdGVySW5kZXhSZWY6IGZ1bmN0aW9uIChpZHgpIHtcbiAgXHRcdHZhciBpZHhzID0gdGhpcy5yZWdpc3RlcmVkSW5kZXhSZWZzO1xuICBcdFx0aWYgKGlkeHMuaW5kZXhPZihpZHgpID09PSAtMSkge1xuICBcdFx0XHRpZHhzLnB1c2goaWR4KTtcbiAgXHRcdH1cbiAgXHR9LFxuICBcdHJlbmRlcjogRnJhZ21lbnRfcHJvdG90eXBlX3JlbmRlcixcbiAgXHR0b1N0cmluZzogRnJhZ21lbnRfcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogRnJhZ21lbnRfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlZ2lzdGVySW5kZXhSZWY6IGZ1bmN0aW9uIChpZHgpIHtcbiAgXHRcdHZhciBpZHhzID0gdGhpcy5yZWdpc3RlcmVkSW5kZXhSZWZzO1xuICBcdFx0aWR4cy5zcGxpY2UoaWR4cy5pbmRleE9mKGlkeCksIDEpO1xuICBcdH0sXG4gIFx0dW5yZW5kZXI6IEZyYWdtZW50X3Byb3RvdHlwZV91bnJlbmRlclxuICB9O1xuXG4gIHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50ID0gRnJhZ21lbnQ7XG5cbiAgdmFyIHByb3RvdHlwZV9yZXNldCA9IFJhY3RpdmUkcmVzZXQ7XG4gIHZhciBzaG91bGRSZXJlbmRlciA9IFtcInRlbXBsYXRlXCIsIFwicGFydGlhbHNcIiwgXCJjb21wb25lbnRzXCIsIFwiZGVjb3JhdG9yc1wiLCBcImV2ZW50c1wiXSxcbiAgICAgIHJlc2V0SG9vayA9IG5ldyBob29rc19Ib29rKFwicmVzZXRcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkcmVzZXQoZGF0YSkge1xuICBcdHZhciBwcm9taXNlLCB3cmFwcGVyLCBjaGFuZ2VzLCBpLCByZXJlbmRlcjtcblxuICBcdGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIFx0aWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzZXQgbWV0aG9kIHRha2VzIGVpdGhlciBubyBhcmd1bWVudHMsIG9yIGFuIG9iamVjdCBjb250YWluaW5nIG5ldyBkYXRhXCIpO1xuICBcdH1cblxuICBcdC8vIElmIHRoZSByb290IG9iamVjdCBpcyB3cmFwcGVkLCB0cnkgYW5kIHVzZSB0aGUgd3JhcHBlcidzIHJlc2V0IHZhbHVlXG4gIFx0aWYgKCh3cmFwcGVyID0gdGhpcy52aWV3bW9kZWwud3JhcHBlZFtcIlwiXSkgJiYgd3JhcHBlci5yZXNldCkge1xuICBcdFx0aWYgKHdyYXBwZXIucmVzZXQoZGF0YSkgPT09IGZhbHNlKSB7XG4gIFx0XHRcdC8vIHJlc2V0IHdhcyByZWplY3RlZCwgd2UgbmVlZCB0byByZXBsYWNlIHRoZSBvYmplY3RcbiAgXHRcdFx0dGhpcy52aWV3bW9kZWwucmVzZXQoZGF0YSk7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRoaXMudmlld21vZGVsLnJlc2V0KGRhdGEpO1xuICBcdH1cblxuICBcdC8vIHJlc2V0IGNvbmZpZyBpdGVtcyBhbmQgdHJhY2sgaWYgbmVlZCB0byByZXJlbmRlclxuICBcdGNoYW5nZXMgPSBjb25maWdfY29uZmlnLnJlc2V0KHRoaXMpO1xuXG4gIFx0aSA9IGNoYW5nZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmIChzaG91bGRSZXJlbmRlci5pbmRleE9mKGNoYW5nZXNbaV0pID4gLTEpIHtcbiAgXHRcdFx0cmVyZW5kZXIgPSB0cnVlO1xuICBcdFx0XHRicmVhaztcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAocmVyZW5kZXIpIHtcbiAgXHRcdHZhciBjb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdHRoaXMudmlld21vZGVsLm1hcmsocm9vdEtleXBhdGgpO1xuXG4gIFx0XHQvLyBJcyB0aGlzIGlzIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHNldCB0aGUgYHNob3VsZERlc3Ryb3lgXG4gIFx0XHQvLyBmbGFnLCBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYnkgZGVmYXVsdCB0aGF0IGEgcGFyZW50IG5vZGVcbiAgXHRcdC8vIHdpbGwgYmUgZGV0YWNoZWQsIGFuZCB0aGVyZWZvcmUgaXQgZG9lc24ndCBuZWVkIHRvIGJvdGhlclxuICBcdFx0Ly8gZGV0YWNoaW5nIGl0cyBvd24gbm9kZXNcbiAgXHRcdGlmIChjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCkge1xuICBcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudW5yZW5kZXIoKTtcblxuICBcdFx0aWYgKGNvbXBvbmVudCkge1xuICBcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBJZiB0aGUgdGVtcGxhdGUgY2hhbmdlZCwgd2UgbmVlZCB0byBkZXN0cm95IHRoZSBwYXJhbGxlbCBET01cbiAgXHRcdC8vIFRPRE8gaWYgd2UncmUgaGVyZSwgcHJlc3VtYWJseSBpdCBkaWQ/XG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudC50ZW1wbGF0ZSAhPT0gdGhpcy50ZW1wbGF0ZSkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUsXG4gIFx0XHRcdFx0cm9vdDogdGhpcyxcbiAgXHRcdFx0XHRvd25lcjogdGhpc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0cHJvbWlzZSA9IHRoaXMucmVuZGVyKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuICBcdFx0dGhpcy52aWV3bW9kZWwubWFyayhyb290S2V5cGF0aCk7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHR9XG5cbiAgXHRyZXNldEhvb2suZmlyZSh0aGlzLCBkYXRhKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIHJlc2V0UGFydGlhbCA9IGZ1bmN0aW9uIChuYW1lLCBwYXJ0aWFsKSB7XG4gIFx0dmFyIHByb21pc2UsXG4gIFx0ICAgIGNvbGxlY3Rpb24gPSBbXTtcblxuICBcdGZ1bmN0aW9uIGNvbGxlY3Qoc291cmNlLCBkZXN0LCByYWN0aXZlKSB7XG4gIFx0XHQvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IGFuZCBpdCBoYXMgaXRzIG93biBwYXJ0aWFsLCBiYWlsXG4gIFx0XHRpZiAocmFjdGl2ZSAmJiByYWN0aXZlLnBhcnRpYWxzW25hbWVdKSByZXR1cm47XG5cbiAgXHRcdHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRcdC8vIHF1ZXVlIHRvIHJlcmVuZGVyIGlmIHRoZSBpdGVtIGlzIGEgcGFydGlhbCBhbmQgdGhlIGN1cnJlbnQgbmFtZSBtYXRjaGVzXG4gIFx0XHRcdGlmIChpdGVtLnR5cGUgPT09IFBBUlRJQUwgJiYgaXRlbS5nZXRQYXJ0aWFsTmFtZSgpID09PSBuYW1lKSB7XG4gIFx0XHRcdFx0ZGVzdC5wdXNoKGl0ZW0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gaWYgaXQgaGFzIGEgZnJhZ21lbnQsIHByb2Nlc3MgaXRzIGl0ZW1zXG4gIFx0XHRcdGlmIChpdGVtLmZyYWdtZW50KSB7XG4gIFx0XHRcdFx0Y29sbGVjdChpdGVtLmZyYWdtZW50Lml0ZW1zLCBkZXN0LCByYWN0aXZlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIG9yIGlmIGl0IGhhcyBmcmFnbWVudHNcbiAgXHRcdFx0aWYgKGlzQXJyYXkoaXRlbS5mcmFnbWVudHMpKSB7XG4gIFx0XHRcdFx0Y29sbGVjdChpdGVtLmZyYWdtZW50cywgZGVzdCwgcmFjdGl2ZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBvciBpZiBpdCBpcyBpdHNlbGYgYSBmcmFnbWVudCwgcHJvY2VzcyBpdHMgaXRlbXNcbiAgXHRcdFx0ZWxzZSBpZiAoaXNBcnJheShpdGVtLml0ZW1zKSkge1xuICBcdFx0XHRcdGNvbGxlY3QoaXRlbS5pdGVtcywgZGVzdCwgcmFjdGl2ZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBvciBpZiBpdCBpcyBhIGNvbXBvbmVudCwgc3RlcCBpbiBhbmQgcHJvY2VzcyBpdHMgaXRlbXNcbiAgXHRcdFx0ZWxzZSBpZiAoaXRlbS50eXBlID09PSBDT01QT05FTlQgJiYgaXRlbS5pbnN0YW5jZSkge1xuICBcdFx0XHRcdGNvbGxlY3QoaXRlbS5pbnN0YW5jZS5mcmFnbWVudC5pdGVtcywgZGVzdCwgaXRlbS5pbnN0YW5jZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBpZiB0aGUgaXRlbSBpcyBhbiBlbGVtZW50LCBwcm9jZXNzIGl0cyBhdHRyaWJ1dGVzIHRvb1xuICBcdFx0XHRpZiAoaXRlbS50eXBlID09PSBFTEVNRU5UKSB7XG4gIFx0XHRcdFx0aWYgKGlzQXJyYXkoaXRlbS5hdHRyaWJ1dGVzKSkge1xuICBcdFx0XHRcdFx0Y29sbGVjdChpdGVtLmF0dHJpYnV0ZXMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChpc0FycmF5KGl0ZW0uY29uZGl0aW9uYWxBdHRyaWJ1dGVzKSkge1xuICBcdFx0XHRcdFx0Y29sbGVjdChpdGVtLmNvbmRpdGlvbmFsQXR0cmlidXRlcywgZGVzdCwgcmFjdGl2ZSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRjb2xsZWN0KHRoaXMuZnJhZ21lbnQuaXRlbXMsIGNvbGxlY3Rpb24pO1xuICBcdHRoaXMucGFydGlhbHNbbmFtZV0gPSBwYXJ0aWFsO1xuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuXG4gIFx0Y29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRpdGVtLnZhbHVlID0gdW5kZWZpbmVkO1xuICBcdFx0aXRlbS5zZXRWYWx1ZShuYW1lKTtcbiAgXHR9KTtcblxuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gVE9ETyBzaG91bGQgcmVzZXRUZW1wbGF0ZSBiZSBhc3luY2hyb25vdXM/IGkuZS4gc2hvdWxkIGl0IGJlIGEgY2FzZVxuICAvLyBvZiBvdXRybywgdXBkYXRlIHRlbXBsYXRlLCBpbnRybz8gSSByZWNrb24gcHJvYmFibHkgbm90LCBzaW5jZSB0aGF0XG4gIC8vIGNvdWxkIGJlIGFjaGlldmVkIHdpdGggdW5yZW5kZXItcmVzZXRUZW1wbGF0ZS1yZW5kZXIuIEFsc28sIGl0IHNob3VsZFxuICAvLyBjb25jZXB0dWFsbHkgYmUgc2ltaWxhciB0byByZXNldFBhcnRpYWwsIHdoaWNoIGNvdWxkbid0IGJlIGFzeW5jXG5cbiAgdmFyIHJlc2V0VGVtcGxhdGUgPSBSYWN0aXZlJHJlc2V0VGVtcGxhdGU7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkcmVzZXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICBcdHZhciB0cmFuc2l0aW9uc0VuYWJsZWQsIGNvbXBvbmVudDtcblxuICBcdHRlbXBsYXRlX3RlbXBsYXRlLmluaXQobnVsbCwgdGhpcywgeyB0ZW1wbGF0ZTogdGVtcGxhdGUgfSk7XG5cbiAgXHR0cmFuc2l0aW9uc0VuYWJsZWQgPSB0aGlzLnRyYW5zaXRpb25zRW5hYmxlZDtcbiAgXHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IGZhbHNlO1xuXG4gIFx0Ly8gSXMgdGhpcyBpcyBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBzZXQgdGhlIGBzaG91bGREZXN0cm95YFxuICBcdC8vIGZsYWcsIG90aGVyd2lzZSBpdCB3aWxsIGFzc3VtZSBieSBkZWZhdWx0IHRoYXQgYSBwYXJlbnQgbm9kZVxuICBcdC8vIHdpbGwgYmUgZGV0YWNoZWQsIGFuZCB0aGVyZWZvcmUgaXQgZG9lc24ndCBuZWVkIHRvIGJvdGhlclxuICBcdC8vIGRldGFjaGluZyBpdHMgb3duIG5vZGVzXG4gIFx0aWYgKGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50KSB7XG4gIFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG4gIFx0fVxuXG4gIFx0dGhpcy51bnJlbmRlcigpO1xuXG4gIFx0aWYgKGNvbXBvbmVudCkge1xuICBcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHQvLyByZW1vdmUgZXhpc3RpbmcgZnJhZ21lbnQgYW5kIGNyZWF0ZSBuZXcgb25lXG4gIFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUsXG4gIFx0XHRyb290OiB0aGlzLFxuICBcdFx0b3duZXI6IHRoaXNcbiAgXHR9KTtcblxuICBcdHRoaXMucmVuZGVyKHRoaXMuZWwsIHRoaXMuYW5jaG9yKTtcblxuICBcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gdHJhbnNpdGlvbnNFbmFibGVkO1xuICB9XG5cbiAgdmFyIHJldmVyc2UgPSBtYWtlQXJyYXlNZXRob2QoXCJyZXZlcnNlXCIpO1xuXG4gIHZhciBSYWN0aXZlX3Byb3RvdHlwZV9zZXQgPSBSYWN0aXZlJHNldDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJHNldChrZXlwYXRoLCB2YWx1ZSkge1xuICBcdHZhciBtYXAsIHByb21pc2U7XG5cbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG5cbiAgXHQvLyBTZXQgbXVsdGlwbGUga2V5cGF0aHMgaW4gb25lIGdvXG4gIFx0aWYgKGlzT2JqZWN0KGtleXBhdGgpKSB7XG4gIFx0XHRtYXAgPSBrZXlwYXRoO1xuXG4gIFx0XHRmb3IgKGtleXBhdGggaW4gbWFwKSB7XG4gIFx0XHRcdGlmIChtYXAuaGFzT3duUHJvcGVydHkoa2V5cGF0aCkpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IG1hcFtrZXlwYXRoXTtcbiAgXHRcdFx0XHRzZXQodGhpcywga2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gU2V0IGEgc2luZ2xlIGtleXBhdGhcbiAgXHRlbHNlIHtcbiAgXHRcdHNldCh0aGlzLCBrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0fVxuXG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldChyYWN0aXZlLCBrZXlwYXRoLCB2YWx1ZSkge1xuICBcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG5cbiAgXHRpZiAoa2V5cGF0aC5pc1BhdHRlcm4pIHtcbiAgXHRcdGdldE1hdGNoaW5nS2V5cGF0aHMocmFjdGl2ZSwga2V5cGF0aCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fSk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLnNldChrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHNoaWZ0ID0gbWFrZUFycmF5TWV0aG9kKFwic2hpZnRcIik7XG5cbiAgdmFyIHByb3RvdHlwZV9zb3J0ID0gbWFrZUFycmF5TWV0aG9kKFwic29ydFwiKTtcblxuICB2YXIgc3BsaWNlID0gbWFrZUFycmF5TWV0aG9kKFwic3BsaWNlXCIpO1xuXG4gIHZhciBzdWJ0cmFjdCA9IFJhY3RpdmUkc3VidHJhY3Q7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkc3VidHJhY3Qoa2V5cGF0aCwgZCkge1xuICBcdHJldHVybiBzaGFyZWRfYWRkKHRoaXMsIGtleXBhdGgsIGQgPT09IHVuZGVmaW5lZCA/IC0xIDogLWQpO1xuICB9XG5cbiAgLy8gVGVhcmRvd24uIFRoaXMgZ29lcyB0aHJvdWdoIHRoZSByb290IGZyYWdtZW50IGFuZCBhbGwgaXRzIGNoaWxkcmVuLCByZW1vdmluZyBvYnNlcnZlcnNcbiAgLy8gYW5kIGdlbmVyYWxseSBjbGVhbmluZyB1cCBhZnRlciBpdHNlbGZcblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfdGVhcmRvd24gPSBSYWN0aXZlJHRlYXJkb3duO1xuXG4gIHZhciBSYWN0aXZlX3Byb3RvdHlwZV90ZWFyZG93bl9fdGVhcmRvd25Ib29rID0gbmV3IGhvb2tzX0hvb2soXCJ0ZWFyZG93blwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSR0ZWFyZG93bigpIHtcbiAgXHR2YXIgcHJvbWlzZTtcblxuICBcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0dGhpcy52aWV3bW9kZWwudGVhcmRvd24oKTtcblxuICBcdHRoaXMuX29ic2VydmVycy5mb3JFYWNoKGNhbmNlbCk7XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudC5yZW5kZXJlZCAmJiB0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXykge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzKTtcbiAgXHR9XG5cbiAgXHR0aGlzLnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuICBcdHByb21pc2UgPSB0aGlzLmZyYWdtZW50LnJlbmRlcmVkID8gdGhpcy51bnJlbmRlcigpIDogdXRpbHNfUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgXHRSYWN0aXZlX3Byb3RvdHlwZV90ZWFyZG93bl9fdGVhcmRvd25Ib29rLmZpcmUodGhpcyk7XG5cbiAgXHR0aGlzLl9ib3VuZEZ1bmN0aW9ucy5mb3JFYWNoKGRlbGV0ZUZ1bmN0aW9uQ29weSk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUZ1bmN0aW9uQ29weShib3VuZCkge1xuICBcdGRlbGV0ZSBib3VuZC5mbltib3VuZC5wcm9wXTtcbiAgfVxuXG4gIHZhciB0b2dnbGUgPSBSYWN0aXZlJHRvZ2dsZTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSR0b2dnbGUoa2V5cGF0aCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRpZiAodHlwZW9mIGtleXBhdGggIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYmFkQXJndW1lbnRzKTtcbiAgXHR9XG5cbiAgXHR2YXIgY2hhbmdlcyA9IHVuZGVmaW5lZDtcblxuICBcdGlmICgvXFwqLy50ZXN0KGtleXBhdGgpKSB7XG4gIFx0XHRjaGFuZ2VzID0ge307XG5cbiAgXHRcdGdldE1hdGNoaW5nS2V5cGF0aHModGhpcywgZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdGNoYW5nZXNba2V5cGF0aC5zdHJdID0gIV90aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHR9KTtcblxuICBcdFx0cmV0dXJuIHRoaXMuc2V0KGNoYW5nZXMpO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnNldChrZXlwYXRoLCAhdGhpcy5nZXQoa2V5cGF0aCkpO1xuICB9XG5cbiAgdmFyIHRvSFRNTCA9IFJhY3RpdmUkdG9IVE1MO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkdG9IVE1MKCkge1xuICBcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKHRydWUpO1xuICB9XG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3VucmVuZGVyID0gUmFjdGl2ZSR1bnJlbmRlcjtcbiAgdmFyIHVucmVuZGVySG9vayA9IG5ldyBob29rc19Ib29rKFwidW5yZW5kZXJcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkdW5yZW5kZXIoKSB7XG4gIFx0dmFyIHByb21pc2UsIHNob3VsZERlc3Ryb3k7XG5cbiAgXHRpZiAoIXRoaXMuZnJhZ21lbnQucmVuZGVyZWQpIHtcbiAgXHRcdHdhcm5JZkRlYnVnKFwicmFjdGl2ZS51bnJlbmRlcigpIHdhcyBjYWxsZWQgb24gYSBSYWN0aXZlIGluc3RhbmNlIHRoYXQgd2FzIG5vdCByZW5kZXJlZFwiKTtcbiAgXHRcdHJldHVybiB1dGlsc19Qcm9taXNlLnJlc29sdmUoKTtcbiAgXHR9XG5cbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG5cbiAgXHQvLyBJZiB0aGlzIGlzIGEgY29tcG9uZW50LCBhbmQgdGhlIGNvbXBvbmVudCBpc24ndCBtYXJrZWQgZm9yIGRlc3RydWN0aW9uLFxuICBcdC8vIGRvbid0IGRldGFjaCBub2RlcyBmcm9tIHRoZSBET00gdW5uZWNlc3NhcmlseVxuICBcdHNob3VsZERlc3Ryb3kgPSAhdGhpcy5jb21wb25lbnQgfHwgdGhpcy5jb21wb25lbnQuc2hvdWxkRGVzdHJveSB8fCB0aGlzLnNob3VsZERlc3Ryb3k7XG5cbiAgXHQvLyBDYW5jZWwgYW55IGFuaW1hdGlvbnMgaW4gcHJvZ3Jlc3NcbiAgXHR3aGlsZSAodGhpcy5fYW5pbWF0aW9uc1swXSkge1xuICBcdFx0dGhpcy5fYW5pbWF0aW9uc1swXS5zdG9wKCk7IC8vIGl0IHdpbGwgcmVtb3ZlIGl0c2VsZiBmcm9tIHRoZSBpbmRleFxuICBcdH1cblxuICBcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoc2hvdWxkRGVzdHJveSk7XG5cbiAgXHRyZW1vdmVGcm9tQXJyYXkodGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMpO1xuXG4gIFx0dW5yZW5kZXJIb29rLmZpcmUodGhpcyk7XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciB1bnNoaWZ0ID0gbWFrZUFycmF5TWV0aG9kKFwidW5zaGlmdFwiKTtcblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfdXBkYXRlID0gUmFjdGl2ZSR1cGRhdGU7XG4gIHZhciB1cGRhdGVIb29rID0gbmV3IGhvb2tzX0hvb2soXCJ1cGRhdGVcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkdXBkYXRlKGtleXBhdGgpIHtcbiAgXHR2YXIgcHJvbWlzZTtcblxuICBcdGtleXBhdGggPSBnZXRLZXlwYXRoKGtleXBhdGgpIHx8IHJvb3RLZXlwYXRoO1xuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuICBcdHRoaXMudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHR1cGRhdGVIb29rLmZpcmUodGhpcywga2V5cGF0aCk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdXBkYXRlTW9kZWwgPSBSYWN0aXZlJHVwZGF0ZU1vZGVsO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkdXBkYXRlTW9kZWwoa2V5cGF0aCwgY2FzY2FkZSkge1xuICBcdHZhciB2YWx1ZXMsIGtleSwgYmluZGluZ3M7XG5cbiAgXHRpZiAodHlwZW9mIGtleXBhdGggPT09IFwic3RyaW5nXCIgJiYgIWNhc2NhZGUpIHtcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5fdHdvd2F5QmluZGluZ3Nba2V5cGF0aF07XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGJpbmRpbmdzID0gW107XG5cbiAgXHRcdGZvciAoa2V5IGluIHRoaXMuX3R3b3dheUJpbmRpbmdzKSB7XG4gIFx0XHRcdGlmICgha2V5cGF0aCB8fCBnZXRLZXlwYXRoKGtleSkuZXF1YWxzT3JTdGFydHNXaXRoKGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0Ly8gVE9ETyBpcyB0aGlzIHJpZ2h0P1xuICBcdFx0XHRcdGJpbmRpbmdzLnB1c2guYXBwbHkoYmluZGluZ3MsIHRoaXMuX3R3b3dheUJpbmRpbmdzW2tleV0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dmFsdWVzID0gY29uc29saWRhdGUodGhpcywgYmluZGluZ3MpO1xuICBcdHJldHVybiB0aGlzLnNldCh2YWx1ZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc29saWRhdGUocmFjdGl2ZSwgYmluZGluZ3MpIHtcbiAgXHR2YXIgdmFsdWVzID0ge30sXG4gIFx0ICAgIGNoZWNrYm94R3JvdXBzID0gW107XG5cbiAgXHRiaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gIFx0XHR2YXIgb2xkVmFsdWUsIG5ld1ZhbHVlO1xuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSByYWRpbyBuYW1lIGJpbmRpbmdzXG4gIFx0XHRpZiAoYi5yYWRpb05hbWUgJiYgIWIuZWxlbWVudC5ub2RlLmNoZWNrZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBjaGVja2JveCBuYW1lIGJpbmRpbmdzIGNvbWUgaW4gZ3JvdXBzLCBzb1xuICBcdFx0Ly8gd2Ugd2FudCB0byBnZXQgdGhlIHZhbHVlIG9uY2UgYXQgbW9zdFxuICBcdFx0aWYgKGIuY2hlY2tib3hOYW1lKSB7XG4gIFx0XHRcdGlmICghY2hlY2tib3hHcm91cHNbYi5rZXlwYXRoLnN0cl0gJiYgIWIuY2hhbmdlZCgpKSB7XG4gIFx0XHRcdFx0Y2hlY2tib3hHcm91cHMucHVzaChiLmtleXBhdGgpO1xuICBcdFx0XHRcdGNoZWNrYm94R3JvdXBzW2Iua2V5cGF0aC5zdHJdID0gYjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0b2xkVmFsdWUgPSBiLmF0dHJpYnV0ZS52YWx1ZTtcbiAgXHRcdG5ld1ZhbHVlID0gYi5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRpZiAoYXJyYXlDb250ZW50c01hdGNoKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWlzRXF1YWwob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICBcdFx0XHR2YWx1ZXNbYi5rZXlwYXRoLnN0cl0gPSBuZXdWYWx1ZTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdC8vIEhhbmRsZSBncm91cHMgb2YgYDxpbnB1dCB0eXBlPSdjaGVja2JveCcgbmFtZT0ne3tmb299fScgLi4uPmBcbiAgXHRpZiAoY2hlY2tib3hHcm91cHMubGVuZ3RoKSB7XG4gIFx0XHRjaGVja2JveEdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHZhciBiaW5kaW5nLCBvbGRWYWx1ZSwgbmV3VmFsdWU7XG5cbiAgXHRcdFx0YmluZGluZyA9IGNoZWNrYm94R3JvdXBzW2tleXBhdGguc3RyXTsgLy8gb25lIHRvIHJlcHJlc2VudCB0aGUgZW50aXJlIGdyb3VwXG4gIFx0XHRcdG9sZFZhbHVlID0gYmluZGluZy5hdHRyaWJ1dGUudmFsdWU7XG4gIFx0XHRcdG5ld1ZhbHVlID0gYmluZGluZy5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRcdGlmICghYXJyYXlDb250ZW50c01hdGNoKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgXHRcdFx0XHR2YWx1ZXNba2V5cGF0aC5zdHJdID0gbmV3VmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0ge1xuICBcdGFkZDogcHJvdG90eXBlX2FkZCxcbiAgXHRhbmltYXRlOiBwcm90b3R5cGVfYW5pbWF0ZSxcbiAgXHRkZXRhY2g6IHByb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogcHJvdG90eXBlX2ZpbmRBbGwsXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IHByb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBwcm90b3R5cGVfZmluZENvbXBvbmVudCxcbiAgXHRmaW5kQ29udGFpbmVyOiBmaW5kQ29udGFpbmVyLFxuICBcdGZpbmRQYXJlbnQ6IGZpbmRQYXJlbnQsXG4gIFx0ZmlyZTogcHJvdG90eXBlX2ZpcmUsXG4gIFx0Z2V0OiBwcm90b3R5cGVfZ2V0LFxuICBcdGluc2VydDogaW5zZXJ0LFxuICBcdG1lcmdlOiBwcm90b3R5cGVfbWVyZ2UsXG4gIFx0b2JzZXJ2ZTogb2JzZXJ2ZSxcbiAgXHRvYnNlcnZlT25jZTogb2JzZXJ2ZU9uY2UsXG4gIFx0b2ZmOiBvZmYsXG4gIFx0b246IG9uLFxuICBcdG9uY2U6IG9uY2UsXG4gIFx0cG9wOiBwb3AsXG4gIFx0cHVzaDogcHVzaCxcbiAgXHRyZW5kZXI6IHByb3RvdHlwZV9yZW5kZXIsXG4gIFx0cmVzZXQ6IHByb3RvdHlwZV9yZXNldCxcbiAgXHRyZXNldFBhcnRpYWw6IHJlc2V0UGFydGlhbCxcbiAgXHRyZXNldFRlbXBsYXRlOiByZXNldFRlbXBsYXRlLFxuICBcdHJldmVyc2U6IHJldmVyc2UsXG4gIFx0c2V0OiBSYWN0aXZlX3Byb3RvdHlwZV9zZXQsXG4gIFx0c2hpZnQ6IHNoaWZ0LFxuICBcdHNvcnQ6IHByb3RvdHlwZV9zb3J0LFxuICBcdHNwbGljZTogc3BsaWNlLFxuICBcdHN1YnRyYWN0OiBzdWJ0cmFjdCxcbiAgXHR0ZWFyZG93bjogUmFjdGl2ZV9wcm90b3R5cGVfdGVhcmRvd24sXG4gIFx0dG9nZ2xlOiB0b2dnbGUsXG4gIFx0dG9IVE1MOiB0b0hUTUwsXG4gIFx0dG9IdG1sOiB0b0hUTUwsXG4gIFx0dW5yZW5kZXI6IFJhY3RpdmVfcHJvdG90eXBlX3VucmVuZGVyLFxuICBcdHVuc2hpZnQ6IHVuc2hpZnQsXG4gIFx0dXBkYXRlOiBSYWN0aXZlX3Byb3RvdHlwZV91cGRhdGUsXG4gIFx0dXBkYXRlTW9kZWw6IHByb3RvdHlwZV91cGRhdGVNb2RlbFxuICB9O1xuXG4gIHZhciB3cmFwTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCwgc3VwZXJNZXRob2QsIGZvcmNlKSB7XG5cbiAgXHRpZiAoZm9yY2UgfHwgbmVlZHNTdXBlcihtZXRob2QsIHN1cGVyTWV0aG9kKSkge1xuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gIFx0XHRcdHZhciBoYXNTdXBlciA9IChcIl9zdXBlclwiIGluIHRoaXMpLFxuICBcdFx0XHQgICAgX3N1cGVyID0gdGhpcy5fc3VwZXIsXG4gIFx0XHRcdCAgICByZXN1bHQ7XG5cbiAgXHRcdFx0dGhpcy5fc3VwZXIgPSBzdXBlck1ldGhvZDtcblxuICBcdFx0XHRyZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBcdFx0XHRpZiAoaGFzU3VwZXIpIHtcbiAgXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9zdXBlcjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiByZXN1bHQ7XG4gIFx0XHR9O1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gbWV0aG9kO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBuZWVkc1N1cGVyKG1ldGhvZCwgc3VwZXJNZXRob2QpIHtcbiAgXHRyZXR1cm4gdHlwZW9mIHN1cGVyTWV0aG9kID09PSBcImZ1bmN0aW9uXCIgJiYgL19zdXBlci8udGVzdChtZXRob2QpO1xuICB9XG5cbiAgdmFyIHVud3JhcEV4dGVuZGVkID0gdW53cmFwO1xuXG4gIGZ1bmN0aW9uIHVud3JhcChDaGlsZCkge1xuICBcdHZhciBvcHRpb25zID0ge307XG5cbiAgXHR3aGlsZSAoQ2hpbGQpIHtcbiAgXHRcdGFkZFJlZ2lzdHJpZXMoQ2hpbGQsIG9wdGlvbnMpO1xuICBcdFx0YWRkT3RoZXJPcHRpb25zKENoaWxkLCBvcHRpb25zKTtcblxuICBcdFx0aWYgKENoaWxkLl9QYXJlbnQgIT09IF9SYWN0aXZlKSB7XG4gIFx0XHRcdENoaWxkID0gQ2hpbGQuX1BhcmVudDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdENoaWxkID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRSZWdpc3RyaWVzKENoaWxkLCBvcHRpb25zKSB7XG4gIFx0Y29uZmlnX3JlZ2lzdHJpZXMuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICBcdFx0YWRkUmVnaXN0cnkoci51c2VEZWZhdWx0cyA/IENoaWxkLnByb3RvdHlwZSA6IENoaWxkLCBvcHRpb25zLCByLm5hbWUpO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkUmVnaXN0cnkodGFyZ2V0LCBvcHRpb25zLCBuYW1lKSB7XG4gIFx0dmFyIHJlZ2lzdHJ5LFxuICBcdCAgICBrZXlzID0gT2JqZWN0LmtleXModGFyZ2V0W25hbWVdKTtcblxuICBcdGlmICgha2V5cy5sZW5ndGgpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAoIShyZWdpc3RyeSA9IG9wdGlvbnNbbmFtZV0pKSB7XG4gIFx0XHRyZWdpc3RyeSA9IG9wdGlvbnNbbmFtZV0gPSB7fTtcbiAgXHR9XG5cbiAgXHRrZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRyZXR1cm4gIShrZXkgaW4gcmVnaXN0cnkpO1xuICBcdH0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0cmV0dXJuIHJlZ2lzdHJ5W2tleV0gPSB0YXJnZXRbbmFtZV1ba2V5XTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE90aGVyT3B0aW9ucyhDaGlsZCwgb3B0aW9ucykge1xuICBcdE9iamVjdC5rZXlzKENoaWxkLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRpZiAoa2V5ID09PSBcImNvbXB1dGVkXCIpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgdmFsdWUgPSBDaGlsZC5wcm90b3R5cGVba2V5XTtcblxuICBcdFx0aWYgKCEoa2V5IGluIG9wdGlvbnMpKSB7XG4gIFx0XHRcdG9wdGlvbnNba2V5XSA9IHZhbHVlLl9tZXRob2QgPyB2YWx1ZS5fbWV0aG9kIDogdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlzIGl0IGEgd3JhcHBlZCBmdW5jdGlvbj9cbiAgXHRcdGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zW2tleV0gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiBvcHRpb25zW2tleV0uX21ldGhvZCkge1xuXG4gIFx0XHRcdHZhciByZXN1bHQgPSB1bmRlZmluZWQsXG4gIFx0XHRcdCAgICBuZWVkc1N1cGVyID0gdmFsdWUuX21ldGhvZDtcblxuICBcdFx0XHRpZiAobmVlZHNTdXBlcikge1xuICBcdFx0XHRcdHZhbHVlID0gdmFsdWUuX21ldGhvZDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIHJld3JhcCBib3VuZCBkaXJlY3RseSB0byBwYXJlbnQgZm5cbiAgXHRcdFx0cmVzdWx0ID0gd3JhcE1ldGhvZChvcHRpb25zW2tleV0uX21ldGhvZCwgdmFsdWUpO1xuXG4gIFx0XHRcdGlmIChuZWVkc1N1cGVyKSB7XG4gIFx0XHRcdFx0cmVzdWx0Ll9tZXRob2QgPSByZXN1bHQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRvcHRpb25zW2tleV0gPSByZXN1bHQ7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgX2V4dGVuZCA9IF9leHRlbmRfX2V4dGVuZDtcblxuICBmdW5jdGlvbiBfZXh0ZW5kX19leHRlbmQoKSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG9wdGlvbnMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdG9wdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIGV4dGVuZE9uZSh0aGlzKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIG9wdGlvbnMucmVkdWNlKGV4dGVuZE9uZSwgdGhpcyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kT25lKFBhcmVudCkge1xuICBcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICBcdHZhciBDaGlsZCwgcHJvdG87XG5cbiAgXHQvLyBpZiB3ZSdyZSBleHRlbmRpbmcgd2l0aCBhbm90aGVyIFJhY3RpdmUgaW5zdGFuY2UuLi5cbiAgXHQvL1xuICBcdC8vICAgdmFyIEh1bWFuID0gUmFjdGl2ZS5leHRlbmQoLi4uKSwgU3BpZGVyID0gUmFjdGl2ZS5leHRlbmQoLi4uKTtcbiAgXHQvLyAgIHZhciBTcGlkZXJtYW4gPSBIdW1hbi5leHRlbmQoIFNwaWRlciApO1xuICBcdC8vXG4gIFx0Ly8gLi4uaW5oZXJpdCBwcm90b3R5cGUgbWV0aG9kcyBhbmQgZGVmYXVsdCBvcHRpb25zIGFzIHdlbGxcbiAgXHRpZiAob3B0aW9ucy5wcm90b3R5cGUgaW5zdGFuY2VvZiBfUmFjdGl2ZSkge1xuICBcdFx0b3B0aW9ucyA9IHVud3JhcEV4dGVuZGVkKG9wdGlvbnMpO1xuICBcdH1cblxuICBcdENoaWxkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDaGlsZCkpIHJldHVybiBuZXcgQ2hpbGQob3B0aW9ucyk7XG4gIFx0XHRpbml0aWFsaXNlKHRoaXMsIG9wdGlvbnMpO1xuICBcdH07XG5cbiAgXHRwcm90byA9IGNyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcbiAgXHRwcm90by5jb25zdHJ1Y3RvciA9IENoaWxkO1xuXG4gIFx0Ly8gU3RhdGljIHByb3BlcnRpZXNcbiAgXHRkZWZpbmVQcm9wZXJ0aWVzKENoaWxkLCB7XG4gIFx0XHQvLyBhbGlhcyBwcm90b3R5cGUgYXMgZGVmYXVsdHNcbiAgXHRcdGRlZmF1bHRzOiB7IHZhbHVlOiBwcm90byB9LFxuXG4gIFx0XHQvLyBleHRlbmRhYmxlXG4gIFx0XHRleHRlbmQ6IHsgdmFsdWU6IF9leHRlbmRfX2V4dGVuZCwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFxuXG4gIFx0XHQvLyBQYXJlbnQgLSBmb3IgSUU4LCBjYW4ndCB1c2UgT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gIFx0XHRfUGFyZW50OiB7IHZhbHVlOiBQYXJlbnQgfVxuICBcdH0pO1xuXG4gIFx0Ly8gZXh0ZW5kIGNvbmZpZ3VyYXRpb25cbiAgXHRjb25maWdfY29uZmlnLmV4dGVuZChQYXJlbnQsIHByb3RvLCBvcHRpb25zKTtcblxuICBcdGN1c3RvbV9kYXRhLmV4dGVuZChQYXJlbnQsIHByb3RvLCBvcHRpb25zKTtcblxuICBcdGlmIChvcHRpb25zLmNvbXB1dGVkKSB7XG4gIFx0XHRwcm90by5jb21wdXRlZCA9IHV0aWxzX29iamVjdF9fZXh0ZW5kKGNyZWF0ZShQYXJlbnQucHJvdG90eXBlLmNvbXB1dGVkKSwgb3B0aW9ucy5jb21wdXRlZCk7XG4gIFx0fVxuXG4gIFx0Q2hpbGQucHJvdG90eXBlID0gcHJvdG87XG5cbiAgXHRyZXR1cm4gQ2hpbGQ7XG4gIH1cblxuICB2YXIgZ2V0Tm9kZUluZm8gPSBmdW5jdGlvbiAobm9kZSkge1xuICBcdHZhciBpbmZvID0ge30sXG4gIFx0ICAgIHByaXYsXG4gIFx0ICAgIGluZGljZXM7XG5cbiAgXHRpZiAoIW5vZGUgfHwgIShwcml2ID0gbm9kZS5fcmFjdGl2ZSkpIHtcbiAgXHRcdHJldHVybiBpbmZvO1xuICBcdH1cblxuICBcdGluZm8ucmFjdGl2ZSA9IHByaXYucm9vdDtcbiAgXHRpbmZvLmtleXBhdGggPSBwcml2LmtleXBhdGguc3RyO1xuICBcdGluZm8uaW5kZXggPSB7fTtcblxuICBcdC8vIGZpbmQgYWxsIGluZGV4IHJlZmVyZW5jZXMgYW5kIHJlc29sdmUgdGhlbVxuICBcdGlmIChpbmRpY2VzID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMocHJpdi5wcm94eS5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdGluZm8uaW5kZXggPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcy5yZXNvbHZlKGluZGljZXMpO1xuICBcdH1cblxuICBcdHJldHVybiBpbmZvO1xuICB9O1xuXG4gIHZhciBSYWN0aXZlLCBwcm9wZXJ0aWVzO1xuXG4gIC8vIE1haW4gUmFjdGl2ZSByZXF1aXJlZCBvYmplY3RcbiAgUmFjdGl2ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFJhY3RpdmUpKSByZXR1cm4gbmV3IFJhY3RpdmUob3B0aW9ucyk7XG4gIFx0aW5pdGlhbGlzZSh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICAvLyBSYWN0aXZlIHByb3BlcnRpZXNcbiAgcHJvcGVydGllcyA9IHtcblxuICBcdC8vIGRlYnVnIGZsYWdcbiAgXHRERUJVRzogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRydWUgfSxcbiAgXHRERUJVR19QUk9NSVNFUzogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRydWUgfSxcblxuICBcdC8vIHN0YXRpYyBtZXRob2RzOlxuICBcdGV4dGVuZDogeyB2YWx1ZTogX2V4dGVuZCB9LFxuICBcdGdldE5vZGVJbmZvOiB7IHZhbHVlOiBnZXROb2RlSW5mbyB9LFxuICBcdHBhcnNlOiB7IHZhbHVlOiBfcGFyc2UgfSxcblxuICBcdC8vIE5hbWVzcGFjZWQgY29uc3RydWN0b3JzXG4gIFx0UHJvbWlzZTogeyB2YWx1ZTogdXRpbHNfUHJvbWlzZSB9LFxuXG4gIFx0Ly8gc3VwcG9ydFxuICBcdHN2ZzogeyB2YWx1ZTogc3ZnIH0sXG4gIFx0bWFnaWM6IHsgdmFsdWU6IGVudmlyb25tZW50X19tYWdpYyB9LFxuXG4gIFx0Ly8gdmVyc2lvblxuICBcdFZFUlNJT046IHsgdmFsdWU6IFwiMC43LjNcIiB9LFxuXG4gIFx0Ly8gUGx1Z2luc1xuICBcdGFkYXB0b3JzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcbiAgXHRjb21wb25lbnRzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcbiAgXHRkZWNvcmF0b3JzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcbiAgXHRlYXNpbmc6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBzdGF0aWNfZWFzaW5nIH0sXG4gIFx0ZXZlbnRzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcbiAgXHRpbnRlcnBvbGF0b3JzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogc3RhdGljX2ludGVycG9sYXRvcnMgfSxcbiAgXHRwYXJ0aWFsczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0dHJhbnNpdGlvbnM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9XG4gIH07XG5cbiAgLy8gUmFjdGl2ZSBwcm9wZXJ0aWVzXG4gIGRlZmluZVByb3BlcnRpZXMoUmFjdGl2ZSwgcHJvcGVydGllcyk7XG5cbiAgUmFjdGl2ZS5wcm90b3R5cGUgPSB1dGlsc19vYmplY3RfX2V4dGVuZChwcm90b3R5cGUsIGNvbmZpZ19kZWZhdWx0cyk7XG5cbiAgUmFjdGl2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYWN0aXZlO1xuXG4gIC8vIGFsaWFzIHByb3RvdHlwZSBhcyBkZWZhdWx0c1xuICBSYWN0aXZlLmRlZmF1bHRzID0gUmFjdGl2ZS5wcm90b3R5cGU7XG5cbiAgLy8gUmFjdGl2ZS5qcyBtYWtlcyBsaWJlcmFsIHVzZSBvZiB0aGluZ3MgbGlrZSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi4gSW5cbiAgLy8gb2xkZXIgYnJvd3NlcnMsIHRoZXNlIGFyZSBtYWRlIGF2YWlsYWJsZSB2aWEgYSBzaGltIC0gaGVyZSwgd2UgZG8gYSBxdWlja1xuICAvLyBwcmUtZmxpZ2h0IGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IGVpdGhlciBhKSB3ZSdyZSBub3QgaW4gYSBzaGl0IGJyb3dzZXIsXG4gIC8vIG9yIGIpIHdlJ3JlIHVzaW5nIGEgUmFjdGl2ZS1sZWdhY3kuanMgYnVpbGRcbiAgdmFyIEZVTkNUSU9OID0gXCJmdW5jdGlvblwiO1xuXG4gIGlmICh0eXBlb2YgRGF0ZS5ub3cgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRyaW0gIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBPYmplY3Qua2V5cyAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUubWFwICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZpbHRlciAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09IEZVTkNUSU9OKSB7XG4gIFx0dGhyb3cgbmV3IEVycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1c2UgUmFjdGl2ZS5qcyBpbiBhbiBvbGRlciBicm93c2VyLiBZb3UnbGwgbmVlZCB0byB1c2Ugb25lIG9mIHRoZSAnbGVnYWN5IGJ1aWxkcycgaW4gb3JkZXIgdG8gY29udGludWUgLSBzZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbGVnYWN5LWJ1aWxkcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIik7XG4gIH1cblxuICB2YXIgX1JhY3RpdmUgPSBSYWN0aXZlO1xuXG4gIHJldHVybiBfUmFjdGl2ZTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFjdGl2ZS5qcy5tYXBcbiIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxyXG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXHJcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxyXG4gICAgICAgIHJvb3QuU3BhcmtsaW5lID0gZmFjdG9yeSgpO1xyXG4gIH1cclxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGV4dGVuZChzcGVjaWZpYywgZ2VuZXJhbCl7XHJcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xyXG4gICAgICAgIGZvcih2YXIga2V5IGluIGdlbmVyYWwpe1xyXG4gICAgICAgICAgICBvYmpba2V5XSA9IGtleSBpbiBzcGVjaWZpYyA/IHNwZWNpZmljW2tleV0gOiBnZW5lcmFsW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gU3BhcmtsaW5lKGVsZW1lbnQsIG9wdGlvbnMpe1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKG9wdGlvbnMgfHwge30sIFNwYXJrbGluZS5vcHRpb25zKTtcclxuXHJcbiAgICAgICAgaW5pdDoge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gXCI8Y2FudmFzPjwvY2FudmFzPlwiO1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IHRoaXMuZWxlbWVudC5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICAgIHRoaXMucmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnRvb2x0aXApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5vbm1vdXNlbW92ZSA9IHNob3dUb29sdGlwLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgU3BhcmtsaW5lLm9wdGlvbnMgPSB7XHJcbiAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAgICBsaW5lQ29sb3I6IFwiYmxhY2tcIixcclxuICAgICAgICBsaW5lV2lkdGg6IDEsXHJcbiAgICAgICAgc3RhcnRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxyXG4gICAgICAgIGVuZENvbG9yOiBcInJlZFwiLFxyXG4gICAgICAgIG1heENvbG9yOiBcInRyYW5zcGFyZW50XCIsXHJcbiAgICAgICAgbWluQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcclxuICAgICAgICBtaW5WYWx1ZTogbnVsbCxcclxuICAgICAgICBtYXhWYWx1ZTogbnVsbCxcclxuICAgICAgICBkb3RSYWRpdXM6IDIuNSxcclxuICAgICAgICB0b29sdGlwOiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIFNwYXJrbGluZS5pbml0ID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucyl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTcGFya2xpbmUoZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNwYXJrbGluZS5kcmF3ID0gZnVuY3Rpb24oZWxlbWVudCwgcG9pbnRzLCBvcHRpb25zKXtcclxuICAgICAgICB2YXIgc3BhcmtsaW5lID0gbmV3IFNwYXJrbGluZShlbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICBzcGFya2xpbmUuZHJhdyhwb2ludHMpO1xyXG4gICAgICAgIHJldHVybiBzcGFya2xpbmU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0WShtaW5WYWx1ZSwgbWF4VmFsdWUsIG9mZnNldFksIGhlaWdodCwgaW5kZXgpe1xyXG4gICAgICAgIHZhciByYW5nZSA9IG1heFZhbHVlIC0gbWluVmFsdWU7XHJcbiAgICAgICAgaWYocmFuZ2UgPT0gMCl7XHJcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0WSArIGhlaWdodC8yO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgcmV0dXJuIChvZmZzZXRZICsgaGVpZ2h0KSAtICgodGhpc1tpbmRleF0gLSBtaW5WYWx1ZSkgLyByYW5nZSkqaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3RG90KHJhZGl1cywgY29sb3IsIHgsIHkpe1xyXG4gICAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgICAgICB0aGlzLmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkqMiwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuZmlsbCgpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgZnVuY3Rpb24gc2hvd1Rvb2x0aXAoZSl7XHJcbiAgICAgICAgdmFyIHggPSBlLm9mZnNldFggfHwgZS5sYXllclggfHwgMDtcclxuICAgICAgICB2YXIgZGVsdGEgPSAoKHRoaXMub3B0aW9ucy53aWR0aCAtIHRoaXMub3B0aW9ucy5kb3RSYWRpdXMqMikgLyAodGhpcy5wb2ludHMubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgIHZhciBpbmRleCA9IG1pbm1heCgwLCBNYXRoLnJvdW5kKCh4IC0gdGhpcy5vcHRpb25zLmRvdFJhZGl1cykvZGVsdGEpLCB0aGlzLnBvaW50cy5sZW5ndGggLSAxKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmNhbnZhcy50aXRsZSA9IHRoaXMub3B0aW9ucy50b29sdGlwKHRoaXMucG9pbnRzW2luZGV4XSwgaW5kZXgsIHRoaXMucG9pbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICBTcGFya2xpbmUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihwb2ludHMpe1xyXG5cclxuICAgICAgICBwb2ludHMgPSBwb2ludHMgfHwgW107XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLm9wdGlvbnMud2lkdGggKiB0aGlzLnJhdGlvO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQgKiB0aGlzLnJhdGlvO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gdGhpcy5vcHRpb25zLndpZHRoICsgJ3B4JztcclxuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcclxuXHJcbiAgICAgICAgdmFyIG9mZnNldFggPSB0aGlzLm9wdGlvbnMuZG90UmFkaXVzKnRoaXMucmF0aW87XHJcbiAgICAgICAgdmFyIG9mZnNldFkgPSB0aGlzLm9wdGlvbnMuZG90UmFkaXVzKnRoaXMucmF0aW87XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLSBvZmZzZXRYKjI7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCAtIG9mZnNldFkqMjtcclxuXHJcbiAgICAgICAgdmFyIG1pblZhbHVlID0gdGhpcy5vcHRpb25zLm1pblZhbHVlIHx8IE1hdGgubWluLmFwcGx5KE1hdGgsIHBvaW50cyk7XHJcbiAgICAgICAgdmFyIG1heFZhbHVlID0gdGhpcy5vcHRpb25zLm1heFZhbHVlIHx8IE1hdGgubWF4LmFwcGx5KE1hdGgsIHBvaW50cyk7XHJcbiAgICAgICAgdmFyIG1pblggPSBvZmZzZXRYO1xyXG4gICAgICAgIHZhciBtYXhYID0gb2Zmc2V0WDtcclxuXHJcbiAgICAgICAgdmFyIHggPSBvZmZzZXRYO1xyXG4gICAgICAgIHZhciB5ID0gZ2V0WS5iaW5kKHBvaW50cywgbWluVmFsdWUsIG1heFZhbHVlLCBvZmZzZXRZLCBoZWlnaHQpO1xyXG4gICAgICAgIHZhciBkZWx0YSA9IHdpZHRoIC8gKHBvaW50cy5sZW5ndGggLSAxKTtcclxuXHJcbiAgICAgICAgdmFyIGRvdCA9IGRyYXdEb3QuYmluZCh0aGlzLmNvbnRleHQsIHRoaXMub3B0aW9ucy5kb3RSYWRpdXMqdGhpcy5yYXRpbyk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5vcHRpb25zLmxpbmVDb2xvcjtcclxuICAgICAgICB0aGlzLmNvbnRleHQubGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmxpbmVXaWR0aCp0aGlzLnJhdGlvO1xyXG5cclxuICAgICAgICB0aGlzLmNvbnRleHQubW92ZVRvKHgsIHkoMCkpO1xyXG4gICAgICAgIGZvcih2YXIgaT0xOyBpPHBvaW50cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIHggKz0gZGVsdGE7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5saW5lVG8oeCwgeShpKSk7XHJcblxyXG4gICAgICAgICAgICBtaW5YID0gcG9pbnRzW2ldID09IG1pblZhbHVlID8geCA6IG1pblg7XHJcbiAgICAgICAgICAgIG1heFggPSBwb2ludHNbaV0gPT0gbWF4VmFsdWUgPyB4IDogbWF4WDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZSgpO1xyXG5cclxuICAgICAgICBkb3QodGhpcy5vcHRpb25zLnN0YXJ0Q29sb3IsIG9mZnNldFggKyAocG9pbnRzLmxlbmd0aCA9PSAxID8gd2lkdGgvMiA6IDApLCB5KDApKTtcclxuICAgICAgICBkb3QodGhpcy5vcHRpb25zLmVuZENvbG9yLCBvZmZzZXRYICsgKHBvaW50cy5sZW5ndGggPT0gMSA/IHdpZHRoLzIgOiB3aWR0aCksIHkoaSAtIDEpKTtcclxuICAgICAgICBkb3QodGhpcy5vcHRpb25zLm1pbkNvbG9yLCBtaW5YICsgKHBvaW50cy5sZW5ndGggPT0gMSA/IHdpZHRoLzIgOiAwKSwgeShwb2ludHMuaW5kZXhPZihtaW5WYWx1ZSkpKTtcclxuICAgICAgICBkb3QodGhpcy5vcHRpb25zLm1heENvbG9yLCBtYXhYICsgKHBvaW50cy5sZW5ndGggPT0gMSA/IHdpZHRoLzIgOiAwKSwgeShwb2ludHMuaW5kZXhPZihtYXhWYWx1ZSkpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gbWlubWF4KGEsIGIsIGMpe1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heChhLCBNYXRoLm1pbihiLCBjKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFNwYXJrbGluZTtcclxufSkpOyJdfQ==
